<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度优先搜索</title>
    <url>/Algorithm/DFS/</url>
    <content><![CDATA[<h1 id="depth-first-search-DFS-深度优先搜索"><a href="#depth-first-search-DFS-深度优先搜索" class="headerlink" title="depth first search ( DFS) 深度优先搜索"></a>depth first search ( DFS) 深度优先搜索</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>git简单用法</title>
    <url>/Git/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="首次创建-推送"><a href="#首次创建-推送" class="headerlink" title="首次创建 &#x2F; 推送"></a>首次创建 &#x2F; 推送</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首次创建新的存储库</span></span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main # 与远程仓库中的分支对应</span><br><span class="line">git remote add origin https://github.com/it-kay/234324.git</span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从命令行中推送到现有的存储库</span></span><br><span class="line">git remote add origin https://github.com/it-kay/234324.git</span><br><span class="line">git branch -M main # 与远程仓库中的分支对应</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>



<h3 id="删除远程库中指定文件"><a href="#删除远程库中指定文件" class="headerlink" title="删除远程库中指定文件"></a>删除远程库中指定文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached a/2.txt //删除a目录下的2.txt文件   删除a目录git rm -r --cached a</span><br><span class="line">git commit -m &quot;删除a目录下的2.txt文件&quot; </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="应用程序的运行"><a href="#应用程序的运行" class="headerlink" title="应用程序的运行"></a>应用程序的运行</h2><p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/yinyongcxu%E7%9A%84yunxing.png" alt="yinyongcxu的yunxing"></p>
<blockquote>
<p>用户双击 App 这一操作会被 os 所感知到；os 会根据文件名，将对应的 App 加载到内存中；加载到内存之后便会寻找去 main() 函数并将其调用；当 main() 函数运行完成之后 return 会向操作系统返回一个值；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Word\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">122</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Press any key to continue . . .</span></span><br><span class="line"><span class="comment">// Word</span></span><br><span class="line"><span class="comment">// Press any key to continue . . .</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中，system 函数是用来执行外部命令的，如 Linux 下的 ls 等等</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Word\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">122</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C:\Users\kay\Desktop\workspace&gt;a.exe</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">Word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C:\Users\kay\Desktop\workspace&gt;echo %ERRORLEVEL%</span></span><br><span class="line"><span class="comment">122</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>powershell 下可以通过 %ERRORLEVEL% 环境变量来获取上一个执行命令的退出状态。这是我们看上当前返回的数值确实是 return 中返回的数值，这则可证明：在 C 语言程序中，main 函数是程序的入口点，当程序执行完毕时，它会通过 return 语句返回一个值给操作系统。这个返回值通常用于表示程序的执行状态或结果。</p>
</blockquote>
<h2 id="函数定义与函数调用"><a href="#函数定义与函数调用" class="headerlink" title="函数定义与函数调用"></a>函数定义与函数调用</h2><ul>
<li>函数在被调用前必须完整定义</li>
<li>函数可以先被声明，再被定义<ul>
<li>声明时，必须给出函数三要素（函数名，参数列表，返回值类型）</li>
<li>定义时，必须完整给出函数体定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span> || i % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到n之间所有能被7或者被9整除的数字的和: %d&quot;</span>, sum);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一题：键入长度 n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    sum(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时在 main 函数中使用 sum 函数并不需要显示的进行函数声明；</p>
<p>因为在同一个源文件中，如果函数的定义（即函数体）出现在对该函数的调用之前，那么编译器在编译到调用点时已经知道函数的存在和签名，因此不需要额外的函数声明。</p>
<p>当 C 文件被加载到内存中时候，他会从上往下去找 main 函数，再找到 main 函数之前他会先加载到 sum 函数，所以在 main 函数中进行使用时无需再次进行声明；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一题：键入长度 n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>; <span class="comment">//	void sum(int);</span></span><br><span class="line">    sum(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span> || i % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1到n之间所有能被7或者被9整除的数字的和: %d&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在同一个源文件中，如果你的函数调用出现在函数定义之前，你也需要在使用函数之前提供函数的声明，以便编译器知道函数的存在、返回类型以及它接受的参数。</p>
</blockquote>
<blockquote>
<p>声明时 void sum(int); 与 void sum(int a); 二者的区别</p>
<p>在C语言中，函数声明的<code>void sum(int);</code>和<code>void sum(int a);</code>在大多数情况下被视为等价的，二者并无区别；但它们在上下文和用途上略有不同，主要区别在于它们是如何被解释的。</p>
<p>void sum(int);</p>
<p>这是C语言中标准的函数声明方式。它声明了一个名为<code>sum</code>的函数，该函数接受一个<code>int</code>类型的参数，但在这个声明中并没有为这个参数命名。这种声明方式通常用于头文件中，或者在你只想声明函数的存在而不关心参数具体名称时。由于参数没有具体名称，这个声明不会为参数分配存储空间或进行任何操作，它仅仅是告诉编译器<code>sum</code>是一个函数，接受一个<code>int</code>类型的参数，并返回一个<code>void</code>（即不返回任何值）。</p>
<p>void sum(int a); </p>
<p>它同样声明了一个名为<code>sum</code>的函数，该函数接受一个<code>int</code>类型的参数，并将其命名为<code>a</code>。然而，这种命名方式主要出现在函数定义中，即你实际编写函数体时。在函数声明中（特别是头文件中），虽然可以这样做，但它实际上并不为外部代码提供关于参数名称的任何有用信息，因为外部代码调用这个函数时不会使用到参数名<code>a</code>。此外，如果这个函数声明出现在多个地方（如头文件中），而每个声明中参数的名称不同，这可能会引起混淆，尽管从技术上讲这是合法的;<code>a</code>仅仅是一个占位符，用于说明函数接收一个<code>int</code>类型的参数。它本身并不在栈上分配空间或执行任何操作。</p>
</blockquote>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>在 C 语言如果想要定义无参函数则需要以下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">==========================================================</span><br><span class="line"><span class="type">void</span> sum() &#123;	<span class="comment">// 这种定义表示可接受任意类型、任意多个的参数</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这三种这种调用在编译时不会进行报错</span></span><br><span class="line">    sum(<span class="number">1</span>);</span><br><span class="line">    sum();</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h2><ul>
<li>可以在定义函数时使用数组形参（如：int f(int a [5])）<ul>
<li>数组形参需要使用<strong>同类型数组</strong>作为参数</li>
<li>在 C 语言中，<strong>数组作为函数参数传递时大小信息丢失</strong></li>
<li>在函数内部修改数组形参，将影响数组实参</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>])</span> &#123;	<span class="comment">// 也可以写成 int a[]</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(a); <span class="comment">// &#x27;strlen&#x27; makes pointer from integer without a cast [-Wint-conversion]</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arry1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arry2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="comment">// 此处并不会报错，因为数组作为函数参数传递时大小信息丢失，他不关心数组参数的个数；</span></span><br><span class="line">    <span class="comment">// 对于数组参数来说，是将数组本身传递到了函数内部；</span></span><br><span class="line">    demo(arry1);</span><br><span class="line">    demo(arry2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arry1[0] = %d\n&quot;</span>, arry1[<span class="number">0</span>]); <span class="comment">// arry1[0] = 50</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arry2[0] = %d&quot;</span>, arry2[<span class="number">0</span>]); <span class="comment">// arry2[0] = 50</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用数组参数时如何获取<strong>数组的大小</strong>信息? 将数组的大小也作为参数，传递给函数;</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归函数</strong></p>
<ul>
<li>函数体中存在<strong>自我调用的函数</strong></li>
<li>递归函数<strong>必须有递归出口</strong>（边界条件）</li>
<li>函数的无限递归将导致程序崩溃</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的安装与配置</title>
    <url>/Git/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;kay.wang&#x27;</span><br><span class="line"></span><br><span class="line">git config --global user.email &#x27;kay@tooupper.com&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="生成本地密钥"><a href="#生成本地密钥" class="headerlink" title="生成本地密钥"></a>生成本地密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;kay@tooupper.com&#x27;</span><br></pre></td></tr></table></figure>

<p>下面一路回车即可</p>
<h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><h3 id="bash-ssh-keygen-command-not-found"><a href="#bash-ssh-keygen-command-not-found" class="headerlink" title="-bash: ssh-keygen: command not found"></a>-bash: ssh-keygen: command not found</h3><p>未安装SSH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S openssh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><img src="/public/image/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/weiyunsuan.png" alt="weiyunsuan"></p>
<p><strong>位运算时需要明确知道的事</strong></p>
<ul>
<li>操作数的大小（占用的内存大小）</li>
<li>操作数是正数还是负数（符号位，数据表示）</li>
<li>不同类型的操作数先自动对齐再进行位运算（补符号位）</li>
</ul>
<blockquote>
<p>对于无符号整数，右侧新增的位将用0填充；而对于有符号整数，这取决于编译器和机器的实现（大多数现代编译器在有符号整数右移时，会在左侧新增的位填充符号位，即正数填充0，负数填充1，这被称为算术右移）。</p>
</blockquote>
<ul>
<li>正数符号位为0，右移运算时，高位补0，低位移除</li>
<li>负数符号位为1，右移运算时，高位补1，低位移除</li>
<li>左移运算时，最高为移除，低位补0</li>
<li>最高位的具体位置，由数据类型决定</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>宏</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AE%8F/</url>
    <content><![CDATA[<h2 id="C-语言中函数的”缺陷”"><a href="#C-语言中函数的”缺陷”" class="headerlink" title="C 语言中函数的”缺陷”"></a>C 语言中函数的”缺陷”</h2><p>实参和形参之间仅仅是值传递，因此，函数中无法直接改变实参。</p>
<h2 id="函数”缺陷“的补充"><a href="#函数”缺陷“的补充" class="headerlink" title="函数”缺陷“的补充"></a>函数”缺陷“的补充</h2><ul>
<li>宏是 C 语言中代码复用的补充方式</li>
<li>宏定义语法：#define MACRO(param) code_segment</li>
<li>宏使用语法：MARCRO(num);</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(a, b) a += b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> a, b;</span><br><span class="line">   a = <span class="number">5</span>;</span><br><span class="line">   b = <span class="number">6</span>;</span><br><span class="line">   sum(a, b);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b); <span class="comment">// a = 11, b = 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>宏可以直接改变传入的参数的值；</p>
</blockquote>
<h2 id="宏与函数的不同"><a href="#宏与函数的不同" class="headerlink" title="宏与函数的不同"></a>宏与函数的不同</h2><ul>
<li>宏不是函数，使用宏没有函数调用的过程(没有函数的跳转、函数体的执行、函数的返回)</li>
<li>函数调用先传递参数值，然后跳转指定函数体，最后返回</li>
<li><strong>使用宏只是单纯”单纯复制粘贴“</strong>（也可以叫宏展开），然后替换参数</li>
<li>同一个宏，无论调用多少次，都执行相同的函数体代码</li>
<li>同一个宏，<strong>每次使用都会”复制粘贴“相同的代码</strong></li>
</ul>
<h2 id="编译器组成简介"><a href="#编译器组成简介" class="headerlink" title="编译器组成简介"></a>编译器组成简介</h2><ol>
<li>预处理模块：处理所有宏以及 # 开头的语句（复制粘贴替换）</li>
<li>编译模块：将 C 程序翻译成二进制程序</li>
<li>链接模块：将二进制程序组合成可执行程序</li>
</ol>
<h2 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h2><p><strong>#define NAME Value</strong></p>
<ul>
<li>预处理模块将代码中出现的 NAME 标识符替换为 Value</li>
<li>宏常量的本质就是字面量</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多文件程序设计</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="多文件之间的互相访问"><a href="#多文件之间的互相访问" class="headerlink" title="多文件之间的互相访问"></a>多文件之间的互相访问</h2><ul>
<li><p>每个文件可以定义功能接口（可被其他文件访问的函数或数据）</p>
<ul>
<li>源文件：代码实现文件，后缀 .c</li>
<li>头文件：源文件的接口定义文件，后缀为 .h</li>
</ul>
</li>
<li><p>当需要使用其他文件提供的功能时，包含对应的头文件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;header.h&gt;</span> <span class="comment">// 在编译系统文件中查找头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;header.h&quot;</span> <span class="comment">// 先查找当前工程文件夹，再查找编译系统文件夹</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>a.c 如果想要访问 b.c 中的代码：</p>
<p>b.c 将对应的代码声明在 b.h 头文件中</p>
<p>a.c 引入 b.h 头文件，即可使用对应的代码</p>
</blockquote>
<p><strong>多文件程序设计的一些原则</strong></p>
<ul>
<li>头文件中只做函数声明和变量声明（<strong>不做具体定义</strong>）</li>
<li>头文件中可以定义数据类型（typedef，struct，union，enum）</li>
<li>根据具体实现，一个头文件可以对应多个源文件（多数情况一对一）</li>
<li>不要使用 #include 语句包含源文件</li>
</ul>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p><strong>普通全局变量</strong></p>
<ul>
<li>源文件中定义的全局变量可在所有其他源文件中使用</li>
<li>可使用 extern 关键字在头文件中进行声明，并在其他文件中使用</li>
</ul>
<p><strong>静态全局变量</strong></p>
<ul>
<li>static 修饰的全局变量只能在当前源文件中使用</li>
<li>无法通过 extern 关键字声明，在其他文件中使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> f_var; <span class="comment">// 只会有 WARNING 因为语法上是合法的，但记住 f_var 被 static 所修饰只能在本身所在的源文件中使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// head.c</span></span><br><span class="line"><span class="type">int</span> g_var = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f_var = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>函数声明语句默认自带 extern 关键字修饰</li>
<li>类型定义必须在头文件中，<strong>仅类型声明无法创建变量</strong></li>
<li>静态全局变量<ul>
<li>生命期为程序运行期</li>
<li>作用域仅在定义的文件中</li>
<li>无法直接在其他文件中使用</li>
</ul>
</li>
<li>static 关键字可使函数具备<strong>文件作用域</strong>（静态函数）</li>
<li>静态函数<strong>无法</strong>在其它文件中被调用</li>
<li>函数设计时需要考虑是否在其他文件中使用</li>
</ul>
<h2 id="多个-c-文件互相调用再不通过-h-文件的情况下"><a href="#多个-c-文件互相调用再不通过-h-文件的情况下" class="headerlink" title="多个 c 文件互相调用再不通过 .h 文件的情况下"></a>多个 c 文件互相调用再不通过 .h 文件的情况下</h2><p>在 C 语言中，两个 <code>.c</code> 文件之间可以互相调用对方的函数或变量，但这通常是通过<strong>声明</strong>的方式来实现的。在不使用 <code>.h</code> 头文件的情况下，可以在一个 <code>.c</code> 文件中通过使用 <code>extern</code> 关键字声明另一个 <code>.c</code> 文件中的函数或变量。<code>extern</code> 告诉编译器某个函数或变量是在其他文件中定义的，链接器在链接时会找到对应的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量和函数</span></span><br><span class="line"><span class="type">int</span> global_variable = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function_in_file1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function in file1.c\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">    </span><br><span class="line">file2</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 file1.c 中的变量和函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global_variable;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">function_in_file1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function_in_file2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is function in file2.c\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_variable from file1.c: %d\n&quot;</span>, global_variable);</span><br><span class="line">    function_in_file1();  <span class="comment">// 调用 file1.c 中的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中，**<code>extern</code>** 关键字的作用是告诉编译器某个变量或函数的定义在别的文件中，但它并不需要知道这个变量具体在哪个文件定义。真正把两个 <code>.c</code> 文件关联起来的过程发生在<strong>链接阶段</strong>，而不是编译阶段。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常量</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>常量是相对变量而言的一种程序元素</li>
<li>其特点为：<ul>
<li>在<strong>编辑时</strong>确定其值，一旦确定无法改变</li>
</ul>
</li>
</ul>
<h3 id="C语言中的常量类型"><a href="#C语言中的常量类型" class="headerlink" title="C语言中的常量类型"></a>C语言中的常量类型</h3><ul>
<li>字面量<ul>
<li>直接表示值含义的符号，如：5, ‘a’, “kay”</li>
</ul>
</li>
<li>宏常量（符号化的字面量）<ul>
<li>通过 #define 定义，间接表示值的符号，如：#defiine FIV -&gt; 5.5</li>
</ul>
</li>
<li>枚举常量<ul>
<li>通过 enum 定义，间接表示值的符号，如：First -&gt; 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;Kay&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MyValue 0.05f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举常量：</span></span><br><span class="line"><span class="comment">// 枚举常量只能是整数</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ThirdValue = <span class="number">333</span>,</span><br><span class="line">    FourthValue = <span class="number">444</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ThirdValue = %d\n&quot;</span>, ThirdValue);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常量无法作为左值使用：</p>
<p>ThirdValue &#x3D; 100; &#x2F;&#x2F; Error</p>
</blockquote>
<h3 id="C语言中的只读变量"><a href="#C语言中的只读变量" class="headerlink" title="C语言中的只读变量"></a>C语言中的只读变量</h3><ul>
<li>C 语言中提供 const 关键字，<strong>用于修饰一个变量</strong></li>
<li>被 const 修饰的变量<strong>只能作为右值使用</strong><ul>
<li>无法直接通过赋值操作符改变 const 变量的值</li>
<li>const 修饰的变量并不是真正意义上的常量</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">222</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="指针：一种特殊的变量"><a href="#指针：一种特殊的变量" class="headerlink" title="指针：一种特殊的变量"></a>指针：一种特殊的变量</h2><p><strong>指针是 C 语言中的变量</strong></p>
<ul>
<li>因为是变量，所以用于保存具体值</li>
<li>特殊之处，指针保存的值是内存中的地址</li>
<li>内存地址是什么？<ul>
<li>内存是计算机中的存储部件，每个存储单元都有固定唯一的编号</li>
<li>内存中存储单元的编号即内存地址</li>
</ul>
</li>
</ul>
<h2 id="内存示例"><a href="#内存示例" class="headerlink" title="内存示例"></a>内存示例</h2><p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/neicunshili.png" alt="neicunshili"></p>
<h2 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h2><ul>
<li>C 语言中通过 &amp; 操作符获取程序元素的地址</li>
<li>&amp; 可获取变量，数组，函数的起始地址</li>
<li>内存地址的本质是一个无符号整数（4 &#x2F; 8 个字节）</li>
</ul>
<blockquote>
<p>注意：只有通过 内存地址 + 长度 才能确定一个变量中保存的值</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>指针定义语法：type * pointer;</strong></p>
<ul>
<li>type-数据类型，决定访问内存时的长度</li>
<li>*-标志，意味着定义一个指针变量</li>
<li>point-变量名，遵循 C 语言命名规则</li>
</ul>
<p><em><em>指针内存访问：</em> pointer</em>*</p>
<ul>
<li>指针访问操作符（*）作用于指针变量即可访问内存数据（解引用）</li>
<li>指针的类型决定通过地址访问内存时的长度范围</li>
<li>指针的类型统一占用 4 字节或 8 字节<ul>
<li>sizeof(type *) &#x3D;&#x3D; 4 or sizeof(type *) &#x3D;&#x3D; 8</li>
</ul>
</li>
</ul>
<h2 id="指针定义的规定"><a href="#指针定义的规定" class="headerlink" title="指针定义的规定"></a>指针定义的规定</h2><ul>
<li>Type * 类型的指针只能保存 Type 类型变量的地址</li>
<li>禁止不同类型的指针相互赋值</li>
<li>禁止将普通数值当作地址赋值给指针</li>
</ul>
<blockquote>
<p>指针保存的地址必须是有效地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* pi = &amp;f; <span class="comment">// warning</span></span><br><span class="line">    <span class="type">float</span>* pf = &amp;f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi = %p, pf = %p\n&quot;</span>, pi, pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pi = %d, *pf = %f\n&quot;</span>, *pi, *pf);</span><br><span class="line"></span><br><span class="line">    pi = i; <span class="comment">//  warning</span></span><br><span class="line"></span><br><span class="line">    *pi = <span class="number">1000</span>; <span class="comment">// OOPS 程序会崩溃掉</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi = %p, *pi = %d\n&quot;</span>, pi, *pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pi = 00000026B29FF7E4, pf = 00000026B29FF7E4</span></span><br><span class="line"><span class="comment">*pi = 1092616192, *pf = 10.000000</span></span><br><span class="line"><span class="comment">崩溃了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>进行指针赋值时，一定要注意类型的区别，不如会造成各种奇快的错误，这些错误编译器可能并不会进行提示或者警告；</p>
</blockquote>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><ul>
<li>数组名可以看作一个指针，代表数组中 0 元素的地址</li>
<li>当指针指向数组元素时，可进行指针运算（指针移动）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = a;</span><br><span class="line">p = p + <span class="number">1</span> <span class="comment">//指向数组中第二个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="深入理解指针数组"><a href="#深入理解指针数组" class="headerlink" title="深入理解指针数组"></a>深入理解指针数组</h3><ul>
<li>&amp;a 与 a 在数值上是相同的，但是意义上不同(int a[] &#x3D; {1, 2, 3, 4, 5};)</li>
<li>&amp;a 代表数组地址，类型为：int (*) [5]</li>
<li>a 代表数组 0 号元素地址，类型为：int *</li>
<li>指向数组的指针：int (*pName) [5] &#x3D; &a;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa) [<span class="number">5</span>] = &amp;a; <span class="comment">// int (*pa) [] = &amp;a;</span></span><br><span class="line">    <span class="type">int</span>* p = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, pa, p); <span class="comment">//00000061F43FFDA0, 00000061F43FFDA0</span></span><br><span class="line">    </span><br><span class="line">    pa = p <span class="comment">// WARNING 类型不一致不能相互赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组名不是指针，只是代表了 0 号元素的地址，因此，可以当作指针使用</p>
<p>int* p &#x3D; a; 是一个声明，其中 p 是一个指向整数的指针。由于数组名 a 在这个上下文中会衰减为指向其首元素（即 a[0]）的指针，因此这个赋值是合法的，并且 p 现在存储了 &#96;a[0] 的地址。</p>
</blockquote>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><ul>
<li>C 语言中的<strong>字符串常量</strong>是 char * 类型，一种指针类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;kay.wang&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;kay.wang&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00007FF67FE74000</span></span><br><span class="line"><span class="comment">00007FF67FE74000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针移动"><a href="#指针移动" class="headerlink" title="指针移动"></a>指针移动</h2><p>*<em>int v &#x3D; <em>p++</em></em></p>
<ul>
<li>指针访问操作符（*）和自增运算操作符（++）优先级相同</li>
<li>所以，先从 p 指向内存中取值，然后 p 在进行移动<ul>
<li>int v &#x3D; *p; p++;</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first = %c\n&quot;</span>, *<span class="string">&quot;D.T.software&quot;</span>);</span><br><span class="line">    s = <span class="string">&quot;D.T.software&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s) <span class="comment">// 字符串转为 char 数组后最有一个元素为 \0 也就是 0 元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *s++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first = D</span></span><br><span class="line"><span class="comment">D.T.software</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><ul>
<li>函数的本质是一段内存中的代码（占用一片连续内存）</li>
<li>函数拥有类型，函数类型由<strong>返回类型</strong>和<strong>参数类型列表</strong>组成</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int sum(int n);</td>
<td align="center">int(int)</td>
</tr>
<tr>
<td align="center">void swap(int* pa, int* pb);</td>
<td align="center">void(int*, int*)</td>
</tr>
<tr>
<td align="center">void g(void);</td>
<td align="center">void(v0id)</td>
</tr>
</tbody></table>
<ul>
<li>函数名就是函数体代码的起始地址（函数入口地址）</li>
<li>通过函数名调用函数，本质为指定具体地址的跳转执行（跳转到指定地址处执行）</li>
<li>因此，可定义指针，保存函数入口地址</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>(Type func(Type1 a, Type2 b))</p>
<ul>
<li>函数名即函数入口地址，类型为 Type (*) (type1, type2)</li>
<li>对于 func 函数，&amp;func 与 func 数值相同，意义相同</li>
<li>指向函数的指针：Type (*pFunc)  （Type1, Type2) &#x3D; func<ul>
<li>对于函数来说，函数名就是地址，所以加不加 &amp; 都是一样的，可以直接写 func</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a * b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*pFunc)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pFunc(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pFunc)(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    pFunc = &amp;mul;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pFunc(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pFunc)(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将函数指针作为参数</strong></p>
<ul>
<li>函数指针本质还是指针（变量，保存内存地址）</li>
<li>可定义函数指针参数，<strong>使用相同的代码实现不同的功能</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span>(*cal) (<span class="type">int</span>, <span class="type">int</span>))</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ret = cal(ret, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>函数指针只是单纯的保存函数的入口地址</li>
<li>因此，<ul>
<li>只能通过函数指针调用目标函数</li>
<li>不能进行指针移动（指针运算）</li>
</ul>
</li>
</ul>
<h2 id="为什么数组作为参数时，无法拿到长度信息"><a href="#为什么数组作为参数时，无法拿到长度信息" class="headerlink" title="为什么数组作为参数时，无法拿到长度信息"></a>为什么数组作为参数时，无法拿到长度信息</h2><p>当数组作为参数时，函数的数组形参退化为指针！，因此，不包含数组实参的长度信息；</p>
<p>使用数组名调用时，传递的是 0 号元素的地址；</p>
<p>void func (int a[]) &lt;–&gt; void func(int* a)</p>
<p>void func (int a[1]) &lt;–&gt;</p>
<p>void func (int a[10]) &lt;–&gt;</p>
<p>void func (int a[100]) &lt;–&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;demo: sizeof(arr) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));    <span class="comment">// 32位系统为 4 64位系统为 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += *arr++;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int v = *a++; // Error</span></span><br><span class="line">    </span><br><span class="line">    demo(a, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么 int v &#x3D; *a++; 而 demo 函数中却可以呢，因为当数组作为参数时，函数的数组形参退化为指针！</p>
<p>让我们详细分析一下：</p>
<ol>
<li><strong>数组名的性质</strong>：数组名在 C 语言中是一个常量表达式，表示数组的首元素地址。尽管它经常被当作指针来使用，但它本身并不是指针变量。你不能改变一个数组名来指向数组的下一个元素或另一个数组。</li>
<li><strong>++ 操作符的用途</strong>：<code>++</code> 操作符用于将变量的值增加 1。对于整数类型，它简单地增加变量的值；对于指针，它增加指针所指向地址的偏移量（通常是增加指针指向类型的大小）。然而，这两种情况都要求操作数是一个可修改的左值。</li>
<li><strong>数组名不是左值</strong>：在 C 语言中，左值是指可以出现在赋值语句左边的表达式，意味着它可以被赋值。数组名虽然在某种程度上可以表示地址，但它并不是一个可修改的左值。你不能将一个新的值赋给数组名来改变它的地址。</li>
<li><strong>类型不匹配</strong>：即使我们忽略了数组名不是左值的事实，<code>a++</code> 在类型上也是不合法的。因为 <code>a</code>（在表达式中）被视为指向其首元素的指针，但 <code>a++</code> 的结果（即递增后的值）将不再是一个数组类型，而是一个指向下一个元素的指针。然而，由于 <code>a</code> 本身不是左值，这种递增操作在语法上就是不允许的。</li>
</ol>
<p>综上所述，<code>int</code> 类型的数组 <code>a</code> 不能执行 <code>a++</code> 这样的操作，因为数组名不是一个可修改的左值，而且 <code>++</code> 操作符不适用于数组名。如果你想要遍历数组中的元素，你应该使用指针或数组索引来访问每个元素。例如：</p>
</blockquote>
<h2 id="指针与堆空间"><a href="#指针与堆空间" class="headerlink" title="指针与堆空间"></a>指针与堆空间</h2><p><strong>堆空间的本质</strong></p>
<ul>
<li>备用的”内存仓库”，以字节为单位预留的可用内存</li>
<li>程序可在需要时，从”仓库“中申请使用内存(动态的借用)</li>
<li>当不需要再使用申请的内存时，需要及时归还（动态的归还）</li>
</ul>
<p><strong>void</strong>*</p>
<ul>
<li>void 类型是<strong>基础类型</strong>，对应的指针类型为 void*</li>
<li>void* 是指针类型，其指针变量能够保存地址（可以保存任意类型的内存地址,也可以转化为其他任意类型的指针）</li>
<li>通过 void* 的指针<strong>无法获取内存长中的数据</strong>（无长度信息）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> f= <span class="number">2.0f</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p = &amp;i;</span><br><span class="line">    p = &amp;f;</span><br><span class="line">    p = &amp;d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%f\n&quot;, *p); // Error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆空间的使用"><a href="#堆空间的使用" class="headerlink" title="堆空间的使用"></a>堆空间的使用</h3><ul>
<li>工具箱：stdlib.h</li>
<li>申请：void* malloc(unsigned bytes)</li>
<li>归还：void free(void* p)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从堆空间中申请 4 个字节用来当作 int 类型的变量使用</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 判断是否申请到了堆空间</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果申请失败 p 为 0； 即：空值</span></span><br><span class="line">        *p = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 100</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>用于保存指向指针的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Type v;</span><br><span class="line">Type* pv = &amp;v;</span><br><span class="line">Type** ppv = &amp;pv;</span><br><span class="line">Type*** pppv = &amp;ppv;</span><br><span class="line">==========================</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> 多级数组的指针该如何表示</span></span><br><span class="line"><span class="comment"> C 语言中没有多级数组，所谓二级数组，就是一维数组的数组，即：数组中的元素是一维数组！！;以此类推</span></span><br><span class="line"><span class="comment"> /*</span></span><br></pre></td></tr></table></figure>

<p>因此：</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/erweishuzuzhizhen.png" alt="erweishuzuzhizhen"></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>控制流程语句</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><ul>
<li>switch 仅能用于离散变量或值（整数值）</li>
<li>case 是分支入口，匹配成功后执行 case下的语句</li>
<li>当语句全部执行后，需要使用 break跳出执行分支</li>
<li>default 分支不是必须的（类似于 else 不是必须的）</li>
</ul>
<blockquote>
<p><strong>离散变量</strong>是指其取值限定在某个特定、可数的集合中的变量；这些取值通常是整数。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>字符数组与字符串</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="字符串中的-0-元素"><a href="#字符串中的-0-元素" class="headerlink" title="字符串中的 0 元素"></a>字符串中的 0 元素</h2><ul>
<li>整数 0 即字符串中的 0 元素（char 是最小的整形）</li>
<li>0 元素对应的字符为 ‘\0’（转义字符）</li>
<li>‘0’ 与 ‘\0’ 不同，表示一个非 0 值，对应的整数为 48</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\0&#x27;</span>);	<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;0&#x27;</span>);	<span class="comment">// 48</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串变量-字符数组"><a href="#字符串变量-字符数组" class="headerlink" title="字符串变量-字符数组"></a>字符串变量-字符数组</h2><ul>
<li>C语言中通过字符数组定义字符串</li>
<li>当字符串中存在 0 元素时，可当作字符串使用</li>
<li>字符数组中的 0 元素表示了一个字符串的结束</li>
<li>字符数组中的元素，不一定是字符串中的元素<ul>
<li>这里指的是 ‘\0’</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ss[] = &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 此处 ss 是一个字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);	<span class="comment">// D.T.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用字符串常量进行初始化</li>
<li>字符串长度 小于 字符数组大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> dt[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> name[] = &#123;<span class="string">&quot;D.T.Software&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> ds = <span class="keyword">sizeof</span>(dt);</span><br><span class="line"><span class="type">int</span> ns = <span class="keyword">sizeof</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dt = %s\n&quot;</span>, dt);	<span class="comment">// abcd</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>, name);	<span class="comment">// D.T.SoftWare</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dt size = %s\n&quot;</span>, ds);	<span class="comment">// 5	字符串长度比字符数组少了一个 \0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name size = %s\n&quot;</span>, ns);	<span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ds; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dt[i]);	<span class="comment">// 97 98 99 100 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个字符数组不一定是一个字符串</li>
<li>而一个字符串一定是一个字符数组</li>
</ul>
<h2 id="string-h-字符串工具包"><a href="#string-h-字符串工具包" class="headerlink" title="string.h 字符串工具包"></a>string.h 字符串工具包</h2><ul>
<li>strlen(s) -&gt; 获取字符串的长度</li>
<li>strcpy(s1, s2) -&gt; 将 s2 中的字符复制到 s1，s1 &lt;- s2</li>
<li>strcat(s1, s2) -&gt; 将 s2 追加到 s1 后面，s1 &lt;- s1 + s2</li>
<li>strcmp(s1, s2) -&gt; 比较 s1 和 s2 是否相等，相等为 0</li>
</ul>
<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><ul>
<li>字符串常量的本质是字符数组，字符数组大小为 字符串长度 + 1</li>
<li>使用字符串工具进行字符串赋值时<ul>
<li>必须保证存储赋值结果的字符串足够大（防止越界）</li>
<li>必须保证参与赋值的字符串必须合法（字符数组存在 0 元素）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型与变量</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="打印语句"><a href="#打印语句" class="headerlink" title="打印语句"></a>打印语句</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span>);		<span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="number">2</span>);		<span class="comment">// 0.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;2;);	// 50</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用了%f来输出一个浮点数，但传入的是一个整数  2。在大多数实现中，整数会被隐式转换为浮点数（即 2.000000）；但是，由于 <code>printf</code> 的行为可能依赖于具体的编译器和运行时环境，有时可能看到不同的输出（比如由于浮点数表示的精度问题）。</p>
<p>字符 ‘2’ 的 ASCII 值是 50</p>
</blockquote>
<h2 id="字面量的类型"><a href="#字面量的类型" class="headerlink" title="字面量的类型"></a>字面量的类型</h2><p>程序中的数值（字面量）也有类型：默认类型或者指定类型</p>
<ul>
<li>默认类型：2 为 int，0.2 为 double， ‘c’ 为 char</li>
<li>指定类型：0.2f 为 float（后缀 f 表示 float）</li>
</ul>
<blockquote>
<p>C 语言是类型严格的语言，字面量也有类型，使用字面量时需要考虑类型；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> s = <span class="number">2</span>; <span class="comment">// 字面量 2 的类型被转换为 short</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">2</span>; <span class="comment">// 字面量 2 的类型会被转为 double</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> n = <span class="number">-1l</span>; <span class="comment">// 表示该字面量为 lang 类型</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> nl = <span class="number">2147483648u</span>; <span class="comment">// 表示该字面量为无符号类型</span></span><br></pre></td></tr></table></figure>

<h2 id="变量之间的赋值"><a href="#变量之间的赋值" class="headerlink" title="变量之间的赋值"></a>变量之间的赋值</h2><ul>
<li><p>大类型赋值给小类型时：可能会发生<strong>溢出</strong></p>
<ul>
<li>当数值在小类型范围内 -&gt; 赋值成功</li>
<li>当数值超过小类型的范围 -&gt; 发生溢出</li>
</ul>
</li>
<li><p>小类型可以安全的赋值给大类型</p>
</li>
<li><p>浮点类型赋值给整形，会发生<strong>截断</strong>（小数部分丢失）</p>
</li>
<li><p>整数赋值给浮点类型，能够完成（会在后面补 0）</p>
</li>
</ul>
<h2 id="signed-与-unsigned"><a href="#signed-与-unsigned" class="headerlink" title="signed 与 unsigned"></a>signed 与 unsigned</h2><p><strong>有符号与无符号</strong></p>
<ul>
<li>signed int<ul>
<li>范围：-2147483648 ～ 2147483647</li>
</ul>
</li>
<li>unsigned int<ul>
<li>范围：0 ～ 4294967295</li>
</ul>
</li>
</ul>
<p><strong>扩展</strong></p>
<ul>
<li>signed 和 unsigned 可与 char 和 short 组合使用<ul>
<li>signed char，unsigned char</li>
<li>signed short，unsigned short</li>
</ul>
</li>
<li>程序中可能出现的关于 int 的缩写<ul>
<li>signed &lt;-&gt; signed int</li>
<li>unsigned &lt;-&gt; unsigned int</li>
</ul>
</li>
</ul>
<blockquote>
<p>打印无符号整形时候要使用 %u 而不是%d，%d 会依旧按照有符号进行操作；</p>
</blockquote>
<p><strong>类型本身是不会占用内存的，只有变量才会占用内存</strong></p>
<h2 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h2><p>功能：用于获取类型或者变量所占用的内存大小（字节）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="keyword">sizeof</span>(<span class="type">short</span>); <span class="comment">// 使用 shrot 类型所表示的字节大小来初始化 s</span></span><br><span class="line">    <span class="type">int</span> t = <span class="keyword">sizeof</span> s; <span class="comment">// 使用变量 s 所作占用的字节大小来初始化 t</span></span><br><span class="line">    <span class="type">int</span> u = <span class="keyword">sizeof</span>(s); <span class="comment">// 同上：使用变量 s 所作占用的字节大小来初始化 t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="long"><a href="#long" class="headerlink" title="long"></a>long</h2><ul>
<li>long 在使用不同编译器时，<strong>可能占用的内存不同</strong></li>
<li>long 通常占用 4 个字节，也可能占用 8 个字节</li>
<li>long long 表示整形，<strong>固定占用 8 个字节</strong></li>
<li>long long 是 long long int 的缩写形式</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><ul>
<li>浮点类型（float &amp; double）对数据的表示是不准确的</li>
<li>整数类型（char，short，int，long）对数据的表示是准确的</li>
<li>浮点类型与整数类型在内存中对数据的表示法完全不同</li>
</ul>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><strong>C 语言中变量的分类</strong></p>
<ul>
<li>局部变量<ul>
<li>函数内部定义的变量（隶属于当前函数）</li>
<li>只能在当前函数中进行使用</li>
</ul>
</li>
<li>全局变量<ul>
<li>全局范围内的函数（不特定隶属于任意一个函数）</li>
<li>可以在任意函数中访问使用</li>
</ul>
</li>
</ul>
<p><strong>同名变量的问题</strong></p>
<ul>
<li>不同函数中的局部变量可以同名（不会产生冲突）</li>
<li>全局变量不能同名（会产生冲突）</li>
<li>当局部变量和全局变量同名时，优先使用局部变量</li>
</ul>
<p><strong>全局变量的作用域</strong></p>
<ul>
<li><p>全局作用域：可以在程序的各个角落访问并使用（不限于当前文件中）</p>
</li>
<li><p>文件作用域：只能在当前代码文件中访问并使用</p>
</li>
<li><p>全局变量的作用域可能被局部变量覆盖（同名局部变量）</p>
</li>
<li><p>工程开发中，全局变量通常以 g_ 作为前缀命名（工程约定）</p>
</li>
</ul>
<h2 id="不同变量的物理存储区域"><a href="#不同变量的物理存储区域" class="headerlink" title="不同变量的物理存储区域"></a>不同变量的物理存储区域</h2><ul>
<li>在现代计算机系统中，物理内存被分为不同区域</li>
<li>区域不同，用途不同，不同种类的变量位于不同区域<ul>
<li>全局数据区域：存放全局变量，静态变量，<strong>其中的变量默认初始化为0</strong></li>
<li>栈空间：存储函数参数，局部变量</li>
<li>堆空间：用于动态创建变量</li>
</ul>
</li>
<li>不同变量的生命期<ul>
<li>全局数据区中的变量<ul>
<li>程序开始运行时创建，程序结束时被销毁，整个程序运行期合法可用</li>
</ul>
</li>
<li>栈空间中的变量<ul>
<li>进入作用域时创建，离开作用域时销毁（自动销毁）<ul>
<li>函数中的局部变量在函数调用返回后销毁</li>
</ul>
</li>
</ul>
</li>
<li>作用域和生命周期二者并无本质联系，只是语法层面(作用域)和二进制层面(生命周期)的两个说法</li>
</ul>
</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul>
<li>static 是 C 语言中的关键字</li>
<li>static 修饰的<strong>局部变量</strong>创建于全局数据区（拥有程序生命周期）</li>
<li>static 修饰的<strong>全局变量</strong>只有文件作用域（超出对应文件外无法访问，作用域被缩小了）</li>
<li>static <strong>局部变量只会初始化一次</strong>，作用域与普通变量无异</li>
</ul>
<blockquote>
<p>对于局部变量而言，static 只是改变了它的生命周期，其本身的作用域不变</p>
</blockquote>
<h2 id="变量的声明周期"><a href="#变量的声明周期" class="headerlink" title="变量的声明周期"></a>变量的声明周期</h2><p><strong>变量的生命周期由变量的存储位置决定</strong></p>
<ul>
<li>static 将变量存储于全局数据区，默认初始化为 0</li>
<li>auto 将变量存储于栈空间，默认初始化为随机值</li>
<li>register 将变量存储于寄存器，默认初始化随机值(因为寄存器太少了，所以存储不一定成功，故实际中基本不用)</li>
</ul>
<h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p><strong>类型命名关键字(typedef)</strong></p>
<ul>
<li>C 语言中可以对类型赋予新名字</li>
<li>语法 typedef Type NewTypeName;<ul>
<li>注意：typedef 并没有创建新类型，只是创建了类型别名</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>typedef 可在函数中定义”局部类型名“</li>
<li>typedef 常用于简化类型名（如：unsigned long long）</li>
<li>typedef 定义类型名，能够以<strong>统一方式</strong>创建变量（Type var;）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 float [5] 起个新名字为： FArr5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">float</span><span class="params">(FArr5)</span>[5];</span><br><span class="line"><span class="comment">// 为 int()(int, int) 起个新名字为： FArr5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(IFuncII)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef float(*FArr5)[5];</span></span><br><span class="line"><span class="comment">typedef int(*IFuncII)(int, int);</span></span><br><span class="line"><span class="comment">如何这么写的话，则：</span></span><br><span class="line"><span class="comment">FArr5 pa = &amp;g_arr;</span></span><br><span class="line"><span class="comment">IFuncII pf = add;</span></span><br><span class="line"><span class="comment">须这样写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> g_arr[<span class="number">5</span>] = &#123;<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    FArr5* pa = &amp;g_arr;</span><br><span class="line">    IFuncII* pf = add;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pf(i, i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.100000</span></span><br><span class="line"><span class="comment">0.200000</span></span><br><span class="line"><span class="comment">0.300000</span></span><br><span class="line"><span class="comment">0.000000</span></span><br><span class="line"><span class="comment">0.000000</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>是能够定义不同数据类型变量的集合类型</p>
<ul>
<li>struct 结构体变量的本质是<strong>变量的集合</strong></li>
<li>struct 结构体变量中的<strong>成员占用独立的内存</strong></li>
<li>struct 结构体可以用 typedef 赋予新类型名</li>
<li>可定义 struct 结构体类型的指针，并指向对应类型的变量</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/jiegoutiyongfa.png" alt="jiegoutiyongfa"></p>
<p><strong>深入 struct 结构体类型</strong></p>
<ul>
<li>struct 结构体类型可以先前置声明，在具体定义；<ul>
<li>struct test;</li>
</ul>
</li>
<li>前置类型声明只能用于定义指针；<ul>
<li>struct test* p</li>
</ul>
</li>
<li>类型完整定义之后才能进行变量定义</li>
<li>struct 结构体类型可以省略类型名<ul>
<li>省略类型名时，每次创建变脸必须给出完整结构体定义</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">g_pt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 必须先给出类型的完整定义才能创建相应类型的变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span>   </span><br><span class="line">    t.a = <span class="number">1</span>;</span><br><span class="line">    t.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    g_pt = &amp;t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct 结构体类型<strong>可以省略类型名（无名结构体类型）</strong></li>
<li>类型名省略时，<strong>每次创建变量必须给出完整结构体定义</strong></li>
<li><strong>无名结构体类型总是互不相同的类型</strong>（互不兼容）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a, b;&#125; v1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a, b;&#125; v2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a, b;&#125;* pv;</span><br><span class="line">    </span><br><span class="line">    v1.a = <span class="number">1</span>;</span><br><span class="line">    v1.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v2 = v1 // Error 类型不同互不兼容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pv = &amp;v1; // WARNING 类型不同互不兼容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h4><ul>
<li>现代程序设计中，内存使用的最小单位为字节（约定俗成）</li>
<li>在一些特定场合中，可将<strong>比特</strong>作为最小单位使用内存</li>
<li>结构体类型能够<strong>指定成员变量占用内存的比特位宽度</strong>（位域）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BW</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">4</span>; <span class="comment">// a 占用一个字节的 4 位款组 二进制的 1111 即：[0, 15]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>; <span class="comment">// b 占用一个字节的 2 位款组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">2</span>; <span class="comment">// c 占用一个字节的 2 位款组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BW</span> <span class="title">bw</span>;</span></span><br><span class="line">    bw.a = <span class="number">10</span>;</span><br><span class="line">    bw.b = <span class="number">1</span>; <span class="comment">// 因为大小为2bit，所以如果赋值超过2bit则会发生溢出回转</span></span><br><span class="line">    bw.c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct BW) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span>  BW));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bw.a = %d\n&quot;</span>, bw.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bw.b = %d\n&quot;</span>, bw.b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bw.c = %d\n&quot;</span>, bw.c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(struct BW) = 1</span></span><br><span class="line"><span class="comment">bw.a = 10</span></span><br><span class="line"><span class="comment">bw.b = 1</span></span><br><span class="line"><span class="comment">bw.c = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>深入位域</strong></p>
<ul>
<li>位域成员必须是整形，默认情况下成员依次排列</li>
<li>位域成员占用的位数<strong>不能超过类型宽度</strong>（错误示例：char c : 9）</li>
<li>当存储位不足时，自动启用新存储单元<ul>
<li>char a : 7; char b : 6; 两个加起来超过了一个字节的大小，那么它将会自动启用一个新的字节来存储当前内容</li>
</ul>
</li>
<li>可以舍弃当前未使用的位，重新启用存储单元</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bits1</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> cahr a : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> cahr   : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> cahr b : <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>unsigned char : 0;</code> 这行代码，其作用主要是<strong>作为填充或对齐</strong>。当你在结构体中声明一个大小为0的位域时，它实际上不占用任何位（即，它不存在于内存布局中），但它可以影响结构体中后续位域的对齐方式。</p>
<p>a占了一个字节的前4位，b正好可以占剩下的后四位，刚刚好一个字节；但<code>unsigned char : 0;</code> 这行代码会将 a 所在字节的后四位进行占位，b 只能重新分配一个新的字节并占前四位；</p>
<ul>
<li><code>unsigned char : 0;</code>：这定义了一个大小为0的位域。在大多数上下文中，这样的位域实际上不占用任何位（即，它不会为结构体增加任何额外的内存负担），并且它的存在主要是为了可能的对齐效果或作为占位符。然而，需要注意的是，编译器如何处理这种0大小的位域可能依赖于编译器的具体实现，并且可能不会产生预期的效果。</li>
<li><code>unsigned char : 4;</code>：这定义了一个大小为4位的位域。这意味着这个位域将占用结构体中的4个位，用于存储数据。在这个例子中，由于使用了 <code>unsigned char</code> 类型（尽管在定义位域时类型主要影响解释方式，而不是实际占用的内存大小），这4个位可以用来存储从0到15（即 <code>0b0000</code> 到 <code>0b1111</code>）的整数值。</li>
</ul>
</blockquote>
<h3 id="联合体-Union"><a href="#联合体-Union" class="headerlink" title="联合体 Union"></a>联合体 Union</h3><p><strong>语法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">TypeName</span> &#123;</span></span><br><span class="line">    Type1 var1;</span><br><span class="line">    Type2 var2;</span><br><span class="line">    ...</span><br><span class="line">    TypeN varn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>union  与 struct 的不同</strong></p>
<ul>
<li>union 类型<strong>所有成员共享一段内存</strong>（所有成员起始地址相同）</li>
<li>union 类型的大小取决于成员的最大类型</li>
<li>union 类型的变量<strong>只能以第一个成员类型的有效值进行初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UT</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UT</span> <span class="title">uu</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>联合体中的所有成员共享一段内存，即：如果 uu.a &#x3D; 1，那么 uu.b 也等于 1；</p>
<p>union 类型的大小取决于成员的最大类型，即：uu 这个联合体的大小为 a 这个字段的大小，也就是 4 字节；</p>
<p>union 类型的变量只能以第一个成员类型的有效值进行初始化，即：union UT uu &#x3D; {0}; 0 是 a 的 int 类型；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UTest</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">UTest</span> <span class="title">t</span> =</span> &#123;<span class="number">987654321</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(union UTest) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> UTest));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t.a = %p\n&quot;</span>, &amp;t.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;t.f = %p\n&quot;</span>, &amp;t.f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.a = %d\n&quot;</span>, t.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.f = %f\n&quot;</span>, t.f);</span><br><span class="line"></span><br><span class="line">    t.f = <span class="number">987654321.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.a = %d\n&quot;</span>, t.a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;t.f = %f\n&quot;</span>, t.f);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(union UTest) = 4</span></span><br><span class="line"><span class="comment">&amp;t.a = 0x7ffc28637ea4</span></span><br><span class="line"><span class="comment">&amp;t.f = 0x7ffc28637ea4</span></span><br><span class="line"><span class="comment">t.a = 987654321</span></span><br><span class="line"><span class="comment">t.f = 0.001697</span></span><br><span class="line"><span class="comment">t.a = 1315666339</span></span><br><span class="line"><span class="comment">t.f = 987654336.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>int 与 float 在内存中的存储方式不同，所以二者在对数据进行处理后展示的内容也是不同的；</p>
<p>浮点数的保存是不精确的，是会存在误差的；</p>
</blockquote>
<p><strong>应用-判断系统大小端</strong></p>
<ul>
<li>小端系统：<strong>低位数据</strong>存储在<strong>低地址</strong>内存中</li>
<li>大端系统：<strong>低位数据</strong>存储在<strong>高地址</strong>内存中</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/daxiaoduan.png" alt="daxiaoduan"></p>
<blockquote>
<p>将 1 填入低位，余下补 0，这就是小端系统</p>
<p>将 1 填入高位，余下补 0，这就是大端系统</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLittleEndian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> a[<span class="number">4</span>];</span><br><span class="line">    &#125; test = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    test.i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(test.a[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 返回 1 说明是小端，返回 0 则是大端</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, isLittleEndian());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><ul>
<li>enum 是 C 语言中的自定义类型关键字</li>
<li>enum 能够定义<strong>整形常量</strong>的集合类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TypeName</span> &#123;</span></span><br><span class="line">    IntConst1,</span><br><span class="line">    INtConst2,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    IntConstN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>第一个枚举常量默认值为 0</li>
<li>后续常量的值在前一起常量值的基础上加1</li>
<li>可以任意对枚举常量指定整型值（<strong>只能指定整型值</strong>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span>MON = <span class="number">1</span>, Tue, WED, THU, FRI, SAT, SUN&#125;; <span class="comment">// 1, 2, 3, ,4 ,5, 6, 7</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> &#123;</span>Spring, Summer = <span class="number">3</span>, Autumn, Winter = <span class="number">-1</span>&#125;; <span class="comment">// 0, 3, 4, -1</span></span><br><span class="line"><span class="comment">// enum Day、num Season 大小分别为 4 个字节</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C&#x2F;C++ 中，枚举类型中的每个枚举成员（如 <code>MON</code>, <code>Tue</code>, 等等）是一个<strong>编译期常量</strong>。这些常量并不需要存储在枚举类型中，它们只是用来表示某些具体的数值，通常会被替换为它们的对应值，而不是占用存储空间。</p>
<p>这些常量在编译时是已知的，并且在运行时不需要存储在内存中。<strong>它们只是简单的整数常量，编译器在需要使用这些值时会直接替换它们</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>辅助语句</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E8%BE%85%E5%8A%A9%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="C语言中的注释"><a href="#C语言中的注释" class="headerlink" title="C语言中的注释"></a>C语言中的注释</h2><ul>
<li>注释是<strong>帮助理解程序</strong>而编写的文本</li>
<li>注释本身对程序功能无任何贡献</li>
<li>注释分为<strong>单行注释</strong>和<strong>多行注释</strong><ul>
<li>注意：单行注释不一定被编译器支持</li>
</ul>
</li>
</ul>
<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul>
<li>逗号（,）优先级最低，逗号表达式可以配合括号使用</li>
<li>逗号表达式的意义是<strong>将多个语句连接为一个语句</strong></li>
<li>逗号表达式<strong>从左向右</strong>开始执行语句</li>
<li>逗号表达式的值就是<strong>最右边语句的值</strong></li>
</ul>
<h2 id="，–"><a href="#，–" class="headerlink" title="++，–"></a>++，–</h2><ul>
<li>不要在一个表达式中混合四则运算与自增（自减）运算<ul>
<li>i &#x3D; i++ * ++i;</li>
</ul>
</li>
</ul>
<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>程序世界的“破坏者”</p>
<ul>
<li>goto 是 C 语言中的一个关键字，用于无条件暴力跳转</li>
<li>goto 的跳转位置由标签指定（具体指定某行代码）</li>
<li>标签就是一个 C 语言中的合法命名，并以（:）结束</li>
<li>语法：goto LABEL;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> LABEL;</span><br><span class="line">c = <span class="number">2</span>;</span><br><span class="line">LABEL:</span><br><span class="line">	print(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">===========================================</span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a + c &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, c = %d\n&quot;</span>, a, c);</span><br><span class="line">        <span class="keyword">goto</span> ELSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ELSE: <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, c, a + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以称为破坏者是因为他破坏了程序的三大基本结构：</p>
<p>顺序、选择、循环</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组是<strong>相同数据类型</strong>变量的<strong>有序集合</strong><ul>
<li>数组作为整体需要一个合法的命名（数组名）</li>
<li>数组中的变量没有独立命名，只有在数组中的编号</li>
<li>数组中变量的个数是固定不变的（数组大小固定）</li>
</ul>
</li>
</ul>
<p><strong>数组的内存布局</strong></p>
<ul>
<li>数组在计算机底层是<strong>一片连续的内存</strong>，用于存储数组元素</li>
<li>数组的大小字节数可以用 sizeof 获取（单位：字节）</li>
</ul>
<p><strong>计算数组的大小</strong></p>
<ul>
<li>type Name[] &#x3D; {V<sub>0</sub>, V<sub>1</sub>, V<sub>2</sub>, …, V<sub>n</sub>,} &#x2F;&#x2F; 共 n 个元素</li>
<li>sizeof(Name) &#x2F; sizeof(Name[0]); &#x2F;&#x2F; 计算结果为 n</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>数组名只能当作左值使用（可以看作是常量）</li>
<li>只能使用<strong>整形常量</strong>对数组大小进行定义<ul>
<li>某些编译器可能支持，是因为编译器本身作了优化，c语言本身是不支持的</li>
</ul>
</li>
<li>只能使用整形值作为下标访问数组元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> arr[size]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的类型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是两个不同类型的数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 类型为：int[10]</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">// 类型为：int[5]</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    a[i] = b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述操作中，按理说是不符合类型的赋值规则的，因为不同类型之间进行输入传递是有可能出现问题的；</p>
<p>在上述赋值操作中，仅仅改变了 a 数组中的前五个变量，这与赋值操作的定义相违背（赋值操作指的是改变所保存的内容，这个改变是完全的改变）；</p>
<p>因此从严格意义上来说是有问题的，但并没有影响程序的运行；</p>
</blockquote>
<p><strong>二维数组</strong></p>
<ul>
<li>二维数组<strong>能且仅能</strong>让编译器自动确定<strong>第一维</strong>的大小</li>
<li>第二维大小必须显示给定，即：数组元素的类型必须正确合法</li>
<li>第一维大小自动确定的方法：（初始值个数 <strong>除以</strong> 第二维大小）<sub>向上取整</sub></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 第一维确定方法：4 / 3 = 2</span></span><br><span class="line"><span class="type">int</span> s1 = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) <span class="comment">// 24 / 12 = 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你声明一个二维数组时，如 <code>int arr[M][N];</code>，这里：</p>
<ul>
<li><code>M</code> 是外层数组的大小，即这个二维数组包含多少个一维数组。</li>
<li><code>N</code> 是内层数组（即每个一维数组）的大小，也就是每个一维数组中有多少个元素。</li>
</ul>
<p>为什么需要指定第二维的大小？</p>
<ol>
<li><strong>内存分配</strong>：编译器需要知道如何为二维数组分配足够的连续内存空间。通过指定 <code>N</code>，编译器可以计算出整个二维数组需要多少字节的内存（<code>M * N * sizeof(int)</code> 对于 <code>int</code> 类型的二维数组）。如果 <code>N</code> 没有被指定，编译器就无法确定每个内部数组的确切大小，进而无法计算整个二维数组所需的总内存量。</li>
<li><strong>索引计算</strong>：在 C 语言中，二维数组的索引是通过 <code>arr[i][j]</code> 这样的形式来访问的。当你知道 <code>N</code> 的值时，编译器可以很容易地计算出 <code>j</code> 索引对应的元素在内存中的偏移量（即 <code>j</code> 乘以每个内部数组的大小，即 <code>N * sizeof(int)</code>）。如果 <code>N</code> 没有被指定，这种索引计算就无法进行。</li>
<li><strong>类型检查</strong>：在编译时，指定 <code>N</code> 还允许编译器对数组索引进行类型检查，确保索引不会超出数组的边界。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C编译和链接过程</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>C 语言的编译器是将 <strong>C 源代码</strong> 转换为 <strong>机器可执行代码</strong> 的工具。编译器通过几个阶段的处理，把人类可读的高级编程语言代码（如 C 语言）转换为计算机可以直接理解和运行的机器代码。常见的 C 语言编译器有 <strong>GCC</strong>、<strong>Clang</strong>、<strong>MSVC</strong> 等。</p>
<p>一个 C 语言编译器包括：预处理器、编译器、汇编器、链接器等，几个子模块。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p><strong>C 编译器的主要功能和工作流程：</strong></p>
<ol>
<li><strong>预处理（Preprocessing）</strong>：</li>
</ol>
<ul>
<li><p>处理所有的注释，以空格代替</p>
</li>
<li><p>将所有的 #define 删除，并且展开所有的宏定义</p>
</li>
<li><p>处理条件编译指令 #if、#ifdef、#elif、#else、#endif</p>
</li>
<li><p>处理 #include，展开被包含的文件</p>
</li>
<li><p>保留编译器需要使用的 #pragma 指令</p>
<p>预处理指令示例：gcc -E file.c -o file.i</p>
</li>
</ul>
<ol start="2">
<li><strong>编译（Compilation）</strong>：</li>
</ol>
<ul>
<li><p>对预处理文件进行<strong>词法分析</strong>、<strong>语法分析</strong>和<strong>语义分析</strong></p>
<ul>
<li>词法分析：分析关键字、标识符、立即数等是否合法</li>
<li>语法分析：分析表达式是否遵循语法规则</li>
<li>语义分析：在语法分析的基础上进一步分析表达式是否合法</li>
</ul>
</li>
<li><p>分析结束后进行<strong>代码优化生成相应的汇编代码文件</strong></p>
<p>编译指令示例：gcc -S file.i -o file.s</p>
</li>
</ul>
<ol start="3">
<li><strong>汇编（Assembly）</strong>：</li>
</ol>
<ul>
<li><p>汇编器将汇编代码代码转为 <strong>机器指令</strong>（即目标代码，通常是 <code>.obj</code> 或 <code>.o</code> 文件）。</p>
</li>
<li><p>每条汇编语句几乎都对应一条机器指令</p>
<p>汇编指令示例：gcc -c file.s -o file.o</p>
</li>
</ul>
<ol start="4">
<li><strong>链接（Linking）</strong>：</li>
</ol>
<ul>
<li>链接器负责将不同的目标文件（包括库文件、外部依赖）合并到一起，生成最终的可执行文件（如 <code>.exe</code> 或 <code>.out</code> 文件）。</li>
<li>链接器还会处理符号解析，确保函数和变量在整个程序中正确引用。</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Clianjieqi.png" alt="Clianjieqi"></p>
<h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>连接器的主要作用是把各个模块之间相互引|用的部分处理好,使得各个模块之间能够正确的衔接。</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/lianjieguoc.png" alt="lianjieguoc"></p>
<p><strong>链接器的两种工作模式</strong></p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a><strong>静态链接</strong></h3><p>将所有的库代码和目标文件合并到最终的可执行文件中。</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cjintailianjie.png" alt="Cjintailianjie"></p>
<p>a.out 可以单独运行，不依赖外部库；运行时无需动态加载库，启动速度快。</p>
<p><strong>Linux 下静态库的创建和使用</strong></p>
<ul>
<li>编译静态库源码：gcc -c lib.c -o lib.o</li>
<li>生成静态库文件：ar -q lib.a lib.o<ul>
<li>（ar 是个打包命令会将后面列出来的的所有文件打包进 lib.a 中）</li>
</ul>
</li>
<li>使用静态库编译：gcc main.c lib.a -o main.out<ul>
<li>此时生成的 main.out 程序可以单独运行，即使你将 main.c、lib.a、lib.c、lib.o这些源文件全部删掉也没有影响。</li>
</ul>
</li>
</ul>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><ul>
<li>只在生成可执行文件时记录库的位置，在程序运行时由系统加载动态库（如 <code>.dll</code> 文件或 <code>.so</code> 文件）。</li>
<li>可执行<strong>程序在运行时</strong>才动态加载库进行链接</li>
<li>库的内容不会进行到可执行文件中</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cdongtailianjie.png" alt="Cdongtailianjie"></p>
<p>连接器在最后链接时候不会将 lib1.so、lib2.so 直接打包进 a.out，他只知道可执行程序在执行时需要查找的库在什么位置。</p>
<p>stub1、stub2 就是 liib1.so、lib2.so 分别暴露出来告诉编译器他可以使用的内容只有 stub1、stub2；</p>
<blockquote>
<p>库的更新可能导致不兼容问题（即 “DLL Hell”）。</p>
</blockquote>
<p><strong>Linux 下动态链接的创建和使用</strong></p>
<ul>
<li>编译动态库源码：gcc -shared dlib.c -o dlib.so</li>
<li>使用动态库编译：gcc main.c -ldl -o main.out</li>
<li>关键系统调用<ul>
<li>dlopen：打开动态库文件</li>
<li>dlsym：查找动态库中的函数并返回调用地址</li>
<li>dlclose：关闭动态库文件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>main函数与命令行参数</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/main%E5%87%BD%E6%95%B0%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p><strong>main 函数的本质究竟是什么?</strong></p>
<ul>
<li>main 函数是操作系统调用的函数</li>
<li>操作系统总是将 main 函数作为<strong>应用程序的开始</strong></li>
<li>操作系统将 main 函数的<strong>返回值</strong>作为<strong>程序的退出状态</strong></li>
</ul>
<p>程序在运行的时候就会产生一个进程，那么操作系统如何去判断这个程序是否是异常退出的呢，有些操作系统会弹出一个对话框，告诉我们应用程序异常退出；</p>
<blockquote>
<p>在 window 下可以使用 echo %ERRORLEUEL% 指令打印出 main 函数返回的值</p>
</blockquote>
<p><strong>那么操作系统是如何使用 main 函数给他的返回值呢</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m A&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m B&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们只在 cmd 中执行 B.exe &amp;&amp; A.exe（从 C 语言来看功能就是正常执行完 B.exe 之后在去执行 A.exe）:</p>
<p>这里我们会发现，程序只输出了 I’m B，说明 99 找个返回值对于操作系统来说是异常的，是不正常执行之后返回的状态；</p>
<p>此时我们反过来  A.exe &amp;&amp; B.exe 就会发现，既输出了 I’m A 也输出了 I’m B，说明 0 找个返回值对于操作系统来说是个正常执行后所返回的状态；</p>
<blockquote>
<p>建议在写程序时候利用这种返回值为 int 0 的标准 main 函数；</p>
</blockquote>
<p><strong>main 函数的参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* env[])</span></span><br><span class="line"><span class="comment">// argc - 命令行参数的个数</span></span><br><span class="line"><span class="comment">// argv - 命令行数组</span></span><br><span class="line"><span class="comment">// env  - 环境变量数组    </span></span><br></pre></td></tr></table></figure>

<p><strong>以 GCC 编译器为例，该如何使用：</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/CGCCliebiaocanshu.png" alt="CGCCliebiaocanshu"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* env[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==============Begin argv==============\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==============End argv==============\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==============Begin env==============\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, env [i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==============End env==============\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 ./a.out 输出：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    ==============Begin argv==============</span></span><br><span class="line"><span class="comment">    ./a.out</span></span><br><span class="line"><span class="comment">    ==============End argv==============</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ==============Begin env==============</span></span><br><span class="line"><span class="comment">    SHELL=/bin/bash</span></span><br><span class="line"><span class="comment">    WSL2_GUI_APPS_ENABLED=1</span></span><br><span class="line"><span class="comment">    WSL_DISTRO_NAME=Ubuntu-22.04</span></span><br><span class="line"><span class="comment">    NAME=ThinkPad</span></span><br><span class="line"><span class="comment">    PWD=/home/kay/workspace/test</span></span><br><span class="line"><span class="comment">    LOGNAME=kay</span></span><br><span class="line"><span class="comment">    MOTD_SHOWN=update-motd</span></span><br><span class="line"><span class="comment">    HOME=/home/kay</span></span><br><span class="line"><span class="comment">    LANG=C.UTF-8</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    ==============End env==============</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>环境变量数组中，并没有给出具体的长度信息，所以通过空去判断；</p>
<p>env 中打印的是程序在运行过程中，操作系统传递进行来的环境变量的信息；</p>
<p>argv 中的参数就是传递给 main 函数所使用的参数；</p>
</blockquote>
<p><strong>main 函数一定是程序执行的第一个函数吗？</strong></p>
<p>这类问题要分情况讨论，以 GCC 编译器为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是 GCC 编译器，如果不是则定义一个空的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __attribute__(x) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC 编译器的属性关键字，表示在 main 函数执行之前先执行下列的函数也就是 void before_main()</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">before_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC 编译器的属性关键字，表示在 main 函数执行之后再执行下列的函数也就是 void after_main()</span></span><br><span class="line">__attribute__((destructor)) </span><br><span class="line"><span class="type">void</span> <span class="title function_">after_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	before_main</span></span><br><span class="line"><span class="comment">	main</span></span><br><span class="line"><span class="comment">	after_main</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>一个 C 程序是从 main 函数开始的</li>
<li>main 函数是<strong>操作系统</strong>调用的函数</li>
<li>main 函数有<strong>参数</strong>和<strong>返回值</strong></li>
<li>现代编译器支持再 main 函数前调用其他函数</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言内存布局</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p><strong>动态内存分配的意义</strong></p>
<ul>
<li>C 语言中的一切操作都是<strong>基于内存</strong>的</li>
<li><strong>变量</strong>和<strong>数组</strong>都是<strong>内存的别名</strong><ul>
<li><strong>内存分配</strong>由编译器在<strong>编译期间决定</strong></li>
<li><strong>定义数组</strong>的时候必须<strong>指定数组长度</strong></li>
<li><strong>数组长度</strong>是在编译器就<strong>必须确定</strong>的</li>
</ul>
</li>
</ul>
<p>在程序运行的过程中，可能需要使用一些额外的内存空间，这时候就需要使用到动态内存分配</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><strong>malloc 和 free 用于执行动态内存分配和释放</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cneicunfenpei.png" alt="Cneicunfenpei"></p>
<ul>
<li>malloc 所分配的是<strong>一块连续的内存</strong></li>
<li>malloc 以<strong>字节为单位</strong>，并且<strong>不带任何的类型信息</strong></li>
<li>malloc <strong>不会初始化申请的内存空间</strong></li>
<li>free 用于将<strong>动态内存归还系统</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* pointer)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>malloc 和 free 都是<strong>库函数</strong>，而<strong>不是系统调用</strong>（不是操作系统提供的函数）</li>
<li>malloc 实际分配的内存<strong>可能</strong>会比请求的多（malloc 是库函数，他的实现需要操作系统的支持，不同的操作系统对于内存的管理不同，以 Linux 为例，空闲的空间总是 4 自己的整数倍，这时我们申请三个字节，就有可能分配给我们的是 4 个字节）</li>
<li><strong>不能依赖</strong>于不同平台下 malloc 行为（不同操作系统对于相同大小空间的申请可能存在差异）</li>
<li>当请求的<strong>动态内存无法满足</strong>时 malloc 返回 NULL</li>
<li>当 free 的<strong>参数为 NULL 时</strong>，函数<strong>直接返回</strong></li>
</ul>
<p><strong>思考 malloc(0); 将返回什么？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 在内存中动态的开辟一段空间，空间的大小为 0，空间的首地址为 p</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 这段空间的首地址为 0x55f7db0e12a0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p); <span class="comment">// p = 0x55f7db0e12a0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何我不停的向内存申请 malloc(0); 会造成内存溢出么</strong></p>
<blockquote>
<p>会，这与操作系统对于内存的管理机制有关，在某些系统中，可能我们申请的空间大小为 0，但因为空间管理机制而导致我们申请到达空间是非 0 的；</p>
<p>所以这里要注意，即使我们 malloc(0); 最后也必须要  free(p);</p>
</blockquote>
<p><strong>一个内存泄漏检测模块的示例代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mleak.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 申请了内存空间，却没有指针指向它，必然会导致无法释放该空间，也就是内存泄漏</span></span><br><span class="line">    MALLOC(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)MALLOC(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    f();</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印内存泄露的信息</span></span><br><span class="line">    <span class="comment">// Address: 0x8377018, size:100, Location: test.c: 6</span></span><br><span class="line">    PRINT_LEAK_INF0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>calloc 和 realloc</strong></p>
<ul>
<li>void* calloc(size_t num, size_t size);<ul>
<li>calloc 的<strong>参数代表</strong>所返回内存的<strong>类型信息</strong></li>
<li>calloc 会将返回的<strong>内存初始化为 0</strong></li>
</ul>
</li>
<li>void* realloc(void* pointer, size_t new_size);<ul>
<li>void* realloc 用于<strong>修改</strong>一个原先<strong>已经分配的内存块大小</strong></li>
<li>在使用 realloc 之后应该使用其返回值</li>
<li>当 pointer 的<strong>第一个参数为 NULL 时，等价于 malloc</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要申请三个 int 类型的空间可以这么写</span></span><br><span class="line"><span class="comment">// 3 表示类型数量，4 表示类型的大小</span></span><br><span class="line"><span class="type">int</span>* p1 = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 修改已经分配的内存块大小</span></span><br><span class="line"><span class="comment">// 将 p1 的大小修改为 8 个字节大小    </span></span><br><span class="line">p1 = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p1, <span class="number">8</span>);    </span><br></pre></td></tr></table></figure>

<p><strong>malloc：</strong> 只负责进行申请空间申请，不会进行内容初始化，所以内容是随机的</p>
<p><strong>calloc：</strong> 申请出来的内存空间会初始化为 0</p>
<p><strong>realloc：</strong>新扩容出来的的空间不会进行初始胡</p>
<p><strong>小结</strong></p>
<ul>
<li><strong>动态内存分配</strong>是 C 语言中的<strong>强大功能</strong></li>
<li>程序<strong>能够</strong>在需要的时候<strong>有机会</strong>使用更多的内存</li>
<li>malloc 单纯的从系统中<strong>申请固定字节</strong>大小的内存</li>
<li>calloc 能以<strong>类型大小为单位</strong>申请内存并初始化为 0</li>
<li>realloc 用于<strong>重置</strong>内存空间大小</li>
</ul>
<h2 id="程序中的三分天下"><a href="#程序中的三分天下" class="headerlink" title="程序中的三分天下"></a>程序中的三分天下</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>程序中的栈</strong></p>
<ul>
<li><p>栈是现代计算机程序里<strong>最为重要的概念之一</strong></p>
</li>
<li><p>栈在程序中用于<strong>维护函数上下文</strong></p>
</li>
<li><p>函数中的<strong>参数和局部变量存储在栈上</strong></p>
</li>
<li><p>栈是一种<strong>后进先出</strong>的行为</p>
</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Czhongdezhan.png" alt="Czhongdezhan"></p>
<ul>
<li>栈保存了一个函数调用所需的维护信息</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Czhanhuodongjilu.png" alt="Czhanhuodongjilu"></p>
<p><strong>函数调用过程</strong></p>
<p>每次函数调用都对应着一个栈上的活动记录</p>
<ul>
<li>调用函数的活动记录位于栈的中部</li>
<li>被调函数的活动记录位于栈的顶部</li>
<li>esp 栈指针，用于指向函数调用后返回的地址（栈顶）跟踪栈的增长和缩减；</li>
<li>ebp 基址指针，用于指向当前函数帧的基址<strong>，即当前函数栈帧的起始地址</strong>；</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Chanshudiaoyongguocheng.png" alt="Chanshudiaoyongguocheng"></p>
<p><strong>函数调用时栈的变化</strong></p>
<ul>
<li>从 main() 开始运行</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cmainkaishizhixing.png" alt="Cmainkaishizhixing"></p>
<blockquote>
<p>每次调用一个函数时，系统会为这个函数创建一个新的<strong>栈帧</strong>（开辟一段新的空间），</p>
<p><strong>EBP：</strong>本身并不存储在当前函数栈帧的起始位置。它指向的是当前栈帧的基址（通常是栈帧的起始位置），但它自身的值不会被存储在这个起始位置上。</p>
<p><strong>ESP：</strong> 是栈顶指针，它指向当前栈的栈顶，随着数据的压栈和弹栈，ESP 不断变化。</p>
<p><strong>返回地址：</strong>函数调用返回后，主程序应该继续执行的代码位置（通常是调用函数的调用条指令的下一条指令的地址）；</p>
<p><strong>Old EBP：</strong>调用的基址；</p>
</blockquote>
<ul>
<li>当 main() 调用 f()</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cmaindiaoyonghanshu.png" alt="Cmaindiaoyonghanshu"></p>
<ul>
<li>当从 f() 调用中返回 main()</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Chanshufanhuimain.png" alt="Chanshufanhuimain.png"></p>
<blockquote>
<p>当 f() 调用结束返回时，</p>
<ul>
<li><p>通过 <code>mov esp, ebp</code> 将 ESP 设置为 EBP 的值。这一步是为了将 ESP 恢复到当前栈帧的顶端位置，也就是栈帧的基址，这样方便释放当前函数的栈帧空间。</p>
</li>
<li><p>通过 <code>pop ebp</code> 指令，将栈上的旧 EBP 恢复到寄存器中。这一步恢复了调用者的 EBP，即调用者的栈帧基址。</p>
</li>
<li><p><code>ret</code>: 使用栈上的返回地址，跳转到调用者函数继续执行。</p>
</li>
</ul>
</blockquote>
<p><strong>函数调用栈上的数据</strong></p>
<ul>
<li>函数调用时，<strong>对应的栈空间在函数返回前是专用的</strong></li>
<li>函数调用结束后，<strong>栈空间将被释放，数据不再有效</strong></li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Chanshudiaoyongzhanshangshuju.png" alt="Chanshudiaoyongzhanshangshuju"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* pointer = g(); <span class="comment">// 野指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        b[i] = pointer[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d\n&quot;, pointer[i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    f();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在低版本的编译器中 b[10] 中的值会被 a[10] 中的值覆盖掉，因为当你在 C 语言中调用函数时，局部变量的内存分配在栈上。函数返回后，局部变量所占用的内存不会被清空或初始化为特定的值，而是变得不可用（或无效）。这段内存可能仍然保持原有的数据，直到被后续的函数调用或其他栈操作覆盖。</p>
<p>而现代标本会将 g() 函数所在的空间标记位不可用，此时第一个 for 就会报错 Segmentation fault (core dumped)，因为你访问了一个不可达的内区区域；</p>
<p>当我们将前面两个 for 循环删除并打开第三个 for 循环时，会发现输出的内容为无意义的随机值，因为此时 g() 函数所在的空间被 print() 函数所占用了，此时 pointer[i] 指向的位置就变成了未知的内容；现代编译器会报段错误 Segmentation fault (core dumped)；</p>
</blockquote>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>堆是<strong>程序中一块预留的内存空间</strong>，可由程序自由使用</li>
<li>堆中被<strong>程序申请使用的内存在被主动释放前一直有效</strong></li>
</ul>
<blockquote>
<p>为什么有了栈还需要堆</p>
<ul>
<li>栈上的数据在函数返回后就会被释放掉</li>
<li>无法传递到函数外部，如：局部变量</li>
</ul>
</blockquote>
<p><strong>程序中的堆</strong></p>
<ul>
<li>C 语言程序中<strong>通过库函数的调用获得堆空间</strong><ul>
<li>头文件：malloc.h</li>
<li>malloc – 以字节的方式<strong>动态申请空间</strong></li>
<li>free     – <strong>将堆空间归还给系统</strong></li>
</ul>
</li>
</ul>
<p><strong>系统对堆空间的管理方式</strong></p>
<ul>
<li>空闲链表、位图法、对象池法等等</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Ckonglianbiaoguanlitu.png" alt="Ckonglianbiaoguanlitu"></p>
<blockquote>
<p>在不同的系统里面对于堆空间的管理是不同的，</p>
<p>C 语言是以高效而闻名的，那么在 malloc 调用的时候，也就是说向堆里面申请内存的时候，也必须是高效的；那么操作系统是如何做到高效的呢？以空闲链表为例，系统会将堆中的空间组织为一条链表，每个节点上所代表的数字就是这个节点下，每个单元内存的大小，当我们调用 malloc 时，系统就会取遍历这个空闲链表，去比较我们所需要的空间和哪一个节点下的空间大小最为接近，找到之后就会在其下的空间中找到一段可以使用的内存并返回给 p；这也就是 malloc 中所申请的空间可能会比实际空间大一点点的原因所在；</p>
</blockquote>
<h3 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h3><ul>
<li>静态存储区<strong>随着程序的运行而分配空间</strong>（在编译期确定大小）</li>
<li>静态存储区的<strong>生命周期直到程序运行结束</strong></li>
<li>在程序的<strong>编译期</strong>静态存储区的<strong>大小就已经确定</strong></li>
<li>静态存储区主要用于保存<strong>全局变量</strong>和<strong>静态局部变量</strong></li>
<li>静态存储区的信息最终会<strong>保存到可执行程序中</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_vs  = <span class="number">2</span>; <span class="comment">// static 修饰表示旨在当前文件可用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> g_vl = <span class="number">3</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;g_vl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;g_v);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;g_vs);</span><br><span class="line">    </span><br><span class="line">    f();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局变量、静态全局变量、静态局部变量，都是放在静态存储区中的</p>
</blockquote>
<p><strong>栈、堆和静态存储区是程序中的三个基本数据区</strong></p>
<ul>
<li>栈区主要用于函数调用的使用</li>
<li>堆区主要适用于内存的动态申请</li>
<li>静态存储区用于保存全局变量和静态变量</li>
</ul>
<h2 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h2><h3 id="程序文件的一般布局"><a href="#程序文件的一般布局" class="headerlink" title="程序文件的一般布局"></a>程序文件的一般布局</h3><p><strong>不同代码在可执行程序中的对应关系</strong></p>
<p>在编译和链接过程中，C 程序的内存布局分为不同的段，不同的代码会被分配在不同的段中；</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Ccxuwenjianyibanbuju.png" alt="Ccxuwenjianyibanbuju"></p>
<p><strong>File Header：</strong>包含了与操作系统和加载器相关的信息，描述了可执行文件的基本结构和布局。文件头通常位于可执行文件的起始位置，为操作系统和加载器提供必要的元数据以正确地加载、执行和管理该程序。</p>
<p><strong>.bss 段：</strong>存储 <strong>未初始化</strong> 的全局变量和静态变量。</p>
<ul>
<li><strong>未初始化</strong>的全局变量和静态变量会存储在这里。</li>
<li>这些变量会在程序启动时被系统自动初始化为 <strong>0</strong>（或对应的 NULL 指针等）。</li>
<li><code>.bss</code> 段在可执行文件中并不会占据空间，因为未初始化的变量在加载时由操作系统分配，并且值被默认初始化为 0。</li>
</ul>
<p><strong>.data 段：</strong>存储 <strong>已初始化</strong> 的全局变量和静态变量。</p>
<ul>
<li>已初始化的全局变量和静态变量会存储在这里，数据在程序加载时被初始化为编译时指定的值。</li>
<li><code>.data</code> 段是可写的，因此在程序运行过程中这些变量可以被修改。</li>
<li>存储在 <code>.data</code> 段中的数据会直接写入可执行文件中，并在加载时映射到内存中。</li>
</ul>
<p><strong>.text 段：</strong>存储程序的 <strong>代码指令</strong>（即可执行的机器指令）。</p>
<ul>
<li>这个段通常是<strong>只读</strong>的，不能被修改。现代操作系统通过内存保护机制防止程序在运行时修改 <code>.text</code> 段的内容，这也是防止代码被恶意修改或破坏的安全措施。</li>
<li>这个段中的内容是<strong>可执行</strong>的。CPU 会从这里读取指令并执行。</li>
<li>在某些情况下（如动态链接库），不同进程可以<strong>共享</strong> .text 段以节省内存。</li>
</ul>
<p><strong>.rodata：</strong>专门用于存储程序中的 <strong>只读数据</strong>，即程序中那些在运行时不能被修改的<strong>常量和字符串字面量</strong>等。</p>
<ul>
<li>这个段的数据是只读的，程序在运行时不能修改这个段中的内容。如果尝试修改，将会导致程序崩溃（通常会抛出内存访问违规错误）。</li>
<li>这个段中的内容不是程序的指令，而是只读的数据，因此它不可执行。</li>
<li>包含了程序中的常量值（如 const 关键字定义的变量）和字符串字面量等数据。</li>
</ul>
<p><strong>程序与进程</strong></p>
<ul>
<li><strong>程序是静态的概念</strong>，表现形式为一个可执行文件</li>
<li><strong>进程是动态的概念</strong>，程序由操作系统加载运行后得到进程</li>
<li>每个程序可以<strong>对应多个进程</strong></li>
<li>每个进程只能<strong>对应一个程序</strong></li>
</ul>
<p><strong>思考</strong></p>
<p><strong>包含脚本代码的文本文件</strong>是一种类型的可执行程序吗？如果是，对应什么样的进程呢？</p>
<p>我们的脚本代码可以说是一种可执行程序，但是它不是一种可以直接运行的可执行程序；他的加载流程如下：</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cjiaobenwenjianyunxinguocheng.png" alt="Cjiaobenwenjianyunxinguocheng"></p>
<p><strong>文件布局在内存中的映射</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cwenjianbujuyinsheneicun.png" alt="Cwenjianbujuyinsheneicun"></p>
<blockquote>
<p>堆和栈是程序运行时用于存储<strong>动态内存</strong>和<strong>局部变量</strong>的区域。它们的内存是在运行时动态分配的，并不是编译时确定的。</p>
<p><strong>.text、.data 和 .bss 段</strong>：这些段是程序可执行文件中的一部分，<strong>在程序加载时</strong>由操作系统分配到内存中，负责存储程序的指令和静态数据。</p>
<p>静态存储区：通常指程序中的 .bss 和 .data 段</p>
<p>只读存储区：通常指程序中的 .rodata 段</p>
<p>局部变量所占空间为栈上的空间</p>
<p>动态空间为堆中的空间</p>
<p>程序可执行代码存放于 .text 中（也就是我们常说的代码段）</p>
</blockquote>
<p><strong>思考</strong></p>
<p><strong>同样是全局变量和静态变量，为什么初始化和未初始化的保存在不同的段中？</strong></p>
<p>一个全局变量或者静态变量，没在有初始化的话通常情况下值为 0，初始化过的值就是固定的；而 C 语言是以高效所闻名的，那么对于未初始化的全局变量和静态变量，在加载时候如果这些未初始化的内存都是统一放在一起的那么我只需要挨个初始化即可；而已经初始化完成的全局变量和静态变量他们的初始值已经给出来了，我们需要将变量与其初值在内存中进行一一对应处理；这二者的复杂程序不同，如果都放在同一个区域中，那么对于效率会产生影响；会将简单的事情也变得复杂；</p>
<p><strong>小结</strong></p>
<ul>
<li>程序源码在编译后<strong>对应</strong>可执行区域中的<strong>不同存储区</strong></li>
<li>程序和进程不同，<strong>程序是静态概念</strong>，<strong>进程是动态概念</strong></li>
<li><strong>堆栈段</strong>是程序运行的基础，<strong>只存在于进程空间中</strong></li>
<li>程序<strong>可执行代码</strong>存放于 .text 段，是<strong>只读的</strong></li>
<li>.bss 和 .data 段用于保护<strong>全局变量</strong>和<strong>静态变量</strong></li>
</ul>
<h3 id="内存操作的经典问题分析"><a href="#内存操作的经典问题分析" class="headerlink" title="内存操作的经典问题分析"></a>内存操作的经典问题分析</h3><p><strong>野指针</strong></p>
<ul>
<li>指针变量中的值是<strong>非法的内存地址</strong>，进而<strong>形成野指针</strong></li>
<li>野指针不是 NULL 指针，<strong>是指向不可用内存地址的指针</strong></li>
<li><strong>NULL 指针并无危害</strong>，很好判断，也很好调试</li>
<li>C 语言中<strong>无法判断一个指针所保存的指针是否合法</strong></li>
</ul>
<p>在开发中一定要尽量杜绝野指针的出现；</p>
<p><strong>野指针的由来</strong></p>
<ul>
<li>局部指针变量<strong>没有被初始化</strong></li>
<li>指针所指向的<strong>变量在指针之前被销毁</strong></li>
<li>使用已经释放过的指针</li>
<li>进行了错误的指针运算</li>
<li>进行了错误的强制类型转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 野指针示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="type">int</span>* p2 = (<span class="type">int</span>*)<span class="number">1234567</span>; <span class="comment">// 错误的强制类型转换</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// P1 + i，实际上移动了 4 个字节</span></span><br><span class="line">        *(p1 + i) = <span class="number">40</span> - i; <span class="comment">// 进行了错误的指针运算，指针越界了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1); <span class="comment">// 释放了 p1 的空间，但不会重置 p1,后面在使用 p1，p1 就是野指针</span></span><br><span class="line">    <span class="comment">// p1 = NULL 每次释放后将指针赋值为 NULL 是避免出现野指针的一种有效方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">40</span>; i++) &#123;</span><br><span class="line">        p1[i] = p2[i]; <span class="comment">// 野指针操作的示例 Segmentation fault (core dumped)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>避免野指针的一些基本原则</strong></p>
<ul>
<li>决不返回<strong>局部变量</strong>和<strong>局部数组</strong>的地址</li>
<li>任何变量在定义后<strong>必须进行初始化</strong></li>
<li>字符串必须<strong>确定 \0 操作符后才能认为他是一个字符串</strong></li>
<li>任何使用与<strong>内存操作相关的函数都必须指定长度信息</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> p[] = <span class="string">&quot;D.T.Software&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span> <span class="comment">// 没有初始化，产生野指针</span></span><br><span class="line">    <span class="type">char</span>* p = func(); <span class="comment">// p 就是野指针</span></span><br><span class="line">    <span class="comment">// s.name 是个野指针，因为没有进行初始化，导致他指向的地址是未知的</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, p); <span class="comment">// Segmentation fault (core dumped)</span></span><br><span class="line">    </span><br><span class="line">    s.number = <span class="number">99</span>;</span><br><span class="line">    </span><br><span class="line">    p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// p 的长度只有 5 却赋值超过了它本身长度的内容</span></span><br><span class="line">    <span class="comment">// 这会产生内存越界</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;D.T.Software&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    del(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><ul>
<li>结构体<strong>成员指针未初始化</strong></li>
<li>结构体成员指针<strong>未分配足够的内存</strong></li>
<li>内存<strong>分配成功</strong>，单并<strong>未初始化</strong></li>
<li><strong>内存操作越界</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( size % <span class="number">2</span> != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果长度为偶数，将不会执行下面的代码进行初始化</span></span><br><span class="line">    <span class="comment">// 同样也不会进行指针空间的释放</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    test(p, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 双重释放</span></span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">    </span><br><span class="line">    func(<span class="number">9</span>);</span><br><span class="line">    func(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	free(): double free detected in tcache 2 // 双重释放</span></span><br><span class="line"><span class="comment">	Aborted (core dumped)    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一处错误：双重释放</p>
<p>在编程时，我们要了解动态内存也就是堆里面的空间属于谁那个函数，p 是在 main() 中声明的那么其他函数就没有资格释放 p 这个指针；那么这时候看 tset() 中的函数就有问题了，他不应该释放 p；</p>
<p>再者，假设我们有 int a[2] 这样一个数组，此时我们调用 test(a, 2) 此时就会报错，因为 free() 释放的是堆上的空间，栈上空间是只读的，free() 释放栈上的空间，这时候就会发生 段错误；</p>
<p>除非特别特殊的性能需求，不然尽量要做到谁申请，谁释放；</p>
</blockquote>
<p><strong>二次释放错误的原因</strong></p>
<p>当你第一次调用 <code>free()</code> 时，C 语言的运行时库会将这块内存标记为 “空闲”。操作系统会把它添加到一个空闲列表中，以备后续的内存分配操作使用。此时，这块内存仍然存在于堆中，在被其他的内容覆盖前，内容依然是存在的，但程序不应该再使用它，因为它可能会在后续内存分配时被覆盖。</p>
<p>如果你再次对同一个指针调用 <code>free()</code>，程序会尝试再次释放已经释放的内存。这时，C 运行时库无法正确判断如何处理这块已经释放的内存。由于 C 语言的内存管理系统不期望同一块内存被释放两次，系统将检测到这种非法操作，通常会抛出一个错误，可能是段错误（<code>Segmentation Fault</code>）或者 <strong>double free</strong> 错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Demo</span> <span class="title">d1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Demo</span> <span class="title">d2</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;a&#x27;</span>; i&lt;<span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// p 这个指针指向的内存是未知的</span></span><br><span class="line">        d1.p[i] = <span class="number">0</span>; <span class="comment">// 段错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// calloc 初始化会默认初值为 0</span></span><br><span class="line">    d2.p = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">// 所以这里是没问题的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, d2.p);</span><br><span class="line">    <span class="comment">// 内存越界</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;a&#x27;</span>; i&lt;<span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">        d2.p[i] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(d2.p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一些内存操作的规则</strong></p>
<ul>
<li>动态申请内存后，应该立即检查指针值是否为 NULL，防止使用 NULl 指针；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p != null) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<ul>
<li>free 指针后必须立即赋值为 NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(p != null) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>任何与内存操作相关的函数都必须带长度信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;cn.kay.wang&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>malloc 操作和 free 操作必须匹配，防止内存泄漏和多次释放。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maiin</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    func();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>内存错误的本质<strong>源于</strong>指针保存的<strong>地址为非法值</strong><ul>
<li>指针变量未初始化，保存随机值</li>
<li>指针运算导致内存越界</li>
</ul>
</li>
<li>内存泄露源于 malloc 和 free 不匹配<ul>
<li>当 malloc 次数多于 free 时，产生内存泄漏</li>
<li>当 malloc 次数少于 free 时，程序可能崩溃</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和指针</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>函数类型</strong></p>
<ul>
<li>C 语言中的<strong>函数有自己特定的类型</strong></li>
<li>函数的类型由<strong>返回值</strong>，<strong>参数类型</strong>和<strong>参数个数</strong>共同决定<ul>
<li>int add (int i, int j) 的类型为 int(int, int)</li>
</ul>
</li>
<li>C 语言中通过 typedef 为函数类型<strong>重命名</strong><ul>
<li>typedef type name(parameter list)</li>
</ul>
</li>
<li>例如：<ul>
<li>typedef int f(int, int) &#x2F;&#x2F; 将 int 类型重命名为 int f(int, int)</li>
<li>typedef void p(int);</li>
</ul>
</li>
</ul>
<p><strong>函数指针</strong></p>
<ul>
<li>函数指针用于<strong>指向一个函数</strong></li>
<li>函数名是执行<strong>函数体的入口地址</strong></li>
<li>可通过函数类型定义函数指针：<em><em>FuncType</em> pointer;</em>*</li>
<li>也可以直接定义：*<em>type (<em>pointer)(parameter list);</em></em><ul>
<li>pointer 为<strong>函数指针变量名</strong></li>
<li>type 为所指函数的<strong>返回值类型</strong></li>
<li>parameter list 为所指函数的<strong>参数类型列表</strong></li>
</ul>
</li>
</ul>
<p><strong>如何使用 C 语言直接跳到某个固定的地址开始执行？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(FUNC)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call f()...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    FUNC* pt = test;</span><br><span class="line">    <span class="type">void</span>(*pf)() = &amp;f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里我们将运行后指针的地址直接赋值给函数指针，输出与之前一模一样</span></span><br><span class="line">    <span class="comment">// 说明函数指针可以直接跳到某个固定的地址开始指针</span></span><br><span class="line">    <span class="comment">// void(*pf)() = 0x55ea891ba17c; </span></span><br><span class="line">    <span class="comment">// 三种写法本质一样的，只是写法不同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pf = %p\n&quot;</span>, pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f = %p\n&quot;</span>, f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;f = %p\n&quot;</span>, &amp;f);</span><br><span class="line"></span><br><span class="line">    pf();</span><br><span class="line"></span><br><span class="line">    (*pf)();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function pointer call: %d\n&quot;</span>, pt(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    pf = 0x55ea891ba17c</span></span><br><span class="line"><span class="comment">    f = 0x55ea891ba17c</span></span><br><span class="line"><span class="comment">    &amp;f = 0x55ea891ba17c</span></span><br><span class="line"><span class="comment">    Call f()...</span></span><br><span class="line"><span class="comment">    Call f()...</span></span><br><span class="line"><span class="comment">    Function pointer call: 4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回调函数</strong></p>
<ul>
<li>回调函数是<strong>利用函数指针实现的</strong>一种<strong>调用机制</strong></li>
<li>回调机制原理<ul>
<li>调用者<strong>不知道</strong>具体事件发生时<strong>需要调用的具体函数</strong></li>
<li>被调函数<strong>不知道</strong>和时被调用，<strong>只知道需要完成任务</strong></li>
<li>当具体事件发生时，<strong>调用者通过函数指针调用具体函数</strong></li>
</ul>
</li>
<li>回调机制中的<strong>调用者和被调用者函数互不依赖</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*Weapon)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fight</span><span class="params">(Weapon wp, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fight boss!\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 调用者不知道自己调用的是谁</span></span><br><span class="line">    result = wp(arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Boss loss: %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用者不知道自己什么时候被调用</span></span><br><span class="line"><span class="comment">// 匕首 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knife</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Knife attack: %d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剑</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sword</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sword attack: %d\n&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        ret += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 棍</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gun</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Gun attack: %d\n&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        ret += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fight(knife, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fight(gun, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Fight boss!</span></span><br><span class="line"><span class="comment">    Knife attack: 1</span></span><br><span class="line"><span class="comment">    Knife attack: 1</span></span><br><span class="line"><span class="comment">    Knife attack: 1</span></span><br><span class="line"><span class="comment">    Boss loss: 3</span></span><br><span class="line"><span class="comment">    Fight boss!</span></span><br><span class="line"><span class="comment">    Gun attack: 10</span></span><br><span class="line"><span class="comment">    Gun attack: 10</span></span><br><span class="line"><span class="comment">    Gun attack: 10</span></span><br><span class="line"><span class="comment">    Gun attack: 10</span></span><br><span class="line"><span class="comment">    Gun attack: 10</span></span><br><span class="line"><span class="comment">    Boss loss: 50</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>C 语言中的<strong>函数都有特定的类型</strong></li>
<li>可以使用函数类型<strong>定义函数指针</strong></li>
<li>函数指针是<strong>实现回调机制的关键技术</strong></li>
<li>通过<strong>函数指针</strong>可以实现在 C 程序中实现<strong>固定地址跳转</strong></li>
</ul>
<h2 id="函数的意义"><a href="#函数的意义" class="headerlink" title="函数的意义"></a>函数的意义</h2><p>从高级角度来看 C 语言的组成，C 语言可以是，以不同函数之间的调用组成的；</p>
<p><strong>函数的由来</strong></p>
<p>程序 &#x3D; 数据 + 算法（处理数据的算法）</p>
<p>C 程序 &#x3D; 数据 + 函数</p>
<p><strong>模块化程序设计</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cmokuaihuasheji.png" alt="Cmokuaihuasheji"></p>
<p>所谓的面向过程就是将一个复杂的问题分解为多个简单的问题；</p>
<p><strong>面向过程的程序设计</strong></p>
<ul>
<li>面向过程是一种<strong>以过程为中心</strong>的编程思想</li>
<li>首先<strong>将复杂的问题分解</strong>为一个个容易解决的问题</li>
<li>分解过后的<strong>问题可以按照步骤一步步完成</strong></li>
<li>函数是面向过程在 C 语言中的体现</li>
<li>解决问题的每个<strong>步骤可以用函数来实现</strong></li>
</ul>
<p><strong>函数的声明和定义</strong></p>
<ul>
<li>声明的意义在于<strong>告诉编译器程序单元的存在</strong></li>
<li>定义则明确<strong>指示程序单元的意义</strong></li>
<li>C 语言中通过 extern 进行程序单元的声明</li>
<li>一些程序单元在声明时可以省略 extern</li>
</ul>
<p>严格意义上来说声明和定义并不相同！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明这是一个外部变量，那么在这个文件中编译器就不会在为这个变量分配空间了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">p</span> =</span> <span class="literal">NULL</span>; <span class="comment">// (struct Test*)malloc(sizeof(struct Test));</span></span><br><span class="line">    <span class="comment">// struct Test* p = (struct Test*)malloc(sizeof(struct Test));</span></span><br><span class="line">    <span class="comment">// 这样将会报错，因为 sizeof(struct Test) 无法得到一个确定的大小信息</span></span><br><span class="line">    <span class="comment">// 文件中仅仅有 struct Test 的声明而没有定义，所以 sizeof(struct Test) 无法得到一个大小信息</span></span><br><span class="line">    <span class="comment">// 当编译 extern struct Test; 还没有编译到 Test 所在的文件时，当前文件是无法得到 Test 结构体大小的</span></span><br><span class="line">    <span class="comment">// 所以我们不能依赖于编译器对于文件的编译顺序</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//g_var = 10;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_var = %d\n&quot;</span>, g_var);</span><br><span class="line">    </span><br><span class="line">    f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g(3) = %d\n&quot;</span>, g(<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中变量的定义必然伴随着内存的分配，如果只是声明则只是告诉编译器有这么个变量，并不会开辟新的空间；</p>
</blockquote>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="顺序点"><a href="#顺序点" class="headerlink" title="顺序点"></a>顺序点</h3><ul>
<li>函数参数在<strong>本质</strong>上与局部变量相同<strong>在栈上分配空间</strong></li>
<li>函数参数的<strong>初始值</strong>是函数调用时的<strong>实际值</strong></li>
</ul>
<p><strong>在 C 语言中，函数参数的求值顺序依赖于编译器的实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    func(k++, k++);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    2, 1</span></span><br><span class="line"><span class="comment">    3   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中并没有规定函数参数的求值顺序，只是规定了必须将值求出来之后在进行函数调用</p>
<p>++ 在后先用后加，那么按照输出应该是 后面的 k 传递给函数后 ++ 变成了 2 ，前面这个参数传递给函数后又 ++ 变成了 3；</p>
<p>在 C 语言中，操作符（包括函数）的求值顺序是不固定的，依赖于编译器的实现； （大多数编译器是从右向左的）</p>
</blockquote>
<p><strong>程序的顺序点</strong></p>
<ul>
<li>程序中存在一定的顺序点</li>
<li>顺序点指的是执行过程中<strong>修改变量值的最晚时刻</strong></li>
<li>在程序<strong>到达顺序点的时候</strong>，之前所作的<strong>一切操作必须完成</strong></li>
</ul>
<p><strong>C 语言中的顺序点</strong></p>
<ul>
<li>每个<strong>完整表达式结束时</strong>，即分号处</li>
<li>&amp;&amp;，||，?:，以及<strong>逗号表达式</strong>的每个参数计算后</li>
<li>函数调用时<strong>所有实参求值完成后（进入函数图之前）</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    b = k++ + k++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d\n&quot;</span>, k); <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;&amp; 左右两边都是完成点，a-- = 0 所以不成立</span></span><br><span class="line">    <span class="keyword">if</span>(a-- &amp;&amp; a) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>k</code> 最初是 2。</li>
<li>第一个 <code>k++</code> 会返回 2，然后 <code>k</code> 变为 3。</li>
<li>第二个 <code>k++</code> 会返回 3，然后 <code>k</code> 变为 4。</li>
</ol>
<p>最终的结果是 <code>b = 2 + 3 = 5</code>。因此，打印结果将是 <code>b = 5</code>。</p>
<p>注意，这种用法在 C 标准中是未定义行为，实际结果可能依赖于编译器和优化设置。为了确保可预测的结果，建议避免在同一表达式中对同一变量进行多次修改。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    func(k++, k++);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d\n&quot;</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    2, 1 // 在 vs 编译器中这里的值为 1， 1</span></span><br><span class="line"><span class="comment">	k = 3</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li><p>函数的参数在<strong>栈上分配空间</strong></p>
</li>
<li><p>函数的<strong>实参并没有固定的计算次序</strong></p>
</li>
<li><p><strong>顺序点</strong>是 C 语言中变量修改的最晚时机</p>
</li>
</ul>
<h3 id="参数入栈的顺序"><a href="#参数入栈的顺序" class="headerlink" title="参数入栈的顺序"></a>参数入栈的顺序</h3><p>函数参数的<strong>计算次序是依赖编译器实现的</strong>，那么函数参数的<strong>入栈次序是如何确定</strong>的呢？</p>
<p><strong>调用约定</strong></p>
<p>当<strong>函数调用</strong>发声时</p>
<ul>
<li><strong>参数</strong>会传递给被调用者的函数</li>
<li>而<strong>返回值</strong>会被返回给函数调用者</li>
</ul>
<p><strong>调用约定</strong>描述<strong>参数如何传递</strong>到栈中以及<strong>栈的维护方式</strong></p>
<ul>
<li>参数<strong>传递顺序</strong></li>
<li>调用<strong>栈清理</strong></li>
</ul>
<p>调用约定是<strong>预定义的</strong>可理解为<strong>调用协议</strong></p>
<p>调用约定通常用于<strong>库调用</strong>和<strong>库开发</strong>的时候</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">从右到左依次入栈：__stdcall, __Cdecl, __thiscall（__Cdecl 是 C 语言默认的调用约定）</span><br><span class="line">从左到右依次入栈：__pascal, __fastcall</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中，函数的调用约定（calling convention）是指在函数调用时，如何传递参数、返回值，以及如何管理栈的约定。这些约定对于不同编译器、处理器架构以及操作系统之间的兼容性至关重要。</p>
</blockquote>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>C 语言可以定义<strong>参数可变的寒素</strong></li>
<li>参数可变函数的实现依赖于 stdarg.h 头文件<ul>
<li>va_list    - 参数集合</li>
<li>va_arg   - 取具体参数值</li>
<li>va_start - 标识参数访问的开始</li>
<li>va_end  - 标识参数访问的结束</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> n, ...)</span> &#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    va_start(args, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        sum += va_arg(args, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    va_end(args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, average(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>va_list args：定义一个类型，用于存储可变参数的列表。</p>
<p>va_start(args, n)：表示从 <strong>n</strong> 的下一个参数开始获取可变参数，而 <strong>n</strong> 本身是最后一个固定参数的名称。</p>
<p>va_arg(args, int)：从 <code>args</code> 中获取下一个参数，并将其转换为 <code>int</code> 类型。</p>
<p>va_end(args)：清理 <code>args</code>，以避免内存泄漏。</p>
</blockquote>
<p><strong>可变参数的限制</strong></p>
<ul>
<li>可变参数必须<strong>从头到尾按照顺序逐个访问</strong></li>
<li>参数列表中<strong>至少要村在一个确定的命名参数</strong></li>
<li>可变参数函数<strong>无法确定实际存在的参数的数量</strong></li>
<li>可变参数<strong>无法确定参数的实际类型</strong></li>
</ul>
<blockquote>
<p>va_arg 中如果制定了错误的类型，那么结果是不可预测的</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li>调用约定指定了<strong>函数参数的入栈顺序</strong>以及<strong>栈的清理方式</strong></li>
<li>可变参数是 C 语言提供的一种函数设计技巧</li>
<li>可变参数的函数提供了一种<strong>更方便的函数调用方式</strong></li>
<li>可变参数<strong>必须顺序点访问</strong>，无法直接访问中间的参数值</li>
</ul>
<h2 id="函数与宏"><a href="#函数与宏" class="headerlink" title="函数与宏"></a>函数与宏</h2><ul>
<li>宏是由<strong>预处理器直接替换展开的</strong>，编译器不知道宏的存在</li>
<li>函数是由<strong>编译器直接编译</strong>的实体，调用行为由编译器决定</li>
<li>多次使用宏会<strong>导致最终可执行程序的体积增大</strong></li>
<li>函数时<strong>跳转执行</strong>的，内存中<strong>只有一份函数体的存在</strong></li>
<li><strong>宏的效率比函数要高</strong>，因为是直接展开，无调用开销</li>
<li>函数调用时会创建活动记录，效率不如宏</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><strong>宏</strong>的效率比函数稍高，但是其<strong>副作用巨大</strong></li>
<li>宏是文本替换，参数无法进行类型检查</li>
<li>可以用函数完成的绝对不用宏</li>
<li>宏的定义中不能出现递归定义</li>
</ul>
<p><strong>宏的妙用</strong></p>
<ul>
<li>用于<strong>生成</strong>一些常规性的代码</li>
<li>封装函数，加上类型信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(type, x)   (type*)malloc(sizeof(type)*x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE(p)           (free(p), p=NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#i 是一个预处理器运算符，它将宏参数 i 转换为字符串。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INT(i)        printf(<span class="string">&quot;%s = %d\n&quot;</span>, #i, i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_CHAR(c)       printf(<span class="string">&quot;%s = %c\n&quot;</span>, #c, c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FLOAT(f)      printf(<span class="string">&quot;%s = %f\n&quot;</span>, #f, f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_POINTER(p)    printf(<span class="string">&quot;%s = %p\n&quot;</span>, #p, p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_STRING(s)     printf(<span class="string">&quot;%s = %s\n&quot;</span>, #s, s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOREACH(i, n)     while(1) &#123; int i = 0, l = n; for(i=0; i &lt; l; i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN             &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END               &#125; break; &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* pi = MALLOC(<span class="type">int</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;D.T.Software&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    LOG_STRING(str);</span><br><span class="line">    </span><br><span class="line">    LOG_POINTER(pi);</span><br><span class="line">    </span><br><span class="line">    FOREACH(k, <span class="number">5</span>)</span><br><span class="line">    BEGIN</span><br><span class="line">        pi[k] = k + <span class="number">1</span>;</span><br><span class="line">    END</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">FOREACH</span><span class="params">(n, <span class="number">5</span>)</span></span><br><span class="line">    BEGIN</span><br><span class="line">        <span class="type">int</span> value = pi[n];</span><br><span class="line">        LOG_INT(value);</span><br><span class="line">    END</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">FREE</span><span class="params">(pi)</span>;</span><br><span class="line">    </span><br><span class="line">    LOG_POINTER(pi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h2 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a>函数设计原则</h2><p>​	</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>字符串的概念</strong></p>
<ul>
<li>字符串是<strong>有序字符的集合</strong></li>
<li>字符串是程序中的<strong>基本元素</strong>之一</li>
<li>C 语言中没有字符串的概念<ul>
<li>C 语言中通过特殊的字符数组<strong>模拟</strong>字符串</li>
<li>C 语言中的字符串是以 ‘\0’ 结尾的字符数组（’\0’ 表示字符串的结束）</li>
</ul>
</li>
</ul>
<p><strong>字符数组与字符串</strong></p>
<p>在 C 语言中，<strong>双引号</strong>引用的单个或多个字符是一种<strong>特殊的字面量</strong></p>
<ul>
<li>存储与程序的<strong>全局只读存储区</strong></li>
<li>本质为字符数组，编译器会自动在结尾加上 ‘\0’ 字符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ca[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> sa[] = &#123;<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;; <span class="comment">// 字符串</span></span><br><span class="line">    <span class="type">char</span> ss[] = <span class="string">&quot;Hello World!&quot;</span>;	<span class="comment">// 字符串</span></span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;Hello World!&quot;</span>;	<span class="comment">// 字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ca);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ss);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HelloWorld</span></span><br><span class="line"><span class="comment">        World</span></span><br><span class="line"><span class="comment">        Hello World!</span></span><br><span class="line"><span class="comment">        Hello World!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>字符串字面量的<strong>本质是一个数组</strong></li>
<li>字符串字面量<strong>可以看作常量指针</strong></li>
<li>字符串字面量中的<strong>字符不可改变</strong></li>
<li>字符串字面量<strong>至少包含一个字符</strong>（’\0’）</li>
</ul>
<p><strong>字符串字面量</strong></p>
<p>Hello World! 是一个<strong>无名的</strong>字符数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> b = <span class="string">&quot;abc&quot;</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span> c = *(<span class="string">&quot;123&quot;</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> t = *<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    空的  // 也就是说这里输出的是 &#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>字符串的长度</strong></p>
<ul>
<li>字符串的长度就是<strong>字符串所包含字符的个数</strong></li>
<li>字符串长度指的是<strong>第一个 ‘\0’ 字符前出现的字符个数</strong></li>
<li>通过 ‘\0’ 结束符来确定字符串的长度</li>
<li>函数 strlen 用于返回字符串的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;Hello\0World&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(<span class="type">char</span>); i++) &#123; <span class="comment">// 此处的 sizeof(s) 包含了两个 \0 所以为 12</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(s)); <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="built_in">strlen</span>(s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    H</span></span><br><span class="line"><span class="comment">    e</span></span><br><span class="line"><span class="comment">    l</span></span><br><span class="line"><span class="comment">    l</span></span><br><span class="line"><span class="comment">    o</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    W</span></span><br><span class="line"><span class="comment">    o</span></span><br><span class="line"><span class="comment">    r</span></span><br><span class="line"><span class="comment">    l</span></span><br><span class="line"><span class="comment">    d</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	12</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>当 sizeof() 用于计算字符串长度时会包含其中的 \0；</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li>C 语言中通过字符数组<strong>模拟字符串</strong></li>
<li>C 语言中的字符串使用 ‘\0’ 作为<strong>结束符</strong></li>
<li>字符串字面量的<strong>本质为字符数组</strong></li>
<li>字符串相关函数都<strong>依赖</strong>与结束符 <strong>‘\0’</strong></li>
</ul>
<p><strong>字符串中的一些典型问题</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello %s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), src); <span class="comment">// buf = Hello @x</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>snprintf</code> 是 C 标准库中的一个函数，用于格式化输出字符串，并将结果存储在一个缓冲区中。</p>
<p>int snprintf(char *str, size_t size, const char *format, …);</p>
<p><strong><code>str</code></strong>: 指向要存储格式化字符串的字符数组（目标缓冲区）。</p>
<p><strong><code>size</code></strong>: 指定写入 <code>str</code> 的最大字符数，也就是 str 的大小（包括终止的空字符 <code>\0</code>）。 </p>
<p><strong><code>format</code></strong>: 类似于 <code>printf</code> 的格式化字符串，用于指定输出的格式。</p>
<p><strong>…</strong>: 可变参数，用于指定格式化字符串中的实际值。</p>
<p>注意：</p>
<p>上述输出总为什么会打印 乱码，而不是 %s 呢？</p>
<p>因为当 snprintf 函数只有 3 个参数时，如果第三个参数没有包含格式化信息，函数调用没有问题；相反，如果第三个参数包含了格式化信息，但缺少后续对应参数，则程序行为不确定；</p>
<p>解释一下，他是类似 ptinrf 的，当我们第三个参数包含 %s 时，他会认识是后续有内容需要按照 %s 的格数输出，但我们其实是没有的，所以在打印的时候这里的 %s 就是一个未知的内容了；</p>
<p>可改为：snprintf(buf, sizeof(buf), “%s”, src);，或者将 %s 改为其他的内容</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR <span class="string">&quot;Hello, \0Kay.Wang\0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* src = STR;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">255</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%s&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlrn(STR) = %ld\n&quot;</span>, <span class="built_in">strlen</span>(STR)); <span class="comment">// 到 \0 截至</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(STR) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(STR));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlrn(src) = %ld\n&quot;</span>, <span class="built_in">strlen</span>(src)); <span class="comment">// 到 \0 截至</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(src) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(src)); <span class="comment">// 指针的大小是 8 个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlrn(buf) = %ld\n&quot;</span>, <span class="built_in">strlen</span>(buf)); <span class="comment">// 数组中字符串的长度 还是到 \0 截至</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 数组的大小 255</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	strlrn(STR) = 7</span></span><br><span class="line"><span class="comment">		sizeof(STR) = 18</span></span><br><span class="line"><span class="comment">		strlrn(src) = 7</span></span><br><span class="line"><span class="comment">		sizeof(src) = 8</span></span><br><span class="line"><span class="comment">		strlrn(buf) = 7</span></span><br><span class="line"><span class="comment">		sizeof(buf) = 255</span></span><br><span class="line"><span class="comment">		src = Hello,</span></span><br><span class="line"><span class="comment">		buf = Hello,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>字符串相关的函数均以<strong>第一个</strong>出现的 ‘\0’ 作为<strong>结束符</strong></li>
<li>编译器<strong>总是</strong>会在字符串字面量的<strong>末尾添加\0</strong></li>
<li>字符串字面量的<strong>本质为数组</strong></li>
</ul>
<blockquote>
<p>字符串、字符数组、字符指针三者本质上是不同，但是互相之间又有一定的关系</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题三</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S1 <span class="string">&quot;Hello, \0Kay.Wang\0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S2 <span class="string">&quot;Hello, \0Kay.Wang\0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="keyword">if</span> (S1 == S2)&#123; <span class="comment">// 两个字符串进行比较本质上是字符数组首地址的比较</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Equal\n&quot;</span>); <span class="comment">// Equal</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non Equal\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(S1, S2) == <span class="number">0</span>) &#123; <span class="comment">// strcmp比较字符串的内容是否一致</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Equal\n&quot;</span>); <span class="comment">// // Equal</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Non Equal\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译器会将相同的字符串优化为一个，也就说 S1、S2引用的是痛同一个字符串，所以二者直接进行比较时，是相同的，因为地址相等；</p>
</blockquote>
<ul>
<li>字符串之间的<strong>相等比较</strong>需要使用 strcmp 完成</li>
<li><strong>不可</strong>直接用 &#x3D;&#x3D; 进行字符串直接的比较</li>
<li><strong>完全相同的</strong>字符串字面量的 &#x3D;&#x3D; 比较结果为 false</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Czifuchuanbijiao.png" alt="Czifuchuanbijiao"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题四，字符串循环右移</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">right_shift_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">char</span>* result, <span class="type">unsigned</span> <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能：将输入的字符串 src 循环右移 n 位，result 为输出结果</span></span><br><span class="line"><span class="comment">要求：	  以最高效率实现</span></span><br><span class="line"><span class="comment">示例：</span></span><br><span class="line"><span class="comment">		&quot;abcde&quot; --&gt;2 &quot;deabc&quot;</span></span><br><span class="line"><span class="comment">		&quot;abcde&quot; --&gt;8 &quot;cdeab&quot;</span></span><br><span class="line"><span class="comment">思路讲解：</span></span><br><span class="line"><span class="comment">abcdefg\0 循环右移三位 efgabcde\0 : 公式为，(i + 3) % 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">right_shift_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">char</span>* result, <span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> LEN = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; LEN; i++) &#123;</span><br><span class="line">        result[(n + i) % LEN] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result[LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> result[<span class="number">255</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    right_shift_r(<span class="string">&quot;abcde&quot;</span>, result, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    right_shift_r(<span class="string">&quot;abcde&quot;</span>, result, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    right_shift_r(<span class="string">&quot;abcde&quot;</span>, result, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>操作符</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="操作符"><a href="#操作符" class="headerlink" title="# 操作符"></a># 操作符</h2><p>当在宏定义中使用 <code>#</code> 运算符时，宏的参数会被转换成字符串字面量。</p>
<ul>
<li>#操作符用于在预处理期<strong>将宏参数转换为字符串</strong></li>
<li>#的转换作用是在预处理期完成的，因此<strong>只在宏定义中生效</strong></li>
<li>编译器不知道 # 的转换作用（# 是预处理器所使用的一个特殊的运算符，编译器是不认识 # 运算符的）</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRING(x) #x <span class="comment">// 这里 #x 中的 #，会将 x 变成一个字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, STRING(Hello World!));  <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure>

<p>使用 gcc -E demo.c -o demo.i 生成中间代码：</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/caozuofu.png" alt="caozuofu"></p>
<blockquote>
<p>此处我们可以发现宏已经不在了，已经被我们的预处理器替换掉了</p>
</blockquote>
<h2 id="操作符-1"><a href="#操作符-1" class="headerlink" title="## 操作符"></a>## 操作符</h2><ul>
<li>##运算符用于在预处理期粘连两个标识符</li>
<li>##的连接作用是在预处理期完成的，因此<strong>只有在宏定义中有效</strong></li>
<li>编译器不知道 ## 的连接作用</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONNECT(a, b) a##b</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CONNECT</span><span class="params">(a, <span class="number">1</span>)</span>; <span class="type">int</span> a1;</span><br><span class="line">al = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>宏</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E5%AE%8F/</url>
    <content><![CDATA[<p><strong>宏定义</strong></p>
<ul>
<li>#define 是<strong>预处理器</strong>处理的单元实体之一</li>
<li>#define 定义的宏可以出现在程序的<strong>任意位置</strong></li>
<li>#define 定义之后的代码都可使用这个宏</li>
</ul>
<blockquote>
<p> #开头的表示他是预处理处理的单元实体之一</p>
</blockquote>
<p><strong>宏常量</strong></p>
<ul>
<li>#define 定义的宏常量可以直接使用</li>
<li>#define 定义的宏常量本质为<strong>字面量</strong></li>
</ul>
<blockquote>
<p>字面量意味着他不占用任何的内存</p>
<p><strong><code>#define</code> 并不会占用内存</strong>，它只是在编译前做了一个文本替换，不涉及任何存储或运行时的内存分配。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH1 <span class="string">&quot;D:\test\test.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH2 D:\test\test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH3 D:\test\			<span class="comment">// 类似 D:testtest.c</span></span></span><br><span class="line">					test.c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于预处理器而言，这四个宏定义都是正确的，因为他不会进行语法检查;</p>
<p>对于预处理来说虽然正确，但是替换后的代码是不符合 C 语言语法规范的，因此编译器肯定会报错的（PATH2、PATH3）</p>
</blockquote>
<p><strong>宏定义表达式</strong></p>
<ul>
<li>#define 表达式的使用<strong>类似</strong>函数调用</li>
<li>#define 表达式可以<strong>比函数更强大</strong></li>
<li>#define 表达式<strong>比函数更容易出错</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stcio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SUM_(a, b) (a) + (b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MIN_(a, b) ((a), (b)? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DIM_(a) sizeof(a) / sizeof(*a)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    iint b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> s1 = _SUM_(a, b);</span><br><span class="line">    <span class="type">int</span> s2 = _SUM_(a, b) * _SUM_(a, b);</span><br><span class="line">    <span class="type">int</span> m = _MIN_(a++, b);</span><br><span class="line">    <span class="type">int</span> d = _DIM_(c);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 = %d\n&quot;</span>, s1); <span class="comment">// s1 = 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 = %d\n&quot;</span>, s2); <span class="comment">// s2 = 5	(a) + (b) * (a) + (b)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m = %d\n&quot;</span>, m); <span class="comment">// m = 2	 ((a++) &lt; (b)? (a++) : (b));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %d\n&quot;</span>, d); <span class="comment">// d = 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>宏表达式与函数的对比</strong></p>
<ul>
<li><p>宏表达式被<strong>预处理器</strong>处理，编译器不知道宏表达式的存在（编译器阶段已经被预处理器替换掉了）</p>
</li>
<li><p>宏表达式用”实参“完全代替形参，<strong>不进行任何运算</strong></p>
</li>
<li><p>宏表达式**没有任何的”调用“开销</p>
</li>
<li><p>宏表达式中<strong>不能出现递归定义</strong></p>
<p><strong>宏没有作用域的概念或者说限制，因为编译器根本不知道宏的存在</strong></p>
</li>
</ul>
<p><strong>内置宏</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_FILE_: 被编译的文件名</span><br><span class="line">_LINE_: 当前行号</span><br><span class="line">_DATE_: 编译时的日期</span><br><span class="line">_TIME_: 编译时的时间</span><br><span class="line">_STDC_: 编译器是否遵循标准 C 规范</span><br></pre></td></tr></table></figure>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>同一份代码产生不同的产品</p>
<ul>
<li>条件编译的行为<strong>类似</strong>于 C 语言中的 if…else…</li>
<li>条件编译是预编译指令命令，用于控制<strong>是否编译</strong>某段代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> C 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>(C == 1)</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is first printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is second printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>#if…#else… 是用来给预编译器执行的 </p>
</blockquote>
<p><strong>条件编译的本质</strong></p>
<ul>
<li><strong>预编译器</strong>根据<strong>条件编译指令</strong>有选择的<strong>删除代码</strong></li>
<li>编译器<strong>不知道</strong>代码分支的存在</li>
<li><strong>if…else…<strong>语句在</strong>运行期进行分支判断</strong></li>
<li>条件编译指令在<strong>预编译期进行分支判断</strong></li>
<li>可以通过<strong>命令行定义宏</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -Dmacro=value file.c <span class="comment">// -D 表示宏定义，等价于 #define macro value</span></span><br><span class="line">		   或</span><br><span class="line">gcc -Dmacro file.c  </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> C	<span class="comment">// 检测后面这个宏是否存在，存在就执行后面的代码 This is first printf...</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is first printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;This is second printf...\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>#include的本质</strong></p>
<ul>
<li>#include 的本质是将已经存在的文件内容嵌入到当前文件中</li>
<li>#include 的间接包含，同样会产生嵌入文件内容的操作</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/includebenzhi.png" alt="includebenzhi.png"></p>
<blockquote>
<p>包含同样的 #include 可能会产生重复定义的问题，在编译期会导致报错</p>
<p>使用 #ifdef 可以解决这样的问题</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><ul>
<li>自动确定数组大小<ul>
<li>type Name[] &#x3D; { V<sub>0</sub> , V<sub>1</sub> , … , V<sub>n</sub> }；</li>
</ul>
</li>
<li>将部分数组元素初始化为 0<ul>
<li>type Name[N] &#x3D; { V<sub>0</sub> , V<sub>1</sub> , … , V<sub>s</sub> }；</li>
<li>S &lt; N，未指定初始值的元素默认为 0</li>
</ul>
</li>
<li>将所有数组元素初始化为 0<ul>
<li>type Name[N] &#x3D; {0};</li>
</ul>
</li>
</ul>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p>数组在计算机底层就是<strong>一片连续的内存</strong>，用于存储数组的元素；可以通过<strong>sizeof</strong>获取（字节）；</p>
<p>其大小根据其中内容决定；</p>
<blockquote>
<p>int a[6]; 此数组的大小就是 4 X 6 &#x3D; 24 （字节）</p>
</blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>数组名只能作为左值使用（可以看作是常量）</li>
<li>只能使用<strong>整形常量</strong>对数组大小进行定义</li>
<li>只能使用<strong>整型值</strong>作为下标对数组值进行访问</li>
</ul>
<p><img src="/public/image/Linux/make/tiaojianpanduanyuju.png" alt="tiaojianpanduanyuju"></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理指令</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>注意：#开头的指示字，都是用于预处理器的</strong></p>
<h2 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h2><p>#error 用于生成一个编译错误消息</p>
<p><strong>用法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span> message</span></span><br></pre></td></tr></table></figure>

<p>message 不需要用双引号包围</p>
<blockquote>
<p>#error 编译指示字用于自定义程序员特有的编译错误消息</p>
<p>类似的，#warning 用于生成编译警告</p>
</blockquote>
<p>#error 是一种<strong>预编译器的指示字</strong></p>
<p>#error 可用于<strong>提示编译条件是否满足</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line">	<span class="meta">#<span class="keyword">error</span> This file should be processed with C++ compiler.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译过程中的任意错误信息意味着无法生成最终的可执行程序；</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line">	<span class="meta">#<span class="keyword">error</span> This file should be processed with C++ compiler.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CppClass</span> &#123;</span></span><br><span class="line">    private:</span><br><span class="line">    	<span class="type">int</span> m_value;</span><br><span class="line">    public:</span><br><span class="line">    	CppClass() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    	~CppClass() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 文件中编译 C++ 的代码肯定是会报错的此时如果使用 C++ 编译器进行编译是没有问题的</p>
<p>g++ test.c &#x2F;&#x2F; ok</p>
<p>但是如果我们此时使用 C 编译器进行编译则会出现问题：</p>
<p>test&#x2F;demo.c:4:10: error: #error This file should be processed with C++ compiler.<br>    4 |         #error This file should be processed with C++ compiler.<br>      |          ^~~~~<br>test&#x2F;demo.c:7:1: error: unknown type name ‘class’<br>    7 | class CppClass {<br>      | ^~~~~<br>test&#x2F;demo.c:7:16: error: expected ‘&#x3D;’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token<br>    7 | class CppClass {<br>      |     </p>
<p>上述可以看出他输出了我们自定义的宏错误，程序会判断 __cplusplus 这个 C++ 关键字是否存在如果不存在则会执行里面的代码并中止程序的执行；</p>
</blockquote>
<h2 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h2><p>#line 用于强制指定新的行号和编译文件名，并对源程序的代码重新编号</p>
<p><strong>用法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> number fileName</span></span><br><span class="line"><span class="comment">// fileName 可省略</span></span><br><span class="line"><span class="comment">// #line 编译指示字的本质就是重定义 __LINE__ 和 __FILE__</span></span><br><span class="line"><span class="comment">// __LINE__：当前编译的行号</span></span><br><span class="line"><span class="comment">// __FILE__：当前编译的文件名</span></span><br></pre></td></tr></table></figure>

<p> <strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 1 <span class="string">&quot;kay.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码运行后会产生错误信息：</p>
<p>kay.c: In function ‘main’:<br>kay.c:3:28: error: expected ‘;’ before ‘return’</p>
<p>此时我们看到，他的提示信息改变了，文件名变成了我们输出的文件名，提示的行号也从第 6 行变成了第 3 行；</p>
<p>他会从 #line 1 “kay.c” 下开始计算为第一行</p>
</blockquote>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。一般是由编译器厂家在使用的；</p>
<ul>
<li>#pragma 用于指示编译器完成一些特定的动作</li>
<li>#pragma 所定义的很多指示字是编译器特有的</li>
<li>#pragma 在不同的编译器间是不可移植的<ul>
<li>预处理器将忽略它不认识的 #pragma 指令</li>
<li>不同的编译器可能以不同的方式解释同一条 #pragma 指令</li>
</ul>
</li>
</ul>
<p><code>#pragma</code> 是 C 和 C++ 中的一种预处理指令，用于向编译器提供特定的指示。这些指示通常与编译器的实现相关，可以控制编译器的行为、优化选项或警告设置。他是编译器所制定的，而类似 #messge 是类似 C 语言的语法；</p>
<p><strong>用法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般用法</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> parameter</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：不同的 parameter 参数语法和意义各不相同</p>
</blockquote>
<p><strong>示例</strong></p>
<ul>
<li>message 参数在大多数的编译器中都有相似的实现</li>
<li>message 参数在编译时输出消息到编译输出窗口中</li>
<li>message 用于条件编译中可提示代码的版本信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ADNROID20)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;Compiler Android SDK 2.0...&quot;</span>)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> VERSION <span class="string">&quot;Android 2.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>与 #error 和 #waring 不同，#pragma meaasge 仅仅代表一条编译消息，不代表程序错误。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ANDROID20)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;Compiler Android SDK 2.0...&quot;</span>)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> VERSION <span class="string">&quot;Android 2.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(ANDROID30)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;Compiler Android SDK 3.0...&quot;</span>)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> VERSION <span class="string">&quot;Android 3.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(ANDROID40)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;Compiler Android SDK 4.0...&quot;</span>)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> VERSION <span class="string">&quot;Android 4.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> Complier Version is not provided!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, VERSION);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译： gcc -DANDROID40 demo.c，他会输出提示信息：</p>
<p>demo.c:10:17: note: ‘#pragma message: Compiler Android SDK 4.0…’<br>   10 |         #pragma message(“Compiler Android SDK 4.0…”)<br>        |   </p>
<p>运行： .&#x2F;a.out</p>
<p>Android 4.0</p>
</blockquote>
<p><strong>#pragma 后面跟着的参数也许在每个编译器都有实现，但是可能实现的方式是不同的</strong></p>
<h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a><strong>#pragma once</strong></h3><ul>
<li>#pragma once 用于保证头文件只被编译一次</li>
<li>#pragma once 是编译器相关的，不一定被支持</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Ctouwenjianduibi.png" alt="Ctouwenjianduibi"></p>
<blockquote>
<p>#ifndef 宏保护：编译器需要检查每个包含的宏定义，因此在某些情况下可能效率稍低。他要去判断检查这个宏是否被定义，没有就展开，被定义了就不执行中间的内容</p>
<p>#pragma once：编译器可以更高效地处理它，因为它只需跟踪文件的路径，而不需要处理宏定义的条件。他是记住头文件的路径或者文件名，下次遇到就自动跳过，减少了判断时的时间消耗。</p>
<p>二者可以结合使用</p>
</blockquote>
<h3 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack"></a>#pragma pack</h3><p>什么是内存对齐</p>
<ul>
<li><strong>不同的数据类型</strong>在内存中按照<strong>一定的规则排列</strong></li>
<li>而<strong>不一定是顺序</strong>的一个接着一个排列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c1; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">short</span> s; <span class="comment">// 2B </span></span><br><span class="line">    <span class="type">char</span> c2; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">int</span> i;	 <span class="comment">// 4B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c1; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">char</span> c2; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">short</span> s; <span class="comment">// 2B </span></span><br><span class="line">    <span class="type">int</span> i;	 <span class="comment">// 4B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Tset1 和 Test2 所占的内存是否相同？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Test1 = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Test2 = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct Test1 = 12</span></span><br><span class="line"><span class="comment">// sizeof(struct Test2 = 8</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么需要内存对齐？</strong></p>
<ul>
<li>CPU 对内存的读取不是连续的，而是分块读取的，块的大小只能是1，2，4，8，16，…个字节</li>
<li>当读取操作的数据未对齐，则需要两次总线周期来访问内存，因为性能会大打折扣</li>
<li>某些硬件平台只能从规定的相对地址处读取特定类型的数据，否则产生硬件异常</li>
</ul>
<p><strong>#pragma pack 用于指定内存对齐的方式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pragma <span class="title function_">pack</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line"><span class="keyword">struct</span> Test1 &#123;</span><br><span class="line">    <span class="type">char</span> c1; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">short</span> s; <span class="comment">// 2B </span></span><br><span class="line">    <span class="type">char</span> c2; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">int</span> i;	 <span class="comment">// 4B</span></span><br><span class="line">&#125;;</span><br><span class="line">pragma <span class="title function_">pack</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">pragma <span class="title function_">pack</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line"><span class="keyword">struct</span> Test2 &#123;</span><br><span class="line">    <span class="type">char</span> c1; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">char</span> c2; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">short</span> s; <span class="comment">// 2B </span></span><br><span class="line">    <span class="type">int</span> i;	 <span class="comment">// 4B</span></span><br><span class="line">&#125;;</span><br><span class="line">pragma <span class="title function_">pack</span><span class="params">()</span></span><br><span class="line"><span class="comment">// Tset1 和 Test2 所占的内存是否相同？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Test1 = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Test2 = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sizeof(struct Test1 = 8</span></span><br><span class="line"><span class="comment">// sizeof(struct Test2 = 8</span></span><br></pre></td></tr></table></figure>

<p>#pragma pack 指定内存对齐的方式为：</p>
<p>struct 占用的内存大小</p>
<ul>
<li>第一个成员起始于<strong>0 偏移处</strong></li>
<li>每个成员按<strong>其大小和 pack 参数中较小的一个</strong>进行对齐<ul>
<li>偏移地址必须能被对齐参数(其大小和 pack 中较小的一个)整除</li>
<li>结构体成员的大小取其内部长度最大的数据成员作为其对齐大小</li>
</ul>
</li>
<li>结构体总长度必须为<strong>所有对其参数的整数倍</strong></li>
</ul>
<p>编译器在 32 位系统下默认情况下按照 4 字节大小对齐（也就是默认情况下是#pragma pack(4)）</p>
<p>编译器在 64 位系统下默认情况下按照 8 字节大小对齐（也就是默认情况下是#pragma pack(8)）</p>
<blockquote>
<p>上面的 12B 和 8B 分别是如何计算的？</p>
<p>Tset1：</p>
<p>c1 占一个字节 pack 是四个字节，按照 1 个字节去对齐，存入 0 下标位置</p>
<p>s 占两个字节，pack 是四个字节，按照 2 个字节去对其，存入下标为 2 的整数倍的最小地址处，也就是下标 2 处</p>
<p>c2 占 1 个字节，pack是四个字节，按照 1 个字节去对其，存入下标为 1 的整数倍的最小地址处的地址，也就是下标为 4 处</p>
<p>i 占4 个字节，pack也是四个字节，按照 4 个字节对齐，存入下标为 4 的整数倍的最小地址处地址处，也就是下标为 8处，</p>
<p>综上占了 12 个字节正好是 1 2 4 的整数倍，所以一共占了 12 个字节。</p>
</blockquote>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cneicunduiqi.png" alt="Cneicunduiqi"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c1; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">short</span> s; <span class="comment">// 2B </span></span><br><span class="line">    <span class="type">char</span> c2; <span class="comment">// 1B</span></span><br><span class="line">    <span class="type">int</span> i;	 <span class="comment">// 4B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> c; <span class="comment">// 1B</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> <span class="title">s</span>;</span> <span class="comment">// 2B  12</span></span><br><span class="line">    <span class="type">double</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"><span class="comment">// Tset1 和 Test2 所占的内存是否相同？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Test1 = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test1)); <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct Test2 = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test2)); <span class="comment">// 24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c 占下标 0处，大小为 0</span></span><br><span class="line"><span class="comment">// s 结构体成员的大小取其内部长度最大的数据成员作为其对齐大小 也就是取 4 作为对齐大小，大小为 12 个字节 4~15</span></span><br><span class="line"><span class="comment">// e 占 8 个字节取下标为 16 处 那么一共占 24 个字节</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>#error 用于自定义一条<strong>编译错误信息</strong></li>
<li>#warning 用于自定义一条<strong>编译警告信息</strong></li>
<li>#rror 和 #warning 常用于<strong>条件编译</strong>的情形</li>
<li>#line 用于强制指定新的<strong>行号</strong>和<strong>编译文件名</strong></li>
<li></li>
<li>#pragma 用于指示编译器完成一些特定动作</li>
<li>#pragma 所定义的很多指示字是编译器特有的<ul>
<li>#pragma message 用于自定义编译信息</li>
<li>#pragma once 用于保证头文件只被编译一次</li>
<li>#pragma pack 用于指定内存对齐方式</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>指针和数组</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>变量是什么</strong></p>
<p>程序中的变量只是一段<strong>存储空间的别名</strong>，那么是不是必须通过这个别名才能使用这段存储空间呢？</p>
<p>不是，我们还可以通过这段空间的地址或者说起始地址去使用这段空间；</p>
<p>*<strong>的意义</strong></p>
<ul>
<li>在指针<strong>声明时</strong>，* 号表示所声明的<strong>变量为指针</strong></li>
<li>在指针<strong>使用时</strong>，* 号表示取指针所指向的<strong>内存空间的地址</strong></li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/zhizhendeyiyi.png" alt="zhizhendeyiyi"></p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* pI;</span><br><span class="line">    <span class="type">char</span>* pC;</span><br><span class="line">    <span class="type">float</span>* pF;</span><br><span class="line"></span><br><span class="line">    pI = &amp;i;</span><br><span class="line"></span><br><span class="line">    *pI = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %d\n&quot;</span>, pI, &amp;i, i); <span class="comment">// 0x7ffd4abc986c, 0x7ffd4abc986c, 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld, %ld, %p\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>*), <span class="keyword">sizeof</span>(pI), &amp;pI);  <span class="comment">// 8, 8, 0x7ffd4abc9870</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld, %ld, %p\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*), <span class="keyword">sizeof</span>(pC), &amp;pC); <span class="comment">// 8, 8, 0x7ffd4abc9878 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld, %ld, %p\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">float</span>*), <span class="keyword">sizeof</span>(pC), &amp;pF); <span class="comment">// 8, 8, 0x7ffd4abc9880</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在C语言中，<strong>指针的大小取决于计算机操作系统</strong>。在32位平台上，指针的大小是4个字节；在64位平台上，指针的大小是8个字节;</p>
</blockquote>
<p><strong>传值调用与传地址调用</strong></p>
<ul>
<li>指针是变量，因此可以声明<strong>指针参数</strong></li>
<li>当一个函数体内部需要<strong>改变实参的值</strong>，则需要使用指针参数</li>
<li>函数调用时是将<strong>实参值将复制到形参</strong></li>
<li>指针适用于<strong>复杂数据类型作为参数</strong>的函数中</li>
</ul>
<p><strong>常量与指针</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/changliangyuzhizhen.png" alt="changliangyuzhizhen"></p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* p1 = &amp;i;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* p2 = &amp;i;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p3 = &amp;i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p4 = &amp;i;</span><br><span class="line"></span><br><span class="line">    *p1 = <span class="number">1</span>; <span class="comment">// error, P1 这个指针指向的内存中的值是不可改变的</span></span><br><span class="line">    p1 = <span class="literal">NULL</span>; <span class="comment">// ok,  p1 本身是可变的，所以这个不会报错,从指向 i 的地址改为 null</span></span><br><span class="line"></span><br><span class="line">    *p2 = <span class="number">2</span>; <span class="comment">// error, 同上</span></span><br><span class="line">    p2 = <span class="literal">NULL</span>; <span class="comment">// ok, 同上</span></span><br><span class="line"></span><br><span class="line">    *p3 = <span class="number">3</span>; <span class="comment">// ok, p3 这个指针指向的内存中的内容是可变的，所以不会报错</span></span><br><span class="line">    p3 = <span class="literal">NULL</span>; <span class="comment">// error, p3 这个指针变量本身是不可变的，所以试图修改它的值就会报错</span></span><br><span class="line"></span><br><span class="line">    *p4 = <span class="number">4</span>; <span class="comment">// error p4 这个指针所指向的内存中的对象是不可变的, 试图修改就会报错</span></span><br><span class="line">    p4 = <span class="literal">NULL</span> <span class="comment">// error p4 这个指针本身是不可变的, 试图修改就会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>指针是 C 语言中一种特别的<strong>变量</strong></li>
<li>指针所保存的值是内存的<strong>地址</strong></li>
<li>可以通过指针修改内存中的任意地址内容</li>
</ul>
<h3 id="指针的阅读技巧"><a href="#指针的阅读技巧" class="headerlink" title="指针的阅读技巧"></a>指针的阅读技巧</h3><p>下列标识符代表什么含义？</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Czhizhenliti.png" alt="Czhizhenliti"></p>
<p><strong>右左法则</strong></p>
<ul>
<li>从<strong>最里面</strong>的圆括号中<strong>未定义的标识符</strong>看起</li>
<li>首先往右看，在往左看</li>
<li>遇到<strong>圆括号</strong>或<strong>方括号</strong>时可以<strong>确定部分类型</strong>，并调转方向</li>
<li>重复2，3步骤，</li>
</ul>
<p><strong>解析</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p1)(<span class="type">int</span>*, <span class="type">int</span> (*f)(<span class="type">int</span>*));</span><br><span class="line">==&gt; p1 为指针，指向函数，指向的函数有两个参数，第一个是 <span class="type">int</span>*,第二个是个函数指针 f，指向的函数是 <span class="type">int</span>*,返回值是 <span class="type">int</span>; p1 的返回值为 <span class="type">int</span> 类型</span><br><span class="line">==&gt; 函数指针，其中有参数为领一个函数指针    </span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> (*p2[<span class="number">5</span>])(<span class="type">int</span>*);</span><br><span class="line">==&gt; p2 为数组，有五个元素，五个元素的内容是指针，指向函数，函数类型为 <span class="type">int</span>(<span class="type">int</span>*)</span><br><span class="line">==&gt; 数组中存放的是函数指针</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> (*(*p3)[<span class="number">5</span>])(<span class="type">int</span>*);</span><br><span class="line">==&gt; p3 是指针，数组指针，指向的数组元素有五个，这五个元素为指针，是函数指针，指向的函数类型为 <span class="type">int</span>(<span class="type">int</span>*)</span><br><span class="line">==&gt; 指针指向了一个数组，数组中的五个元素为函数指针    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>*(*(*p4)(<span class="type">int</span>*))(<span class="type">int</span>*);</span><br><span class="line">==&gt; p4 为指针，函数指针，参数为 <span class="type">int</span>* 返回值为指针，是函数指针，指向的函数类型为 <span class="type">int</span>* (<span class="type">int</span>*)  </span><br><span class="line">==&gt; 一个函数指针的返回值是个函数指针</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*(*p5)(<span class="type">int</span>*))[<span class="number">5</span>];</span><br><span class="line">==&gt; p5 为指针，函数指针，参数为 <span class="type">int</span>*, 返回值为指针,指向的数组类型为 <span class="type">int</span>[<span class="number">5</span>]</span><br><span class="line">==&gt; 一个函数指针的返回值是个数组</span><br><span class="line"></span><br><span class="line">以最后一个为例可以简化为：</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>(ArrayType)[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">typedef</span> ArrayType* (FuncType)(<span class="type">int</span>*)</span><br><span class="line">FuncType* p5;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可通过 typedef 简化复杂指针的定义</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组就是相同类型的变量的有序集合</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/shuzujieshao.png" alt="shuzujieshao"></p>
<p><strong>数组的大小</strong></p>
<ul>
<li>数组在一片<strong>连续的内存空间</strong>中存储元素</li>
<li>数组元素的个数可以<strong>显示或隐式指定</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>数组大小与数组名</strong></p>
<ul>
<li><strong>数组名</strong>代表<strong>数组元素的首地址</strong></li>
<li><strong>数组的地址</strong>需要用取地址符 <strong>&amp;</strong> 才能得到</li>
<li>数组首元素的地址值与数组的<strong>地址值相同</strong></li>
<li>数组首元素的地址与数组的地址是<strong>两个不同的概念</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);         <span class="comment">//     a = 0x7ffcfb8b3950</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);       <span class="comment">//    &amp;a = 0x7ffcfb8b3950</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = %p\n&quot;</span>, &amp;a[<span class="number">0</span>]); <span class="comment">// &amp;a[0] = 0x7ffcfb8b3950</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组的地址值和数组第一个元素的地址值，从地址值上看是完全一致的，但其实他们所代表的意义是不相同的，不相同在他们所占用的空间长度是不一样的</p>
<p>在 C 语言中，<strong>数组的地址值</strong>与<strong>数组第一个元素的地址值</strong>从表面上看是相同的，即 <code>&amp;array</code> 和 <code>&amp;array[0]</code> 的值是相同的，都是数组首地址。</p>
<p>不同点在于：</p>
<ul>
<li><code>&amp;array</code>：代表整个数组的地址，类型是 <code>T (*)[N]</code>（指向数组的指针，<code>T</code> 是数组元素的类型，<code>N</code> 是数组的大小）</li>
<li><code>&amp;array[0]</code>：代表数组第一个元素的地址，类型是 <code>T*</code>（指向数组元素的指针）</li>
<li><code>&amp;array</code>（整个数组的地址）：代表整个数组所占用的内存块，这个块的大小是 <code>sizeof(array)</code>，也就是数组中所有元素的总大小。</li>
<li><code>&amp;array[0]</code>（第一个元素的地址）：仅仅代表数组中第一个元素的地址，它指向的内存块大小是 <code>sizeof(array[0])</code>，也就是单个元素的大小。</li>
</ul>
<p>例如，假设你有一个 <code>int array[10]</code>，在 32 位系统上：</p>
<ul>
<li><code>sizeof(array)</code> 是 40 字节（假设每个 <code>int</code> 是 4 字节）。</li>
<li><code>sizeof(&amp;array)</code> 是指针的大小，通常为 4 字节（32 位系统上）。</li>
<li><code>sizeof(array[0])</code> 是单个元素的大小，4 字节。</li>
</ul>
</blockquote>
<p><strong>数组名的盲点</strong></p>
<ul>
<li>数组名可以看做一个<strong>常量指针</strong></li>
<li>数组名”指向“的是内存中数组<strong>首元素的起始地址</strong></li>
<li>数组名<strong>不包含数组的长度信息</strong></li>
<li>在表达式中数组名<strong>只能作为右值使用</strong></li>
<li>只有在下列场合中数组名<strong>不能</strong>看作常量指针<ul>
<li>数组名作为 sizeof 操作符的参数</li>
<li>数组名作为 &amp; 运算符的参数</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>常量指针</strong>：指针指向的值是常量，不能通过该指针修改指向的值，但指针可以指向其他变量。</p>
<p><strong>指针常量</strong>：指针本身是常量，不能改变指针指向的地址，但可以通过该指针修改所指向的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a = 0x7ffc15ef2ba0</span></span><br><span class="line"><span class="comment">        p = 0x7ffc15ef2ba0</span></span><br><span class="line"><span class="comment">        &amp;p = 0x7ffc15ef2b98</span></span><br><span class="line"><span class="comment">        sizeof(a) = 20</span></span><br><span class="line"><span class="comment">        sizeof(p) = 8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p = b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a = 0x7fff744ebe08</span></span><br><span class="line"><span class="comment">        p = 0x7fff744ebe08</span></span><br><span class="line"><span class="comment">        &amp;p = 0x7fff744ebe00</span></span><br><span class="line"><span class="comment">        sizeof(b) = 8</span></span><br><span class="line"><span class="comment">        sizeof(p) = 8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    b = a; <span class="comment">// Error, 数组与指针是不同的不可以互相赋值， 2.数组名不可作为左值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>数组是一片<strong>连续的内存空间</strong></li>
<li>数组的地址和数组首元素的地址<strong>意义不同</strong></li>
<li>数组名在大多数情况下被当成<strong>常量指针</strong>处理</li>
<li><strong>数组名其实并不是指针</strong>，不能将其等同于指针</li>
</ul>
<blockquote>
<p>概念的混淆是 BUG 的根源之一！</p>
</blockquote>
<h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><p>在数组中 a + 1 的意义是什么？结果是什么？</p>
<p>指针运算的意义是什么？结果又是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + 1 = 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(a + <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(p));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p + 1 = 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(p + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a = 0xb9ff2670</span></span><br><span class="line"><span class="comment">        a + 1 = 0xb9ff2674</span></span><br><span class="line"><span class="comment">        p = 0x0</span></span><br><span class="line"><span class="comment">        p + 1 = 0x4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一、a 是数组元素的首地址，首地址 + 1，它却增加了 4，因为数组的中元素的大小是 4 个字节；</p>
<p>二、a 是数组元素的首地址，首地址进行操作，他得到的结果也是个地址（指针s）值；	</p>
</blockquote>
<p>指针是一种特殊的变量，与整数的运算规则为：</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/zhizhenzhenshuyunsuanguize.png" alt="zhizhenzhenshuyunsuanguize"></p>
<p><strong>指针和指针之间的运算</strong></p>
<ul>
<li>指针之间只<strong>支持减法运算</strong></li>
<li>参与减法运算的指针<strong>类型必须相同</strong></li>
</ul>
<p>规则为：</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/zhizhenzhijianyunsuanguize.png" alt="zhizhenzhijianyunsuanguize"></p>
<p><strong>指针之间也可以进行比较运算</strong></p>
<ul>
<li>指针也可以进行关系运算（&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;）</li>
<li>指针关系运算的<strong>前提是同时指向同一个数组的元素</strong></li>
<li>任意两个指针之间的*<em>比较运算（&#x3D;&#x3D;，!&#x3D;）无限制</em></li>
<li>参与比较运算的指针<strong>类型必须相同</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;arr[<span class="number">1</span>];  <span class="comment">// 指向数组的第二个元素 20</span></span><br><span class="line">    <span class="type">int</span> *p2 = &amp;arr[<span class="number">3</span>];  <span class="comment">// 指向数组的第四个元素 40</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较指针是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p1 and p2 point to the same location.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p1 and p2 point to different locations.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较指针大小，检查指针指向的地址位置</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p1 points to an earlier element in the array than p2.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p1 points to a later element in the array than p2.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	p1 and p2 point to different locations.</span></span><br><span class="line"><span class="comment">		p1 points to an earlier element in the array than p2.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>指针之间的比较是比较二者在数组中的位置，比较的是二者指向的地址，而不是地址中的数据；</p>
</blockquote>
<p><strong>数组的访问方式</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/shuzudefangwenfangshi.png" alt="shuzudefangwenfangshi"></p>
<p><strong>下标形式 vs 数组形式</strong></p>
<ul>
<li>指针以固定增量在数组中移动时，效率高于下标形式</li>
<li>指针增量为 1 且硬件具有硬件模型时，效率更高</li>
<li>下标形式与指针形式的转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[n] &lt;--&gt; *(a + n) &lt;--&gt; *(n + a) &lt;--&gt; n[a]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>现代编译器的生成代码优化率已大大提高，在固定增量时，下标形式的效率已经和指针形式相当；</p>
<p>但从可读性和代码的维护角度来看，下标形式更优；</p>
</blockquote>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = a;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        p[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, *(a + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        i[a] = i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p[%d] = %d\n&quot;</span>, i, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a[0] = 1</span></span><br><span class="line"><span class="comment">        a[1] = 2</span></span><br><span class="line"><span class="comment">        a[2] = 3</span></span><br><span class="line"><span class="comment">        a[3] = 4</span></span><br><span class="line"><span class="comment">        a[4] = 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        p[0] = 10</span></span><br><span class="line"><span class="comment">        p[1] = 11</span></span><br><span class="line"><span class="comment">        p[2] = 12</span></span><br><span class="line"><span class="comment">        p[3] = 13</span></span><br><span class="line"><span class="comment">        p[4] = 14</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组名是不是指针？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ext.c</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> a[];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>, *a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &amp;a = 0x55c4991b9010</span></span><br><span class="line"><span class="comment">        a =  0x55c4991b9010</span></span><br><span class="line"><span class="comment">        *a = 1</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">===================================</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span>* a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a); <span class="comment">// 获取变量 a 在内存中的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>, *a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &amp;a = 0x556c7aeb5010</span></span><br><span class="line"><span class="comment">        a = 0x200000001</span></span><br><span class="line"><span class="comment">        Segmentation fault (core dumped)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组名不是指针，只不过在某些情况下可以看作指针，或者当作指针来进行使用；</p>
<p>**<code>&amp;a</code>**：这行代码打印的是变量 <code>a</code> 本身的地址。</p>
<p>**<code>a</code>**：这里的 <code>a</code> 是被 <code>extern int* a;</code> 声明为一个指针。然而，由于指针 <code>a</code> 没有被正确初始化，它的值是未定义的，可能是垃圾值或无效的内存地址。这个地址是一个无效的或随机的内存地址，可能指向了程序无法访问的区域。</p>
<p>**<code>*a</code>**：这里试图访问 <code>a</code> 指针指向的内存位置，并打印出该位置的值。但是，由于 <code>a</code> 指针指向的是无效的内存地址（如上例中的 <code>0x200000001</code>），所以试图访问该地址时会引发段错误。</p>
</blockquote>
<p><strong>a 和 &amp;a 的区别</strong></p>
<ul>
<li>a 为数组<strong>首元素的地址</strong></li>
<li>&amp;a 为<strong>整个数组的地址</strong></li>
<li>a 和 &amp;a 的区别在于指针运算</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/ahedizhiadequbie.png" alt="ahedizhiadequbie"></p>
<p><strong>面试示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]  = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p1 = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span>* p2 = (<span class="type">int</span>*)((<span class="type">int</span>)a + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span>* p3 = (<span class="type">int</span>*)(a + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p1[<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p3[<span class="number">3</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	5 // p1[-1]，因为 P1 指向了数组末尾的边界，-1 就变成了指向 5 这个元素的地址 p1[-1] ==&gt; *(p1 - 1)</span></span><br><span class="line"><span class="comment">		Segmentation fault (core dumped) //这是指向了一个未知的地址，如果该地址不可读那么就会报段错误，否则就是一个未知的地址</span></span><br><span class="line"><span class="comment">		2  // 这里输出2 就是数组首地址 + 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>&amp;a 是数组的地址，数组地址加一，这时候就超出了数组的地址范围了，指向了 5 这个元素右边界的位置；</p>
<p>a 是元素的首地址，转为一个整数，就是将一个八位的地址值截取为一个四位的整数；加一，那就是简单的整数加一，这时候再将它转为一个指针，就是将一个四位的整数转为一个八位的指针地址，那么这个地址就会变成一个指向未知数据的一个地址，这时候我们想想获取一个字节的内容，这时候就是一个未知状态的访问，那么也就报错了；</p>
<p>a 是元素的首地址，首地址加一，就是指向数组的下一个元素，也就是数据为 2 的未知</p>
</blockquote>
<p><strong>数组参数</strong></p>
<ul>
<li>数组作为函数参数时，编译器将其编译成对应的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a[])</span> &lt;==&gt; <span class="type">void</span> f(<span class="type">int</span>* a)</span><br><span class="line"><span class="type">void</span> f(<span class="type">int</span> a[<span class="number">5</span>]) &lt;==&gt; <span class="type">void</span> f(<span class="type">int</span>* a)    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>在传递数组时，数组的大小信息是不会传递过去的，因此当定义的函数中有数组参数时，需要定义另一个参数来表示数组的大小</p>
</blockquote>
<p><strong>虚幻的数组参数</strong></p>
<p>数组参数会退化为指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">char</span> a[<span class="number">5</span>])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func1: sizeof(a) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">    *a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    a = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">char</span> b[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In func2 sizeof(b) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">    *b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    func1(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %c\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    func2(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %c\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	In func1: sizeof(a) = 8</span></span><br><span class="line"><span class="comment">		array[0] = a</span></span><br><span class="line"><span class="comment">		In func2 sizeof(b) = 8</span></span><br><span class="line"><span class="comment">		array[0] = b</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面的输出中可以看出将数组作为函数参数时，他会退化为指针：</p>
<p>否则 输出的 sizeof 大小应该是数组的长度，而不是指针的长度，且 a &#x3D; NULL 也会报错，因为数组名不可以作为左值使用；</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li>数组名和指针<strong>使用方式相同</strong><ul>
<li>数组名的本质不是指针</li>
<li>指针的本质不是数组</li>
</ul>
</li>
<li>数组名并<strong>不是数组的地址</strong>，而是<strong>数组首元素的地址</strong></li>
<li>函数的<strong>数组参数退化为指针</strong></li>
</ul>
<h2 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span>* pa = <span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span>* pm = matrix;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>array 代表数组名，即数组元素的首地址</p>
</li>
<li><p>那么 matrix 代表什么？</p>
</li>
<li><p>&amp;array 表示数组的地址，虽然与 array 二者在值上是一致的，但二者意义是不同的，二者所代表的类型相同么？</p>
</li>
</ol>
</blockquote>
<p><strong>数组类型</strong></p>
<ul>
<li>C 语言中的<strong>数组有自己的类型</strong></li>
<li>数组的类型由<strong>元素类型</strong>和<strong>数组大小</strong>共同决定</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] 的类型为 <span class="type">int</span>[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>定义数组类型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C 语言中通过 typedef 为数字类型重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">type</span><span class="params">(name)</span>[size];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组类型：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(AINT5)</span>[5];</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">float</span><span class="params">(AFLOAT10)</span>[10];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组定义：</span></span><br><span class="line">AINT5 iArray;</span><br><span class="line">AFLOAT10 fArray;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>typedef 是重命名关键字，在 type(name)[size]; 表示要对数组重命名，重命名为 name；</p>
<p>AINT5 iArray; 中 iArray 就是个数组类型，元素类型为 int，数组长度为 5；</p>
</blockquote>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>数组指针是个指针用于指向一个数组(不是指向数组的首元素)</p>
<ul>
<li>数组指针用于<strong>指向一个数组</strong></li>
<li>数组名是<strong>数组首元素的起始地址</strong>，但并<strong>不是数组的起始地址</strong></li>
<li>通过将取地址符 &amp; 作用于数组名可以得到数组的起始地址</li>
<li>可<strong>通过数组类型定义数组的指针</strong>：ArrayType* pointer;</li>
<li>也可以直接定义：type(*pointer)[n];<ul>
<li>pointer 为数组指针变量名</li>
<li>type 为指向的数组中元素的类型</li>
<li>n 为指向的数组的大小</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(AINT5)</span>[5];</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">float</span><span class="params">(AFLOAT10)</span>[10];</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">char</span><span class="params">(ACHAR9)</span>[9];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AINT5 al;</span><br><span class="line">    <span class="type">float</span> fArray[<span class="number">10</span>];</span><br><span class="line">    AFLOAT10* pf = &amp;fArray;</span><br><span class="line">    ACHAR9 cArray;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>(*pc)[<span class="number">9</span>] = &amp;cArray;</span><br><span class="line">    <span class="type">char</span>(*pcw)[<span class="number">4</span>] = cArray; <span class="comment">// cArray 是数组的首地址，类型为 char*</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof(al) 中 al 是个变量，是个 AINT5 类型的变量所以需要占 AINT5 类型大小的字节数，也就是 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu, %lu\n&quot;</span>, <span class="keyword">sizeof</span>(AINT5), <span class="keyword">sizeof</span>(al)); <span class="comment">// 20 20?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        (*pf)[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, fArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p\n&quot;</span>, &amp;cArray, pc + <span class="number">1</span>, pcw + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        20, 20</span></span><br><span class="line"><span class="comment">        0.000000</span></span><br><span class="line"><span class="comment">        1.000000</span></span><br><span class="line"><span class="comment">        2.000000</span></span><br><span class="line"><span class="comment">        3.000000</span></span><br><span class="line"><span class="comment">        4.000000</span></span><br><span class="line"><span class="comment">        5.000000</span></span><br><span class="line"><span class="comment">        6.000000</span></span><br><span class="line"><span class="comment">        7.000000</span></span><br><span class="line"><span class="comment">        8.000000</span></span><br><span class="line"><span class="comment">        9.000000</span></span><br><span class="line"><span class="comment">        0x7ffc5f3943ef, 0x7ffc5f3943f8, 0x7ffc5f3943f3</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======================================================</span><br><span class="line"><span class="comment">// 同类型试题：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>(ACHAR9)[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    ACHAR9 cArray;</span><br><span class="line">    <span class="type">char</span>(*pc)[<span class="number">9</span>] = &amp;cArray;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* pa = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p\n&quot;</span>, &amp;a, (&amp;a + <span class="number">1</span>), pa); <span class="comment">// &amp;a 和 &amp;a + 1 差了 0x14 也就是 20 个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;cArray, pc + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>pc 是个变量，指针指向的内容为 &amp;cArray；pc + 1 也就是 &amp;cArray 的地址 + 他数据类型的长短小，而 &amp;cArray 的类型为 ACHAR9 它占了 9 个字节的大小；所以 pc + 1 在地址中的实际偏移量为 9；0x7ffc5f3943f8 &#x3D; 0x7ffc5f3943ef + 9；</p>
<p>同理 pcw + 1 的地址 0x7ffc5f3943f3 &#x3D; 0x7ffc5f3943ef + 4；</p>
</blockquote>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><ul>
<li>指针数组是<strong>一个普通的数组</strong></li>
<li>指针数组中<strong>每一个元素为一个指针</strong></li>
<li>指针数组的定义：type* pArray[n];</li>
</ul>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Czhizhenshuzudingyi.png" alt="Czhizhenshuzudingyi"></p>
<p><strong>小结</strong></p>
<ul>
<li>数组的类型由<strong>元素类型</strong>和<strong>数组大小</strong>共同决定</li>
<li>数组指针是一个<strong>指针</strong>，指向对应类型的数组</li>
<li>指针数组是一个<strong>数组</strong>，其中每个元素为指针</li>
<li>数组指针<strong>遵循</strong>指针运算法则</li>
<li>指针数组<strong>拥有 C 语言数组的各种特性</strong></li>
</ul>
<h2 id="多维数组与多维指针"><a href="#多维数组与多维指针" class="headerlink" title="多维数组与多维指针"></a>多维数组与多维指针</h2><p><strong>指向指针的指针</strong></p>
<ul>
<li><p>指针的<strong>本质是变量</strong></p>
</li>
<li><p>指针会<strong>占用</strong>一定的<strong>内存空间</strong></p>
</li>
<li><p>可以定义<strong>指针的指针</strong>来保存<strong>指针变量的地址</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span>** pp = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pp = &amp;p;</span><br><span class="line">    </span><br><span class="line">    *pp = &amp;i; <span class="comment">// 给 p 一个 &amp;i 的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要指向指针的指针？</strong></p>
<ul>
<li>指针在本质上也是变量 </li>
<li>对于<strong>指针</strong>也同样存在<strong>传值调用</strong>与<strong>传址调用</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重置一个动态空间的大小，本来一个 5 大小的空间不够了，申请一个 10 大小的空间，然后把内容复制过去</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">reset</span><span class="params">(<span class="type">char</span>** p, <span class="type">int</span> size, <span class="type">int</span> new_size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* pt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* pp = *p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &amp;&amp; (new_size &gt; <span class="number">0</span>) &#123; <span class="comment">// 安全性检测</span></span><br><span class="line">        pt = (<span class="type">char</span>*)<span class="built_in">malloc</span>(new_size); <span class="comment">// 动态的申请一个 new_size 大小的空间</span></span><br><span class="line">        tmp = pt;</span><br><span class="line">        len = (size &lt; new_size)? size : new_size; <span class="comment">// 取小的哪一个进行赋值</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            *tmp++ = *pp++ <span class="comment">// 将 pp 中保存的内容(p 指向的地址)传递给 tem 的空间并自增；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(*p); <span class="comment">// 释放掉原来的空间</span></span><br><span class="line">        *p = pt; <span class="comment">// 指向新申请的地址的地址；</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span>(reset(&amp;p, <span class="number">5</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	0x5559925152a0</span></span><br><span class="line"><span class="comment">		0x5559925156d0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二维数组与二级指针</strong></p>
<ul>
<li><p>二维数组在内存中以<strong>一维的方式排布</strong></p>
</li>
<li><p>二维数组中的<strong>第一维四一维数组</strong></p>
</li>
<li><p>二维数组中的<strong>第二维才是具体的值</strong></p>
</li>
<li><p>二维数组的<strong>数组名可看做常量指针</strong></p>
</li>
</ul>
<p>二维数组是一个一维数组，其中的值是另一个一维数组</p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Cerweishuzushili.png" alt="Cerweishuzushili"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二维数组的访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printArray: %ld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">0</span> , <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// *(a + i) 表示拿到一维数组的首地址，也就是二维数组中每个一维数组的首地址</span></span><br><span class="line">            <span class="comment">// a 是二维数组的数组名</span></span><br><span class="line">            <span class="comment">// a + i，以 a + 1 为例，也就是昂上图中 a1 中第一个元素的位置</span></span><br><span class="line">            <span class="comment">// *(a + 1) 也就是 a1 找个元素的地址，也就是 a1 这个一维指针的首地址</span></span><br><span class="line">            <span class="comment">// 		这里要注意，不要理解为 *(a + 1) 是 a1 中第一个元素的值</span></span><br><span class="line">            <span class="comment">//	    因为二维数组也就是一维数组，只不过它的值是一维数组，我们才将他称为二维数组</span></span><br><span class="line">            <span class="comment">//	    所以这里 *(a + i) 获取的是二速数组中 a1 找个元素的值也就是 a1 所在的一维数组的首地址</span></span><br><span class="line">            <span class="comment">// *(*(a + 1) + j) 也就是 a1 数组中的第 j 个元素</span></span><br><span class="line">            <span class="comment">// *(a + i) ==&gt; a[i], *(a[i] + j) ==&gt; a[i][j]</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n, &quot;</span>, *(*(a + i) + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printArray(p, <span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0, 1, 2,</span></span><br><span class="line"><span class="comment">        3, 4, 5,</span></span><br><span class="line"><span class="comment">        6, 7, 8,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        printArray: 8</span></span><br><span class="line"><span class="comment">        0</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">        5</span></span><br><span class="line"><span class="comment">        6</span></span><br><span class="line"><span class="comment">        7</span></span><br><span class="line"><span class="comment">        8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 C 语言中，<code>*(*(a + i) + j)</code> 和 <code>a[i][j]</code> 之间的等价关系可以通过以下步骤理解：</p>
<ol>
<li><strong>数组名作为指针</strong>：<code>a</code> 是一个指向数组的指针，<code>a + i</code> 计算的是指向第 <code>i</code> 行的指针。</li>
<li><strong>解引用</strong>：<code>*(a + i)</code> 取得第 <code>i</code> 行的首地址，实际上是一个指向该行一维数组的指针。</li>
<li><strong>偏移量</strong>：<code>*(a + i) + j</code> 计算的是第 <code>i</code> 行中第 <code>j</code> 列的地址。</li>
<li><strong>解引用</strong>：最后，通过 <code>*(*(a + i) + j)</code> 解引用这个地址，得到了 <code>a[i][j]</code> 的值。</li>
</ol>
<p>因此，<code>*(*(a + i) + j)</code> 实际上是先获取第 <code>i</code> 行的指针，然后再访问该行的第 <code>j</code> 列的元素，这与 <code>a[i][j]</code> 的操作是等价的。</p>
</blockquote>
<p><strong>数组名</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维数组名代表数组首元素的地址</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]，a 的类型为 <span class="type">int</span>*</span><br><span class="line"><span class="comment">// 二维数组名同样代表数组首元素的地址</span></span><br><span class="line"><span class="type">int</span> m[<span class="number">2</span>][<span class="number">5</span>]，m 的类型为 <span class="type">int</span>(*)[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二维数组名可以看作是指向数组的常量指针</p>
<p>二维数组可以看作是一维数组</p>
<p>二维数组中的每个元素都是同类型的一维数组</p>
</blockquote>
<p><strong>如何动态的申请二维数组</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">malloc2d</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">int</span>** ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((row &gt;<span class="number">0</span> &amp;&amp; (col &gt; <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 申请指向指针的内存</span></span><br><span class="line">        ret = (<span class="type">int</span>**)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">        <span class="comment">// 具体的元素的个数</span></span><br><span class="line">        p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(row * col);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((ret != <span class="literal">NULL</span>) &amp;&amp; (p != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                ret[i] = p + i * col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">free</span>(ret);</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            ret = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数组空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free2d</span><span class="params">(<span class="type">int</span>** p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(*p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>** a = malloc2d(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    free2d(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0, 0, 0,</span></span><br><span class="line"><span class="comment">    0, 0, 0,</span></span><br><span class="line"><span class="comment">    1041, 0, 825503793,</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>malloc 这个函数不保证申请出来的空间所有值都为 0;</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li><p>C 语言中<strong>只支持</strong>一维数组</p>
</li>
<li><p>C 语言中的数组大小必须<strong>在编译期就作为常数确定</strong></p>
</li>
<li><p>C 语言中的数组元素可以是<strong>任何类型的数据</strong></p>
</li>
<li><p>C 语言中<strong>数组的元素可以是另一个数组</strong></p>
</li>
</ul>
<h2 id="数组参数和指针参数"><a href="#数组参数和指针参数" class="headerlink" title="数组参数和指针参数"></a>数组参数和指针参数</h2><p>数组作为函数参数时会退化为指针；</p>
<p><strong>为什么 C 语言中的数组参数会退化为指针？</strong></p>
<p>退化的意义：</p>
<ul>
<li>C 语言中<strong>只会以值拷贝的方式</strong>传递参数</li>
<li>当向函数传递数组时：<ul>
<li>将整个数组拷贝一份传入函数（错误的，会造成空间上的浪费）</li>
<li>将数组名看作常量指针传递数组元素的首地址（正确的，显著的提高效率不会造成空间上的浪费）</li>
</ul>
</li>
</ul>
<blockquote>
<p>C 语言以高效作为最初的设计目标：</p>
<p>a) 参数传递的时候如果拷贝整个数组执行效率将大大降低</p>
<p>b) 参数位于栈上，太大的数组拷贝将导致栈溢出</p>
</blockquote>
<p><strong>二维数组参数</strong></p>
<ul>
<li>二维数组参数<strong>同样存在退化</strong>的问题<ul>
<li>二维数组<strong>可以看作</strong>是一维数组</li>
<li>二维数组中的<strong>每个元素都是一维数组</strong></li>
</ul>
</li>
<li>二维数组参数中<strong>第一维的参数可以省略</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a[<span class="number">5</span>])</span> &lt;--&gt; <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a[])</span> &lt;--&gt; <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>* a)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>])</span> &lt;--&gt; <span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> a[][<span class="number">3</span>])</span> &lt;--&gt; <span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">3</span>])</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一维数组 退化为 int*a，int 是数组中元素的类型</p>
<p>二维数组退化为 int(*a)[5]，int[5] 是二维数组中元素的类型</p>
<p>可见，一维数组退化为指针，二维数组退化为数组指针</p>
</blockquote>
<p><strong>等价关系</strong></p>
<p><img src="/public/image/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/shuzuzhizhencanshudengjiaguanxi.png" alt="shuzuzhizhencanshudengjiaguanxi"></p>
<p><strong>注意</strong></p>
<ul>
<li>C 语言中<strong>无法</strong>向一个函数<strong>传递任意的多维数组</strong>（接收二维参数，你就只能传递二维的）</li>
<li>必须<strong>提供除第一维之外的所有维度的长度</strong><ul>
<li>第一维之外的维度信息用于<strong>完成指针运算</strong></li>
<li>N 维数组的<strong>本质是一维数组</strong>，元素是 N-1 维的数组</li>
<li>对于多维数组的函数参数<strong>只有第一维是可变的</strong>（其他的是参数类型不可变，这话好像有问题？）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只接受列数为 3 的二维数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">access</span><span class="params">(<span class="type">int</span> a[][<span class="number">3</span>], <span class="type">int</span> row)</span> &#123;</span><br><span class="line">    <span class="type">int</span> col = <span class="keyword">sizeof</span>(*a) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof(a) = 8，因为在 64 位的系统中指针大小为 8 个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(a)); </span><br><span class="line">    <span class="comment">// sizeof(*a) = 12，因为二维数组 a 中每个元素(一维数组)占 12 个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(*a) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(*a)); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">access_ex</span><span class="params">(<span class="type">int</span> b[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sizeof(b) = 8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(b)); </span><br><span class="line">    <span class="comment">// sizeof(*b) = 24 int[2][3] ==&gt; 24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(*b) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(*b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> aa[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">     </span><br><span class="line">    access(a, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sizeof(a) = 8</span></span><br><span class="line"><span class="comment">    sizeof(*a) = 12</span></span><br><span class="line"><span class="comment">    0   1    2    3    4    5    6    7    8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    access(aa, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sizeof(a) = 8</span></span><br><span class="line"><span class="comment">    sizeof(*a) = 12</span></span><br><span class="line"><span class="comment">    0    0    0    0    0    0    0    0    0    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    access_ex(b, <span class="number">1</span>); <span class="comment">// 0 0 0 0 0 0 </span></span><br><span class="line"></span><br><span class="line">    access_ex(aa, <span class="number">1</span>); <span class="comment">// 0 0 0 0 0 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>C 语言中<strong>只会以值拷贝的方式</strong>传递参数</li>
<li>C 语言中的数组参数<strong>必然退化为指针</strong></li>
<li>多维数组必须<strong>提供除第一维之外的所有维的长度</strong></li>
<li>对于多维数组的函数参数<strong>只有第一维是可变的</strong></li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉编译</title>
    <url>/OS/OS%E5%9F%BA%E7%A1%80/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>交叉编译是指在主机平台上生成目标平台上的可执行代码。</p>
<p>参与编译和运行的机器根据其角色可以分成以下三类</p>
<ul>
<li>构建(build)系统：<code>生成编译器可执行程序</code>的计算机系统。(生成编译器的电脑)</li>
<li>主机(host)系统：<code>运行编译器可执行程序，编译链接应用程序</code>的计算机系统。(生成应用程序的电脑)</li>
<li>目标(target)系统：<code>运行应用程序</code>的计算机系统。(执行应用程序的电脑)</li>
</ul>
<p>根据 build&#x2F;host&#x2F;target 的不同组合我们可以得到如下的编译方式分类</p>
<ul>
<li>本地(native)编译：<strong>build &#x3D;&#x3D; host &#x3D;&#x3D; target</strong></li>
<li>交叉(cross)编译： <strong>build &#x3D;&#x3D; host !&#x3D; target</strong></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装配置</title>
    <url>/OS/Ubuntu/MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>添加 MySQL APT 存储库</strong></p>
<p> <a href="https://dev.mysql.com/downloads/repo/apt/">MySQL APT 存储库下载页面</a>。</p>
<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo dpkg -i mysql-apt-config_0.8.32-1_all.deb</span> </span><br></pre></td></tr></table></figure>

<p><strong>更新存储库</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br></pre></td></tr></table></figure>

<p><strong>安装MySQL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install mysql-server</span></span><br></pre></td></tr></table></figure>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>1. 停止MySQL服务</strong></p>
<p>在卸载之前，首先需要确保MySQL服务已经停止运行，以防止卸载过程中出现潜在问题。可以使用以下命令来停止MySQL服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop mysql</span><br></pre></td></tr></table></figure>

<p>或者，如果你使用的是较旧的Ubuntu版本，可能需要使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql stop</span><br></pre></td></tr></table></figure>

<p><strong>2. 卸载MySQL软件包</strong></p>
<p>使用<code>apt-get</code>命令来卸载MySQL服务器及其相关软件包。通常，除了<code>mysql-server</code>外，可能还需要卸载<code>mysql-client</code>和<code>mysql-common</code>等软件包。使用以下命令进行卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove --purge mysql-server mysql-client mysql-common</span><br></pre></td></tr></table></figure>

<p><code>--purge</code>选项会卸载软件包并删除其配置文件。</p>
<p><strong>3. 删除MySQL的配置文件和数据目录</strong></p>
<p>尽管<code>apt-get remove --purge</code>命令会删除大多数配置文件，但为了确保彻底卸载，建议手动删除MySQL的配置文件和数据目录。这些文件通常位于<code>/etc/mysql</code>和<code>/var/lib/mysql</code>目录下。使用以下命令进行删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /etc/mysql /var/lib/mysql</span><br></pre></td></tr></table></figure>

<p>此外，有些MySQL版本可能会在<code>/var/log/mysql</code>目录下生成日志文件，你也可以选择删除这些日志文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/log/mysql</span><br></pre></td></tr></table></figure>

<p><strong>4. 清理残留文件和依赖项</strong></p>
<p>使用<code>apt-get autoremove</code>命令来自动删除不再需要的依赖项。此外，<code>apt-get autoclean</code>命令可以清理下载的软件包缓存，但这一步不是必须的，因为它不会直接删除MySQL的残留文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get autoremove  </span><br><span class="line">$ sudo apt-get autoclean</span><br></pre></td></tr></table></figure>

<p><strong>5. 验证卸载结果</strong></p>
<p>为了验证MySQL是否已完全卸载，可以尝试运行<code>mysql</code>命令查看其版本。如果MySQL已成功卸载，系统将显示一个错误消息，指出找不到<code>mysql</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql --version</span><br></pre></td></tr></table></figure>

<p>如果看到类似“Command ‘mysql’ not found, but can be installed with:”的错误消息，则表示MySQL已成功卸载。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式工具介绍</title>
    <url>/OS/OS%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>参与编译和运行的机器根据其角色可以分成以下三类</p>
<ul>
<li>构建(build)系统：<code>生成编译器可执行程序</code>的计算机系统。(生成编译器的电脑)</li>
<li>主机(host)系统：<code>运行编译器可执行程序，编译链接应用程序</code>的计算机系统。(生成应用程序的电脑)</li>
<li>目标(target)系统：<code>运行应用程序</code>的计算机系统。(执行应用程序的电脑)</li>
</ul>
<p>根据 build&#x2F;host&#x2F;target 的不同组合我们可以得到如下的编译方式分类</p>
<ul>
<li>本地(native)编译：<strong>build &#x3D;&#x3D; host &#x3D;&#x3D; target</strong></li>
<li>交叉(cross)编译： <strong>build &#x3D;&#x3D; host !&#x3D; target</strong></li>
</ul>
<h2 id="调试器-GDB"><a href="#调试器-GDB" class="headerlink" title="调试器 GDB"></a>调试器 GDB</h2><ul>
<li><a href="https://ww.gnu.org/software/gdb">https://ww.gnu.org/software/gdb</a></li>
<li>GDB(The GNU Project Debugger)，GNU 项目调试器，用于查看另一个程序在执行过程中正在执行的操作，或该程序崩溃时正在执行的操作。</li>
<li>被调试的程序可能与 GDB 在同一台计算机上执行，也可能在另一台计算机(远程)上或者在模拟器上执行。</li>
<li>GDB 支持调试多种语言：如 Rust 等。</li>
</ul>
<p><img src="/public/image/OS/os/GDB.png" alt="GDB"></p>
<blockquote>
<p>当执行<code>gdb a.out</code>后发生了什么</p>
<p>本地调试时</p>
<p>gdb运行起来之后他会在本地先 <em>fork</em> 一个子进程去运行 <code>a.out</code>，然后 <em>gdb</em> 本身也会运行在一个子进程中，二者通过 <em>ptrace</em> 这个系统调用建立连接；当你在 <em>gdb</em> 中运行至<code>a.out</code> 中的断点时，他就会把 <code>a.out</code> 这个所在的进程挂起来进入阻塞状态。</p>
<p>远程调试时</p>
<p>首先会在目标机器上启动一个名叫 <em>gdbServer</em> 的远程服务，本地的 <em>gdb</em> 会与 <em>gdbServer</em> 建立连接，由 <em>gdbServer</em> 来代理我们的调试过程; <code>a.out</code> 和 <em>gdbServer</em> 运行在目标机器上。</p>
<p>调试机器和目标机器通过网络进行连接。</p>
</blockquote>
<h3 id="GDB基本调试流程"><a href="#GDB基本调试流程" class="headerlink" title="GDB基本调试流程"></a>GDB基本调试流程</h3><h2 id="模拟器-QEMU"><a href="#模拟器-QEMU" class="headerlink" title="模拟器 QEMU"></a>模拟器 QEMU</h2><ul>
<li><a href="https://www.qemu.org/">https://www.qemu.org/</a></li>
<li>QEMU是一套由(Fabrice Bellard)编写的以 GPL 许可证分发源代码的计算机系统模拟软件，在 GNU&#x2F;Linux 平台上被广泛使用。</li>
<li>支持多种体系架构。譬如：RISC-V、X86等。</li>
<li>QEMU 有两种主要运行模式<ul>
<li>User mode：直接运行应用程序。</li>
<li>System mode：模拟整个计算机系统，包括中央处理器及其他周边设变。</li>
</ul>
</li>
</ul>
<h2 id="项目构造工具-Make"><a href="#项目构造工具-Make" class="headerlink" title="项目构造工具 Make"></a>项目构造工具 Make</h2><ul>
<li><a href="https://ww.gnu.org/software/make/">https://ww.gnu.org/software/make/</a></li>
<li>Make 是什么<ul>
<li>make 是一种自动化工程管理工具。</li>
</ul>
</li>
<li>Makefile 是什么<ul>
<li>配合 make，用于描述构建过程中所管理的对象以及如何构造工程的过程。</li>
</ul>
</li>
<li>Make 如何找到 Makefile<ul>
<li>隐士查找：当前目录下按顺序查找名为”GNUmakefule”、”makefile”、”Makefile”的文件。</li>
<li>显示查找：-f</li>
</ul>
</li>
</ul>
<h3 id="Makefile-的构成"><a href="#Makefile-的构成" class="headerlink" title="Makefile 的构成"></a>Makefile 的构成</h3><ul>
<li><p>Makefile 由一条或者多条规则(fule)构成。</p>
</li>
<li><p>每条规则由三要素构成</p>
<ul>
<li>target：目标，可以是 obj 文件也可以是可执行文件。</li>
<li>prerequisites：生成 target 所需要的依赖。</li>
<li>command：为了生成 target 需要执行的命令，可以有多条。</li>
</ul>
</li>
<li><p>一个简单的 Makefile 如下</p>
</li>
<li><pre><code class="makefile"># 定义 Makefile 中的一些变量名
# = 为简单赋值 := 为赋值展开，即如果后续更改了用于赋值的变量的值，那么这个改变不会影响已经赋值的变量。
TARGET := riscv64gc-unknown-none-elf
MODE := release
APP_DIR := src/bin
TARGET_DIR := target/$(TARGET)/$(MODE)
APPS := $(wildcard $(APP_DIR)/*.rs)
ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS))
BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS))

OBJDUMP := rust-objdump --arch-name=riscv64
OBJCOPY := rust-objcopy --binary-architecture=riscv64

elf:
    @cargo build --release --target $(TARGET)

binary: elf
    @$(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));)

build: binary
</code></pre>
</li>
<li><p>行注释以 # 开头</p>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/OS/OS%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>目标：</p>
<ul>
<li>是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>v2raya安装配置</title>
    <url>/OS/Ubuntu/v2raya%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="安装-v2ray-core"><a href="#安装-v2ray-core" class="headerlink" title="安装 v2ray-core"></a>安装 v2ray-core</h2><p>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/v2fly/v2ray-core</span><br></pre></td></tr></table></figure>

<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo unzip v2ray-linux-64.zip -d /usr/local/v2ray-core</span><br></pre></td></tr></table></figure>

<p>拷贝geoip.dat和geosite.dat到&#x2F;usr&#x2F;local&#x2F;share&#x2F;v2ray&#x2F;：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/share/v2ray/</span><br><span class="line">sudo mv /usr/local/v2ray-core/*dat  /usr/local/share/v2ray/</span><br></pre></td></tr></table></figure>

<h2 id="安装-v2rayA"><a href="#安装-v2rayA" class="headerlink" title="安装 v2rayA"></a>安装 v2rayA</h2><p>下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/v2rayA/v2rayA</span><br></pre></td></tr></table></figure>

<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i installer_debian_x64_*.deb</span><br></pre></td></tr></table></figure>

<h2 id="配置-v2rayA"><a href="#配置-v2rayA" class="headerlink" title="配置 v2rayA"></a>配置 v2rayA</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/default/v2raya</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加如下配置</span></span><br><span class="line"></span><br><span class="line">V2RAYA_V2RAY_BIN=/usr/local/v2ray-core/v2ray</span><br><span class="line">V2RAYA_V2RAY_CONFDIR=/usr/local/v2ray-core</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入<span class="string">&quot;:wq!&quot;</span>后可保存更改</span></span><br></pre></td></tr></table></figure>

<p>设置开机自启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now v2raya</span><br><span class="line">sudo systemctl status v2raya </span><br></pre></td></tr></table></figure>

<p>打开v2rayA：<code>v2rayA Web panel</code></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust数据内存布局</title>
    <url>/Rust/basic/Rust%E6%95%B0%E6%8D%AE%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p><strong>整数类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
<th>大小(bytes)</th>
<th>对齐(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td><code>u8</code></td>
<td>0</td>
<td>28-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>u16</code></td>
<td>0</td>
<td>216-1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>u32</code></td>
<td>0</td>
<td>232-1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>u64</code></td>
<td>0</td>
<td>264-1</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>u128</code></td>
<td>0</td>
<td>2128-1</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
<th>大小(bytes)</th>
<th>对齐(bytes)align(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td><code>i8</code></td>
<td>-(27)</td>
<td>27-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>i16</code></td>
<td>-(215)</td>
<td>215-1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>i32</code></td>
<td>-(231)</td>
<td>231-1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>i64</code></td>
<td>-(263)</td>
<td>263-1</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>i128</code></td>
<td>-(2127)</td>
<td>2127-1</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<p><strong>浮点数</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(bytes)</th>
<th>对齐(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td>f32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>f64</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>f64 在 x86 系统上对齐到 4 bytes。</p>
<p><strong>usized &amp; isized</strong></p>
<p>usize 无符号整形，isize 有符号整形。 在 64 位系统上，长度为 8 bytes，在 32 位系统上长度为 4 bytes。</p>
<p><strong>bool</strong></p>
<p>bool 类型，取值为 true 或 false，长度和对齐长度都是 1 byte。</p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>数组的内存布局为系统类型元组的有序组合。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">A</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::size_of::&lt;[<span class="type">i32</span>; <span class="number">3</span>]&gt;()); <span class="comment">// 大小: 12</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::align_of::&lt;[<span class="type">i32</span>; <span class="number">3</span>]&gt;()); <span class="comment">// 对齐: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p><strong>char 类型</strong></p>
<p>char 表示：一个 32 位长度字符，Unicode 标量值 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode Scalar Value</a> 范围为 in the 0x0000 - 0xD7FF 或者是 0xE000 - 0x10FFFF。</p>
<p><strong>str 类型</strong></p>
<p>str 与 [u8] 一样表示一个 u8 的 slice。Rust 中标准库中对 str 有个假设：符合 UTF-8 编码。内存布局与 [u8] 相同。</p>
<blockquote>
<p>[u8]是一个字节切片的类型，而不是一个固定大小的数组。切片是对数组的引用或数组部分的一个动态视图，允许你访问一个连续的内存区域，就像访问一个数组一样，但切片本身并不拥有其引用的数据。</p>
<p><code>[u8; N]</code>：这是一个固定大小的字节数组，其中 <code>N</code> 是数组的长度。例如，<code>[u8; 4]</code> 是一个包含四个 <code>u8</code> 元素的数组。</p>
<p>二者要注意不要搞混了</p>
</blockquote>
<p><strong>slice</strong></p>
<p>slice 是 DST 类型，是类型 T 序列的一种视图。 slice 的使用必须要通过指针，&amp;[T] 是一个胖指针，保存指向<code>数据的地址</code>和<code>元素个数</code>。 <code>slice 的内存布局与其指向的 array 部分相同</code>。</p>
<p><strong>&amp;str 与 String 的区别</strong></p>
<p>下面给出 &amp;str String 的内存结构比对：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">my_name.<span class="title function_ invoke__">push_str</span>( <span class="string">&quot; Precht&quot;</span>);</span><br><span class="line"><span class="comment">// str</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">last_name</span> = &amp;my_name[<span class="number">7</span>..];</span><br></pre></td></tr></table></figure>

<p>String</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                     buffer</span><br><span class="line">                   /   capacity</span><br><span class="line">                 /   /  length</span><br><span class="line">               /   /   /</span><br><span class="line">            +–––+–––+–––+</span><br><span class="line">stack frame │ • │ 8 │ 6 │ &lt;- my_name: String</span><br><span class="line">            +–│–+–––+–––+</span><br><span class="line">              │</span><br><span class="line">            [–│–––––––– capacity –––––––––––]</span><br><span class="line">              │</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"></span><br><span class="line">            [––––––– length ––––––––]</span><br></pre></td></tr></table></figure>

<p>String vs &amp;str</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">         my_name: <span class="type">String</span>   last_name: &amp;<span class="type">str</span></span><br><span class="line">            [––––––––––––]    [–––––––]</span><br><span class="line">            +–––+––––+––––+–––+–––+–––+</span><br><span class="line">stack frame │ • │ <span class="number">16</span> │ <span class="number">13</span> │   │ • │ <span class="number">6</span> │  <span class="comment">// &amp;str 没有 capacity</span></span><br><span class="line">            +–│–+––––+––––+–––+–│–+–––+</span><br><span class="line">              │                 │</span><br><span class="line">              │                 +–––––––––+</span><br><span class="line">              │                           │</span><br><span class="line">              │                           │</span><br><span class="line">              │                         [–│––––––– <span class="type">str</span> –––––––––]</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"></span><br><span class="line">			[––––––––––––––––––––––––––– my_name –––––––––––––––––––––––––––]</span><br><span class="line">										[–––––––––––– last_name ––––––––––––]</span><br></pre></td></tr></table></figure>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>结构体是带命名的复合类型，有以下几种</p>
<p><strong>具名结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元组结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br></pre></td></tr></table></figure>

<p><strong>单元结构体</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Gamma;</span><br></pre></td></tr></table></figure>

<p><strong>内存布局</strong></p>
<blockquote>
<p>数据对齐</p>
<p>数据对齐是指将数据存储在内存中时，按照特定的规则将数据放置在内存地址上的一种方式。</p>
<p>数据对齐的主要目的是为了提高数据读取效率。当CPU访问正确对齐的数据时，它的运行效率最高。若数据没有对齐，CPU在读取或写入数据时可能需要进行多次操作，这会降低CPU的效率，增加系统的开销。</p>
<p>编译器优化 -&gt; 字段重排</p>
<p>Rust编译器在优化结构体时，可能会进行字段重排（field reordering），这是为了优化内存访问、提高数据缓存的效率，以及确保数据满足平台的内存对齐要求。</p>
<p>Rust编译器的字段重排是一种优化技术，旨在提高程序的性能和内存使用效率。</p>
</blockquote>
<p>Rust 中结构体的对齐属性等于<code>它所有成员中最大的那个</code>。Rust 会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时<code>整个类型的尺寸是对齐属性的整数倍</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>, <span class="comment">// 1B</span></span><br><span class="line">    b: <span class="type">u32</span>, <span class="comment">// 4B</span></span><br><span class="line">    c: <span class="type">u16</span>, <span class="comment">// 2B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印下变量地址，可以根据结果看到对齐属性为 4, 结构大小为 8 byte 。</span></span><br><span class="line"><span class="comment">// 1 + 4 + 2 = 7</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = A &#123;</span><br><span class="line">        a: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x&#123;:X&#125; 0x&#123;:X&#125; 0x&#123;:X&#125;&quot;</span>, &amp;a.a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">usize</span>, &amp;a.b <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u32</span> <span class="keyword">as</span> <span class="type">usize</span> , &amp;a.c <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u16</span> <span class="keyword">as</span> <span class="type">usize</span> );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::size_of::&lt;A&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0x327EFBF35E</span> <span class="number">0x327EFBF358</span> <span class="number">0x327EFBF35C</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rust编译器会进行内存重排，并填充所需大小(这里是1B)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    b: <span class="type">u32</span>,</span><br><span class="line">    c: <span class="type">u16</span>,</span><br><span class="line">    a: <span class="type">u8</span>,</span><br><span class="line">    _pad: [<span class="type">u8</span>; <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo1字段顺序：data2(0), count(4), data1(6) </span></span><br><span class="line"><span class="comment">// foo1字段顺序：data1(8), count(c), data2(e) </span></span><br><span class="line"><span class="comment">// 可以看到编译器会改变 Foo&lt;T, U&gt; 中成员顺序。</span></span><br><span class="line"><span class="comment">// 内存优化原则要求不同的范型可以有不同的成员顺序。 如果不优化的可能会造成如下情况，造成大量内存开销：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">u16</span>, <span class="type">u32</span>&gt; &#123;</span><br><span class="line">    count: <span class="type">u16</span>,</span><br><span class="line">    data1: <span class="type">u16</span>,</span><br><span class="line">    data2: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">u32</span>, <span class="type">u16</span>&gt; &#123;</span><br><span class="line">    count: <span class="type">u16</span>,</span><br><span class="line">    _pad1: <span class="type">u16</span>,</span><br><span class="line">    data1: <span class="type">u32</span>,</span><br><span class="line">    data2: <span class="type">u16</span>,</span><br><span class="line">    _pad2: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是匿名的复合类型，有以下几种 tuple：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">() (unit)</span><br><span class="line">(<span class="type">f64</span>, <span class="type">f64</span>)</span><br><span class="line">(<span class="type">String</span>, <span class="type">i32</span>)</span><br><span class="line">(<span class="type">i32</span>, <span class="type">String</span>) (different <span class="keyword">type</span> <span class="title class_">from</span> the previous example)</span><br><span class="line">(<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, <span class="type">Option</span>&lt;<span class="type">bool</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>tuple 的结构和 Struct 一致，只是元素是通过 index 进行访问的。</p>
<h2 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h2><p>闭包相当于一个捕获变量的结构体，实现了<code>FnOnce</code>或<code>FnMut</code>或<code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;F : <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>&gt; (g: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">g</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">f</span>(|| &#123;</span><br><span class="line">    s += &amp;t;</span><br><span class="line">    s</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Prints &quot;foobar&quot;.</span></span><br></pre></td></tr></table></figure>



<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><h2 id="Dynamically-Sized-Types-DST"><a href="#Dynamically-Sized-Types-DST" class="headerlink" title="Dynamically Sized Types(DST)"></a>Dynamically Sized Types(DST)</h2><h2 id="零大小类型-ZST-Zero-Sized-Type"><a href="#零大小类型-ZST-Zero-Sized-Type" class="headerlink" title="零大小类型(ZST, Zero Sized Type)"></a>零大小类型(ZST, Zero Sized Type)</h2><h2 id="空类型-Empty-Types"><a href="#空类型-Empty-Types" class="headerlink" title="空类型(Empty Types)"></a>空类型(Empty Types)</h2><h2 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>应用程序与基本执行环境</title>
    <url>/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="应用程序与基本执行环境"><a href="#应用程序与基本执行环境" class="headerlink" title="应用程序与基本执行环境"></a>应用程序与基本执行环境</h1><h2 id="创建一个bin项目"><a href="#创建一个bin项目" class="headerlink" title="创建一个bin项目"></a>创建一个bin项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new os --bin</span></span><br><span class="line">    Creating binary (application) `os` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<h2 id="移除执行环境对操作系统的依赖"><a href="#移除执行环境对操作系统的依赖" class="headerlink" title="移除执行环境对操作系统的依赖"></a>移除执行环境对操作系统的依赖</h2><h3 id="1-添加目标平台"><a href="#1-添加目标平台" class="headerlink" title="1.添加目标平台"></a>1.添加目标平台</h3><ol>
<li>我们要构建一个可以在裸机上运行的 RISC-V架构的操作系统，那么就需要添加对目标平台的支持：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/os</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version --verbose</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: 385fa9d845dd326c6bbfd58c22244215e431948a</span><br><span class="line">commit-date: 2024-04-04</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.79.0-nightly</span><br><span class="line">LLVM version: 18.1.2</span><br></pre></td></tr></table></figure>

<p>这条命令有几个作用：</p>
<ol>
<li><p><strong>识别目标平台：</strong></p>
<ul>
<li><code>riscv64gc</code> 表示 RISC-V 64位通用计算（General-Purpose Computing）架构（ CPU 架构）。</li>
<li><code>unknown</code> 表示 Rust 不了解这个目标的操作系统或供应商信息（CPU 厂商）。</li>
<li><code>none</code> 表示没有操作系统，这通常用于裸机编程（操作系统）。</li>
<li><code>elf</code> 表示没有标准的运行时库（没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序（运行时库）。</li>
</ul>
</li>
<li><p><strong>安装必要组件：</strong>如果 <code>rustup</code> 有为 <code>riscv64gc-unknown-none-elf</code> 准备的预编译组件，它会尝试下载并安装这些组件。</p>
</li>
<li><p><strong>更新Rust工具链配置：</strong>在 Rust 配置中添加对新目标的支持，这样当你使用 <code>cargo build --target riscv64gc-unknown-none-elf</code> 命令时，Cargo 就会知道如何为 <code>riscv64gc-unknown-none-elf</code> 目标构建你的项目。</p>
</li>
</ol>
<p>可以使用如下命令查看当前Rust工具链支持的所有目标平台:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target list</span></span><br></pre></td></tr></table></figure>

<p>2.在 <code>tuos</code> 目录下新建 <code>.cargo</code> 目录，并在这个目录下创建 <code>config</code> 文件，并在里面输入如下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">#  tuos/os/.cargo/config</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会对于 Cargo 工具在 os 目录下的行为进行调整：<strong>现在默认会使用 riscv64gc 作为目标平台而不是原先的默认 x86_64-unknown-linux-gnu。</strong></p>
<h3 id="2-移除标准库依赖"><a href="#2-移除标准库依赖" class="headerlink" title="2.移除标准库依赖"></a>2.移除标准库依赖</h3><p>我们希望它能够被编译到 RV64GC 裸机平台上，为此我们需要移除它对于 Rust std标准库的依赖，因为 Rust std标准库自己就需要操作系统内核的支持。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/os/src/main.rs</span><br><span class="line"><span class="comment">// 告诉 Rust 编译器不使用 Rust 标准库 std 转而使用核心库 core（core库不需要操作系统的支持）;</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 注释掉println!宏,它是由标准库 std 提供的且会使用到一个名为 write 的系统调用;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加错误处理机制"><a href="#3-添加错误处理机制" class="headerlink" title="3.添加错误处理机制"></a>3.添加错误处理机制</h3><p>Rust编译器在编译程序时，从安全性考虑，需要有 <code>panic!</code> 宏的具体实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/lang_items.rs</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="comment">// 指定一个函数作为程序的 panic 处理程序。</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把 <code>panic_handler</code> 配置在单独的文件 <code>tuos/src/lang_items.rs</code> 后，需要在os&#x2F;src&#x2F;main.rs文件中添加以下内容才能正常编译整个软件：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br></pre></td></tr></table></figure>

<h3 id="4-移除标准main函数"><a href="#4-移除标准main函数" class="headerlink" title="4.移除标准main函数"></a>4.移除标准main函数</h3><p>应用程序在执行之前进行一些初始化工作，然后才跳转到应用程序的入口点（也就是跳转到我们编写的 <code>main</code> 函数）开始执行。 <code>start</code> 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。最简单的解决方案就是压根不让编译器使用这项功能。我们在 <code>main.rs</code> 的开头加入设置 <code>#![no_main]</code> 告诉编译器我们没有一般意义上的 <code>main</code> 函数，并将原来的 <code>main</code> 函数删除。在失去了 <code>main</code> 函数的情况下，编译器也就不需要完成所谓的初始化工作了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 禁用标准main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 删掉 自带的main函数</span></span><br></pre></td></tr></table></figure>

<p>至此，我们成功移除了标准库的依赖，并完成了构建裸机平台上操作系统的第一步工作–通过编译器检查并生成执行码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure>

<h2 id="验证Qemu模拟器与执行环境是否正确可用"><a href="#验证Qemu模拟器与执行环境是否正确可用" class="headerlink" title="验证Qemu模拟器与执行环境是否正确可用"></a>验证Qemu模拟器与执行环境是否正确可用</h2><p>下面我们将实践在 Qemu 上执行内核的第一条指令,用以检验环境是否正确可用。</p>
<h3 id="编写内核第一条指令"><a href="#编写内核第一条指令" class="headerlink" title="编写内核第一条指令"></a>编写内核第一条指令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line">    .section .text.entry # .section: 定义或切换到一个特定的代码段 .text.enery代码段</span><br><span class="line">    .globl _start        # 告知编译器 _start 是一个全局符号,可以被其他目标文件使用</span><br><span class="line">_start:                  # 全局符号,指向下面的(li x1, 100)</span><br><span class="line">    li x1, 100           # 立即数 100 被加载到了寄存器 x1 中</span><br></pre></td></tr></table></figure>

<p>一般情况下，所有的代码都被放到一个名为 <code>.text</code> 的代码段中，这里我们将其命名为 <code>.text.entry</code> 从而区别于其他 <code>.text</code> 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。</p>
<blockquote>
<p> 常见的 x86、RISC-V 等架构采用的是小端序。</p>
</blockquote>
<p><strong>将汇编代码嵌入<code>main.rs</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="comment">// 移除标准库</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 移除main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 载入模块</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">use</span> core::arch::global_asm;</span><br><span class="line"><span class="comment">// global_asm!宏：嵌入全局汇编代码;include_str!宏：文件的内容作为一个字符串嵌入到程序中;</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于 <code>main</code> 函数和 <code>global_asm!</code> 的执行顺序，重要的是理解它们的作用和上下文：</strong></p>
<ul>
<li><p><strong>global_asm!</strong>: 这个宏用于在编译时嵌入汇编代码。这些汇编代码通常用于设置中断向量表、初始化硬件或其他低级设置。这些代码在二进制文件的开始或特定段中，并且在程序开始执行时就已经存在。<em>它们并不是在运行时执行的代码，而是作为二进制文件的一部分存在</em>。</p>
</li>
<li><p><strong>main 函数</strong>: 在 Rust 程序中，<code>main</code> 函数是程序的入口点。当程序开始执行时，它首先会跳转到 <code>main</code> 函数。<em>在 <code>main</code> 函数之前，任何全局的初始化代码（包括通过 <code>global_asm!</code> 嵌入的汇编代码）都应该已经完成</em>。</p>
</li>
</ul>
</blockquote>
<h3 id="调整内核的内存布局"><a href="#调整内核的内存布局" class="headerlink" title="调整内核的内存布局"></a>调整内核的内存布局</h3><p>由于链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000 。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code>os/src/linker.ld</code> 而非使用默认的内存布局：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/.cargo/config</span></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>“-Clink-arg&#x3D;-Tsrc&#x2F;linker.ld” ：告诉 Rust 编译器在链接阶段使用 <code>src/linker.ld</code> 作为链接器脚本</li>
<li>“-Cforce-frame-pointers&#x3D;yes” : 强制编译器在生成的代码中包含帧指针。</li>
</ul>
</blockquote>
<p>链接脚本 <code>os/src/linker.ld</code> 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)	# 设置了目标平台为 riscv;</span><br><span class="line">ENTRY(_start)	# 设置了整个程序的入口点为之前定义的全局符号 _start;</span><br><span class="line">BASE_ADDRESS = 0x80200000;	# 定义了一个常量 BASE_ADDRESS 为 0x80200000 ,内核的初始化时的地址;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code>_start</code>；</p>
<p>第 3 行定义了一个常量 <code>BASE_ADDRESS</code> 为 <code>0x80200000</code> ，也就是我们之前提到内核的初始化代码被放置的地址；</p>
<p>从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 <code>.</code> 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 <code>.</code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code>.</code> 从而记录这一时刻的位置。我们还能够看到这样的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 <code>&lt;ObjectFile&gt;(SectionName)</code>，表示目标文件 <code>ObjectFile</code> 的名为 <code>SectionName</code> 的段需要被放进去。我们也可以使用通配符来书写 <code>&lt;ObjectFile&gt;</code> 和 <code>&lt;SectionName&gt;</code> 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 <code>.text, .rodata .data, .bss</code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code>.text</code> 段的开始和结束地址分别是 <code>stext</code> 和 <code>etext</code> ）。</p>
<p>第 12 行我们将包含内核第一条指令的 <code>.text.entry</code> 段放在最终的 <code>.text</code> 段的最开头，同时注意到在最终内存布局中代码段 <code>.text</code> 又是先于任何其他段的。因为所有的段都从 <code>BASE_ADDRESS</code> 也即 <code>0x80200000</code> 开始放置，这就能够保证内核的第一条指令正好放在 <code>0x80200000</code> 从而能够正确对接到 Qemu 上。</p>
<p>生成内核可执行文件，切换到 <code>os</code> 目录下进行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 release 模式生成了内核可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.06s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 file 工具查看它的属性</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file target/riscv64gc-unknown-none-elf/release/os</span></span><br><span class="line">target/riscv64gc-unknown-none-elf/release/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>

<h3 id="手动加载内核可执行文件"><a href="#手动加载内核可执行文件" class="headerlink" title="手动加载内核可执行文件"></a>手动加载内核可执行文件</h3><p>使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cargo build --release</code>后得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。所以我们需要将其元数据丢弃</p>
</blockquote>
<h3 id="基于GDB验证启动流程"><a href="#基于GDB验证启动流程" class="headerlink" title="基于GDB验证启动流程"></a>基于GDB验证启动流程</h3><p>在 <code>os</code> 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \</span></span><br><span class="line"><span class="language-bash">    -s -S</span></span><br></pre></td></tr></table></figure>

<p><code>-s</code> 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 <code>-S</code> 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 <code>-s -S</code> 。</p>
<p>打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-elf-gdb \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;set arch riscv:rv64&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;target remote localhost:1234&#x27;</span></span></span><br><span class="line">[GDB output]</span><br><span class="line">0x0000000000001000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 <code>0x1000</code> 。我们可以检查一下 Qemu 的启动固件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) x/10i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x1000:      auipc   t0,0x0</span><br><span class="line">   0x1004:      add     a2,t0,40</span><br><span class="line">   0x1008:      csrr    a0,mhartid</span><br><span class="line">   0x100c:      ld      a1,32(t0)</span><br><span class="line">   0x1010:      ld      t0,24(t0)</span><br><span class="line">   0x1014:      jr      t0</span><br><span class="line">   0x1018:      unimp</span><br><span class="line">   0x101a:      .2byte  0x8000</span><br><span class="line">   0x101c:      unimp</span><br><span class="line">   0x101e:      unimp</span><br></pre></td></tr></table></figure>

<p>这里 <code>x/10i $pc</code> 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 <code>0x1018</code> 开始都是数据，当数据为 0 的时候则会被反汇编为 <code>unimp</code> 指令。 <code>0x101a</code> 处的数据 <code>0x8000</code> 是能够跳转到 <code>0x80000000</code> 进入启动下一阶段的关键。总之，在执行位于 <code>0x1014</code> 的指令之前，寄存器 <code>t0</code> 的值恰好为 <code>0x80000000</code> ，随后通过 <code>jr t0</code> 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000000000100c in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$t0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x80000000</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>其中， <code>si</code> 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 <code>p/x $t0</code> 以 16 进制打印寄存器 <code>t0</code> 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 <code>$</code> 。可以看到，当位于 <code>0x1010</code> 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 <code>0x80000000</code> ，这意味着我们即将把控制权转交给 RustSBI 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x80000000:  auipc   sp,0x29</span><br><span class="line">   0x80000004:  add     sp,sp,-200</span><br><span class="line">   0x80000008:  lui     t0,0x4</span><br><span class="line">   0x8000000a:  add     t1,a0,1</span><br><span class="line">   0x8000000e:  add     sp,sp,t0</span><br><span class="line">   0x80000010:  add     t1,t1,-1</span><br><span class="line">   0x80000012:  bnez    t1,0x8000000e</span><br><span class="line">   0x80000016:  j       0x80015e0c</span><br><span class="line">   0x8000001a:  unimp</span><br><span class="line">   0x8000001c:  add     sp,sp,-32</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000a in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000e in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) b *0x80200000</span></span><br><span class="line">Breakpoint 1 at 0x80200000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) c</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000080200000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们在内核的入口点，也即地址 <code>0x80200000</code> 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 <code>*</code> 。接下来通过 <code>c</code> 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 <code>0x80200000</code> 处。随后，可以检查内核第一条指令是否被正确执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/5i $pc</span><br><span class="line">=&gt; 0x80200000:  li      ra,100</span><br><span class="line">   0x80200004:  unimp</span><br><span class="line">   0x80200006:  unimp</span><br><span class="line">   0x80200008:  unimp</span><br><span class="line">   0x8020000a:  unimp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080200004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/d <span class="variable">$x1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 100</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$sp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x0</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们在 <code>entry.asm</code> 中编写的第一条指令可以在 <code>0x80200000</code> 处找到。这里 <code>ra</code> 是寄存器 <code>x1</code> 的别名， <code>p/d $x1</code> 可以以十进制打印寄存器 <code>x1</code> 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 <code>sp</code> 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。</p>
<h2 id="设置栈空间以及内核初始化"><a href="#设置栈空间以及内核初始化" class="headerlink" title="设置栈空间以及内核初始化"></a>设置栈空间以及内核初始化</h2><h3 id="分配栈空间"><a href="#分配栈空间" class="headerlink" title="分配栈空间"></a>分配栈空间</h3><p>我们在 <code>entry.asm</code> 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 <code>sp</code> 设置为栈顶的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line"></span><br><span class="line">    .section .text.entry	# 定义一个段</span><br><span class="line">    .globl _start	# 定义一个全局符号</span><br><span class="line">_start:	# 程序入口</span><br><span class="line">    la sp, boot_stack_top	# 立即将 boot_stack_top 的地址加载到栈指针 sp 中</span><br><span class="line">    call main # 调用一个名为main的子程序</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16	# 为数据段分配一定数量的空间。</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:		# 表示为栈顶 ,上文_start程序入口加载的位置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上所述，这段代码定义了程序的入口点 <code>_start</code>，并设置了一个栈空间，栈的顶部是 <code>boot_stack_top</code>，底部是 <code>boot_stack_lower_bound</code>，总共 64KB。程序从 <code>_start</code> 开始执行，首先设置栈指针，然后调用 Rust 编写的 <code>main</code> 函数。</p>
</blockquote>
<h3 id="编写入口函数"><a href="#编写入口函数" class="headerlink" title="编写入口函数"></a>编写入口函数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要对该函数名进行修饰，以便其他语言就可以通过该原始名称来链接和调用 Rust 函数或访问 Rust 变量。</span></span><br><span class="line"><span class="comment">// 这里面的main名字要与汇编代码中指定的入口子函数名称一致</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123; </span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-bss-段的清零"><a href="#对-bss-段的清零" class="headerlink" title="对 .bss 段的清零"></a>对 <code>.bss</code> 段的清零</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对.bss段清零</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数 <code>clear_bss</code> 中，我们会尝试从其他地方找到全局符号 <code>sbss</code> 和 <code>ebss</code> ，它们由链接脚本 <code>linker.ld</code> 给出，并分别指出需要被清零的 <code>.bss</code> 段的起始和终止地址。接下来我们只需遍历该地址区间并逐字节进行清零即可。</p>
</blockquote>
<h2 id="使用RustSBI-实现字符打印功能"><a href="#使用RustSBI-实现字符打印功能" class="headerlink" title="使用RustSBI 实现字符打印功能"></a>使用RustSBI 实现字符打印功能</h2><p>RustSBI 通过实现 SBI 标准，使得操作系统能够利用RISC-V处理器的指令集系统来执行各种操作。</p>
<h3 id="调用-SBI-服务"><a href="#调用-SBI-服务" class="headerlink" title="调用 SBI 服务"></a>调用 SBI 服务</h3><p><strong>在 <code>Cargo.toml</code> 中引入 sbi_rt 依赖来调用 SBI 服务的接口：</strong></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 因为兼容问题Qemu9.0.0在进行后续学习时候或出错，故将版次改为 2018	</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sbi-rt</span> = &#123; version = <span class="string">&quot;0.0.2&quot;</span>, features = [<span class="string">&quot;legacy&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>我们将内核与 RustSBI 通信的相关功能实现在子模块 <code>sbi</code> 中，因此我们需要在 <code>main.rs</code> 中加入 <code>mod sbi</code> 将该子模块加入我们的项目。在 <code>os/src/sbi.rs</code> 中，我们直接调用 sbi_rt 提供的接口来将输出字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="keyword">mod</span> sbi;</span><br><span class="line"></span><br><span class="line"># os/src/sbi.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// #[allow(deprecated)]属性来禁止编译器发出警告,对于某些已经弃用的方法。</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    sbi_rt::legacy::<span class="title function_ invoke__">console_putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现关机功能"><a href="#实现关机功能" class="headerlink" title="实现关机功能"></a>实现关机功能</h3><p><strong>实现关机功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/sbi.rs</span></span><br><span class="line">pub fn shutdown(failure: bool) -&gt; ! &#123;</span><br><span class="line">    use sbi_rt::&#123;system_reset, NoReason, Shutdown, SystemFailure&#125;;</span><br><span class="line">    if !failure &#123;</span><br><span class="line">        system_reset(Shutdown, NoReason);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        system_reset(Shutdown, SystemFailure);</span><br><span class="line">    &#125;</span><br><span class="line">    unreachable!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">mod</span> console;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/console.rs</span></span><br><span class="line"><span class="keyword">use</span> crate::sbi::console_putchar;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成内核镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Qemu模拟器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行结果如图：</span></span><br><span class="line">[rustsbi] RustSBI version 0.4.0-alpha.1, adapting to RISC-V SBI v2.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.3</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e01290</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">Hello, world!</span><br><span class="line">Panicked at src/main.rs:23 Shutdown machine!</span><br></pre></td></tr></table></figure>

<h2 id="程序内存布局与编译流程"><a href="#程序内存布局与编译流程" class="headerlink" title="程序内存布局与编译流程"></a>程序内存布局与编译流程</h2><h3 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h3><p>在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： <strong>段</strong> (Section) 。不同的段会被编译器放置在内存不同的位置上，这构成了程序的 <strong>内存布局</strong> (Memory Layout)。一种典型的程序相对内存布局如下所示：</p>
<p><img src="/public/image/OS/tuos/MemoryLayout.png" alt="MemoryLayout"></p>
<p>在上图中可以看到，代码部分只有代码段 <code>.text</code> 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：</p>
<ul>
<li>已初始化数据段保存程序中那些已初始化的全局数据，分为 <code>.rodata</code> 和 <code>.data</code> 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。</li>
<li>未初始化数据段 <code>.bss</code> 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；</li>
<li><strong>堆</strong> （heap）区域用来存放程序运行时动态分配的数据，如 C&#x2F;C++ 中的 malloc&#x2F;new 分配到的数据本体就放在堆区域，它向高地址增长；</li>
<li><strong>栈</strong> （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。</li>
</ul>
<blockquote>
<p><strong>局部变量与全局变量</strong></p>
<p>在一个函数的视角中，它能够访问的变量包括以下几种：</p>
<ul>
<li>函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；</li>
<li>全局变量：保存在数据段 <code>.data</code> 和 <code>.bss</code> 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。</li>
<li>堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 <em>直接</em> 访问栈上或者全局数据段中的 <strong>编译期确定大小</strong> 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。</li>
</ul>
</blockquote>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：</p>
<ul>
<li><p><strong>编译器</strong> (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；</p>
</li>
<li><p><strong>汇编器</strong> (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 <strong>目标文件</strong> (Object File)；</p>
</li>
<li><p><strong>链接器</strong> (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。</p>
</li>
</ul>
<p>汇编器输出的每个目标文件都有一个独立的程序内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整合成一个整体的内存布局。在此期间链接器主要完成两件事情：</p>
<ul>
<li>第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 <code>1.o</code> 和 <code>2.o</code> 段被按照段的功能进行分类，相同功能的段被排在一起放在拼装后的目标文件 <code>output.o</code> 中。注意到，目标文件 <code>1.o</code> 和 <code>2.o</code> 的内存布局是存在冲突的，同一个地址在不同的内存布局中存放不同的内容。而在合并后的内存布局中，这些冲突被消除。</li>
</ul>
<p>​	<img src="/public/image/tuos/MemoryLayout-Linker.png" alt="MemoryLayout-Linker"></p>
<ul>
<li><p>第二件事情是将符号替换为具体地址。这里的符号指什么呢？我们知道，在我们进行模块化编程的时候，每个模块都会提供一些向其他模块公开的全局变量、函数等供其他模块访问，也会访问其他模块向它公开的内容。要访问一个变量或者调用一个函数，在源代码级别我们只需知道它们的名字即可，这些名字被我们称为符号。取决于符号来自于模块内部还是其他模块，我们还可以进一步将符号分成内部符号和外部符号。然而，在机器码级别（也即在目标文件或可执行文件中）我们并不是通过符号来找到索引我们想要访问的变量或函数，而是直接通过变量或函数的地址。例如，如果想调用一个函数，那么在指令的机器码中我们可以找到函数入口的绝对地址或者相对于当前 PC 的相对地址。</p>
<p>那么，符号何时被替换为具体地址呢？因为符号对应的变量或函数都是放在某个段里面的固定位置（如全局变量往往放在 <code>.bss</code> 或者 <code>.data</code> 段中，而函数则放在 <code>.text</code> 段中），所以我们需要等待符号所在的段确定了它们在内存布局中的位置之后才能知道它们确切的地址。当一个模块被转化为目标文件之后，它的内部符号就已经在目标文件中被转化为具体的地址了，因为目标文件给出了模块的内存布局，也就意味着模块内的各个段的位置已经被确定了。然而，此时模块所用到的外部符号的地址无法确定。我们需要将这些外部符号记录下来，放在目标文件一个名为符号表（Symbol table）的区域内。由于后续可能还需要重定位，内部符号也同样需要被记录在符号表中。</p>
<p>外部符号需要等到链接的时候才能被转化为具体地址。假设模块 1 用到了模块 2 提供的内容，当两个模块的目标文件链接到一起的时候，它们的内存布局会被合并，也就意味着两个模块的各个段的位置均被确定下来。此时，模块 1 用到的来自模块 2 的外部符号可以被转化为具体地址。同时我们还需要注意：两个模块的段在合并后的内存布局中被重新排布，其最终的位置有可能和它们在模块自身的局部内存布局中的位置相比已经发生了变化。因此，每个模块的内部符号的地址也有可能会发生变化，我们也需要进行修正。上面的过程被称为重定位（Relocation），这个过程形象一些来说很像拼图：由于模块 1 用到了模块 2 的内容，因此二者分别相当于一块凹进和凸出一部分的拼图，正因如此我们可以将它们无缝地拼接到一起。</p>
</li>
</ul>
<p>上面我们简单介绍了程序内存布局和编译流程特别是链接过程的相关知识。那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 <code>0x80200000</code> 处，同时代码段所在的地址应低于其他段。这是因为 Qemu 物理内存中低于 <code>0x80200000</code> 的区域并未分配给内核，而是主要由 RustSBI 使用。其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中。下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>实现批处理系统</title>
    <url>/OS/rCore/%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h1><p>管理无需或仅需少量用户交互即可运行的程序，在资源允许的情况下它可以自动安排程序的执行。</p>
<p>核心思想为：将多个程序打包到一起输入计算机。而当一个程序运行结束后，计算机会 <em>自动</em> 加载下一个程序到内存并开始执行。</p>
<h2 id="特权级机制"><a href="#特权级机制" class="headerlink" title="特权级机制"></a>特权级机制</h2><ul>
<li><p><em>保护</em> 计算机系统不受有意或无意出错的程序破坏的机制被称为 <strong>特权级</strong> (Privilege) 机制。</p>
<ul>
<li>应用程序不能执行某些可能破坏计算机系统的指令</li>
</ul>
</li>
<li><p>它让应用程序运行在<strong>用户态</strong>，而操作系统运行在<strong>内核态</strong>，且实现用户态和内核态的隔离。</p>
<ul>
<li>处理器设置两个不同安全等级的执行环境：<strong>用户态特权级的执行环境</strong>和<strong>内核态特权级的执行环境</strong>。且明确指出可能破坏计算机系统的内核态特权级指令子集，规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行。处理器在执行指令前会进行特权级安全检查，如果在用户态执行环境中执行这些内核态特权级指令，会产生异常。</li>
</ul>
</li>
<li><p>软硬件协同工作。</p>
</li>
</ul>
<h2 id="模拟客户端应用程序"><a href="#模拟客户端应用程序" class="headerlink" title="模拟客户端应用程序"></a>模拟客户端应用程序</h2><h3 id="创建应用端库"><a href="#创建应用端库" class="headerlink" title="创建应用端库"></a>创建应用端库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new user -lib</span></span><br><span class="line">    Creating library `user` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<p>修改库名</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuos/user/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;user_lib&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Kay &lt;cn.kay.wang@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 这里要改不然后续执行会报错</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">riscv</span> = &#123; git = <span class="string">&quot;https://github.com/rcore-os/riscv&quot;</span>, features = [<span class="string">&quot;inline-asm&quot;</span>] &#125; </span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span> <span class="comment"># 因qemu9.0.0兼容性文件所以要设置</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>lib.rs</code> 中我们定义了用户库的入口点 <code>_start</code> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性宏从指定库中导入到当前作用域中</span></span><br><span class="line"><span class="keyword">use</span> user_lib::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不修改符号名</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="comment">// 指定.text.entry段入口</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable after sys_exit!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还在 <code>lib.rs</code> 中看到了另一个 <code>main</code> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标为弱链接，虽然名叫main但不会作为主函数</span></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了支持上述这些链接操作，我们需要在 <code>lib.rs</code> 的开头加入</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#![feature(linkage)]</span></span><br></pre></td></tr></table></figure>

<h3 id="设置内存布局"><a href="#设置内存布局" class="headerlink" title="设置内存布局"></a>设置内存布局</h3><p>让操作系统能够把应用加载到内存地址，然后顺利启动并运行应用程序。</p>
<ul>
<li><p>在 <code>user/.cargo/config</code> 中，设置链接时使用链接脚本 <code>user/src/linker.ld</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/.cargo/config</span></span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-args=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置内存布局</p>
<ul>
<li>在<code>user/src/linker.ld</code>中设置程序起始地址为<code>0x80400000</code>；</li>
<li>将 <code>_start</code> 所在的 <code>.text.entry</code> 放在整个程序的开头，使得系统只要跳转到<code>0x80400000</code>就已经进入了 用户库的入口点，并会在初始化之后跳转到应用程序主逻辑；</li>
<li>提供了最终生成可执行文件的 <code>.bss</code> 段的起始和终止地址，方便 <code>clear_bss</code> 函数使用；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/src/linker.ld</span></span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">BASE_ADDRESS = 0x80400000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        start_bss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">        end_bss = .;</span><br><span class="line">    &#125;</span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">        *(.debug*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调用系统ABI"><a href="#调用系统ABI" class="headerlink" title="调用系统ABI"></a>调用系统ABI</h3><p>使用RISC-V 提供的机器指令：执行环境调用指令（Execution Environment Call，简称 <code>ecall</code> ）和一类执行环境返回（Execution Environment Return，简称 <code>eret</code> ）指令。其中：</p>
<ul>
<li><code>ecall</code> 具有用户态到内核态的执行环境切换能力的函数调用指令；</li>
<li><code>sret</code> ：具有内核态到用户态的执行环境切换能力的函数返回指令。</li>
</ul>
<p>这里约定如下两个系统调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 功能：将内存中缓冲区中的数据写入文件。</span></span><br><span class="line"><span class="comment">/// 参数：`fd` 表示待写入文件的文件描述符；</span></span><br><span class="line"><span class="comment">///      `buf` 表示内存中缓冲区的起始地址；</span></span><br><span class="line"><span class="comment">///      `len` 表示内存中缓冲区的长度。</span></span><br><span class="line"><span class="comment">/// 返回值：返回成功写入的长度。</span></span><br><span class="line"><span class="comment">/// syscall ID：64</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：退出应用程序并将返回值告知批处理系统。</span></span><br><span class="line"><span class="comment">/// 参数：`exit_code` 表示应用程序的返回值。</span></span><br><span class="line"><span class="comment">/// 返回值：该系统调用不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：93</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure>

<p>由于rust不直接支持寄存器操作，为此我们需要在代码中使用内嵌汇编来完成参数&#x2F;返回值绑定和 <code>ecall</code> 指令的插入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// asm! 宏可以将汇编代码嵌入到局部的函数上下文中。</span></span><br><span class="line">        <span class="comment">// 相比 global_asm!, asm! 宏可以获取上下文中的变量信息并允许嵌入的汇编代码对这些变量进行操作</span></span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有的系统调用都封装成 <code>syscall</code> 函数。</p>
<blockquote>
<p>在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 <code>a0~a6</code> 保存系统调用的参数， <code>a0</code> 保存系统调用的返回值。有些许不同的是寄存器 <code>a7</code> 用来传递 syscall ID，这是因为所有的 syscall 都是通过 <code>ecall</code> 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。</p>
<p><strong>RISC-V 寄存器编号和别名</strong></p>
<p>RISC-V 寄存器编号从 <code>0~31</code> ，表示为 <code>x0~x31</code> 。 其中：</p>
<ul>
<li><code>x10~x17</code> : 对应 <code>a0~a7</code></li>
<li><code>x1</code> ：对应 <code>ra</code></li>
</ul>
<p>在 <code>ecall</code> 指令中<code>a0~a2</code> 和 <code>a7</code> 作为输入寄存器分别表示系统调用参数和系统调用 ID，当系统调用返回后， <code>a0</code> 作为输出寄存器保存系统调用的返回值。</p>
</blockquote>
<p>于是 <code>sys_write</code> 和 <code>sys_exit</code> 只需将 <code>syscall</code> 进行包装：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述两个系统调用在用户库 <code>user_lib</code> 中进一步封装，从而更加接近在 Linux 等平台的实际系统调用接口：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> syscall::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(fd: <span class="type">usize</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_write</span>(fd, buf) &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_exit</span>(exit_code) &#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>console</code> 子模块中 <code>Stdout::write_str</code> 改成基于 <code>write</code> 的实现，且传入的 <code>fd</code> 参数设置为 1，它代表标准输出， 也就是输出到屏幕。目前我们不需要考虑其他的 <code>fd</code> 选取情况。这样，应用程序的 <code>println!</code> 宏借助系统调用变得可用了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/console.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STDOUT: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(STDOUT, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exit</code> 接口则在用户库中的 <code>_start</code> 内使用，当应用程序主逻辑 <code>main</code> 返回之后，使用它退出应用程序并将返回值告知 底层的批处理系统。</p>
<h3 id="模拟应用程序执行"><a href="#模拟应用程序执行" class="headerlink" title="模拟应用程序执行"></a>模拟应用程序执行</h3><p>尝试在用户态模拟器 <code>qemu-riscv64</code> 执行这两个应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> target/riscv64gc-unknown-none-elf/release/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认待执行的应用为 ELF 格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file 03priv_inst</span></span><br><span class="line">03priv_inst: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行特权指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./03priv_inst</span></span><br><span class="line">Try to execute privileged instruction in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行访问特权级 CSR 的指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./04priv_csr</span></span><br><span class="line">Try to access privileged CSR in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>user/Cargo.toml</code>下要设置</p>
<p>[package]</p>
<p>edition &#x3D; “2018”</p>
<p>[profile.release]</p>
<p>5 1  0opt-level &#x3D; 0</p>
<p>不然几个实例客户端程序将可能会出错</p>
</blockquote>
<h2 id="实现批处理系统"><a href="#实现批处理系统" class="headerlink" title="实现批处理系统"></a>实现批处理系统</h2><ul>
<li>操作系统自身运行在内核态，支持应用程序在用户态运行，且能够完成应用程序发出的系统调用。</li>
<li>能够一个接着一个地自动运行不同的运行程序</li>
</ul>
<p>在具体实现其批处理执行应用程序功能之前，本节我们首先实现该应用加载机制，也即：在操作系统和应用程序需要被放置到同一个可执行文件的前提下，设计一种尽量简洁的应用放置和加载方式，使得操作系统容易找到应用被放置到的位置，从而在批处理操作系统和应用程序之间建立起联系的纽带。具体而言，应用放置采用“静态绑定”的方式，而操作系统加载应用则采用“动态加载”的方式：</p>
<ul>
<li>静态绑定：通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起。</li>
<li>动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。</li>
</ul>
<h3 id="将应用程序链接到内核"><a href="#将应用程序链接到内核" class="headerlink" title="将应用程序链接到内核"></a>将应用程序链接到内核</h3><p>利用<code>build.rs</code>脚本文件生成汇编代码将应用程序链接到内核</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::&#123;read_dir, File&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="type">Result</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=../user/src/&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=&#123;&#125;&quot;</span>, TARGET_PATH);</span><br><span class="line">    <span class="title function_ invoke__">insert_app_data</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> TARGET_PATH: &amp;<span class="type">str</span> = <span class="string">&quot;../user/target/riscv64gc-unknown-none-elf/release/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">insert_app_data</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;src/link_app.S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">apps</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="title function_ invoke__">read_dir</span>(<span class="string">&quot;../user/src/bin&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|dir_entry| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name_with_ext</span> = dir_entry.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">into_string</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            name_with_ext.<span class="title function_ invoke__">drain</span>(name_with_ext.<span class="title function_ invoke__">find</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">unwrap</span>()..name_with_ext.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            name_with_ext</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    apps.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">writeln!</span>(</span><br><span class="line">        f,</span><br><span class="line">        <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .align 3</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global _num_app</span></span><br><span class="line"><span class="string">_num_app:</span></span><br><span class="line"><span class="string">    .quad &#123;&#125;&quot;#</span>,</span><br><span class="line">        apps.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..apps.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_start&quot;#</span>, i)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_end&quot;#</span>, apps.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx, app) <span class="keyword">in</span> apps.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;app_&#123;&#125;: &#123;&#125;&quot;</span>, idx, app);</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_start</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_end</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_start:</span></span><br><span class="line"><span class="string">    .incbin &quot;&#123;2&#125;&#123;1&#125;.bin&quot;</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_end:&quot;#</span>,</span><br><span class="line">            idx, app, TARGET_PATH</span><br><span class="line">        )?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>build.rs</code>脚本文件将生成以下类似文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># os/src/link_app.S</span><br><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;</span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;</span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin&quot;</span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin&quot;</span><br><span class="line">app_4_end:</span><br></pre></td></tr></table></figure>

<p>将汇编代码链接到内核</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="找到并加载应用程序二进制码"><a href="#找到并加载应用程序二进制码" class="headerlink" title="找到并加载应用程序二进制码"></a>找到并加载应用程序二进制码</h3><p>创建一个<em>应用管理器</em><code>AppManager</code>用来找到并加载应用程序二进制码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    current_app: <span class="type">usize</span>,</span><br><span class="line">    app_start: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中：</p>
<ul>
<li><code>current_app</code> 字段表示当前执行的是第几个应用，它是一个可修改的变量，会在系统运行期间发生变化。</li>
</ul>
</blockquote>
<p>我们希望将 <code>AppManager</code> 实例化为一个全局变量，使得任何函数都可以直接访问，最简单就是将它设置为<code>static mut</code>，但<code>static mut</code>则是 unsafe 的，而我们要在编程中尽量避免使用 unsafe ，这样才能让编译器负责更多的安全性检查。因此，我们需要使用<code>RefCell</code>，即内部可变性。但要给<code>static</code>类型的变量设置<code>RefCell</code>则必须要实现<code>Sync</code> tarit。为此我们在<code>RefCell</code>上封装一层叫做<code>UPSafeCell</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/sync/up.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UPSafeCell</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// inner data</span></span><br><span class="line">    inner: RefCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">UPSafeCell</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; UPSafeCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// User is responsible to guarantee that inner struct is only used in</span></span><br><span class="line">    <span class="comment">/// uniprocessor.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; inner: RefCell::<span class="title function_ invoke__">new</span>(value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Panic if the data has been borrowed.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exclusive_access</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> RefMut&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">borrow_mut</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UPSafeCell</code> 对于 <code>RefCell</code> 简单进行封装，它和 <code>RefCell</code> 一样提供内部可变性和运行时借用检查，只是更加严格：调用 <code>exclusive_access</code> 可以得到它包裹的数据的独占访问权。因此当我们要访问数据时（无论读还是写），需要首先调用 <code>exclusive_access</code> 获得数据的可变借用标记，通过它可以完成数据的读写，在操作完成之后我们需要销毁这个标记，此后才能开始对该数据的下一次访问。相比 <code>RefCell</code> 它不再允许多个读操作同时存在。</p>
<p>这段代码里面出现了两个 <code>unsafe</code> ：</p>
<ul>
<li>首先 <code>new</code> 被声明为一个 <code>unsafe</code> 函数，是因为我们希望使用者在创建一个 <code>UPSafeCell</code> 的时候保证在访问 <code>UPSafeCell</code> 内包裹的数据的时候始终不违背上述模式：即访问之前调用 <code>exclusive_access</code> ，访问之后销毁借用标记再进行下一次访问。这只能依靠使用者自己来保证，但我们提供了一个保底措施：当使用者违背了上述模式，比如访问之后忘记销毁就开启下一次访问时，程序会 panic 并退出。<code>unsafe</code> 关键字本身无法提供上述保障，这个关键字主要是给用户一个警告和提示。这个保证在单核的情况下可以由借用检查器给到。</li>
<li>另一方面，我们将 <code>UPSafeCell</code> 标记为 <code>Sync</code> 使得它可以作为一个全局变量。这是 unsafe 行为，因为编译器无法确定我们的 <code>UPSafeCell</code> 能否安全的在多线程间共享。而我们能够向编译器做出保证，第一个原因是目前我们内核仅运行在单核上，因此无需在意任何多核引发的数据竞争&#x2F;同步问题；第二个原因则是它基于 <code>RefCell</code> 提供了运行时借用检查功能，从而满足了 Rust 对于借用的基本约束进而保证了内存安全。</li>
</ul>
<p>初始化<code>AppManager</code>的全局实例<code>APP_MANAGER</code></p>
<p>这里我们使用了外部库 <code>lazy_static</code> 提供的 <code>lazy_static!</code> 宏。</p>
<p>添加依赖</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = &#123; version = <span class="string">&quot;1.4.0&quot;</span>, features = [<span class="string">&quot;spin_no_std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>lazy_static!</code> 宏进行初始化工作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="keyword">fn</span> <span class="title function_">_num_app</span>(); &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =  core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">        app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">        AppManager &#123;</span><br><span class="line">            num_app,</span><br><span class="line">            current_app: <span class="number">0</span>,</span><br><span class="line">            app_start,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现跨特权级的系统接口调用"><a href="#实现跨特权级的系统接口调用" class="headerlink" title="实现跨特权级的系统接口调用"></a>实现跨特权级的系统接口调用</h3><h3 id="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"><a href="#执行系统调用前后能够准备和恢复用户态执行应用程序的上下文" class="headerlink" title="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"></a>执行系统调用前后能够准备和恢复用户态执行应用程序的上下文</h3><h3 id="支持多个应用程序轮流启动运行"><a href="#支持多个应用程序轮流启动运行" class="headerlink" title="支持多个应用程序轮流启动运行"></a>支持多个应用程序轮流启动运行</h3><h2 id="二者之间的特权级切换"><a href="#二者之间的特权级切换" class="headerlink" title="二者之间的特权级切换"></a>二者之间的特权级切换</h2><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust版本概述</title>
    <url>/Rust/basic/Rust%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>Rust语言的版本主要包括<code>语义化版本</code>、<code>发行版本</code>、<code>Edition版次</code>三个相互正交的概念。</p>
<h1 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h1><ul>
<li><p>格式：主版本号.次版本号.修订号，以此用 . 隔开</p>
<p>主版本号：当做了不兼容的 API 修改。</p>
<p>次版本号：当做了向下兼容的功能性递增。</p>
<p>修订号：   当做了向下兼容的问题修正。</p>
</li>
</ul>
<h1 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h1><p>master -&gt; Nightly：开发版；</p>
<p>bata -&gt; Beta：测试版；</p>
<p>stable -&gt; Stable：稳定版；</p>
<h1 id="Edition版次"><a href="#Edition版次" class="headerlink" title="Edition版次"></a>Edition版次</h1><p>版次的意义在于方便<code>Rust</code>自身的进化，保证新的变化不会影响自身原有的生态系统。</p>
<p>类似于<code>Java</code>中编译器用于区分<code>Java8</code>与<code>Java17</code>这样的不兼容版本。</p>
<p>不同版次编译的代码可以互相依赖不影响使用(2021版次的代码可以引用2015版次编译的库)。</p>
<ol>
<li>2015 Edition</li>
<li>2018 Edition</li>
<li>2021 Edition</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>异步Web实战</title>
    <url>/Rust/project/%E5%BC%82%E6%AD%A5Web%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h2 id="rust编码规范"><a href="#rust编码规范" class="headerlink" title="rust编码规范"></a>rust编码规范</h2><p>新建<code>.rustfmt.toml</code>文件用于帮助你写出地道的rust代码。</p>
<p>Rustfmt 的设计非常易于配置。您可以创建一个名为 <code>rustfmt.toml</code>或 的TOML 文件<code>.rustfmt.toml</code>，将其放在项目或任何其他父目录中，它将应用该文件中的选项。</p>
<p>这需要将rust设置为<code>nightly</code>时才可使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure>

<p>在当前工作目录中的 Cargo 项目上运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo +nightly fmt</span><br><span class="line"></span><br><span class="line"># rustfmt lib.rs main.rs 将就只格式化“lib.rs”和“main.rs”</span><br><span class="line"># rustfmt lib.rs --check 检查 lib.rs 文件的格式，并给出修改意见，不进行格式化</span><br></pre></td></tr></table></figure>

<h2 id="学习axum"><a href="#学习axum" class="headerlink" title="学习axum"></a>学习axum</h2><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p><strong>1.cargo-edit工具</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cargo install cargo<span class="literal">-edit</span></span><br></pre></td></tr></table></figure>

<p><strong>2. Toml文件插件</strong></p>
<p><code>TOML Language Support</code></p>
<p><strong>3. cratescha插件</strong></p>
<p><code>crates</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-实战</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/C/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><ul>
<li>char-字符型，一个字节的整数，范围【-128-127】</li>
<li>字符数据（单引号括起来的字符）的本质是整数类型</li>
<li>char 类型的变量可以打印为整数或者字符</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>const 修饰的变量是只读的，本质还是变量</li>
<li>const 修饰的局部变量在<strong>栈</strong>上分配空间</li>
<li>const 修饰的全局变量在<strong>只读存储区</strong>分配空间</li>
<li>const 只在编译器有用，在运行期无用</li>
</ul>
<blockquote>
<p>const 修饰的变量不是真正的变量，他只是告诉编译器该变量不能出现在赋值符号的左边；</p>
</blockquote>
<ul>
<li>在现代 C 语言编译器中，直接修改 const 全局变量将导致程序崩溃</li>
</ul>
<blockquote>
<p>注意：标准 C 语言编译器不会将 const 修饰的全局变量存储与只读存储区中，而是存储与可修改的全局数据区，其值依然可以改变；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_cc = <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cc = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* pp = (<span class="type">int</span>*)&amp;cc;</span><br><span class="line">    <span class="type">int</span>* g_pp = (<span class="type">int</span>*)&amp;g_cc;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cc); <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p = 3 // Error</span></span><br><span class="line">    *pp = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc = %d\n&quot;</span>, cc);<span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc);<span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//g_cc = 2 // Error</span></span><br><span class="line">     </span><br><span class="line">    *g_pp = <span class="number">3</span>; <span class="comment">// oops! Segmentation fault </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_cc = %d\n&quot;</span>, g_cc);<span class="comment">// 2</span></span><br><span class="line">        </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gcc 将全局 cosnt 存储与只读存储区，当我们试图修改其中的内容时候，就会报 Segmentation fault 错误（这也是标准 C 语言的定义）</p>
<p>其他编译器可能就没问题</p>
</blockquote>
<ul>
<li>C 语言中的 const 使得变量具有只读属性</li>
<li>现代 C 编译器中的 const 将具有全局生命周期的变量存储与只读存储区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_array[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    *p = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;i, <span class="number">1</span>);    <span class="comment">// ok</span></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;j, <span class="number">1</span>);    <span class="comment">// Error</span></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;<span class="built_in">array</span>[<span class="number">0</span>], <span class="number">1</span>); <span class="comment">// ok</span></span><br><span class="line">    modify((<span class="type">int</span>*)&amp;g_array[<span class="number">0</span>], <span class="number">1</span>); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arrya[0] = %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_arrya[0] = %d\n&quot;</span>, g_array[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>modify((int*)&amp;j, 1);    &#x2F;&#x2F; Error</p>
<p>被 static 修饰的变量被存储在全局存储区，const 修饰的全局变量将被存放在只读存储区</p>
<p>modify((int*)&amp;g_array[0], 1); &#x2F;&#x2F; Error</p>
<p>g_array[0] 是全局变量，被 const 修饰的全局变量将存储区只读存储区</p>
</blockquote>
<ul>
<li>const 修饰函数参数表示在函数体内不希望改变参数的值</li>
<li>const 修饰函数返回值表示返回值不可改变，多用于返回指针的情形</li>
</ul>
<blockquote>
<p>C 语言中的字符串字面量存储与只读存储区中，在程序中需要使用 const char* 指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i )</span> &#123;</span><br><span class="line">    <span class="comment">// i = 5;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;kay wang&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pc = f(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pc[3] = &quot;_&quot;; // Error 因为是只读的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pc);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p><strong>在 C 语言中可以定义 void 类型的指针</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> var; <span class="comment">// Eroor</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">array</span>[<span class="number">5</span>]; <span class="comment">// Err</span></span><br><span class="line">    <span class="type">void</span>* pv; <span class="comment">// C 语言允许定义 void 类型的指针 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不存在 void 类型的变量</strong></p>
<ul>
<li><p>C 语言中没有定义 void 究竟是多大内存的别名，无法在内存中开辟出 void 大小对应的变量</p>
</li>
<li><p>而指针是固定 4 或 8 个字节大小的，所以可以开辟指针类型的 void 变量</p>
</li>
</ul>
<blockquote>
<p>注意：在非标准 C 语言编译器中有的对 void 规定了大小，比如 gcc 编译器就规定了 void 大小为 1 个字节</p>
<p>printf(“%ld\n”, sizeof(void)); &#x2F;&#x2F; 1</p>
</blockquote>
<p><strong>意义</strong></p>
<ul>
<li>C 语言规定只有相同类型的指针才可以互相赋值</li>
<li>void* 指针作为左值用于 “接收” 任意类型的指针</li>
<li>void* 指针作为右值使用时需要进行强制类型转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// malloc() 函数是 C 语言标准库中的一个函数，用于动态地分配内存。</span></span><br><span class="line"><span class="type">int</span>* pI = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">char</span>* pC = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="type">void</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* pni = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* pnc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = pI; <span class="comment">// ok</span></span><br><span class="line">============</span><br><span class="line">pni = P; <span class="comment">// Error oops! pni = (int*)p</span></span><br><span class="line"></span><br><span class="line">p = pC <span class="comment">// ok</span></span><br><span class="line">==================</span><br><span class="line">pnc = P; <span class="comment">// Error oops! pnc = (void*)p</span></span><br></pre></td></tr></table></figure>

<ul>
<li>void 是一种抽象的数据类型</li>
<li>void 类型不能用于定义变量</li>
<li>void 类型用于声明函数无参数</li>
<li>void 类型用于声明函数无返回值</li>
<li>可以定义 void* 类型的指针</li>
<li>void* 类型的指针可以接收任意类型的指针值</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>volatile 可理解为 “编译器警告关键字”</li>
<li>volatile 告诉编译器必须每次去内存中取变量值</li>
<li>volatile 主要修饰可能被多个线程访问的变量</li>
<li>volatile 也可以修饰可能被未知因数更改的变量</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>C 语言中的常量类型</strong></p>
<ul>
<li>字面量<ul>
<li>直接表示值含义的符号，如：5、’a’、”Ubuntu”</li>
</ul>
</li>
<li>宏常量（字符化的字面量）<ul>
<li>通过 #define 定义，间接表示值的符号，如：FIV &#x3D;&gt; 5.5</li>
</ul>
</li>
<li>枚举常量<ul>
<li>通过 enum 定义，间接表示值的符号，如：First &#x3D;&gt; 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME kay;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举常量只能是整形常量，浮点数都不可以</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ThirdValue = <span class="number">333</span>,</span><br><span class="line">    FourthValue = <span class="number">444</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>常量的类型</strong></p>
<ul>
<li>字面量有其默认的类型，也可通过后缀指定其类型</li>
<li>#define 定义的宏常量可以是任意类型</li>
<li>enum 定义的枚举常量只能是整形</li>
</ul>
<blockquote>
<p>字面量是常量，但是它的默认类型由语言提供，也可通过后缀指定其类型；</p>
</blockquote>
<h2 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h2><p><strong>C 语言中的只读变量</strong></p>
<ul>
<li>C 语言提供了 const 关键字，用于修饰一个变量</li>
<li>被 const 修饰的变量<strong>只能作为右值使用</strong><ul>
<li>无法通过赋值操作改变 const 变量的值</li>
<li>const 修饰</li>
</ul>
</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><strong>同样是4个字节，为什么float却比int的范围大得多呢？</strong></p>
<ul>
<li>float 能表示的具体数字的个数与int相同</li>
<li>float可表示的数字之间不是连续的，存在间隙</li>
<li>float只是一种近似的表示法，不能作为精确使用</li>
<li>由于内存表示法相对复杂，float的运算速度比int慢很多</li>
</ul>
<blockquote>
<p>注意：</p>
<p>double 与 float 具有相同的内存表示法，因此 double 也是不精确的。由于 double 占用的内存较多，所能表示的精度比 float 高；</p>
</blockquote>
<p><strong>小结</strong></p>
<ul>
<li>浮点类型与整数类型的内存表示法不同</li>
<li>浮点类型的内存表示更复杂</li>
<li>浮点类型可表示的范围更大</li>
<li>浮点类型是一种不精确的类型</li>
<li>浮点类型的运算速度很慢</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><ul>
<li>long 在使用不同的编译器时，可能占用的内存不同</li>
<li>long 通常占 4 字节内存，也可能占 8 字节内存</li>
<li>long long表示整形，固定占用 8 字节内存</li>
<li>long long 是 long long int 的缩写形式</li>
</ul>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><ul>
<li>C 语言中的 struct 可以看作变量的集合</li>
</ul>
<p><strong>空结构体占用多大内存？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TS</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TS</span> <span class="title">t1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TS</span> <span class="title">t2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct TS) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> TS));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(t1) = %ld, &amp;t1 = %p\n&quot;</span>, <span class="keyword">sizeof</span>(t1), &amp;t1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(t2) = %ld, &amp;t2 = %p\n&quot;</span>, <span class="keyword">sizeof</span>(t2), &amp;t2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*    </span></span><br><span class="line"><span class="comment">    sizeof(struct TS) = 0</span></span><br><span class="line"><span class="comment">	sizeof(t1) = 0, &amp;t1 = 0x7ffec502f4d6</span></span><br><span class="line"><span class="comment">	sizeof(t2) = 0, &amp;t2 = 0x7ffec502f4d7</span></span><br><span class="line"><span class="comment">  	*/</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GCC 编译器允许空结构体的存在，且大小为 0 ，其他编译器如 vs 则不支持空结构体的存在；</p>
</blockquote>
<h3 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h3><ul>
<li>柔性数组即数组大小待定的数组</li>
<li>C 语言中可以由结构体产生柔性数组</li>
<li>C 语言中结构体的最后一个元素可以是未知大小的数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoftArray</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 此时：</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> SoftArray) = ?</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SoftArray 中的 array 仅是一个待使用的标识符，不占用存储空间；</p>
<p>此时 SoftArray 的大小就是 int len 的大小 4 个字节；</p>
</blockquote>
<p><strong>柔性数组的用法</strong></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust编译期计算</title>
    <url>/Rust/basic/Rust%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="Rust-编译期计算"><a href="#Rust-编译期计算" class="headerlink" title="Rust 编译期计算"></a>Rust 编译期计算</h2><p><em>CTFE</em>(compile time function evaluation)：是指在编译阶段由编译器进行的运算，这种运算不占用程序运行时的时间。</p>
<p>两种方式：</p>
<ul>
<li><p>过程宏 + Build脚本(build.rs)</p>
</li>
<li><p>常量表达式求值</p>
<ul>
<li>常量函数(const fn)</li>
<li>常量泛型(const generic)</li>
</ul>
</li>
</ul>
<p><strong>常量传播</strong>：常量传播是编译器的一种优化方式，例如将3 + 4 优化为 7 ，避免运行时再次计算。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> X: <span class="type">u32</span> = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// CTEF</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 不是 CTEF,但可能会被常量传播优化，因为他不在常量上下文。</span></span><br></pre></td></tr></table></figure>

<h3 id="常量表达式求值"><a href="#常量表达式求值" class="headerlink" title="常量表达式求值"></a>常量表达式求值</h3><p><strong>常量函数</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">fib</span>(n: <span class="type">u128</span>) <span class="punctuation">-&gt;</span> <span class="type">u128</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">helper</span>(n: <span class="type">u128</span>, a: <span class="type">u128</span>, b: <span class="type">u128</span>, i: <span class="type">u128</span>) <span class="punctuation">-&gt;</span> <span class="type">u128</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt;= n &#123;</span><br><span class="line">            <span class="title function_ invoke__">helper</span>(n, b, a + b, i + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">helper</span>(n, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> X: <span class="type">u128</span> = <span class="title function_ invoke__">filb</span>(<span class="number">10</span>); <span class="comment">// X 会在编译器完成求值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, X); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译期计算通过 MIR(中级中间语言) 中内置的 MIri(编译器内置 MIR 解释器) 实现</p>
</blockquote>
<p><strong>常量泛型</strong></p>
<p>为什么要有常量泛型？</p>
<p>因为在 Rust 中定义相同的静态数组是不同的元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二者是不同的类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="number">3</span>; <span class="type">i32</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="number">5</span>; <span class="type">i32</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>为了在使用过程中可以使用泛型统一个的不同长度的数组，官方引入了常量泛型的概念。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::MaybeUninit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ArrayVec</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    items: [MaybeUninit&lt;T&gt;; N],</span><br><span class="line">    length: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过程宏-Build脚本-build-rs"><a href="#过程宏-Build脚本-build-rs" class="headerlink" title="过程宏 + Build脚本(build.rs)"></a>过程宏 + Build脚本(build.rs)</h3>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>环境配置</title>
    <url>/OS/rCore/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h2><h3 id="WSL2配置"><a href="#WSL2配置" class="headerlink" title="WSL2配置"></a>WSL2配置</h3><p><strong>1.勾选适用于Linux的Windows子系统</strong>后<strong>重启</strong></p>
<p>打开“<strong>控制面板</strong>”-&gt;点击”<strong>程序</strong>“-&gt;在“<strong>程序和功能</strong>”中-&gt;点击“<strong>启用或关闭 Windows 功能</strong>”-&gt; 选中“<strong>适用于 Linux 的 Windows 子系统</strong>”-&gt;选择”<strong>立即重新启动</strong>“；</p>
<p><strong>2.启用虚拟机功能</strong></p>
<p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed">虚拟化功能</a>才能使用此功能。</p>
<p>以管理员身份打开 PowerShell 并运行：</p>
<p><strong>点击“开始”-&gt;搜索“Power shell”-&gt;右键“Power shell”-&gt;已管理员方式运行</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>此处最好重启一下不然后续启动arch Linux时会报错<strong>error: 0x8004032d(null)</strong></p>
<blockquote>
<p>如何没有安装 PowerShell 建议直接从 Microsoft Store 中搜索并下载</p>
</blockquote>
<p><strong>3.下载Linux内核更新包</strong></p>
<p>从<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">官网</a>下载最新的Linux内核更新包并<strong>安装</strong>；</p>
<p><strong>管理员</strong>身份打开PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl.exe <span class="literal">--update</span></span><br><span class="line">正在检查更新。</span><br><span class="line">已安装最新版本的适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure>

<p>这里如果安装进度一直为0.0%可以试下开启科学上网；</p>
<p><strong>4.将WSL2设置为默认版本</strong></p>
<p>打开 PowerShell运行以下命令，将 WSL 2 设置为默认版本：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">有关与 WSL <span class="number">2</span> 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">操作成功完成。</span><br></pre></td></tr></table></figure>

<p><strong>5.安装所选的Linux分发</strong></p>
<p>打开 <a href="https://aka.ms/wslstore">Microsoft Store</a>，并选择你偏好的 Linux 分发版。（我这里使用的是arch Linux）</p>
<p>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。</p>
<p>然后，需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">为新的 Linux 分发版创建用户帐户和密码</a>。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Installing,this may take a few minutes...</span><br><span class="line">Iainstallation successful!</span><br><span class="line">Please create a default UNIX user account, The username does not needor to match your windows username.</span><br><span class="line"><span class="keyword">For</span> more information visit: https://aka.ms/wslusers</span><br><span class="line">Enter new UNIX username:</span><br></pre></td></tr></table></figure>

<p>这里要关掉科学上网，不然<strong>Microsoft Store</strong>可能会打不开；</p>
<p><strong>6.查看当前环境的wsl版本和对应子系统</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 在Windows终端中键入</span><br><span class="line">&gt; wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line">  NAME    STATE           VERSION</span><br><span class="line">* Arch    Running         <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>7.注销安装的Linux子系统账户</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--unregister</span> Arch</span><br></pre></td></tr></table></figure>

<p>（名称要与wsl -l -v 命令中NAME一致）</p>
<p><strong>8.删除安装的Linux子系统</strong></p>
<p>系统 -&gt; 应用 -&gt; 安装的应用 删除Arch WSL。</p>
<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu // 防止软件库更新导致某些功能无法使用</span><br><span class="line">sudo pacman -S neovim</span><br><span class="line">sudo nvim /etc/pacman.conf 尾部添加</span><br><span class="line"></span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Never</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/$repo/$arch</span><br><span class="line"></span><br><span class="line">顺便开启</span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line">sudo pacman -Syyu</span><br><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure>

<h3 id="C-Rust环境配置"><a href="#C-Rust环境配置" class="headerlink" title="C&#x2F;Rust环境配置"></a>C&#x2F;Rust环境配置</h3><p><strong>1.更新&#x2F;同步arch Linux内核</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>

<p><strong>这里cmd中需要管理员模式启动</strong>（WSL2中不要开梯子）</p>
<p><strong>2.C开发环境配置</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo pacman -S git base-devel riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full riscv64-elf-gdb</span><br></pre></td></tr></table></figure>

<p><strong>3.Rust开发环境配置</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.<span class="number">2</span> -sSf https:<span class="comment">//sh.rustup.rs | sh</span></span><br></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo --version // 如果cargo无效则重新打开终端进入Linux即可</span></span><br><span class="line">cargo 1.77.1 (e52e36006 2024-03-26)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.77.1 (7cf61ebde 2024-03-27)</span><br></pre></td></tr></table></figure>

<p>切换 nightly 版本，并设置为 rustc 的缺省版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup install nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup default nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br></pre></td></tr></table></figure>

<p>安装一些Rust相关的软件包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install cargo-binutils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add llvm-tools-preview</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add rust-src</span></span><br></pre></td></tr></table></figure>

<h3 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h3><p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qemu</span><br></pre></td></tr></table></figure>

<p>三个选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)qemu-base   2)qemu-desktop   3)qemu-full</span><br></pre></td></tr></table></figure>

<p>第一个提示中提示中选择<code>3</code>，第二个提示默认<code>1</code>即可。</p>
<p><strong>确认 QEMU 的版本：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 --version</span></span><br><span class="line">qemu-riscv64 version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>获取代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rCore-Tutorial-v3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ch1</span></span><br></pre></td></tr></table></figure>

<p>在Qemu模拟的计算机上运行: （第一次可能会有些很慢）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LOG=TRACE make run</span></span><br><span class="line"></span><br><span class="line">(rustup target list | grep &quot;riscv64gc-unknown-none-elf (installed)&quot;) || rustup target add riscv64gc-unknown-none-elf</span><br><span class="line">riscv64gc-unknown-none-elf (installed)</span><br><span class="line">cargo install cargo-binutils</span><br><span class="line">    Updating crates.io index</span><br><span class="line">     Ignored package `cargo-binutils v0.3.6` is already installed, use --force to override</span><br><span class="line">rustup component add rust-src</span><br><span class="line">info: component &#x27;rust-src&#x27; is up to date</span><br><span class="line">rustup component add llvm-tools-preview</span><br><span class="line">info: component &#x27;llvm-tools&#x27; for target &#x27;x86_64-unknown-linux-gnu&#x27; is up to date</span><br><span class="line">Platform: qemu</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) in 0.00s</span><br><span class="line">[rustsbi] RustSBI version 0.3.1, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e010f6</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">[kernel] Hello, world!</span><br><span class="line">[TRACE] [kernel] .text [0x80200000, 0x80202000)</span><br><span class="line">[DEBUG] [kernel] .rodata [0x80202000, 0x80203000)</span><br><span class="line">[ INFO] [kernel] .data [0x80203000, 0x80204000)</span><br><span class="line">[ WARN] [kernel] boot_stack top=bottom=0x80214000, lower_bound=0x80204000</span><br><span class="line">[ERROR] [kernel] .bss [0x80214000, 0x80215000)</span><br></pre></td></tr></table></figure>

<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>1.当你在wsl2环境下运行<code>code</code>命令时报错<code>-bash: code: command not found</code>时：</p>
<ul>
<li>在vscode中安装<code>Remote Development</code>扩展包。</li>
<li>设置Windows下环境变量<code>D:\tools\IDE\VSCode\VSCode\bin</code>(一定要到bin下)</li>
</ul>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><h3 id="C-Rust环境配置-1"><a href="#C-Rust环境配置-1" class="headerlink" title="C&#x2F;Rust环境配置"></a>C&#x2F;Rust环境配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// C开发环境</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span></span><br><span class="line"></span><br><span class="line">// Rust开发环境</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://sh.rustup.rs -sSf | sh</span></span><br><span class="line"></span><br><span class="line">// 安装 rustc 的 nightly 版本，并把该版本设置为 rustc 的缺省版本。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup install nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup default nightly</span></span><br><span class="line"></span><br><span class="line">// 安装一些Rust相关的软件包</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install cargo-binutils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add llvm-tools-preview</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add rust-src</span></span><br></pre></td></tr></table></figure>

<h3 id="QEMU模拟器"><a href="#QEMU模拟器" class="headerlink" title="QEMU模拟器"></a>QEMU模拟器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装编译所需的依赖包</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span></span><br><span class="line"><span class="language-bash">              gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span></span><br><span class="line"><span class="language-bash">              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev libslirp-dev \</span></span><br><span class="line"><span class="language-bash">              git tmux python3 python3-pip ninja-build</span></span><br><span class="line">              </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Qemu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install qemu-system</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install qemu-user</span></span><br></pre></td></tr></table></figure>

<h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rCore-Tutorial-v3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ch1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LOG=TRACE make run</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust编译过程</title>
    <url>/Rust/basic/Rust%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Rust 编译过程</strong></p>
<p><img src="/public/image/Rust/basic/rust-complie-process.png" alt="rust-complie-process"></p>
<p>直接使用源代码非常不方便且容易出错。因此在我们做任何其他事情之前，我们将原始源代码转换为 AST。即使这样做也涉及大量工作，包括词法分析、解析、 宏扩展、名称解析、条件编译、功能门控 AST的检查和验证。</p>
<p>值得注意的是，这些任务之间并不总是有明确的顺序。例如，宏扩展依赖于名称解析来解析宏和 imports。解析需要宏扩展，而这反过来又可能需要分析宏的输出。</p>
<p><strong>步骤说明</strong>：</p>
<ol>
<li><p>Rust 源码(Unicode字符)作为 <em>UTF-8</em> 编码序列输入到编译器，编译器的 Lexing 会获取字符编码并将他们转换为<code>token Steam</code>，然后解析 token Stream 将它们转换为结构化的编译器更容易使用的表单，通常称为<code>抽象语法树</code>(AST)  。</p>
<p>请注意，在解析为 AST 时 ，Rust编译器会对其进行<em>词法分析</em>包括但不限于宏扩展、名称解析、#[test]实现、panic实现、AST验证、Feature 检查、检索 Lang 项目等。</p>
</li>
<li><p>AST 降低到  <em>HIR</em>(高级中间表示) </p>
<p>HIR 是抽象语法树 (AST) 对编译器更友好的表示形式，很多 Rust 语法糖在这一阶段，已经被脱糖（desugared）处理。比如 <code>for</code> 循环和<code>while(let)</code>在这个阶段会被转为<code>loop</code>，<code>if let</code> 被转为<code>match</code>，普遍<code>impl Trait</code>转换为泛型参数，存在<code>impl Trait</code>转换为虚拟声明<code>existential type</code>等等。</p>
<p>对于编译器来说，所有的版次也就是Edition版本，在到达中间语言层次的时候已经消除了版次差异。</p>
</li>
<li><p>HIR 降低到 <em>THIR</em>(类型化高级中间表示)</p>
<p>THIR 是 rustc 在类型检查后生成的另一种IR，它用于MIR建设、详尽性检查和不安全检查。是一个在在 HIR 的基础上进一步添加了类型信息的版本。</p>
</li>
<li><p>THIR 降级为 <em>MIR</em>(中级中间表示)</p>
<p>它是 Rust 的一种彻底简化的形式，用于 某些对流量敏感的安全检查——特别是借用检查器！– 也用于优化和代码生成。</p>
</li>
</ol>
<blockquote>
<p>Rust 源码(Unicode字符)作为 <em>UTF-8</em> 编码序列输入到编译器，通过分词把词法结构处理为词条流，词条流经过语法解析形成<code>抽象语法树</code>，抽象语法树降级（简化）为<code>高级中间语言</code>（<em>HIR</em>），高级中间语言被用于编译器对代码进行类型检查方法查找等工作，高级中间语言继续降级（简化）为<code>中级中间语言</code>（<em>MIR</em>），中级中间语言被用于借用检查、优化、代码生成（宏、泛型、单态化）等工作，中级中间语言（MIR）优化为<code>LLVM中间语言</code>，最后交给LLVM编译器生成机器码。</p>
</blockquote>
<p><a href="https://rustc-dev-guide.rust-lang.org/the-parser.html">Rust 编译器开发指南</a></p>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rustc_part1.html">Rust编译器专题 | 图解 Rust 编译器与语言设计 Part 1 - Rust精选</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>crate与模块</title>
    <url>/Rust/basic/crate%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="crate与模块"><a href="#crate与模块" class="headerlink" title="crate与模块"></a>crate与模块</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode中的Rust配置</title>
    <url>/Rust/basic/vscode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装必要插件"><a href="#安装必要插件" class="headerlink" title="安装必要插件"></a>安装必要插件</h1><ul>
<li>rust-analyzer ：Rust 插件</li>
<li>Dependi ：crate 相关插件</li>
<li>Even Better TOML ：TOML 语法高亮</li>
</ul>
<h1 id="一些非必要但是好用的-crate"><a href="#一些非必要但是好用的-crate" class="headerlink" title="一些非必要但是好用的 crate"></a>一些非必要但是好用的 crate</h1><ul>
<li>cargo-edit: 该工具扩展了Cargo，允许您通过从命令行修改Cargo.toml文件来添加、删除和升级依赖项。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">任意目录下</span></span><br><span class="line">cargo install cargo-edit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>定义自己的Crate</title>
    <url>/Rust/basic/%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84Crate/</url>
    <content><![CDATA[<h1 id="创建自己的-Crate"><a href="#创建自己的-Crate" class="headerlink" title="创建自己的 Crate"></a>创建自己的 Crate</h1><p>安装<code>cargo-edit</code>工具，他扩展了<code>cargo</code>的功能</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目根目录下下</span></span><br><span class="line"></span><br><span class="line">cargo install cargo<span class="literal">-edit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>cargo add toml：将最新的<code>toml</code> Crate安装到当前项目中，并自动写入当前目录下的<code>Cargo.toml</code>文件中。</li>
</ul>
<h1 id="代码重构实践"><a href="#代码重构实践" class="headerlink" title="代码重构实践"></a>代码重构实践</h1><h1 id="探索引入模块的最佳实践"><a href="#探索引入模块的最佳实践" class="headerlink" title="探索引入模块的最佳实践"></a>探索引入模块的最佳实践</h1>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和闭包</title>
    <url>/Rust/basic/%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="常规函数"><a href="#常规函数" class="headerlink" title="常规函数"></a>常规函数</h2><p><strong>特点</strong></p>
<ul>
<li>函数都拥有显示的类型签名；</li>
<li>函数可分为三种类型：<strong>自由函数</strong>、<strong>关联函数</strong>和<strong>方法</strong>；</li>
<li>函数自身也是一种类型(<strong>函数项类型</strong>)</li>
</ul>
<p><strong>自由函数</strong></p>
<p>最普通的函数，他的参数、返回值等都一目了然。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自由函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关联函数 &#x2F; 方法</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    	a + b</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">A</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, A::<span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, a.<span class="title function_ invoke__">math</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数项类型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> (<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="comment">// 此处存在一个自动解引用 Self::sum((*self).0, (*self).1) </span></span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">A</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// add 是 函数项类型 也就是函数自己本身的类型(Fn item 类型)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span> = A::sum; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_math</span> = A::math; <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>), A::<span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add_math</span>(&amp;a),a.<span class="title function_ invoke__">math</span>());</span><br><span class="line">    <span class="comment">// 大小为 0 函数项类型是零大小类型(指那些没有占用任何内存空间的类型)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add)); <span class="comment">// 大小为 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add_math)); <span class="comment">// 大小为 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;A)); <span class="comment">// 大小为 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;a)); <span class="comment">// 大小为 8 (4（i32）+ 4（i32）= 8)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数指针类型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 函数指针类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>)); <span class="comment">// (1, 1, 1)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;c)); <span class="comment">// 大小为 8 函数指针类型  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数指针类型  </span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">rgb</span>: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB;  </span><br><span class="line">    <span class="comment">// 将函数项赋值给函数指针  </span></span><br><span class="line">	rgb = color; </span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rgb: &#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;rgb)); <span class="comment">// 函数项大小为 0 函数项是零大小类型  </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结论：</strong></p>
<ul>
<li>函数项类型可以通过显式指定函数类型转换为一个函数指针类型；</li>
<li>在写代码的时候，尽可能地去使用 <em>函数项类型</em>，不到万不得已不要使用函数指针类型，这样有助于享受零大小类型的优化；</li>
</ul>
</blockquote>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>函数无法捕获环境变量，这时就需要使用闭包。</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">inc</span>(n: <span class="type">i32</span>)<span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">		n+i <span class="comment">//error[E0434]: can&#x27;t capture dynamic environment in a fn item</span></span><br><span class="line">    &#125;</span><br><span class="line">	inc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">assert_eq!</span>(<span class="number">3</span>，<span class="title function_ invoke__">f</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包与函数的异同"><a href="#闭包与函数的异同" class="headerlink" title="闭包与函数的异同"></a>闭包与函数的异同</h2><p><strong>闭包可以捕获环境中的自由变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> | n | n + i <span class="comment">// move 关键字将环境变量 i 的所有权移动到闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包可以与函数指针互通</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span> = color;</span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb); <span class="comment">// (1, 1, 1)</span></span><br><span class="line">    <span class="comment">// 定义了实现`Fn(&amp;str) -&gt; RGB`trait 的闭包类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = | s: &amp;<span class="type">str</span> | &#123; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#125;; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(c); <span class="comment">// (1, 2, 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rust闭包的实现原理"><a href="#Rust闭包的实现原理" class="headerlink" title="Rust闭包的实现原理"></a>Rust闭包的实现原理</h2><p>rust中的闭包并没有引入特殊的语法，而是一种编译器的语法糖。</p>
<h3 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h3><ol>
<li>未捕获环境变量(所有权)</li>
<li>捕获但修改环境变量(可变引用)</li>
<li>捕获但未修改环境变量(不可变引用)</li>
</ol>
<p><strong>未捕获环境变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 未捕获环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">c1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    env_var: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库中 FnOnce trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		type Output;</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">FnOnce</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Closure &#123; env_var: ()&#125;; <span class="comment">// 闭包未捕获任何变量用()来表示</span></span><br><span class="line">    c.<span class="title function_ invoke__">call_once</span>(()); <span class="comment">// c 这个结构体示例就会被消耗掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你创建闭包的时候，编译器会解析你的闭包，然后生成一个匿名结构体<code>Closure</code>，其中的字段<code>env_var</code>用于存储捕获的自由变量；在上面的场景中闭包未捕获任何变量,所以<code>main</code>函数中创建<code>Closure</code>的字段值用<code>()</code>来表示；</p>
<p>接下来在为这个匿名的结构体<code>Closure</code>实现<code>FnOnce&lt;()&gt;</code>这个trait；其中<code>Arges</code>这个参数是闭包自身的参数，即闭包调用时传入的参数；</p>
<p>当闭包被调用的时候等价于调用匿名结构体实现的<code>call_once</code>这个方法；该方法会消耗掉该结构体的实例；</p>
</blockquote>
<p>编译器将<code>FnOnce</code>类型的闭包看成是函数指针</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || &#123; <span class="string">&quot;c1&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = || &#123; <span class="string">&quot;c2&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2]; <span class="comment">// Ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="string">&quot;c3&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || &#123; i &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2, c3] <span class="comment">// Error  expected fn pointer, found closure 他把c1, c2当成了函数指针，c3当成了闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>捕获可修改环境变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 可修改环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c2</span> = | i | &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">c2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    env_var: [<span class="type">i32</span>, <span class="number">3</span>],  <span class="comment">// 捕获的环境变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 至少需要一个能消耗自身的一个方法，用于在多次调用之间保持并修改状态。</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnOnce</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库中 FnMut trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		// type Output; 因为 FnMut 实现自 FnOnce 所以此处不需要再重复定义了</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnMut</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">            <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Closuse &#123; env_var: arr &#125;;</span><br><span class="line">    <span class="comment">// c.call_once((0, )); 同样这里也会消耗 c</span></span><br><span class="line">    c.<span class="title function_ invoke__">call_mut</span>((<span class="number">0</span>, )); <span class="comment">// 这里会修改 c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处根据<code>rust-call</code>的约定 <code>args</code>的参数类型必须是元组类型，这是<code>Rust API</code>的约定；</p>
<p>当闭包被调用的时候等价于调用匿名结构体实现的<code>call_mut</code>这个方法；该方法会修改该结构体的实例；</p>
</blockquote>
<p><strong>捕获但未修改环境变量</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">anwser</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            anwser</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">c3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    env_var: <span class="type">i32</span>,  <span class="comment">// 捕获的环境变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 至少需要一个能消耗自身的一个方法，用于在多次调用之间保持并修改状态。</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnOnce</span>&lt;( )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.env_var</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnMut</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.env_var</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库中 Fn trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fn</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">        	<span class="string">&quot;The answer to the Ultimate Question of Life, The Universe, and Everything is &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.env_var</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">anwser</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Closure &#123;env_var: anwser&#125;;</span><br><span class="line">    <span class="comment">//c.call_once((0, )); </span></span><br><span class="line">    <span class="comment">//c.call_mut((0, ));</span></span><br><span class="line">    c.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出要实现<code>Fn</code>必须先实现<code>FnMut</code>，要实现<code>FnMut</code>必须先实现<code>FnOnce</code>；</p>
</blockquote>
<h3 id="实现总结"><a href="#实现总结" class="headerlink" title="实现总结"></a>实现总结</h3><p><strong>这里指的是编译器生成的默认结构体</strong></p>
<ul>
<li>如果没有捕获任何变量，则实现<code>FnOnce</code></li>
<li>如果有捕获变量，且对捕获变量进行了修改，则实现<code>FnMut</code></li>
<li>如果有捕获变量，但未对变量进行修改，则实现<code>Fn</code></li>
</ul>
<p><strong>两条特殊情况</strong></p>
<ul>
<li>编译器会将<code>FnOnce</code>当成<code>fn(T)</code>函数指针去看待。</li>
<li><code>Fn</code>&#x2F;<code>FnMut</code>&#x2F;<code>FnOnce</code>这三者t<code>rait</code>的关系是依次继承，他们正好对应<em>所有权语义三件套</em>。</li>
<li><code>Fn()</code>是<code>FnMut()</code>的子特型，而<code>FnMut()</code>是<code>FnOnce()</code>的子特型，</li>
</ul>
<h2 id="逃逸闭包与非逃逸闭包"><a href="#逃逸闭包与非逃逸闭包" class="headerlink" title="逃逸闭包与非逃逸闭包"></a>逃逸闭包与非逃逸闭包</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span></span><br><span class="line"><span class="comment">// 此处 impl FnMut(i32) -&gt; [i32; 3] 称为 impl trait</span></span><br><span class="line"><span class="comment">// 语法表示 任意一个实现了 FnMut(i32) -&gt; [i32; 3] 的类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">c_mut</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> [<span class="type">i32</span>; <span class="number">3</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// i 是 FnMut(i32) 中传入的</span></span><br><span class="line">    <span class="comment">// 闭包会复制一份 arr 到闭包中，arr 实现了 Copy</span></span><br><span class="line">    <span class="comment">// 从而实现将局部变量移出到其他位置</span></span><br><span class="line">    <span class="keyword">move</span> |i| &#123;arr[<span class="number">0</span>] = i; arr&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr_clouse</span> = <span class="title function_ invoke__">c_mut</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, arr_clouse.call_once((i, )));</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">arr_clouse</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回不在函数调用过程中被销毁的闭包称为<strong>逃逸闭包</strong>，否则就是<strong>非逃逸闭包</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">c_mut2</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">for</span>&lt;<span class="symbol">&#x27;a</span>&gt;<span class="title function_ invoke__">FnMut</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">move</span> |i| &#123;s += i; s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mut</span> = arr_clouse = <span class="title function_ invoke__">c_mut2</span>(); <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处，<code>s</code>是一个动态大小的类型，当<code>move</code>移动时，移动的是指向推上的指针；根据<code>Rust</code>内存管理机制，<code>s</code>销毁后,他所指向的堆上的数据也会被销毁掉，这是<code>move</code>中的<code>s</code>就变成了<em>悬垂指针</em>，这是<code>rust</code>所不允许的。</p>
<h2 id="唯一不可变引用"><a href="#唯一不可变引用" class="headerlink" title="唯一不可变引用"></a>唯一不可变引用</h2><p>捕获方式中有一种被称为<em>唯一不可变借用</em>的特殊类型的借用捕获，这种借用不能在语言的其他任何地方使用，也不能显式地写出。唯一不可变借用发生在<strong>修改可变引用的引用对象(referent)时</strong>，如下面的示例所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里 x 是不可变借用</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = || &#123;(*x)[<span class="number">0</span>] = <span class="number">0</span>;&#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// Error</span></span><br><span class="line">        <span class="title function_ invoke__">c</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = &amp;x; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，不能去可变借用 <code>x</code>，因为 <code>x</code> 没有标注 <code>mut</code>。但与此同时，如果不可变借用 <code>x</code>，那对其赋值又会非法，因为 <code>&amp; &amp;mut</code> 引用可能不是唯一的，因此此引用不能安全地用于修改值。所以这里闭包使用了唯一不可变借用：它采用了不可变的方式借用了 <code>x</code>，但是又像可变借用一样，当然前提是此借用必须是唯一的。在上面的例子中，解开 <code>y</code> 那行上的注释将产生错误，因为这将违反闭包对 <code>x</code> 的借用的唯一性；<code>z</code> 的声明是有效的，因为闭包的生存期在块结束时已过期，从而已经释放了对 <code>x</code> 的借用。</p>
<h2 id="闭包自身所实现的trait"><a href="#闭包自身所实现的trait" class="headerlink" title="闭包自身所实现的trait"></a>闭包自身所实现的trait</h2><ul>
<li>Sized（默认实现）</li>
<li>Copy &#x2F; Clone（取决于环境变量是否实现）<ul>
<li>如果环境变量实现了 Copy &#x2F; Clone，闭包如果以<strong>可变借用方式</strong>捕获环境变量，并对其进行修改，则闭包自身不会实现 Copy &#x2F; Clone;（防止出现多个闭包的可变借用）</li>
<li>如果环境自身是 Move 语义，则闭包内捕获环境变量的操作涉及<strong>修改环境变量或者消耗环境变量</strong>，则闭包自身不会实现 Copy &#x2F; Clone；（防止出现多个闭包的可变借用）</li>
</ul>
</li>
<li>Sync &#x2F; Send<ul>
<li>如果所有捕获变量均实现了 Sync,则闭包实现 Sync;</li>
<li>如果环境变量都不是[唯一不可变引用]方式捕获的，并且都实现了 Sync,则闭包实现 Send;</li>
<li>如果环境变量是以[唯一不可变引用]、[可变引用]、Copy 或 Move 所有权捕获的，那闭包实现 Send;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/Rust/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><strong>基于栈的原因，先定义的后释放</strong></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>trait</title>
    <url>/Rust/basic/trait/</url>
    <content><![CDATA[<h1 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>(<span class="type">i8</span>，<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>=<span class="title function_ invoke__">A</span>(<span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> =a; <span class="comment">// (Bit-wise Copy)按位复制，复制后，b和a完全相同，包括内存对齐填充的padding部分。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>=<span class="title function_ invoke__">A</span>(a.<span class="number">0</span>，a.<span class="number">1</span>); <span class="comment">// 逐成员复制，非按位复制，c和a的padding部分不一定相同。</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>按位复制他们的内存布局是完全相同的，成员复制则不一定相同。</strong></p>
 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u16</span>,</span><br><span class="line">    b: <span class="type">u8</span>,</span><br><span class="line">    c: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">unsound_a</span>();</span><br><span class="line">    <span class="comment">// 尝试将 Some(a) 改为 a 可以发现 Some 本身带有一个检查的效果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_a</span> = <span class="title function_ invoke__">Some</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:#?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;some_a: &#123;:#?&#125;&quot;</span>, some_a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">unsound_a</span>() <span class="punctuation">-&gt;</span> A &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        a: <span class="type">u16</span>,</span><br><span class="line">        b: <span class="type">u8</span>,</span><br><span class="line">        c: <span class="type">u8</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次修改 c 的值为 0，1，2 打印输出结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = B &#123; a: <span class="number">1</span>, b: <span class="number">1</span>, c: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;*(&amp;b <span class="keyword">as</span> *<span class="keyword">const</span> B <span class="keyword">as</span> *<span class="keyword">const</span> A) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// let b = B &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">a: A &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    c: true,</span><br><span class="line">&#125;</span><br><span class="line">some_a: Some(</span><br><span class="line">    A &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 1,</span><br><span class="line">        c: true,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// let b = B &#123; a: 1, b: 1, c: 0 &#125;;</span><br><span class="line">a: A &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    c: false,</span><br><span class="line">&#125;</span><br><span class="line">some_a: Some( </span><br><span class="line">    A &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 1,</span><br><span class="line">        c: false,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// let b = B &#123; a: 1, b: 1, c: 2 &#125;;</span><br><span class="line">a: A &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 1,</span><br><span class="line">    c: true,</span><br><span class="line">&#125;</span><br><span class="line">some_a: Some( // let some_a = Some(a); 输出False; let some_a = a; 输出 None</span><br><span class="line">    A &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 1,</span><br><span class="line">        c: true,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>可以发现 Some 本身带有一个检查的效果</strong></p>
 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::&#123;ptr, mem&#125;;</span><br><span class="line"><span class="keyword">use</span> std::men::needs_drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">d</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cccc&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d_len</span> = d.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="type">String</span>::<span class="title function_ invoke__">with_capacity</span>(d_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// ptr::copy：从原(&amp;d)中copy一份(1 usize)大小的内容到目标区域(&amp;mut c)中</span></span><br><span class="line">            <span class="comment">// 此处 d 是栈上的一个指针</span></span><br><span class="line">            <span class="comment">// 相当于将 d 指向 &quot;cccc&quot; 的地址复制了一份到 c 中</span></span><br><span class="line">            <span class="comment">// 此时就存在了一个双重引用; d 和 c 都指向了&quot;cccc&quot;这块堆内存的区域</span></span><br><span class="line">            ptr::<span class="title function_ invoke__">copy</span>(&amp;d, &amp;<span class="keyword">mut</span> c, <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">        <span class="comment">// unsafe &#123;</span></span><br><span class="line">        <span class="comment">//     assert_eq!(needs_drop::&lt;*mut u8&gt;, false);  //成立</span></span><br><span class="line">        <span class="comment">//     ptr::drop_in_place(c.as_mut_ptr());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 注掉 drop，会产生double free，</span></span><br><span class="line">        <span class="comment">// 但是不注掉 drop，会产生无效指针</span></span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, d.<span class="title function_ invoke__">as_ptr</span>());</span><br><span class="line">    d.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0x5630bd63f9b0</span></span><br><span class="line"><span class="comment">// 0x5630bd63f9b0</span></span><br><span class="line"><span class="comment">// c  </span></span><br><span class="line"><span class="comment">// 之所以输出一个 C 是因为在上面的作用域中 C 在离开作用域时将 d 指向的那部分内存drop掉了。</span></span><br><span class="line"><span class="comment">// 但是因为有 d 这个引用指向&quot;cccc&quot;区域，所以暂时内存不会被清理，但是会被标识为不可用。</span></span><br><span class="line"><span class="comment">// 所以此时给 d 追加一个&quot;c&quot;,d 中的内容应该是,一部分不可用的内容加上&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy 不一定只在栈上进行</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line">        *b.<span class="title function_ invoke__">borrow_mut</span>() = *a.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;    </span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, a) // Error</span></span><br><span class="line">    </span><br><span class="line">    a = <span class="string">&quot;32&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a)  <span class="comment">// 32</span></span><br><span class="line">    <span class="comment">// a 会在此处释放 相当于在此处进行  drop(a)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述可以看出 Move 的本质是 Rust 编译期把这个 a 变量重新进行了一个未初始化的标记，并不是立刻进行 drop，它会将 drop 延后到函数末尾释放</strong></p>
<h1 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h1><p>析构函数时，按照栈先进后出的顺序进行析构，变量按照内存布局进行析构；</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/Rust/basic/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>生命周期</title>
    <url>/Rust/basic/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="late-early-bound"><a href="#late-early-bound" class="headerlink" title="late&#x2F;early bound"></a>late&#x2F;early bound</h1><p>晚限定与早限定</p>
<h2 id="late-bound"><a href="#late-bound" class="headerlink" title="late bound"></a>late bound</h2><p>这也是最普遍的生命周期的理解。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>  = A::&lt;<span class="type">i32</span>&gt;(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ==============================================================</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">the_longest</span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;c</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;c</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123; s1 &#125; <span class="keyword">else</span> &#123; s2&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1_r</span> = &amp;s1;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">the_longest</span>(s1_r, &amp;s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is the longest&quot;</span>, res); <span class="comment">// Rust is the longest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>晚限定，就是对象在被定义的时候，他的泛型类型是没有被限定(为具体类型)的，只有在实际调用的时候才会被限定为是何类型。</p>
<p>在定义<code>the_longest</code>时只是确定了他们生命周期之间的关系；只有在具体的使用的时候，我们才需要判断个生命周期的实例，与上面函数中定义的是否一致。</p>
<p>生命周期参数只是开发与与编译期之间的一种约定，对实际代码的运行不做影响。</p>
<p>这一切是在编译期完成的。</p>
<h2 id="early-bound"><a href="#early-bound" class="headerlink" title="early bound"></a>early bound</h2><p>鸿蒙：</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/Rust/basic/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p><strong>Lazy</strong> 特性</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>伪目标</title>
    <url>/Linux/Make/%E4%BC%AA%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="makefile-中的目标究竟是什么？"><a href="#makefile-中的目标究竟是什么？" class="headerlink" title="makefile 中的目标究竟是什么？"></a>makefile 中的目标究竟是什么？</h2><p>make 被设计的初衷是用于编译和管理 C 语言源代码的，所以目标在默认情况下：</p>
<ul>
<li>make 认为**目标对应着一个文件 **</li>
<li>make 比较<strong>目标文件和依赖文件的新旧关系</strong>，决定是否执行命令</li>
<li>make 以<strong>文件处理</strong>作为第一优先级</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面的代码有何意义：</span></span><br><span class="line"><span class="comment"># hello.out all : func.o main.o</span></span><br><span class="line"><span class="comment"># 	 gcc -o hello.out func.o main.o</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># func.o : func.c</span></span><br><span class="line"><span class="comment"># 	 gcc -o func.o -c func.c</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># main.o : main.c</span></span><br><span class="line"><span class="comment"># 	 gcc -o main.o -c main.c</span></span><br><span class="line">	</span><br><span class="line">clean :</span><br><span class="line">	rm *.o hello.out</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 当前目录不存在名为 clean 的文件时，clean会被作为标签进行使用，执行 rm *.o hello.out 命令；</p>
<p>当前目录下存在名为 clean 的文件时，由于 make 以文件处理作为第一优先级，所以他会去检查 clean 这个命令，这时他会发现 clean 文件(目标)所对应的依赖并没有被修改过(clean没有依赖所以也就无法被修改依赖)，那么 make 就会认为 clean 文件是最新的就会不执行下面的命令，并提示”clean 是最新的。”</p>
</blockquote>
<p>为了解决这个问题(我们要执行 clean 下的命令而不是让 make 将 clean 当成成文件进行处理)，我们就引入了”伪代码”这个概念。</p>
<p><strong>makefile 中的伪目标</strong></p>
<ul>
<li>通过 .PHONY 关键字声明一个伪目标</li>
<li>伪目标不对应任何实际文件</li>
<li>不管伪目标的依赖是否更新，命令总是执行</li>
</ul>
<h2 id="伪目标语法"><a href="#伪目标语法" class="headerlink" title="伪目标语法"></a>伪目标语法</h2><p><strong>先声明，后使用；</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean	# 声明</span></span><br><span class="line"><span class="comment">##注释##</span></span><br><span class="line"><span class="section">clean:	# 使用</span></span><br><span class="line">	rm *.o hello.out	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样处理后即使当前目录下存在 clean 文件，make 也只会将 clean 当作一个标签进行处理，而不是文件；</p>
<p>因为此时 clean 就相当于变成了 .PHONY 文件的依赖，而 .PHONY 这样一个文件其实并不存在，所以 clean 文件的创建时间相比  .PHONY 来说永远是新的；这样 clean 下的命令就肯定会被执行； </p>
</blockquote>
<h2 id="妙用"><a href="#妙用" class="headerlink" title="妙用"></a>妙用</h2><p><strong>规则调用（函数调用）</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean rebuild all	# 声明</span></span><br><span class="line"><span class="comment">## oter rules ##</span></span><br><span class="line"><span class="section">rebuild: clean all</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o hello.out</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样当我们执行 make rebuild 时他就会按照先 clean 再 all 的顺序执行下去；</p>
</blockquote>
<p><strong>技巧</strong></p>
<p>当我们使用的不是 GNU 下的标准 make 程序时，可能不存在 .PHONY 这个关键字，那么该如何实现伪目标的效果呢？</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean: FORCE</span></span><br><span class="line">	rm *.o hello.out</span><br><span class="line"><span class="section">FORCE:</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理：如果一个规则没有命令或者依赖，并且它也不是一个文件名，在执行此规则时，目标(FORCE)总会被认为是最新的</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>默认情况下，make 认为目标对应着一个文件</li>
<li>.PHONY 用于声明一个伪目标，伪目标不对应实际的文件</li>
<li><strong>伪目标的本质是 make 中特殊目标 .PHONY 的依赖</strong></li>
<li>使用伪目标可以模拟”函数调用”</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>make 和 makefile</title>
    <url>/Linux/Make/make%20%E5%92%8C%20makefile/</url>
    <content><![CDATA[<h2 id="make-与-makefile介绍"><a href="#make-与-makefile介绍" class="headerlink" title="make 与 makefile介绍"></a>make 与 makefile介绍</h2><p>make：是一个工具程序，通过读取”makefile”文件以实现自动化构建软件。</p>
<ul>
<li><strong>解析源程序之间的依赖关系</strong></li>
<li>根据依赖关系<strong>自动维护</strong>编译工作</li>
<li>执行宿主操作系统中的各种命令</li>
</ul>
<p><strong>众多编译辅助工具中的王者</strong></p>
<p>makefile：是一个配置文件，一个描述文件。</p>
<ul>
<li><strong>定义一系列规则</strong>来指定源文件编译的先后顺序</li>
<li><strong>拥有特定的语法规则</strong>，支持函数定义和函数调用</li>
<li>能够<strong>直接集成</strong>操作系统中的各种命令</li>
</ul>
<p><strong>二者关系</strong>：makefile 中的描述用于指导 make 程序如何完成工作；make 根据 makefile 中的规则执行命令，最后完成编译输出。</p>
<p><img src="/public/image/Linux/make/erzheguanxi.png" alt="erzheguanxi"></p>
<p>简单示例</p>
<p>make 程序的使用示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 hello 关键字作为目标查找 mf.txt 文件，并执行 hello 处的命令。</span></span><br><span class="line">make -f mf.txt hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录下以 hello 关键字为目标查找 makefile 或 Makefile 文件，并执行 hello 处的命令。</span></span><br><span class="line">make hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录下查找 makefile 或 Makefile 文件中最顶层目标，并执行最顶层目标的命令。</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>小结</p>
<ul>
<li>make 只是一个<strong>特殊功能的</strong>应用程序</li>
<li>make 用于根据指定的目标<strong>执行相应的命令</strong></li>
<li>makefile 用于<strong>定义目标</strong>和实现目标所需的命令</li>
<li>makefile 有特定的语法规则，支持函数定义和调用</li>
</ul>
<h2 id="makefile-的结构"><a href="#makefile-的结构" class="headerlink" title="makefile 的结构"></a>makefile 的结构</h2><p><strong>makefile 的意义</strong></p>
<ul>
<li><p>makefile 用于定义源文件之间的依赖关系</p>
</li>
<li><p>makefile 说明如何编译各个源文件并生成可执行文件</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># makefile语法</span></span><br><span class="line"><span class="comment"># 第一种写法</span></span><br><span class="line"><span class="section">target(目标文件): 文件1 文件2(依赖文件列表); command(命令) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种写法</span></span><br><span class="line"><span class="section">target(目标文件): 文件1 文件2(依赖文件列表) </span></span><br><span class="line">`\t`command</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<p>target 可以包含多个目标</p>
<ul>
<li>使用空格对多个目标进行分割</li>
</ul>
<p>依赖 可以包含多个依赖</p>
<ul>
<li>使用空格对多个依赖进行分割</li>
</ul>
<p>[Tab]键：<code>\t</code></p>
<ul>
<li>每一个命令必须以[Tab]字符开始</li>
<li>[Tab]字符告诉 make 此行是一个命令行</li>
</ul>
<p>续航符: \</p>
<ul>
<li>可以将内容分开写到下一行，提高可读性</li>
</ul>
<p><strong>makefile的依赖示例</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: test</span></span><br><span class="line">	echo <span class="string">&quot;make all&quot;</span></span><br><span class="line"><span class="section">test: </span></span><br><span class="line">	echo <span class="string">&quot;make test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： 可使用 @ 进行无回写设置</span></span><br><span class="line"><span class="comment"># echo &quot;make test&quot;</span></span><br><span class="line"><span class="comment"># make test</span></span><br><span class="line"><span class="comment"># echo &quot;make all&quot;</span></span><br><span class="line"><span class="comment"># make all</span></span><br></pre></td></tr></table></figure>

<p>依赖规则</p>
<ul>
<li>当<strong>目标对应的文件不存在时</strong>，执行对应命令</li>
<li><strong>当依赖在时间上比目标更新时</strong>，执行对应命令(要理解下)</li>
<li><strong>当依赖关系连续发生时</strong>，对比依赖链上的每一个目标</li>
</ul>
<p>小技巧</p>
<ul>
<li>makefile 中可以在命令前加上 @ 符，作用为命令无回显。</li>
<li>工程开发中可以将最终可执行文件名和all同时作为 makefile 中第一条规则的目标</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">案例：</span><br><span class="line">hello.out all: main.o func.o</span><br><span class="line">	gcc -o hello.out main.o func.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc -o main.o, -c main.c</span><br><span class="line"><span class="section">func.o: func.c</span></span><br><span class="line">	gcc -o func.o -c func.c</span><br></pre></td></tr></table></figure>

<p>小结</p>
<ul>
<li><p>makefile 用于定义源文件间的<strong>依赖关系</strong></p>
</li>
<li><p>makefile 说明<strong>如何编译各个源文件</strong>并生成可执行文件</p>
</li>
<li><p>makefile 中的目标之间存在<strong>连续依赖关系</strong></p>
</li>
<li><p><strong>依赖存在</strong>并且<strong>命令执行成功</strong>是目标完成的充要条件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类型</title>
    <url>/Rust/basic/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Vec"><a href="#Vec" class="headerlink" title="Vec&lt;T&gt;"></a>Vec&lt;T&gt;</h1><p>动态可增长数组；</p>
<h1 id="VecDeque"><a href="#VecDeque" class="headerlink" title="VecDeque&lt;T&gt;"></a>VecDeque&lt;T&gt;</h1><p>基于环形换冲突的先进先出双端队列；</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList&lt;T&gt;"></a>LinkedList&lt;T&gt;</h1><p>非侵入式双向链表实现；</p>
<h1 id="BinaryHeap"><a href="#BinaryHeap" class="headerlink" title="BinaryHeap&lt;T&gt;"></a>BinaryHeap&lt;T&gt;</h1><p>二叉堆实现，可用作优先队列</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap&lt;K, V&gt;"></a>HashMap&lt;K, V&gt;</h1><h1 id="BTreeMap"><a href="#BTreeMap" class="headerlink" title="BTreeMap&lt;K, V&gt;"></a>BTreeMap&lt;K, V&gt;</h1><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet&lt;T&gt;"></a>HashSet&lt;T&gt;</h1><h1 id="BTreeSet"><a href="#BTreeSet" class="headerlink" title="BTreeSet&lt;T&gt;"></a>BTreeSet&lt;T&gt;</h1>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/Linux/Make/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>makefile 中支持函数的概念</p>
<ul>
<li>make 解释器提供了一系列的函数供 makefile 调用</li>
<li>在 makefile 中支持自定义函数实现，并调用执行</li>
<li>通过 define 关键字实现自定义函数</li>
</ul>
<h2 id="自定义函数语法"><a href="#自定义函数语法" class="headerlink" title="自定义函数语法"></a>自定义函数语法</h2><p><img src="/public/image/Linux/make/zidingyihanshuyufa.png" alt="zidingyihanshuyufa"></p>
<blockquote>
<p>$(0) 表示这个函数的第 0 个参数；即这个函数的名字</p>
<p>$(1) 表示i这个函数的第 1 个参数；即 func2 调用时候，后面跟着的第一个参数</p>
</blockquote>
<p><strong>深入理解自定义函数</strong></p>
<ul>
<li>自定义函数是<strong>一个多行变量</strong>，无法直接调用</li>
<li>自定义函数是<strong>一种过程调用</strong>，没有任何返回值</li>
<li>自定义函数<strong>用于定义命令集合</strong>，并应用于规则中</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func1</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func2</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;Param 1 =&gt; $(1)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;Param 2 =&gt; $(2)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">var := <span class="variable">$(<span class="built_in">call</span> func1)</span></span><br><span class="line">new := <span class="variable">$(func1)</span></span><br><span class="line"></span><br><span class="line">test :</span><br><span class="line">	@echo <span class="string">&quot;new =&gt; <span class="variable">$(new)</span>&quot;</span>	<span class="comment"># new =&gt; @echo &quot;My name is&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span>	<span class="comment"># var =&gt; @echo &quot;My name is func1&quot;</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func1)</span>  <span class="comment"># My name is func1</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func2, D.T.Software, delphi_tang)</span></span><br><span class="line">	<span class="comment"># My name is func2</span></span><br><span class="line">	<span class="comment"># Param 1 =&gt; D.T.Software</span></span><br><span class="line">	<span class="comment"># Param 2 =&gt; delphi_tang</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么 new &#x3D;&gt; @echo “My name is、var &#x3D;&gt; @echo “My name is func1？</p>
<p>是因为define 关键字是用来定义多行变量的，只不过 call 关键字将它(func1、func2)当作了一个自定义函数进行使用；当这个使用不在规则中的时候，make 解释器就将他当成了一个变量来进行使用，所以输出的是命令的内容；</p>
<p>而为什么 var 多了一个 func1 呢？是因为 call 关键字将实参替换到函数体当中对应的位置；</p>
<p>由上述执行结果可以看出</p>
<p>define 关键字是用来定义多行变量的，只不过在 call 关键字的作用下被当作了一个自定义函数进行使用；只不过这个使用是有限制的，只有在规则中才可以进行使用。</p>
</blockquote>
<h2 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h2><p><strong>make 解释器中的预定义函数</strong></p>
<ul>
<li>make 的函数提供了<strong>处理文件名，变量和命令</strong>的函数</li>
<li>可以在需要的地方<strong>调用函数来处理指定的参数</strong></li>
<li>函数在<strong>调用的地方被替换为处理结果</strong></li>
</ul>
<p><strong>预定义函数的调用</strong></p>
<p><img src="/public/image/Linux/make/yudingyihanshudiaoyong.png" alt="yudingyihanshudiaoyong"></p>
<p><strong>为什么自定义函数与预定义函数的调用形式完全不同？</strong></p>
<ul>
<li>makefile 中<strong>不支持</strong>真正意义上的自定义函数，自定义函数的<strong>本质是多行变量</strong></li>
<li>预定义的 call 函数在调用时将参数传递给多行变量</li>
<li>自定义函数是 call 函数的实参，并在 call 中被执行</li>
</ul>
<blockquote>
<p>call 函数就是将参数传递给多行变量，是用来处理参数值的；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func1</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">func2 := @echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func1)</span></span><br><span class="line">	<span class="variable">$(<span class="built_in">call</span> func2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># My name is func1</span></span><br><span class="line"><span class="comment"># My name is </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>func1 是个多行变量，使用时 call 将参数传递给了多行变量；</p>
<p>func2 是个普通变量，call 无法处理普通变量，所以这里 $(0) 是空值；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func1</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> func2</span><br><span class="line">	@echo <span class="string">&quot;My name is $(0)&quot;</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line">var1 := <span class="variable">$(<span class="built_in">call</span> func1)</span></span><br><span class="line">var2 := <span class="variable">$(<span class="built_in">call</span> func2)</span></span><br><span class="line">var3 := <span class="variable">$(<span class="built_in">abspath</span> ./)</span></span><br><span class="line">var4 := <span class="variable">$(<span class="built_in">abspath</span> tst.app)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;var1 =&gt; <span class="variable">$(var1)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var2 =&gt; <span class="variable">$(var2)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var3 =&gt; <span class="variable">$(var3)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var4 =&gt; <span class="variable">$(var4)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># var1 =&gt; 	@echo &quot;My name is func1&quot; </span></span><br><span class="line"><span class="comment"># var2 =&gt; 	@echo &quot;My name is func2&quot; </span></span><br><span class="line"><span class="comment"># var3 =&gt; /hom/kay</span></span><br><span class="line"><span class="comment"># var4 =&gt; /hom/kay/tst.app</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>make 解释器<strong>提供了一系列的函数</strong>供 makefile 调用</li>
<li>自定义函数是<strong>一个多行变量，无法直接调用</strong></li>
<li>自定义函数用于<strong>定义命令集合</strong>，并应用于规则中</li>
<li>预定义的 call 函数在调用时将参数传递给多行变量</li>
<li><strong>自定义函数是 call 函数的实参</strong>，并在 call 中被执行</li>
</ul>
<h2 id="变量与函数的综合示例"><a href="#变量与函数的综合示例" class="headerlink" title="变量与函数的综合示例"></a>变量与函数的综合示例</h2><p><strong>实战需求</strong></p>
<ul>
<li>自动生成 target 文件夹存放可执行文件</li>
<li>自动生成 objs 文件夹存放编译生成的目标文件（*.o）</li>
<li>支持调试版本的编译选项</li>
<li>考虑代码的扩展性</li>
</ul>
<p><strong>工具原料</strong></p>
<ul>
<li>$(wildcard_pattern)<ul>
<li>获取当前工作目录中满足 _pattern 的文件或者目录列表</li>
</ul>
</li>
<li>$(addprefix _prefix,_names)<ul>
<li>给名字列表 _names 中每一个名字增加前缀 _prefix</li>
</ul>
</li>
</ul>
<p><strong>技巧</strong></p>
<ol>
<li>自动获取当前目录下的源文件列表（函数调用）<ul>
<li>SRCS :&#x3D; $(wildcard *.c)</li>
</ul>
</li>
<li>根据源文件列表生成目标文件列表（文件的值替换）<ul>
<li>OBJS :&#x3D; $(SRCS:.c&#x3D;.o)</li>
</ul>
</li>
<li>对每一个目标文件列表加上路径前缀（函数调用）<ul>
<li>OBJS :&#x3D; $(addprefix path&#x2F;, $(OBJS))</li>
</ul>
</li>
</ol>
<p><strong>规则中的模式替换（目录结构）</strong></p>
<p><img src="/public/image/Linux/make/guizezhongdemoshitihuan.png" alt="guizezhongdemoshitihuan"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>变量</title>
    <url>/Linux/Make/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>makefile 中支持程序设计语言中的<strong>变量的概念</strong></li>
<li>makefile 中的变量<strong>只代表文本数据</strong>(字符串)</li>
<li>makefile 中的变量名规则：<ul>
<li>变量名可以包含字符，数字，下划线</li>
<li>不能包含 “:”, “#”, “&#x3D;”, 或 “ “</li>
<li>变量名大小写敏感</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以 makefile 中的变量不需要声明类型；</p>
<p>在 makefile 中使用变量前可以不去定义它，但是这样将会得到一个空值</p>
</blockquote>
<h3 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h3><p><img src="/public/image/Linux/make/bianliangshiyong.png" alt="bianliangshiyong"></p>
<h3 id="makefile-中变量的赋值方式"><a href="#makefile-中变量的赋值方式" class="headerlink" title="makefile 中变量的赋值方式"></a>makefile 中变量的赋值方式</h3><ul>
<li>简单赋值（:&#x3D;）</li>
<li>递归赋值（&#x3D;）</li>
<li>条件赋值（?&#x3D;）</li>
<li>追加赋值（+&#x3D;）</li>
</ul>
<p><strong>:&#x3D; 简单赋值</strong></p>
<p><strong>只对当前语句的变量有效</strong></p>
<p><img src="/public/image/Linux/make/jiandanfuzhi.png" alt="jiandanfuzhi"></p>
<p><strong>&#x3D; 递归赋值</strong></p>
<p><strong>赋值可能影响多个其他变量</strong></p>
<p><strong>所有与目标变量相关的其他变量都将受到影响</strong></p>
<p><img src="/public/image/Linux/make/diguifuzhi.png" alt="diguifuzhi"></p>
<p><strong>?&#x3D; 条件赋值</strong></p>
<p><strong>如果变量未定义，使用赋值符号中的值定义变量</strong></p>
<p><strong>如果变量已经定义，则赋值无效</strong></p>
<p><img src="/public/image/Linux/make/tiaojianfuzhi.png" alt="tiaojianfuzhi.png"></p>
<p><strong>+&#x3D; 追加赋值</strong></p>
<p><strong>原变量值后加上一个新值</strong></p>
<p>原变量值与新值之间由<strong>空格</strong>隔开</p>
<p><img src="/public/image/Linux/make/zhuijiafuzhi.png" alt="zhuijiafuzhi.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>makefile 中支持变量的定义和使用</p>
<p>makefile 中存在四种变量的赋值方式</p>
<ul>
<li>简单赋值（:&#x3D;）</li>
<li>递归赋值（&#x3D;）</li>
<li>条件赋值（?&#x3D;）</li>
<li>追加赋值（+&#x3D;）</li>
</ul>
<h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><ul>
<li><strong>自动变量</strong><ul>
<li>$@，$^，$&lt;</li>
</ul>
</li>
<li><strong>特殊变量</strong><ul>
<li>$(MAKE)， $(MAKECMDGOALS)， $(MAKEFILE_LIST)</li>
<li>$(MAKE_VERSION)，$(CURDIR)，$(.VARIABLES)</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul>
<li><p>$@</p>
<ul>
<li>当前规则中，触发命令被执行的<strong>目标</strong>(即当前规则中的目标);</li>
</ul>
</li>
<li><p>$^</p>
<ul>
<li>当前规则(目标)中的<strong>所有依赖</strong></li>
</ul>
</li>
<li><p>$&lt;</p>
<ul>
<li>当前规则中的<strong>第一个依赖</strong></li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all first second third</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: first second third</span></span><br><span class="line">	@echo <span class="string">&quot;\$<span class="variable">$@</span> =&gt; <span class="variable">$@</span>&quot;</span>	<span class="comment"># $@ =&gt; all</span></span><br><span class="line">	@echo <span class="string">&quot;$<span class="variable">$^</span> =&gt; <span class="variable">$^</span>&quot;</span>	<span class="comment"># $^ =&gt; first second third</span></span><br><span class="line">	@echo <span class="string">&quot;$<span class="variable">$&lt;</span> =&gt; <span class="variable">$&lt;</span>&quot;</span>	<span class="comment"># $&lt; =&gt; first</span></span><br><span class="line"><span class="section">first:</span></span><br><span class="line"><span class="section">second:</span></span><br><span class="line"><span class="section">third:</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>“$” 对于 makefile 有特殊含义，输出 “$” 时需要加上一个 “$” 进行转义；</p>
<p>“$@” 对于 Bash shell 有特殊的含义，输出时需要加上 “\“ 进行转义； </p>
</blockquote>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><ul>
<li>$(MAKE)<ul>
<li>当前 make 解释器的文件名</li>
</ul>
</li>
<li>$(MAKECMDGOALS)<ul>
<li>命令行中指定的目标名(make 的命令行参数)</li>
</ul>
</li>
<li>$(MAKEFILE_LIST)<ul>
<li>make 所需要处理的 makefile 文件列表</li>
<li>当前 makefile 的文件名总是位于列表的最后</li>
<li>文件名之间以空格进行分隔</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all first second third</span></span><br><span class="line"></span><br><span class="line">all out: first second third		<span class="comment"># 执行 make</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(AMKE)</span>&quot;</span>				<span class="comment"># make</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span>		<span class="comment"># </span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(MAKEFILE_LIST)</span>&quot;</span>	<span class="comment">#  makefile (前面有个空格)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>$(MAKE_VERSION)<ul>
<li>当前 make 解释器的版本</li>
</ul>
</li>
<li>$(CURDIR)<ul>
<li>当前 make 解释器的工作目录</li>
</ul>
</li>
<li>$(.VARIABLES)<ul>
<li>所有已经定义的变量名列表(预定义变量和自定义变量)</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test1 test2</span></span><br><span class="line"></span><br><span class="line"><span class="section">test1: 						# 执行 make</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(AMKE_VERSION)</span>&quot;</span>	<span class="comment"># 3.81</span></span><br><span class="line">	@echo <span class="string">&quot;<span class="variable">$(CURDIR)</span>&quot;</span>		<span class="comment"># /home/kay</span></span><br><span class="line">	@echo <span class="string">&quot;$(.VSRLABLES)&quot;</span>	<span class="comment">#  (...太多了)</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>maekefile 提供了预定义变量供开发者使用</li>
<li>预定义变量的使用能够使得 makefile 的开发更高效</li>
<li>自动变量是 makefile 中最常见的元素</li>
<li>使用 $(.VSRLABLES) 能够获取所有的特殊变量</li>
</ul>
<h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><h3 id="变量值的替换"><a href="#变量值的替换" class="headerlink" title="变量值的替换"></a>变量值的替换</h3><ul>
<li>使用指定字符（串）替换变量值中的后缀字符（串）</li>
<li>语法格式：$(var:a&#x3D;b) 或 ${var:a&#x3D;b}<ul>
<li>替换表达式中不能有任何的空格</li>
<li>make 中支持使用${}对变量进行取值</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">src:= a.cc b.cc c.cc	<span class="comment"># 可以理解为编译语言中的字符串类型 &quot;a.cc b.cc c.cc&quot;</span></span><br><span class="line">obj:= $(src:cc=o)	<span class="comment"># 将src中所有的cc替换为o</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;obj =&gt; <span class="variable">$(obj)</span>&quot;</span>	<span class="comment"># a.o b.o c.o</span></span><br></pre></td></tr></table></figure>

<h3 id="变量的模式替换"><a href="#变量的模式替换" class="headerlink" title="变量的模式替换"></a>变量的模式替换</h3><ul>
<li>使用 % 保留变量值中的指定字符，替换其他字符</li>
<li>语法格式：$(var:a%b&#x3D;x%b) 或 ${var:a%b&#x3D;x&amp;b}<ul>
<li>替换表达式中不能有任何的空格</li>
<li>make 中支持使用${}对变量进行取值</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">src:= a1b.c a2b.c a3b.c</span><br><span class="line">obj:= $(src:a%b.c=x%y)	<span class="comment"># 将src中a替换为x，b替换为y，其余的保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;obj =&gt; <span class="variable">$(obj)</span>&quot;</span>	<span class="comment"># x1y x2y x3y</span></span><br></pre></td></tr></table></figure>

<h3 id="规则中的模式替换"><a href="#规则中的模式替换" class="headerlink" title="规则中的模式替换"></a>规则中的模式替换</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="section">target: target-pattern: prereq-patern</span></span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>作用：通过 target-pattern 从 target 中匹配子目标；再通过 prereq-patern 从子目标生成依赖；进而构成完整的规则。</p>
<p><img src="/public/image/Linux/make/guizezhongmoshitihuan.png" alt="guizezhongmoshitihuan"></p>
<blockquote>
<p>此处，%.o 从 OBJS 中匹配以 .o 结尾的文件，这是就先找到了 func.o 这个文件名；%.o : %.c 表示对于每一个 .o 文件他都依赖于一个同名的 .c 文件(即文件名除了扩展名外完全相同,)；基于以上规则第一个 </p>
<p>func.o : func.c</p>
<p>​	gcc -o $@ -c $^</p>
<p>就被构建出来了，main.o 也是同理。</p>
</blockquote>
<h3 id="变量值的嵌套引用"><a href="#变量值的嵌套引用" class="headerlink" title="变量值的嵌套引用"></a>变量值的嵌套引用</h3><ul>
<li>一个变量名之中可以<strong>包含对其它变量的引用</strong></li>
<li>嵌套引用的本质是<strong>使用一个变量表示另外一个变量</strong></li>
</ul>
<p><img src="/public/image/Linux/make/bianliangzhiqtyy.png" alt="bianliangzhiqtyy"></p>
<h3 id="命令行变量"><a href="#命令行变量" class="headerlink" title="命令行变量"></a>命令行变量</h3><ul>
<li>运行 make 时可以在命令行定义变量，命令行中输入的默认覆盖 makefile 中定义的变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">hm := hello makefile</span><br><span class="line"><span class="section">test: </span></span><br><span class="line">	@echo <span class="string">&quot;hm =&gt; <span class="variable">$(hm)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行输入	make hm=cmd</span></span><br><span class="line"><span class="comment"># 命令行输出	hm =&gt; cmd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在实际开发中，可用于零时改变某个变量的值，以得到一个特殊的可执行编译程序(测试程序)</p>
</blockquote>
<h3 id="override-关键字"><a href="#override-关键字" class="headerlink" title="override 关键字"></a>override 关键字</h3><ul>
<li>用于指示 makefile 中定义的变量不能被覆盖</li>
<li><strong>变量的定义和赋值都需要使用 override 关键字</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">override</span> var := test</span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"><span class="comment"># 命令行输入	make var=cmd</span></span><br><span class="line"><span class="comment"># 命令行输出	hvarm =&gt; test</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>override 关键字仅对后续在 Makefile 中定义的变量生效，如果在 Makefile 中先定义了变量，然后在其后使用 override 关键字尝试覆盖它，那么这个 override 指令将不会有任何效果；</p>
<p>在 Makefile 中，即使一个变量被 override 修饰，它仍然可以在 Makefile 的后续部分进行二次赋值；</p>
<p>override 主要影响的是命令行参数（通过 make VAR&#x3D;value 传递的）和通过 -e 选项传递给 make 的环境变量，让其不可被覆盖命令行变量覆盖；</p>
</blockquote>
<h3 id="define-关键字"><a href="#define-关键字" class="headerlink" title="define 关键字"></a>define 关键字</h3><ul>
<li>用于在 makefile 中定义多行变量</li>
<li>多行变量的定义从变量名开始到 endef 结束</li>
<li>可使用 override 关键字防止变量被覆盖</li>
<li>define 定义的变量等价于使用 &#x3D; 定义的变量</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">define</span> foo</span><br><span class="line">I&#x27;m fool!</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo =&gt; I&#x27;m fool!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> cmd</span><br><span class="line">	@echo <span class="string">&quot;run cmd ls ...&quot;</span></span><br><span class="line">	@ls</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 cmd 的值就是两条命令，当值为命令的时候，前面一定要加[Tab]键</span></span><br></pre></td></tr></table></figure>

<h3 id="环境变量-全局变量"><a href="#环境变量-全局变量" class="headerlink" title="环境变量(全局变量)"></a>环境变量(全局变量)</h3><p>也是操作系统中的环境变量</p>
<ul>
<li>makefile 中能够直接使用操作系统中的环境变量<ul>
<li>当定义的变量与系统环境变量同名时，环境变量将被覆盖</li>
<li>运行 make 时指定 “-e” 选项，优先使用环境变量</li>
</ul>
</li>
</ul>
<p><strong>为什么要在 makefile 中使用环境变量?</strong></p>
<ul>
<li>优势<ul>
<li>环境变量可以在所有 makefile 中使用</li>
</ul>
</li>
<li>劣势<ul>
<li>过多的依赖于环境变量会导致移植性变差</li>
</ul>
</li>
</ul>
<p><strong>变量在不同 makefile 之间的传递方式</strong></p>
<ul>
<li>直接使用外部定义的环境变量（操作系统的环境变量）进行传递<ul>
<li>存在操作系统之间移植性的问题</li>
</ul>
</li>
<li>使用 export 定义变量进行传递（定义临时环境变量）<ul>
<li>因为变量都是在各自 makefile 文件中进行定义，所以不存在移植性的问题</li>
</ul>
</li>
<li>定义 make 命令行变量进行传递（推荐）</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line">JAVA_HOME := java home</span><br><span class="line"><span class="section">tset:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># echo $JAVA_HOME	系统环境变量中的 JAVA_HOME</span></span><br><span class="line"><span class="comment"># /home/kay/...</span></span><br><span class="line"><span class="comment"># make -e</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; /home/kay/...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># makefile.1</span></span><br><span class="line">JAVA_HOME := java home</span><br><span class="line">ver := kay</span><br><span class="line"><span class="section">tset:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;make another file ...&quot;</span></span><br><span class="line">	@(MAKE) -f makefile.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile.2</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># make another file ...</span></span><br><span class="line"><span class="comment"># 正在进入目录 &#x27;/home/xxx&#x27;</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># var =&gt;</span></span><br><span class="line"><span class="comment"># 正在离开目录 &#x27;/home/xxx&#x27;	</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处 makefile.2 中输出的 JAVA_HOME 为何还是 makefile.1 中的值呢？</p>
<p>因为 JAVA_HOME 为系统的环境变量，当我们子啊 makefile.1 中改写了 JAVA_HOME 之后，它的生命周期在整个 make 环境中都是有效的；</p>
<p>为什么在 makefile.2 中 var 是无效的呢？</p>
<p>因为 var 是在 makefile.1 中定义的变量，他的生命周期或者说作用域只在 makefile.1 这个文件中有效；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># makefile.1</span></span><br><span class="line">JAVA_HOME := java home</span><br><span class="line"><span class="keyword">export</span> ver := kay</span><br><span class="line">new := hello</span><br><span class="line"><span class="section">tset:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;make another file ...&quot;</span></span><br><span class="line">	@(MAKE) -f makefile.2</span><br><span class="line">	@(MAKE) -f makefile.2 new:=<span class="variable">$(new)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile.2</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">	@echo <span class="string">&quot;JAVA_HOME =&gt; <span class="variable">$(JAVA_HOME)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;new =&gt; <span class="variable">$(new)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># make another file ...</span></span><br><span class="line"><span class="comment"># 正在进入目录 &#x27;/home/xxx&#x27;</span></span><br><span class="line"><span class="comment"># JAVA_HOME =&gt; java home</span></span><br><span class="line"><span class="comment"># var =&gt; kay</span></span><br><span class="line"><span class="comment"># new =&gt; hello</span></span><br><span class="line"><span class="comment"># 正在离开目录 &#x27;/home/xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 export 定义的变量可以进行传递，这个变量将在该 makefile 及其所有通过它直接或间接调用（如使用 -f 参数指定或通过 include 指令包含）的子 makefile 中可用；</p>
<p>使用命令行也可以将变量进行传递，作用域和 exprot 类似；</p>
</blockquote>
<h3 id="目标变量-局部变量"><a href="#目标变量-局部变量" class="headerlink" title="目标变量(局部变量)"></a>目标变量(局部变量)</h3><ul>
<li>作用域只在指定目标及连带规则中<ul>
<li>target : name <assignment> value</li>
<li>target : override name <assignment> value</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">var := kay.wang	<span class="comment"># 在当前整个 makefile 中可用</span></span><br><span class="line">test : var := tset-var	<span class="comment"># 只在 tset 这个目标及其连带规则中可用</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: another</span></span><br><span class="line">	@echo <span class="string">&quot;test:&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"><span class="section">another:</span></span><br><span class="line">	@echo <span class="string">&quot;another:&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;var =&gt; <span class="variable">$(var)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 test 和 another 中 tset-var 是可用的</span></span><br></pre></td></tr></table></figure>

<h3 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h3><ul>
<li>模式变量是<strong>目标变量的扩展</strong></li>
<li>作用域只在<strong>符合模式的</strong>目标及连带规则中<ul>
<li>target : name <assignment> value</li>
<li>target : override name <assignment> value</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">new := kay.wang	<span class="comment"># 在当前整个 makefile 中可用</span></span><br><span class="line">%e : <span class="keyword">override</span> new := test-new	<span class="comment"># 只在符合 %e 这个模式的目标及其连带规则中可用</span></span><br><span class="line"></span><br><span class="line"><span class="section">rule:</span></span><br><span class="line">	@echo <span class="string">&quot;rule:&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;new =&gt; <span class="variable">$(new)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>全局变量：makefile 外部定义的环境变量</li>
<li>文件变量：makefile 中定义的变量</li>
<li>局部变量：制定目标的变量</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/Linux/Ubuntu/MySQL/</url>
    <content><![CDATA[<h2 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h2><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="安装并设置密码"><a href="#安装并设置密码" class="headerlink" title="安装并设置密码"></a>安装并设置密码</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>条件判断语句</title>
    <url>/Linux/Make/%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>makefile 中支持条件判断语句</p>
<ul>
<li>可以根据<strong>条件的值</strong>来决定 make 的执行</li>
<li>可以<strong>比较</strong>两个不同变量或者变量值和常量值</li>
</ul>
<p><img src="/public/image/Linux/make/tiaojianpanduanyuju.png" alt="tiaojianpanduanyuju"></p>
<blockquote>
<p>注意事项：</p>
<p>条件判断语句只能用于控制 make 实际执行的语句；不能控制规则中命令的执行过程。</p>
</blockquote>
<h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><ul>
<li>常用形式<ul>
<li>ifxxx (arg1, arg2)</li>
</ul>
</li>
<li>其他合法形式<ul>
<li>ifxxx “arg1” “arg2”</li>
<li>ifxxx ‘arg1’ ‘arg2’</li>
<li>ifxxx “arg1” ‘arg2’</li>
<li>ifxxx ‘arg1’ “arg2”</li>
</ul>
</li>
</ul>
<p><img src="/public/image/Linux/make/xiaotieshi.png" alt="xiaotieshi"></p>
<h3 id="条件判断关键字"><a href="#条件判断关键字" class="headerlink" title="条件判断关键字"></a>条件判断关键字</h3><table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifeq</td>
<td align="center">判断参数是否相等，相等为 true，否则为 false</td>
</tr>
<tr>
<td align="center">ifneq</td>
<td align="center">判断参数是否不相等，不相等为 true，相等为 false</td>
</tr>
<tr>
<td align="center">ifdef</td>
<td align="center">判断变量是否有值，有值为 true，否则为 false</td>
</tr>
<tr>
<td align="center">ifndef</td>
<td align="center">判断变量是否没有值，没有值为 true，否则为 false</td>
</tr>
</tbody></table>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var1 := A</span><br><span class="line">var2 := <span class="variable">$(var1)</span></span><br><span class="line">var3 :=</span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    <span class="keyword">ifeq</span> (<span class="variable">$(var1)</span>,<span class="variable">$(var2)</span>) 	<span class="comment"># # 这里前面是空格而不是一个 [Tab]</span></span><br><span class="line">		@echo <span class="string">&quot;var1 == var2&quot;</span>	</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var1 != var2&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifneq</span> (<span class="variable">$(var2)</span>,)</span><br><span class="line">		@echo <span class="string">&quot;var2 is NOT empty&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var2 is empty&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var2</span><br><span class="line">		@echo <span class="string">&quot;var2 is NOT empty&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var2 is empty&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifndef</span> var3</span><br><span class="line">		@echo <span class="string">&quot;var3 is empty&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var3 is NOT empty&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在使用上述条件判断语句时候，前面就不能使用 [Tab] 了，要改为使用空格</p>
</blockquote>
<h3 id="一些工程经验"><a href="#一些工程经验" class="headerlink" title="一些工程经验"></a>一些工程经验</h3><ul>
<li>条件判断语句之前可以有空格，但<strong>不能有 [Tab] 字符</strong>（’\t’）</li>
<li>在条件语句中<strong>不要使用自动变量</strong>（$@、$^、$&lt;）</li>
<li>一条完整的条件语句<strong>必须</strong>位于同一个 makefile 中</li>
<li>条件判断语句类似 C 语言中的宏，<strong>预处理阶段有效，执行阶段无效</strong></li>
<li>make 在加载 makefile 时<ul>
<li>首先计算表达式的值（赋值方式不同，计算方式不同）</li>
<li>根据判断语句的表达式决定执行的内容</li>
</ul>
</li>
</ul>
<blockquote>
<p>此处的预处理阶段是指 make 解释器加载 makefile 的时候，在加载的时候就对条件判断语句进行处理了；除了完成后才会实际去执行 makefile 中的规则；</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">.PHONY : test</span><br><span class="line"></span><br><span class="line">var1 :=</span><br><span class="line">var2 := <span class="variable">$(var1)</span></span><br><span class="line"></span><br><span class="line">var3 =</span><br><span class="line">var4 = <span class="variable">$(var3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#var3 = 3 </span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    <span class="keyword">ifdef</span> var1 </span><br><span class="line">		@echo <span class="string">&quot;var1 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var1 is NOT defined&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var2</span><br><span class="line">		@echo <span class="string">&quot;var2 is defined&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var2 is NOT defined&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var3 </span><br><span class="line">		@echo <span class="string">&quot;var3 is defined&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var3 is NOT defined&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ifdef</span> var4</span><br><span class="line">		@echo <span class="string">&quot;var4 is defined&quot;</span>    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		@echo <span class="string">&quot;var4 is NOT defined&quot;</span>    </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># make</span></span><br><span class="line"> <span class="comment"># var1 is NOT defined</span></span><br><span class="line"> <span class="comment"># var2 is NOT defined</span></span><br><span class="line"> <span class="comment"># var3 is NOT defined</span></span><br><span class="line"> <span class="comment"># var4 is defined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 make 解释器认为 var4 已经定义了，是为什么呢？</p>
<p>因为在预处理阶段 make 解释器在加载 makefile 的时候，根本就无法判断出 var4 的值应该是什么，此时 make 解释器只能判断出var3 的值是空的，但 var4 的值要延迟到加载 makefile 文件的时候才能够得知，所以他就认为 var4 是有值的。</p>
<p>当 var3 &#x3D; 3 时，二者就都是有值的。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>条件判断根据条件的值来决定 make 的执行</li>
<li>条件判断可以比较两个不同变量或者变量和常量的值</li>
<li>条件判断在预处理阶段有效，执行阶段无效</li>
<li>条件判断不能控制规则中命令的执行过程</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>三极管</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/%E4%B8%89%E6%9E%81%E7%AE%A1/</url>
    <content><![CDATA[<h2 id="MOS-管"><a href="#MOS-管" class="headerlink" title="MOS 管"></a>MOS 管</h2><p>MOS管（Metal-Oxide-Semiconductor Field-Effect Transistor，MOSFET）是一种广泛应用于电子电路中的场效应晶体管（FET）。它利用电场效应来控制电流流动，是数字和模拟电路中常见的元件。MOS 管凭借其高输入阻抗和低功耗特性，在功率开关、信号放大以及逻辑电路中有着广泛的应用。</p>
<h3 id="MOS-管的结构"><a href="#MOS-管的结构" class="headerlink" title="MOS 管的结构"></a>MOS 管的结构</h3><p>MOS管主要由三部分构成：</p>
<ol>
<li><strong>栅极（Gate）</strong>：这是 MOS 管的控制端，通过在栅极施加电压来控制电流的导通与关断。栅极和通道之间由一层薄薄的绝缘氧化物层（通常是二氧化硅）隔开，因此栅极与其他区域几乎没有电流流动。</li>
<li><strong>源极（Source）</strong>：电流从源极流向漏极，源极是电流的起点。</li>
<li><strong>漏极（Drain）</strong>：漏极是电流的终点，当 MOS 管导通时，电流从源极流向漏极。</li>
<li><strong>基极（Body or Substrate）</strong>：MOS 管内部的一个半导体区域，通常接地或接电源电压，用来控制或隔离栅极与源漏极之间的</li>
</ol>
<p>MOS 管通常分为 <strong>N沟道（N-Channel）</strong>和 <strong>P沟道（P-Channel）</strong>两种类型，分别根据导电通道是由 N 型还是 P 型半导体形成来区分。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/MOSguanyuanlitu.png" alt="MOSguanyuanlitu"></p>
<blockquote>
<p>G极(gate)—栅极，不用说比较好认</p>
<p>S极(source)—源极，不论是P沟道还是N沟道，两根线相交的就是</p>
<p>D极(drain)—漏极，不论是P沟道还是N沟道，是单独引线的那边</p>
</blockquote>
<h3 id="N-沟道与-P-沟道判别"><a href="#N-沟道与-P-沟道判别" class="headerlink" title="N 沟道与 P 沟道判别"></a>N 沟道与 P 沟道判别</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/NPpanbie.png" alt="NPpanbie"></p>
<blockquote>
<p>箭头指向G极的是N沟道<br>箭头背向G极的是P沟道</p>
</blockquote>
<h3 id="MOS-管的工作原理"><a href="#MOS-管的工作原理" class="headerlink" title="MOS 管的工作原理"></a>MOS 管的工作原理</h3><p>MOS 管是一种<strong>电压控制器件</strong>，它的工作状态由<strong>栅极的电压</strong>来控制。当在栅极和源极之间施加一定的电压时，栅极通过电场影响沟道区域的电荷分布，从而控制源极和漏极之间的电流流动。</p>
<ul>
<li><strong>N 沟道 MOS 管（NMOS）</strong>：当栅极电压高于源极电压（即正偏压）时，导电沟道形成，电流从漏极流向源极。这个过程称为导通。</li>
<li><strong>P 沟道 MOS 管（PMOS）</strong>：与 NMOS 相反，当栅极电压低于源极电压（即负偏压）时，导电沟道形成，电流从源极流向漏极。</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>数电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs安装与配置</title>
    <url>/%E5%89%8D%E7%AB%AF/nodejs/nodejs%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://nodejs.org/">Node.js</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下一步即可</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>1.在你需要的目录下新建两个文件夹【node_global】和【node_cache】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\tools\SDK\nodejs\configuration\node_global&quot;</span><br><span class="line"></span><br><span class="line">npm config set cache &quot;D:\tools\SDK\nodejs\configuration\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>【此电脑】-单击右键【属性】-【高级系统设置】-【环境变量】</p>
<p>2.在【系统变量】中点击【新建】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE_PATH</span><br><span class="line">D:\tools\SDK\nodejs\configuration\node_global\node_modules</span><br></pre></td></tr></table></figure>

<p>3.编辑【用户变量】中的【Path】</p>
<p>将默认C盘下【AppData\Roaming\npm】修改为【node_global】的路径</p>
<p>4.在【系统变量】中选择【Path】添加【%NODE_PATH%】</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>组件</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h2><p>半加器是一种能够对<strong>两个一位二进制数进行相加并输出结果</strong>的逻辑门电路。它只能处理两个输入位（被加数和加数），<strong>不考虑低位进位</strong>。	</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/banjiaqi.png" alt="banjiaqi"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/banjiaqizhenzhibiao.png" alt="banjiaqizhenzhibiao"></p>
<h2 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h2><p>全加器（Full-Adder）是一种能够处理<strong>两个一位二进制数</strong>以及<strong>它们之间可能产生的进位</strong>的加法器；</p>
<p>在计算机中，全加器是算术逻辑单元（ALU）的重要组成部分，用于执行加法、减法等算术运算（在计算机中所谓的减法、称法、除法都是通过加法来实现的）；</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/quanjiaqi.png" alt="quanjiaqi"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/quanjiaqizhenzhibiao.png" alt="quanjiaqizhenzhibiao"></p>
<h2 id="八位二进制加法器"><a href="#八位二进制加法器" class="headerlink" title="八位二进制加法器"></a>八位二进制加法器</h2><p>八位二进制加法器是一种数字电路，用于将两个八位的二进制数相加，并产生一个八位的和以及一个进位输出（通常称为溢出位或最高位进位）。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/baweijiafaqi.png" alt="qbaweijiafaqi"></p>
<p>八位二进制加法器能够执行从0到255之间的任何两个数的加法，产生从0到510（包括溢出情况）的结果。如果结果小于或等于255，则溢出位为0；如果结果大于255，则溢出位为1，表示实际结果需要模256处理（在计算机科学中，这通常意味着忽略溢出位，只考虑最低的八位）。</p>
<blockquote>
<p>由上述可以看出，任意位数的加法器都只需要对应个数的全加器及可实现（如：16位加法器之只需要一个半加器和15个全加器。）</p>
</blockquote>
<h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><p><strong>可记忆数据的电路</strong></p>
<p>锁存器的工作原理基于电平控制数据的输入。它通常包括锁存控制信号输入端（如使能端WE）、数据输入端（Din）和数据输出端（Q）。当锁存控制信号有效时（如使能端WE为高电平或低电平，具体取决于锁存器的类型），数据输入端（Din）的状态被锁存到输出端Q，并保持不变，直到下一个锁存信号到来。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/suocunqi.png" alt="suocunqi"></p>
<blockquote>
<p>锁存器可以将数据暂存起来，等待后续处理，从而起到缓存的作用。</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>数电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>电流</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E7%94%B5%E6%B5%81/</url>
    <content><![CDATA[<h2 id="AC-DC"><a href="#AC-DC" class="headerlink" title="AC&#x2F;DC"></a>AC&#x2F;DC</h2><p><strong>AC(交流电)，DC(直流电)</strong></p>
<h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><ul>
<li><p>交流电的电流方向随时间变化</p>
</li>
<li><p>电荷会在正、负两个方向上流动，周期性的交替反向</p>
</li>
<li><p>交流电通常是通过电网提供电力</p>
</li>
<li><p>用于各种大型的较大功耗的电器设备和机械设备中</p>
<p>（如电视、冰箱、微波炉、电动汽车的电机）</p>
</li>
</ul>
<h3 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h3><ul>
<li><p>直流电是指电流方向不变的电流</p>
</li>
<li><p>电荷始终在同一个方向上流动</p>
</li>
<li><p>直流电源通常是由电池或者其他直流电源供应</p>
</li>
<li><p>直流电常用于需要稳定电压和恒定方向的小型设备中</p>
<p>（如手机、电动自行车）</p>
</li>
</ul>
<h3 id="AC-DC的对比"><a href="#AC-DC的对比" class="headerlink" title="AC&#x2F;DC的对比"></a>AC&#x2F;DC的对比</h3><p>直流电和交流电的主要区别在于电流的<strong>方向</strong>和<strong>性质</strong>。直流电的电流方向不变，而交流电的电流方向随时间周期性变化。直流电通常<br>用于需要恒定电压和电流方向的设备，而交流电通常用于各种电器设备和机械设备中。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">直流电</th>
<th align="center">交流电</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>方向</strong></td>
<td align="center">电流方向不变</td>
<td align="center">电流的方向随时间周期性变化</td>
</tr>
<tr>
<td align="center"><strong>电压变化</strong></td>
<td align="center">电压稳定不变</td>
<td align="center">电压随时间周期性变化</td>
</tr>
<tr>
<td align="center"><strong>发电方式</strong></td>
<td align="center">化学电池、太阳能电池等</td>
<td align="center">发电厂</td>
</tr>
<tr>
<td align="center"><strong>传输损失</strong></td>
<td align="center">传输损失小</td>
<td align="center">电流传输损失较大</td>
</tr>
<tr>
<td align="center"><strong>方便改变电压</strong></td>
<td align="center">不太方便</td>
<td align="center">非常方便</td>
</tr>
<tr>
<td align="center"><strong>应用</strong></td>
<td align="center">电池供电的设备：手机、笔记本电脑等</td>
<td align="center">家用电器、工业用电</td>
</tr>
</tbody></table>
<h2 id="开路和闭路"><a href="#开路和闭路" class="headerlink" title="开路和闭路"></a>开路和闭路</h2><p>“Open circuit”和“Close circuit”的区别在于电路中开关的状态是否闭合，这直接影响了电路中的电流是否能够流通，从而影响电路中的电器设备是否能够正常工作。</p>
<h3 id="开路Open-circuit"><a href="#开路Open-circuit" class="headerlink" title="开路Open circuit"></a>开路Open circuit</h3><p>当电路中的开关处于断开状态，电路就处于”Open circuit”(开路)状态。在这种状态下，电流无法流通，电路中的电器设备也无法工作。</p>
<h3 id="闭路close-circuits"><a href="#闭路close-circuits" class="headerlink" title="闭路close circuits"></a>闭路close circuits</h3><p>当电路中的开关处于闭合状态，电路就处于”Close circuit”(闭路)状态。在这种状态下，电流可以在电路中流通，电器设备也可以正常工作。</p>
<blockquote>
<p>电工操作的安全要求就是，保证电路是open的。</p>
<p>比如说站到木椅子上，使用绝缘手套;</p>
<p>千万不要让电流通过身体形成回路(close circuit);</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>电阻</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E7%94%B5%E9%98%BB/</url>
    <content><![CDATA[<h2 id="欧姆定律"><a href="#欧姆定律" class="headerlink" title="欧姆定律"></a>欧姆定律</h2><p>电压产生电势差，推动电流的流动</p>
<p><strong>阻碍电流的流动就是电阻</strong></p>
<p>电阻是电子学中的基本概念，它是指电流经过导体时阻碍电流流动的程度。电阻的单位是欧姆（Ω）。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/dianzu.png" alt="dianzu"></p>
<p>欧姆定律描述了电流和电压之间的关系。欧姆定律的公式为：I &#x3D; U &#x2F; R，其中 I 是电流，U 是电压，R 是电阻。这个公式表明：在电阻不变的情况下，电压和电流成正比。</p>
<blockquote>
<p>I 电流（A）、U 电压（V）、R 电阻（Ω）</p>
</blockquote>
<h3 id="欧姆定律的计算"><a href="#欧姆定律的计算" class="headerlink" title="欧姆定律的计算"></a>欧姆定律的计算</h3><p>分为串联电路和并联电路</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/chuanbingliandianlu.png" alt="chuanbingliandianlu"></p>
<table>
<thead>
<tr>
<th align="center">串联电路</th>
<th align="center">并联电路</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电流关系：I &#x3D; I1 &#x3D; I2</td>
<td align="center">电流关系：I &#x3D; I1 + I2</td>
</tr>
<tr>
<td align="center">电压关系：U &#x3D; U1 + U2</td>
<td align="center">电压关系：U &#x3D; U1 &#x3D; U2</td>
</tr>
<tr>
<td align="center">电阻关系：R &#x3D; R1 + R2</td>
<td align="center">电阻关系：1&#x2F;R &#x3D; 1&#x2F;R1 + 1&#x2F;R2</td>
</tr>
<tr>
<td align="center">电压分配关系：U1&#x2F;R1 &#x3D; U2&#x2F;R2</td>
<td align="center">电压分配关系：I1R1 &#x3D; I2R2</td>
</tr>
</tbody></table>
<h2 id="常见电阻介绍"><a href="#常见电阻介绍" class="headerlink" title="常见电阻介绍"></a>常见电阻介绍</h2><p><strong>基于功能和制作工艺划分</strong><br><strong>普通电阻：</strong>普通电阻是一种最基本的电阻器，通常由一根或多根绕在绝缘体上的金属丝或碳膜组成，可以提供固定的电阻值适用于各种电路中。</p>
<p><strong>薄膜电阻：</strong>薄膜电阻是一种由金属或合金薄膜制成的电阻器，可以提供高精度和稳定性的电阻值，常用于精密仪器、测量仪器等高要求的场合。</p>
<p><strong>光敏电阻：</strong>光敏电阻是一种电阻值受光照强度影响的电阻器，常用于光敏电路和光控系统中。</p>
<p><strong>金属薄膜电阻：</strong>金属薄膜电阻器是一种由金属薄膜制成的电阻器，具有较高的精度和稳定性，适用于高精度电路中。</p>
<p><strong>电位器：</strong>电位器是一种可调电阻器，通常由一个旋转或滑动的电阻器件和一个旋钮或滑动器组成，可以提供可调的电阻值，常用于电路的调节和控制。</p>
<p><strong>旋钮可调电阻：</strong>旋钮可调电阻是一种可调电阻器，与电位器类似，但是旋钮可调电阻通常是用旋钮来改变电阻值，通常用于电子设备的调节和控制。</p>
<p><strong>热敏电阻：</strong>热敏电阻是一种电阻值随温度变化而变化的电阻器，通常用于温度测量和控制系统中。</p>
<p><strong>压敏电阻：</strong>压敏电阻是一种电阻值随压力变化而变化的电阻器，通常用于压力传感器和压力测量等应用场合。</p>
<p><strong>高精度电阻：</strong>高精度电阻是一种精度较高的电阻器，通常具有稳定的电阻值和温度系数，适用于高精度仪器和精密测量仪器等场合。</p>
<h2 id="电阻的数据手册"><a href="#电阻的数据手册" class="headerlink" title="电阻的数据手册"></a>电阻的数据手册</h2><p>电阻我们主要关心:<strong>封装</strong>(尺寸大小)，<strong>标称</strong>(精密度)，<strong>额定功率</strong></p>
<p>封装:看电阻是什么样的，是直插的还是贴片的，大小是多大。</p>
<p>标称:看电阻表的电阻阻值是多少，精确度是多少，误差1%的，还是5%的，还是20%的，精度越高越贵。</p>
<p>额定功率:额定功率是 <code>P=I*I*R = I*U</code>,额定功率其实决定了耐压值。电阻能通过的最大电流是固定的，额定功率越高，耐压值就越高，超过了电阻的耐压值会导致电阻烧毁。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>AHT21</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/</url>
    <content><![CDATA[<p><strong>AHT21</strong> 是一款由 <strong>Aosong Electronics</strong>（奥松电子）生产的数字温湿度传感器芯片，具有 <strong>高精度、低功耗</strong> 和 <strong>数字输出</strong> 的特点，广泛应用于环境监测、物联网设备、家居自动化等领域。AHT21 能够同时测量 <strong>温度</strong> 和 <strong>湿度</strong>，并将其通过 <strong>I2C</strong> 接口以数字信号输出，方便与各种微控制器（如 Arduino、ESP32、STM32 等）连接和使用。</p>
<h2 id="电器特性"><a href="#电器特性" class="headerlink" title="电器特性"></a>电器特性</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21dqtx.png" alt="AHT21dqtx"></p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21yjsm.png" alt="AHT21yjsm"></p>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21sldl.png" alt="AHT21sldl"></p>
<p>为避免信号冲突，微处理器（MCU）必须只能驱动 SDA 和 SCL 在低电平。需要一个外部的上拉电阻（例如：4.7kΩ）将信号提拉至高电平。<strong>上拉电阻已包含在 AHT21B 的微处理器的 I&#x2F;O 电路中。</strong></p>
<h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><h3 id="启动传感器"><a href="#启动传感器" class="headerlink" title="启动传感器"></a>启动传感器</h3><p>第一步，将传感器上电，电压为所选择的 VDD 电源电压(范围介于2.2V与5.5V之间)。<strong>上电后传感器需要不少于 100ms 稳定时间</strong>（此时SCL为高电平)以达到空闲状态即做好准备接收由主机(MCU)发送的命令。</p>
<h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21sbdz.png" alt="AHT21sbdz"></p>
<h2 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h2><p>1.上电后要等待不少于 100ms，读取温湿度值之前，通过发送 0x71 获取一个字节的状态字，如果状态字和 0x18 相与后不等于 0x18，初始化 0x1B、0x1C、0x1E 寄存器，详细初始化流程请参照我司官网例程；如果相等，执行下一步。</p>
<p>2.等待 10ms 发送 0xAC 命令(触发测量)，此命令参数有两个字节，第一个字节为 0x33，第二个字节为 0x00。 </p>
<p>3.等待 80ms 待测量完成,如果读取状态字 Bit[7] 为0，表示测量完成，然后可以连续读取六个字节；否则继续等待。 </p>
<p>4.当接收完六个字节后，紧接着下一个字节是 CRC 校验数据，用户可以根据需要读出，如果接收端需要 CRC 校验，则在接收完第六个字节后发 ACK 应答，否则发 NACK 结束，CRC 初始值为 0XFF,CRC8 校验多项式为： CRC[7:0]&#x3D;1+x 4 + x 5 + x 8 </p>
<p>5.计算温湿度值。</p>
<blockquote>
<p>注：在第一步的校准状态检验只需要上电时检查，在正常采集过程无需操作。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21dqlc.png" alt="AHT21dqlc"></p>
<blockquote>
<p>传感器在采集时需要时间,主机发出测量指令（0xAC）后,延时 80 毫秒以上再读取转换后的数据并判断返回的状态位是否正常。若状态比特位 [Bit7] 为 0 代表数据可正常读取,为 1 时传感器为忙状态,主机需要等待数据处理完成。</p>
</blockquote>
<h2 id="温湿度转换"><a href="#温湿度转换" class="headerlink" title="温湿度转换"></a>温湿度转换</h2><h3 id="相对湿度转换"><a href="#相对湿度转换" class="headerlink" title="相对湿度转换"></a>相对湿度转换</h3><p>相对湿度 RH 都可以根据 SDA 输出的相对湿度信号 S<sub>RH</sub> 通过如下公式计算获得（结果以 %RH 表示）：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21sdzh.png" alt="AHT21sdzh"></p>
<h3 id="温度转换"><a href="#温度转换" class="headerlink" title="温度转换"></a>温度转换</h3><p>温度T都可以通过将温度输出信号 S<sub>T</sub> 代入到下面的公式计算得到（结果以温度 ℃ 表示）：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/AHT21/AHT21wdzh.png" alt="AHT21wdzh"></p>
<blockquote>
<p>其中的 S<sub>RH</sub>、S<sub>T</sub> 代表的是读取到的 20 位数据。</p>
</blockquote>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>元器件</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E5%85%83%E5%99%A8%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="电容器"><a href="#电容器" class="headerlink" title="电容器"></a>电容器</h2><p><strong>电容就是装电的容器</strong><br>电容器是一种电子元件，用于储存电荷和能量。它由两个导体板和介质层组成(两个板子一边积累正电荷，一边积累负电荷)，介质层位于两个导体板之间。</p>
<p> 当电容器接入电路时，负电荷被储存在导体板上，并在两板之间产生电场。</p>
<p>电容器的单位是<strong>法拉</strong>(F)，<strong>一个法拉等于存储一库仑电荷所需的电势差为一伏特的电容器</strong>。常见的电容器有电解电容器、陶瓷电容器、聚酯薄膜电容器、铝电解电容器等。</p>
<p>不同的材料介质，容纳电荷的能力不一样。电容的充放电是基于静电力的，不涉及化学反应变化，比锂电池更安全。</p>
<p>注意:法拉是个非常大非常大的单位哦，其他单位为mF，uF，nF，pF，</p>
<p>1F   (法拉) &#x3D; 1000mF(毫法)，</p>
<p>1mF(毫法) &#x3D; 1000μF(微法)，</p>
<p>1μF (微法) &#x3D; 1000nF(纳法)，</p>
<p>1nF (纳法) &#x3D; 1000pF(皮法)</p>
<p>电容器能够非常迅速地达到其存储电荷的能力上限，即充满电的状态。</p>
<p><strong>电容器的作用</strong></p>
<p>阻止电压的突变，储能，滤波(大电容滤低频，小电容滤高频)</p>
<p>生活中的电容: 充电器的电源灯并不是立刻断开，里面有电容，电荷慢慢释放掉。差点的耳机，滤波不好，噪音大。</p>
<p>常用的有$10^{-6},10^{-9}$大小等。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>基于功能和制作工艺划分</strong></p>
<p><strong>玻璃电容：</strong>使用玻璃作为介质的电容器，具有高温稳定性和低损耗等特点，常用于高频和高温环境下的电路中。</p>
<p><strong>钽电容：</strong>使用钽金属作为电极的电容器，具有小尺寸、大电容量和高频特性等优点，常用于微型电路中。</p>
<p><strong>薄膜电容：</strong>使用金属膜或金属箔作为电极的电容器，具有高精度、稳定性好等特点，常用于高性能电子器件中</p>
<p><strong>铝电解电容：</strong>使用铝箔和电解液作为电极的电容器，具有大电容量、低成本等特点，常用于低频和直流电路中。</p>
<p><strong>云母电容：</strong>使用云母作为介质的电容器，具有高精度、高频特性等特点，常用于精密仪器和高频电路中。</p>
<p><strong>空气电容：</strong>使用空气作为介质的电容器，具有高精度、稳定性好等特点，但体积较大，常用于高频和高压电路中。</p>
<p><strong>陶瓷电容：</strong>使用陶瓷作为介质的电容器，具有小尺寸、高频特性和高温稳定性等优点，常用于电子设备中。</p>
<p><strong>可调电容：</strong>具有可变电容值的电容器，常用于无线电和调谐电路中。</p>
<p><strong>金属纸电容：</strong>使用金属化薄膜作为电极的电容器，具有高精度、稳定性好等特点，常用于高性能电子器件中。</p>
<p><strong>超级电容：</strong>也称为电化学电容器，具有高能量密度、高功率密度和长寿命等特点，常用于储能系统和电动汽车中。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>有的电容是有极性的，正负极接错了会爆炸哦!!!</strong></p>
<p><strong>在电子元器件中如果两个引脚长短不一，通常情况下长脚为正极，短脚为负极</strong></p>
<p>例如：铝电解电容是一种极性电容，由于其特殊的结构和工作原理，如果接反了极性，万能会导致电容器失效或者损坏，甚至可能导致电容器短路或者起火等危险情况。</p>
<p>铝电解电容的结构是由一层氧化铝薄膜和一层电解液构成的。当正极连接正电压，负极连接负电压时，电解液中的氢离子会向氧化铝膜的负极移动，而负离子则向电解液的正极移动，形成一个稳定的电场，从而形成电容效应。如果电容器反接了极性，电解液中的氢离子会向氧化铝膜的正极移动，形成氢气，铝电解电容会爆浆。电容爆浆后压力较大,电解电容的外壳也是无规律的变形,有可能产生手榴弹爆炸后的效果,容易造成其他元器件的损坏。</p>
<h3 id="超级电容"><a href="#超级电容" class="headerlink" title="超级电容"></a>超级电容</h3><p>灯能亮多久?<br>t &#x3D; (C * *V) &#x2F; 1<br>t  是放电时间(单位：秒)<br>C 是电容的容量(单位：法拉)</p>
<p>V 是电容的电压(单位：伏特)</p>
<p>I  是放电电流(单位：安培)</p>
<p>C &#x3D; 1.5F</p>
<p>V &#x3D; 2.8V</p>
<p>1 &#x3D; 20mA &#x3D; 0.02A</p>
<p>将这些值代入公式，计算放电t &#x3D; (1.5 * 2.8) &#x2F; 0.02 ≈ 210秒</p>
<h2 id="电感器"><a href="#电感器" class="headerlink" title="电感器"></a>电感器</h2><p><strong>电和磁之间有密切的关系</strong><br>当我们在水里扔一块石头时，会产生一个涟漪，涟漪会从石头周围向外扩散。电和磁也是如此。当电通过导线时，它就像是在水中扔了一块石头一样，会在周围产生一个磁场，这个磁场就像是涟漪一样向外扩散。反过来，当一个磁场改变时产生的涟漪又会带动周围的电子运动，这些涟漪会产生电场，这就是电磁感应的原理。<br><strong>电和磁可以互相转换。</strong><br>电机中的电流流过线圈，从而产生磁场，这个磁场将旋转部件(例如电动机轴)带动起来。这就是电磁感应原理的应用。<br>发电机和电机相反。通过旋转磁场，发电机可以转换机械能为电能。</p>
<p><strong>什么是电感器</strong><br>电感器是一种电子元件，用于在电路中存储和释放能量。<strong>它由一个线圈组成，通常由铜线绕成，通常带有一个铁芯。</strong>当电流通过电感器时，它会在线圈中产生一个磁场，从而存储能量。当电流停止流动时，磁场会崩溃导致电感器释放存储的能量。<br>电感器的主要作用是在电路中调节电流的变化率。它可以用来过滤电路中的高频噪声，电感器两端的电流不会突变，保护其他电子元件不受到电磁干扰的影响。</p>
<p><strong>电感器的核心要点</strong></p>
<ul>
<li>通过磁场存储能量</li>
<li>阻止电流的突变</li>
</ul>
<h3 id="电感和电阻"><a href="#电感和电阻" class="headerlink" title="电感和电阻"></a>电感和电阻</h3><p><strong>理想的电感没有能量损耗</strong><br>电感:电磁感应元器件，电会产生磁场，磁场又会抵制电流的变化。理想的电感没有能量损耗。</p>
<p>跟电阻不同，电阻阻碍电流，发热。</p>
<p>电感使用漆包线，纱包线等外部绝缘导线缠绕到铁芯上。</p>
<p>电感的单位是亨利(Henry)表示为H，它的中文读法是“恒利”，以英国物理学家亨利的名字命名。</p>
<p>电感的基本单位是:H(亨)，它和电容一样，也是一个很大的计量单位，另外还有毫户mh、微亨uh、纳亨nh。</p>
<p><strong>电感的作用</strong></p>
<p>电感可以作为电路稳定器的 一部分，通过抵抗电路中电流的变化，保持电路的稳定性和可靠性。</p>
<p>在电源电路中，电感器可以储存能量并在需要时释放，从而平滑电源电压的波动，减少电压瞬变对电路的影响，提高电路的稳定性。</p>
<blockquote>
<p>电流突变会产生磁场。可能会影响其他元器件，电感器可以起到一个缓冲的作用。</p>
</blockquote>
<h2 id="电感电容组成LRC振荡电路"><a href="#电感电容组成LRC振荡电路" class="headerlink" title="电感电容组成LRC振荡电路"></a>电感电容组成LRC振荡电路</h2><p><strong>振荡电路原理</strong></p>
<p>LRC振荡电路是一种基本的振荡电路，由电感L、电容C和电阻R组成，可以产生稳定的交流电信号。在LRC振荡电路中，电感和电容通过共振的方式相互作用，导致电荷周期性地从电容器到电感器和反向流动，从而产生周期性的电流和电压信号。</p>
<p>LRC振荡电路的工作原理是当电容器放电时，电感器中的电流开始增加，而电容器的电荷开始减少。当电容器的电荷达到零时，电感器中的电流达到最大值，并开始流回电容器中，导致电容器的电荷开始增加。当电容器的电荷重新达到最大值时，电感器中的电流达到零值，并开始再次增加。这个过程不断重复，从而形成一个周期性的交流电信号。</p>
<p><strong>LRC振荡电路的频率由电感L和电容C的值决定，可以通过调整电感和电容的值来改变输出信号的频率。</strong></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>充电阶段<ul>
<li>当电容C开始充电时，电流从电源流向电容，此时电流方向可以视为“向右流动”（假设我们定义从电源到电容的方向为右）。</li>
<li>电容储存电荷，同时电感L由于电流的变化而产生感应电动势，但此时电感中的电流较小。</li>
</ul>
</li>
<li>放电阶段<ul>
<li>当电容C充满电后，如果电路中的开关（如果有的话）切换，使得电容开始放电，电流将流向电感L，此时电流方向变为“向左流动”（从电容到电感）。</li>
<li>电感L开始储存磁能，并产生与电容放电方向相反的感应电动势，试图阻止电流的变化。</li>
</ul>
</li>
<li>振荡过程<ul>
<li>随着电容的放电，其两端的电压逐渐降低，而电感中的电流逐渐增加。当电容放电完毕时，电感中的电流达到最大值。</li>
<li>此时，电感开始释放其储存的磁能，通过感应电动势对电容进行反向充电，电流方向再次变为“向右流动”。</li>
<li>这个过程不断重复，形成周期性的振荡。在振荡过程中，电流的方向会不断地在“向左”和“向右”之间切换。</li>
</ul>
</li>
</ol>
<h2 id="保险丝、熔断器"><a href="#保险丝、熔断器" class="headerlink" title="保险丝、熔断器"></a>保险丝、熔断器</h2><p>保险丝和熔断器都是用来保护电路免受过载或短路等电气故障的设备。</p>
<p>保险丝是一种电气元件，通常由金属丝或铜箔制成，其作用是<strong>在电流过载时断开电路，以保护电路中其他电气元件不受损坏。</strong>当电流达到或超过保险丝的额定电流时，保险丝中的金属丝或铜箔会被加热，最终熔断，中断电路，以避免电气火灾等危险情况。</p>
<p>熔断器与保险丝类似，与保险丝不同，其作用是<strong>当电流超过额定值的时候熔断器会自动断开，当过一段时间温度降下来后，熔断器会自动恢复。</strong>熔断器通常可以重复使用。熔断器的另一个优点是它们通常比保险丝更快地响应电气故障，因此能更好地保护电路。</p>
<p><strong>熔断器实现方式通常由两种</strong></p>
<ul>
<li><p><strong>基于材料特性熔断：</strong>在这种方式中，熔断器内部包含一段易熔的金属导体（即熔体），该导体由具有特定熔点的金属或合金制成。当通过熔断器的电流超过其额定值时，熔体因发热而温度急剧上升，当温度达到其熔点时，熔体将迅速熔化并断开电路，从而实现过流保护。这种方式的关键在于熔体材料的选择和熔体尺寸的设计，它们共同决定了熔断器的额定电流和熔断特性。</p>
</li>
<li><p><strong>基于物理结构熔断：</strong>例如：将两个不同材质的金属片压合在一起组成一个熔断器。这两个金属片由于材料不一样，他们热胀冷缩的系数也不一样，当温度达到一定地步的时候，其中一个金属片膨胀的厉害，另外一个金属片变化不明显，这时膨胀厉害的那一个金属片就弯掉了，导致电路断开，形成熔断的效果。</p>
</li>
</ul>
<h3 id="保险丝、熔断器参数"><a href="#保险丝、熔断器参数" class="headerlink" title="保险丝、熔断器参数"></a>保险丝、熔断器参数</h3><p><strong>购买元器件最重要的看参数</strong></p>
<p>熔断速度：慢速，中速，快速，特快速。</p>
<p>快速熔断器：熔断时间小于0.001秒</p>
<p>电压额定值：所能承受的最高电压(多大电压的时候他会熔断)</p>
<p>电流额定值:所能承受的最高电流(多大电流的时候他会熔断)</p>
<p>熔断特性:快速熔断器适用于对电路的保护要求较高的场合，能够在短时间内切断过载电流或短路电流;</p>
<p>​		而慢速熔断器则适用于对电路保护要求不高的场合，能够在一定时间内承受额定电流的2-3倍电流。</p>
<h2 id="接插件"><a href="#接插件" class="headerlink" title="接插件"></a>接插件</h2><p><strong>开关、按键、连接端子本质上都是电路连接器</strong></p>
<h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p><strong>能发出哗哔哗的声音的小元器件</strong><br>声音是由物体的震动产生，一切发生的物体都是在震动。 震动的频率不同，声音的音调就不同。</p>
<p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，源是震动源。有源蜂鸣器插电就叫，无源蜂鸣器插电不叫，需要一定周期的高低电压信息给他，他才会叫。</p>
<p>蜂鸣器的音频是指蜂鸣器发出的声音的声波频率，是指每秒连续循环的次数。频率的计量单位是“赫兹”(Hz)，人类听觉的频率范围约为20-20000Hz。20Hz以下是次声，20kHz以上是超声波。</p>
<p>蜂鸣器常用产品的谐振频率为2-4 kHz</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%A8%A1%E7%94%B5%E5%9F%BA%E7%A1%80/%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="万用表"><a href="#万用表" class="headerlink" title="万用表"></a>万用表</h2>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>模电基础</tag>
      </tags>
  </entry>
  <entry>
    <title>BQ25700A</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/</url>
    <content><![CDATA[<p>BQ25700A 是德州仪器（Texas Instruments, TI）推出的一款高度集成的电源管理芯片，主要用于单节或多节电池充电管理。</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><p><strong>多源充电</strong>：支持从多种输入源为 1 至 4 节电池充电，输入电压范围为 3.5V 至 24V，兼容 USB 2.0、USB 3.0、USB 3.1 (Type-C) 和 USB_PD。</p>
<p><strong>功率管理</strong>：具有窄 VDC (NVDC) 电源路径管理，支持无电池或深度放电电池的瞬时启动，并能在适配器满载时由电池补充系统电量。</p>
<p><strong>USB OTG 功能</strong>：支持从电池为 USB 端口供电，输出电压范围为 4.48V 至 20.8V，兼容 USB PD，输出电流限制高达 6.35A。</p>
<p><strong>可编程开关频率</strong>：支持 800kHz 或 1.2MHz 的可编程开关频率，适用于 1μH 至 3.3μH 的电源器。</p>
<p><strong>系统配置与控制</strong>：通过 SMBus 端口实现灵活的系统配置和状态报告，支持硬件引脚设置输入电流限制，无需外部控制器。</p>
<p><strong>高精度监控</strong>：集成 ADC 监控电压、电流和功率，具有高精度的调节和监控功能。</p>
<p><strong>安全性</strong>：包括热关断、过电压保护和 MOSFET 电磁过流保护等多种安全特性。</p>
<p><strong>低静态电流</strong>：具有低电池静态电流，优化了电池使用效率。</p>
<p><strong>输入电流优化器</strong>：可获取最大输入功率，支持多种化学电池充电。(ICO)</p>
<p><strong>封装</strong>：采用 32 引脚 4 x 4 WOFN 封装。</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="left">引脚名称</th>
<th align="center">引脚编号</th>
<th align="center">输入&#x2F;输出</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">VBUS</td>
<td align="center">1</td>
<td align="center">PMR</td>
<td align="left">充电器输入电压。建议使用 12Ω 和 0.47µF（最小）的输入低通滤波器。</td>
</tr>
<tr>
<td align="left">ACN</td>
<td align="center">2</td>
<td align="center">PWR</td>
<td align="left">输入电流检测电阻负端输入。ACP 和 ACN 的漏电流匹配。ACP 和 ACN 引脚上的串联电阻放置在检测电阻和滤波电容之间。请参阅数据手册《应用与实现》中的 ACP&#x2F;ACN 滤波器设计。</td>
</tr>
<tr>
<td align="left">ACP</td>
<td align="center">3</td>
<td align="center">PWR</td>
<td align="left">输入电流检测电阻正端输入。ACP 和 ACN 的漏电流匹配。ACP 和 ACN 引脚上的串联电阻放置在检测电阻和滤波电容之间。请参阅数据手册《应用与实现》中的 ACP&#x2F;ACN 滤波器设计。</td>
</tr>
<tr>
<td align="left">CHRG_OK</td>
<td align="center">4</td>
<td align="center">O</td>
<td align="left">开漏主动高电平指示器，用于通知系统已连接到充电输入的良好电源。通过 10 kΩ 电阻连接到上拉电源轨。当 VBUS 上升到 3.5V 以上或下降到 24.5V 以下时，CHRG_OK 在 50ms 去抖时间后为高电平。当 VBUS 下降到 3.2V 以下或上升到 26V 以上时，CHRG_OK 为低电平。发生故障时，CHRG_OK 被置为低电平。</td>
</tr>
<tr>
<td align="left">EN_OTG</td>
<td align="center">5</td>
<td align="center">I</td>
<td align="left">高电平有效以启用 OTG 模式。当 EN_OTG 引脚为高电平且 REG0x32[13] 为高电平时，可以启用 OTG，请参阅 USB On-The-Go (OTG) 以了解如何启用 OTG 功能的详细信息。</td>
</tr>
<tr>
<td align="left">ILIM_HIZ</td>
<td align="center">6</td>
<td align="center">I</td>
<td align="left">输入电流限制输入。通过从电源轨到 ILIM_HIZ 引脚再到地的电阻分压器编程 ILIM_HIZ 电压。引脚电压计算为：V<sub>(ILIM_HIZ)</sub> &#x3D; 1V + 40 × IDPM × RAC，其中 IDPM 是目标输入电流。充电器使用的输入电流限制是 ILIM_HIZ 引脚和 REG0x3F() 的较低设置。当引脚电压低于 0.4V 时，设备进入高阻模式，静态电流低。当引脚电压高于 0.8V 时，设备退出高阻模式。</td>
</tr>
<tr>
<td align="left">VDDA</td>
<td align="center">7</td>
<td align="center">PMR</td>
<td align="left">内部参考偏置引脚。从 REGN 到 VDDA 连接一个 10Ω 电阻，并从 VDDA 到电源地连接一个 1µF 陶瓷电容。</td>
</tr>
<tr>
<td align="left">IADPT</td>
<td align="center">8</td>
<td align="center">I&#x2F;O</td>
<td align="left">缓冲的适配器电流输出。V<sub>(IADPT)</sub> &#x3D; 20 或 40 × (V<sub>(ACP)</sub> − V<sub>(ACN)</sub>)。比例可通过 REG0x12[4] 选择。根据使用的电感从 IADPT 引脚到地放置一个电阻。对于 2.2μH，电阻为 137kΩ。在 IADPT 引脚到地之间放置一个 100pF 或更小的陶瓷去耦电容。IADPT 输出电压被钳位在 3.3V 以下。</td>
</tr>
<tr>
<td align="left">IBAT</td>
<td align="center">9</td>
<td align="center">O</td>
<td align="left">由 SMBus 选择的缓冲电池电流。V<sub>(IBAT)</sub> &#x3D; 8 或 16 × (V<sub>(SRP)</sub>−V<sub>(SRN)</sub>) 用于充电电流，或 V<sub>(IBAT)</sub> &#x3D; 8 或 16 × (V<sub>(SRN)</sub>−V<sub>(SRP)</sub>) 用于放电电流，比例可通过 REG0x12[3] 选择。在 IBAT 引脚到地之间放置一个 100pF 或更小的陶瓷去耦电容。如果未使用，此引脚可以悬空。其输出电压被钳位在 3.3V 以下。</td>
</tr>
<tr>
<td align="left">PSYS</td>
<td align="center">10</td>
<td align="center">O</td>
<td align="left">电流模式系统功率监视器。输出电流与来自适配器和电池的总功率成正比。增益可通过 SMBus 选择。从 PSYS 到地放置一个电阻以生成输出电压。如果未使用，此引脚可以悬空。其输出电压被钳位在 3.3V 以下。在电阻上并联一个电容以进行滤波。</td>
</tr>
<tr>
<td align="left">PROCHOT</td>
<td align="center">11</td>
<td align="center">O</td>
<td align="left">处理器热指示器的低电平有效开漏输出。它监控适配器输入电流、电池放电电流和系统电压。在 PROCHOT 配置文件中的任何事件触发后，会发出一个脉冲。最小脉冲宽度可在 REG0x33[5:2] 中调整。</td>
</tr>
<tr>
<td align="left">SDA</td>
<td align="center">12</td>
<td align="center">I&#x2F;O</td>
<td align="left">SMBus 开漏数据 I&#x2F;O。连接到主机控制器或智能电池的数据线。根据 SMBus 规格连接一个 10kΩ 上拉电阻。</td>
</tr>
<tr>
<td align="left">SCL</td>
<td align="center">13</td>
<td align="center">I</td>
<td align="left">SMBus 时钟输入。连接到主机控制器或智能电池的时钟线。根据 SMBus 规格连接一个 10kΩ 上拉电阻。</td>
</tr>
<tr>
<td align="left">CMPIN</td>
<td align="center">14</td>
<td align="center">I</td>
<td align="left">独立比较器的输入。独立比较器将 CMPIN 引脚上的电压与内部参考电压进行比较，输出在 CMPOUT 引脚上。内部参考电压、输出极性和去抖时间可通过 SMBus 选择。当极性为高（REG0x30[6] &#x3D; 1）时，在 CMPIN 和 CMPOUT 之间放置一个电阻以设置滞后。当极性为低（REG0x30[6] &#x3D; 0）时，内部滞后为 100mV。如果独立比较器未使用，将 CMPIN 接地。</td>
</tr>
<tr>
<td align="left">CMPOUT</td>
<td align="center">15</td>
<td align="center">O</td>
<td align="left">独立比较器的开漏输出。从 CMPOUT 到上拉电源轨放置一个上拉电阻。内部参考电压、输出极性和去抖时间可通过 SMBus 选择。</td>
</tr>
<tr>
<td align="left">COMP1</td>
<td align="center">16</td>
<td align="center">I</td>
<td align="left">降压-升压转换器补偿引脚 1。请参阅 bq25700 EVM 原理图中的 COMP1 引脚 RC 网络。</td>
</tr>
<tr>
<td align="left">COMP2</td>
<td align="center">17</td>
<td align="center">I</td>
<td align="left">降压-升压转换器补偿引脚 2。请参阅 bq25700 EVM 原理图中的 COMP2 引脚 RC 网络。</td>
</tr>
<tr>
<td align="left">CELL_BATPRESZ</td>
<td align="center">18</td>
<td align="center">I</td>
<td align="left">电池单元选择引脚，用于 1-4 单元电池设置，CELL_BATPRESZ 引脚从 VDDA 偏置。CELL_BATPRESZ 引脚还将 SYSOVP 阈值设置为 1 单元时为 5V，2 单元时为 12V，3 单元&#x2F;4 单元时为 19.5V。CELL_BATPRESZ 引脚拉低至 V<sub>CELL_BATPRESZ_FALL</sub> 以下以指示电池移除。设备退出 LEARN 模式并禁用充电。REG0x15() 恢复为默认值。</td>
</tr>
<tr>
<td align="left">SRN</td>
<td align="center">19</td>
<td align="center">PMR</td>
<td align="left">充电电流检测电阻负端输入。SRN 引脚也用于电池电压检测。将 SRN 引脚与可选的 0.1 µF 陶瓷电容连接到 GND 以进行共模滤波。在 SRP 和 SRN 之间连接一个 0.1µF 陶瓷电容以提供差模滤波。SRP 和 SRN 的漏电流匹配。为防止反向电池插入，SRP 和 SRN 上放置了 10Ω 的串联电阻。</td>
</tr>
<tr>
<td align="left">SRP</td>
<td align="center">20</td>
<td align="center">PMR</td>
<td align="left">充电电流检测电阻正端输入。在 SRP 和 SRN 之间连接一个 0.1µF 陶瓷电容以提供差模滤波。SRP 和 SRN 的漏电流匹配。为防止反向电池插入，SRP 和 SRN 上放置了 10Ω 的串联电阻。将 SRP 引脚与可选的 0.1µF 陶瓷电容连接到 GND 以进行共模滤波。</td>
</tr>
<tr>
<td align="left">BATDRV</td>
<td align="center">21</td>
<td align="center">O</td>
<td align="left">P 沟道电池 FET (BATFET) 栅极驱动输出。短路到 VSYS 以关闭 BATFET。低于 VSYS 10V 以完全打开 BATFET。当电池耗尽时，BATFET 处于线性模式以调节 VSYS 至最小系统电压。在快速充电和补充模式下，BATFET 完全打开。</td>
</tr>
<tr>
<td align="left">VSYS</td>
<td align="center">22</td>
<td align="center">PMR</td>
<td align="left">充电器系统电压检测。系统电压调节限制在 REG(x15f) 和 REG(x3Ef) 中编程。</td>
</tr>
<tr>
<td align="left">SW2</td>
<td align="center">23</td>
<td align="center">PMR</td>
<td align="left">升压模式高侧功率 MOSFET 驱动器源极。连接到高侧 n 沟道 MOSFET 的源极。</td>
</tr>
<tr>
<td align="left">HIDRV2</td>
<td align="center">24</td>
<td align="center">O</td>
<td align="left">升压模式高侧功率 MOSFET (Q4) 驱动器。连接到高侧 n 沟道 MOSFET 栅极。</td>
</tr>
<tr>
<td align="left">BTST2</td>
<td align="center">25</td>
<td align="center">PWR</td>
<td align="left">升压模式高侧功率 MOSFET 驱动器电源。在 SW2 和 BTST2 之间连接一个 0.047 µF 电容。REGN 和 BTST2 之间的自举二极管已集成。</td>
</tr>
<tr>
<td align="left">LODRV2</td>
<td align="center">26</td>
<td align="center">O</td>
<td align="left">升压模式低侧功率 MOSFET (Q3) 驱动器。连接到低侧 n 沟道 MOSFET 栅极。</td>
</tr>
<tr>
<td align="left">PGND</td>
<td align="center">27</td>
<td align="center">GND</td>
<td align="left">设备电源地。</td>
</tr>
<tr>
<td align="left">REGN</td>
<td align="center">28</td>
<td align="center">PWR</td>
<td align="left">6 V 线性稳压器输出，由 VBUS 或 VSYS 供电。当 VBUS 高于 VVBUS<em>V<strong>V</strong>B<strong>U</strong>S</em> 凸点时，LDO 处于活动状态。从 REGN 到电源地连接一个 2.2 或 3.3μF 陶瓷电容。REGN 引脚输出用于电源级栅极驱动。</td>
</tr>
<tr>
<td align="left">LODRV1</td>
<td align="center">29</td>
<td align="center">O</td>
<td align="left">降压模式低侧功率 MOSFET (Q2) 驱动器。连接到低侧 n 沟道 MOSFET 栅极。</td>
</tr>
<tr>
<td align="left">BTST1</td>
<td align="center">30</td>
<td align="center">PWR</td>
<td align="left">降压模式高侧功率 MOSFET 驱动器电源。在 SW1 和 BTST1 之间连接一个 0.047µF 电容。REGN 和 BTST1 之间的自举二极管已集成。</td>
</tr>
<tr>
<td align="left">HIDRV1</td>
<td align="center">31</td>
<td align="center">O</td>
<td align="left">降压模式高侧功率 MOSFET (Q1) 驱动器。连接到高侧 n 沟道 MOSFET 栅极。</td>
</tr>
<tr>
<td align="left">SW1</td>
<td align="center">32</td>
<td align="center">PMR</td>
<td align="left">降压模式高侧功率 MOSFET 驱动器源极。连接到高侧 n 沟道 MOSFET 的源极。</td>
</tr>
<tr>
<td align="left">热焊盘</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="left">IC 下方的裸露焊盘。模拟地和电源地在 IC 的地附近星形连接。始终将热焊盘焊接到电路板上，并在热焊盘平面上设置通孔连接到电源地平面。它还用作散热焊盘以散发热量。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>PMR</strong>：这通常表示“Power Management Rail”（电源管理轨），指的是与电源管理相关的引脚。这些引脚通常用于电源输入、输出或电源管理功能。</p>
<p><strong>PWR</strong>：表示“Power”（电源），指的是与电源相关的引脚，如电源输入、电源输出或电源参考电压。</p>
<p><strong>I</strong>：表示“Input”（输入），指的是该引脚用于输入信号或电压。</p>
<p><strong>O</strong>：表示“Output”（输出），指的是该引脚用于输出信号或电压。</p>
<p><strong>I&#x2F;O</strong>：表示“Input&#x2F;Output”（输入&#x2F;输出），指的是该引脚既可以作为输入也可以作为输出。</p>
</blockquote>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/sldl.png" alt="sldl"></p>
<blockquote>
<p><strong>BATDRV</strong>：这个引脚控制电池的充电和放电，通过电流控制电池的充电过程。</p>
<p><strong>VSYS</strong>：通过这个引脚，芯片可以向外部电路（比如主控 MCU）提供电源。当充电过程进行时，它可以从电池获取电源。</p>
<p><strong>SRP&#x2F;SRN</strong>：这两个引脚用于电池电压和充电电流的监测，可以帮助芯片评估电池的状态，并根据电池的健康状况调整充电策略。</p>
<p><strong>CELL_BATPRESZ</strong>：这是一个电池存在检测引脚，可以检测电池是否存在或是否正常连接。</p>
<p><strong>SDA</strong> 和 <strong>SCL</strong>：这两个引脚用于与主控 MCU 进行通信。它们支持 <strong>SMBus</strong> 协议，允许主控读取或写入 BQ25700A 的寄存器，从而控制充电参数或读取电池状态。</p>
<p><strong>Host</strong>：通过 I2C（或 SMBus）接口，主控设备可以与 BQ25700A 进行数据交互，例如设置充电电流、电压、监测电池的健康状态等。</p>
<p><strong>REGN</strong>：这是一个用于电压稳定的参考电压引脚，可以为其他相关电路提供稳定的电源。</p>
<p><strong>COMP1 和 COMP2</strong>：这些引脚用于电流控制，芯片通过它们调整充电电流，使电池的充电过程更平稳、避免过充或过流。</p>
<p><strong>ILIM_HIZ</strong>：这个引脚控制充电电流的限制，防止电池被过快充电。</p>
<p><strong>CHRG_OK</strong>：这个引脚指示充电是否正常，当充电完成时会发出信号。</p>
<p><strong>CMPIN</strong>：用于保护电池免受过压或过温影响。</p>
</blockquote>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p><strong>BQ25700A</strong> 电池管理芯片通过 <strong>SMBus</strong> （System Management Bus）进行通信，它与主控 MCU（如微控制器）之间的通信方式与 I2C 非常相似。SMBus 是 I2C 的一种扩展协议，专门用于电池、温控、电源管理等硬件设备的通信。</p>
<p>如果主控没有直接支持 <strong>SMBus</strong> 协议，但你仍然想与 <strong>BQ25700A</strong> 通信，实际上可以通过 <strong>I2C</strong> 接口来实现通信，因为 <strong>SMBus</strong> 基于 <strong>I2C</strong> 协议，它们在物理层面上是兼容的。</p>
<p> BQ25700A 的 SMBus 地址是 <strong>0x12</strong>（7 位地址）。</p>
<h3 id="写入格式"><a href="#写入格式" class="headerlink" title="写入格式"></a>写入格式</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/xrgs.png" alt="xrgs"></p>
<blockquote>
<p>S (Start Condition)：表示起始条件，主设备发出一个信号，表明通信的开始。</p>
<p>SLAVE ADDRESS：从设备的地址（7位），标识目标设备。</p>
<p>W (Write bit)：写入位，值为 0，表示写操作。</p>
<p>ACK (Acknowledge)：应答信号，接收设备确认收到数据。</p>
<p>COMMAND BYTE：命令字节，主设备向从设备发送的命令，用于指示操作的类型或目标寄存器。</p>
<p>LOW DATA BYTE 和 HIGH DATA BYTE：分别是数据的低字节和高字节。在一个完整的数据传输中，数据被分为低字节和高字节，逐字节传输。</p>
<p>P (Stop Condition)：停止条件，表示通信的结束</p>
</blockquote>
<p><strong>写入时序图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/xrsst.png" alt="xrsst"></p>
<blockquote>
<p><strong>A &#x3D; Start condition（起始条件）</strong>：</p>
<ul>
<li>当通信开始时，主设备在 SMBCLK 为高电平时，SMBDATA 从高电平变为低电平。这个状态表示开始一个新的通信会话。</li>
</ul>
<p><strong>B &#x3D; MSB of address clocked into slave（地址的高位字节被时钟同步到从设备）</strong>：</p>
<ul>
<li>在主设备发送起始信号后，主设备开始向从设备发送地址的高位字节。此时，SMBDATA 会根据时钟信号（SMBCLK）同步传输数据。</li>
</ul>
<p><strong>C &#x3D; LSB of address clocked into slave（地址的低位字节被时钟同步到从设备）</strong>：</p>
<ul>
<li>继续传送从设备的地址，此时传送的是地址的低位字节。</li>
</ul>
<p><strong>D &#x3D; R&#x2F;W bit clocked into slave（读写位被时钟同步到从设备）</strong>：</p>
<ul>
<li>主设备发送读写控制位，指定当前操作是读取还是写入。读写位（R&#x2F;W）在这个阶段通过 SMBDATA 传送给从设备。</li>
</ul>
<p><strong>E &#x3D; Slave pulls SMBDATA line low（从设备将 SMBDATA 拉低）</strong>：</p>
<ul>
<li>从设备确认接收到主设备发出的地址和读写位后，它会拉低数据线，表示准备好接收数据或者准备发送数据。</li>
</ul>
<p><strong>F &#x3D; ACKNOWLEDGE bit clocked into master（主设备接收到的应答位）</strong>：</p>
<ul>
<li>从设备通过拉低 SMBDATA 线来确认它已成功接收到主设备发送的数据或命令。</li>
</ul>
<p><strong>G &#x3D; MSB of data clocked into slave（数据的高位字节被时钟同步到从设备）</strong>：</p>
<ul>
<li>主设备将要写入的数据的高位字节通过 SMBCLK 时钟信号发送到从设备。SMBDATA 数据线同步传送。</li>
</ul>
<p><strong>H &#x3D; LSB of data clocked into slave（数据的低位字节被时钟同步到从设备）</strong>：</p>
<ul>
<li>数据的低位字节被发送到从设备，继续通过 SMBDATA 进行传输。</li>
</ul>
<p><strong>I &#x3D; Slave pulls SMBDATA line low（从设备将 SMBDATA 拉低）</strong>：</p>
<ul>
<li>从设备确认已接收到数据的低位字节，再次拉低数据线进行应答。</li>
</ul>
<p><strong>J &#x3D; Acknowledge clocked into master（主设备接收到的应答信号）</strong>：</p>
<ul>
<li>主设备通过时钟信号接收到从设备的确认信号，表明数据已成功传输。</li>
</ul>
<p><strong>K &#x3D; Acknowledge clock pulse（应答时钟脉冲）</strong>：</p>
<ul>
<li>这表示主设备在通信过程中接收来自从设备的确认信号的时钟脉冲。</li>
</ul>
<p><strong>L &#x3D; Stop condition, data executed by slave（停止条件，数据由从设备执行）</strong>：</p>
<ul>
<li>在所有数据传输完成后，主设备发出停止条件（Stop condition），这标志着通信会话的结束。从设备会根据收到的数据执行操作。</li>
</ul>
<p><strong>M &#x3D; New start condition（新的起始条件）</strong>：</p>
<ul>
<li>如果主设备需要重新启动一个新的通信会话，它可以发出新的起始条件（Start condition）。</li>
</ul>
</blockquote>
<h3 id="读取格式"><a href="#读取格式" class="headerlink" title="读取格式"></a>读取格式</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/dqgs.png" alt="dqgs"></p>
<blockquote>
<p>S (Start Condition)：表示起始条件，主设备发出一个信号，表明通信的开始。</p>
<p>SLAVE ADDRESS：从设备的地址（7位），标识目标设备。</p>
<p>R (Read bit)：读取位，值为 1，表示读操作。</p>
<p>ACK (Acknowledge)：应答信号，接收设备确认收到数据。</p>
<p>LOW DATA BYTE 和 HIGH DATA BYTE：分别是数据的低字节和高字节。从设备返回的数据被分为低字节和高字节，主设备逐字节读取。</p>
<p>NACK (Not Acknowledge)：非应答信号，表示读取完毕或传输结束。</p>
<p>P (Stop Condition)：停止条件，表示通信的结束。</p>
</blockquote>
<p><strong>读取时序图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/BQ25700A/dqsst.png" alt="dqsst"></p>
<blockquote>
<p><strong>A &#x3D; Start condition</strong>: 这是传输开始的标志，数据线从高电平跳到低电平。</p>
<p><strong>B &#x3D; MSB of address clocked into slave</strong>: 这是传输地址的最高有效位（MSB），被时钟信号驱动传送给从设备。</p>
<p><strong>C &#x3D; LSB of address clocked into slave</strong>: 地址的最低有效位（LSB）被传送给从设备。</p>
<p><strong>D &#x3D; R&#x2F;W bit clocked into slave</strong>: 读写控制位（R&#x2F;W）传送给从设备，决定是读操作还是写操作。</p>
<p><strong>E &#x3D; Slave pulls SMBDATA line low</strong>: 从设备拉低数据线，表示准备响应。</p>
<p><strong>F &#x3D; ACKNOWLEDGE bit clocked into master</strong>: 主设备收到从设备的响应，表示数据有效。</p>
<p><strong>G &#x3D; MSB of data clocked into master</strong>: 数据的最高有效位（MSB）被传送给主设备。</p>
<p><strong>H &#x3D; LSB of data clocked into master</strong>: 数据的最低有效位（LSB）被传送给主设备。</p>
<p><strong>I &#x3D; Acknowledge clock pulse</strong>: 主设备发出时钟脉冲，从设备回传响应信号。</p>
<p><strong>J &#x3D; Stop condition</strong>: 这是传输的停止条件，数据线从低电平跳到高电平，表示数据传输结束。</p>
<p><strong>K &#x3D; New start condition</strong>: 新的起始条件，表示将开始新的数据传输</p>
</blockquote>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><table>
<thead>
<tr>
<th align="left">SMBus 地址</th>
<th align="left">寄存器名称</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">12h</td>
<td align="left">ChargeOption00</td>
<td align="left">读写</td>
<td align="left">充电选项 0</td>
</tr>
<tr>
<td align="left">14h</td>
<td align="left">ChargeCurrent</td>
<td align="left">读写</td>
<td align="left">7 位充电电流设置，LSB 64mA，范围 8128mA</td>
</tr>
<tr>
<td align="left">15h</td>
<td align="left">MaxChargeVoltage</td>
<td align="left">读写</td>
<td align="left">11 位充电电压设置，LSB 16mV，默认值：1S-4192mV, 2S-8400mV, 3S-12592mV, 4S-16800mV</td>
</tr>
<tr>
<td align="left">30h</td>
<td align="left">ChargeOption10</td>
<td align="left">读写</td>
<td align="left">充电选项 1</td>
</tr>
<tr>
<td align="left">31h</td>
<td align="left">ChargeOption20</td>
<td align="left">读写</td>
<td align="left">充电选项 2</td>
</tr>
<tr>
<td align="left">32h</td>
<td align="left">ChargeOption30</td>
<td align="left">读写</td>
<td align="left">充电选项 3</td>
</tr>
<tr>
<td align="left">33h</td>
<td align="left">ProchotOption00</td>
<td align="left">读写</td>
<td align="left">PROCHOT 选项 0</td>
</tr>
<tr>
<td align="left">34h</td>
<td align="left">ProchotOption10</td>
<td align="left">读写</td>
<td align="left">PROCHOT 选项 1</td>
</tr>
<tr>
<td align="left">35h</td>
<td align="left">ADCOption</td>
<td align="left">读写</td>
<td align="left">ADC 选项</td>
</tr>
<tr>
<td align="left">20h</td>
<td align="left">ChargerStatus</td>
<td align="left">只读</td>
<td align="left">充电状态</td>
</tr>
<tr>
<td align="left">21h</td>
<td align="left">ProchotStatus</td>
<td align="left">只读</td>
<td align="left">PROCHOT 状态</td>
</tr>
<tr>
<td align="left">22h</td>
<td align="left">IIN_DPM</td>
<td align="left">只读</td>
<td align="left">7 位输入电流限制，LSB 50mA，范围 50mA - 6400mA</td>
</tr>
<tr>
<td align="left">23h</td>
<td align="left">ADCVBUS&#x2F;PSYS</td>
<td align="left">只读</td>
<td align="left">输入电压的 8 位数字输出，系统功率 PSYS 的 8 位数字输出，PSYS 全范围：3.06V，LSB 12 mV，VBUS 全范围：3.2V - 19.52V，LSB 64mV</td>
</tr>
<tr>
<td align="left">24h</td>
<td align="left">ADCIBAT</td>
<td align="left">只读</td>
<td align="left">电池充电电流的 8 位数字输出，电池放电电流的 8 位数字输出，ICHC 全范围 8.128A，LSB 64mA，IDCHG 全范围：32.512A，LSB 256mA</td>
</tr>
<tr>
<td align="left">25h</td>
<td align="left">ADCIN&#x2F;CMPIN</td>
<td align="left">只读</td>
<td align="left">输入电流的 8 位数字输出，CMPIN 电压的 8 位数字输出，POR 状态 - IN 全范围：12.75 A，LSB 50mA，CMPIN 全范围：3.06V，LSB 12mV</td>
</tr>
<tr>
<td align="left">26h</td>
<td align="left">ADCVSYSVBAT</td>
<td align="left">只读</td>
<td align="left">系统电压的 8 位数字输出，电池电压的 8 位数字输出，VSYS 全范围：2.88V - 19.2V，LSB 64 mV，VBAT 全范围：2.88V - 19.2V，LSB 64mV</td>
</tr>
<tr>
<td align="left">38h</td>
<td align="left">OTGVoltage</td>
<td align="left">读写</td>
<td align="left">8 位 OTG 电压设置，LSB 64mV，范围：4480 – 20800mV</td>
</tr>
<tr>
<td align="left">3Ch</td>
<td align="left">OTGCurrent</td>
<td align="left">读写</td>
<td align="left">7 位 OTG 输出电流设置，LSB 50mA，范围：0A – 6350mA</td>
</tr>
<tr>
<td align="left">3Dh</td>
<td align="left">InputVoltage</td>
<td align="left">读写</td>
<td align="left">8 位输入电压设置，LSB64 mV，范围：3200mV – 19520mV</td>
</tr>
<tr>
<td align="left">3Eh</td>
<td align="left">MinSystemVoltage</td>
<td align="left">读写</td>
<td align="left">6 位最小系统电压设置，LSB 256mV，范围：1024mV - 16182mV，默认值：1S-3.584V, 2S-6.144V, 3S-9.216V, 4S-12.288V</td>
</tr>
<tr>
<td align="left">3Fh</td>
<td align="left">IIN_HOST</td>
<td align="left">读写</td>
<td align="left">主机设置的 6 位输入电流限制，LSB 50mA，范围：50 mA - 6400mA</td>
</tr>
<tr>
<td align="left">FEn</td>
<td align="left">ManufacturerID</td>
<td align="left">只读</td>
<td align="left">制造商 ID - 0x0040H</td>
</tr>
<tr>
<td align="left">FFh</td>
<td align="left">DeviceID</td>
<td align="left">只读</td>
<td align="left">设备 ID</td>
</tr>
</tbody></table>
<p>具体描述请查看数据手册。</p>
<h2 id="示例驱动"><a href="#示例驱动" class="headerlink" title="示例驱动"></a>示例驱动</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>CS47L35</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/CS47L35/</url>
    <content><![CDATA[<p>CS47L35 是 Cirrus Logic 推出的一款高性能、低功耗音频编解码器（Audio Codec），专为智能手机、可穿戴设备、蓝牙耳机、智能音箱等音频设备设计。它集成了高品质的 DAC（数字-模拟转换）、ADC（模拟-数字转换）、低功耗 DSP（数字信号处理器）和语音增强功能，支持多种音频输入&#x2F;输出接口，能够实现高质量音频播放、录音、降噪和回声消除等功能。</p>
<h2 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h2><p><strong>模拟电源（AVDD）</strong>：1.7V ~ 1.9V</p>
<p><strong>数字核心电源（DBVDD）</strong>：1.2V</p>
<p><strong>I&#x2F;O 电源（IOVDD）</strong>：1.8V 或 3.3V</p>
<p><strong>耳机驱动电源（HPVDD）</strong>：2.5V ~ 5V（典型 3.3V）</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/CS47L35/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th><strong>引脚名称</strong></th>
<th><strong>引脚编号</strong></th>
<th><strong>功率供应</strong></th>
<th><strong>I&#x2F;O 类型</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP1C1A</strong></td>
<td>E5</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 正向电容引脚 1。</td>
</tr>
<tr>
<td><strong>CP1C1B</strong></td>
<td>D6</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 正向电容引脚 2</td>
</tr>
<tr>
<td><strong>CP1C2A</strong></td>
<td>C5</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 反向电容引脚 1。</td>
</tr>
<tr>
<td><strong>CP1C2B</strong></td>
<td>B8</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 反向电容引脚 2。</td>
</tr>
<tr>
<td><strong>CP1VOUT1P</strong></td>
<td>E7</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 输出正电压。</td>
</tr>
<tr>
<td><strong>CP1VOUT1N</strong></td>
<td>F8</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 输出负电压。</td>
</tr>
<tr>
<td><strong>CP1VOUT2P</strong></td>
<td>A7</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 正向电压输出 2。</td>
</tr>
<tr>
<td><strong>CP1VOUT2N</strong></td>
<td>D8</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 1 反向电压输出 2。</td>
</tr>
<tr>
<td><strong>CP2CA</strong></td>
<td>G7</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 2 正向电容引脚。</td>
</tr>
<tr>
<td><strong>CP2CB</strong></td>
<td>G5</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 2 反向电容引脚。</td>
</tr>
<tr>
<td><strong>CP2VOUT</strong></td>
<td>F4</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>电荷泵 2 输出电压供电&#x2F;解耦。</td>
</tr>
<tr>
<td><strong>EPOUTN</strong></td>
<td>C9</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>耳机输出负电压。</td>
</tr>
<tr>
<td><strong>EPOUTP</strong></td>
<td>A9</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>耳机输出正电压。</td>
</tr>
<tr>
<td><strong>GPSWN</strong></td>
<td>G9</td>
<td>I&#x2F;O</td>
<td>General I&#x2F;O</td>
<td>通用双向开关引脚。</td>
</tr>
<tr>
<td><strong>GPSWP</strong></td>
<td>F10</td>
<td>I&#x2F;O</td>
<td>General I&#x2F;O</td>
<td>通用双向开关引脚。</td>
</tr>
<tr>
<td><strong>HPDET</strong></td>
<td>C11</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>耳机输入检测。</td>
</tr>
<tr>
<td><strong>HPOUTL</strong></td>
<td>B12</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>左耳机输出输入。</td>
</tr>
<tr>
<td><strong>HPOUTR</strong></td>
<td>A11</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>右耳机输出输入。</td>
</tr>
<tr>
<td><strong>HPOUT</strong></td>
<td>D12</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>耳机输出反馈引脚，连接外部麦克风及耳机输入。</td>
</tr>
<tr>
<td><strong>IN1ALP</strong></td>
<td>E3</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>左通道单端输入&#x2F;左通道正向输入信号。</td>
</tr>
<tr>
<td><strong>IN1ALP</strong></td>
<td>G3</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>左通道单端输入&#x2F;左通道正向输入信号。</td>
</tr>
<tr>
<td><strong>IN1BRP</strong></td>
<td>H2</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>右通道单端输入&#x2F;右通道正向输入信号。</td>
</tr>
<tr>
<td><strong>IN2BLP</strong></td>
<td>H4</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>左通道负向输入信号。</td>
</tr>
<tr>
<td><strong>IN2BRP</strong></td>
<td>H6</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>右通道负向输入信号。</td>
</tr>
<tr>
<td><strong>IN2ALP</strong></td>
<td>K6</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>左通道负向输入信号。</td>
</tr>
<tr>
<td><strong>IN2BRP</strong></td>
<td>K7</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>右通道负向输入信号。</td>
</tr>
<tr>
<td><strong>IN2LP</strong></td>
<td>K4</td>
<td>MICVDD</td>
<td>I</td>
<td>左通道单端麦克风输入&#x2F;左通道正向差分输入信号。</td>
</tr>
<tr>
<td><strong>IN2RN&#x2F;DMICDAT2</strong></td>
<td>E1</td>
<td>MICVDD 或 MICBIASn</td>
<td>I</td>
<td>右通道单端麦克风输入&#x2F;右通道正向差分输入信号。</td>
</tr>
<tr>
<td><strong>IN2RP</strong></td>
<td>F2</td>
<td>MICVDD</td>
<td>I</td>
<td>右通道单端麦克风输入&#x2F;右通道正向差分输入信号。</td>
</tr>
<tr>
<td><strong>JACKDET1</strong></td>
<td>D10</td>
<td>AVDD</td>
<td>I</td>
<td>插孔检测输入 1。</td>
</tr>
<tr>
<td><strong>JACKDET2</strong></td>
<td>H10</td>
<td>AVDD</td>
<td>I</td>
<td>插孔检测输入 2。</td>
</tr>
<tr>
<td><strong>MICBISA1</strong></td>
<td>A1</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>麦克风偏置 1A。</td>
</tr>
<tr>
<td><strong>MICBISA1B</strong></td>
<td>A3</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>麦克风偏置 1B。</td>
</tr>
<tr>
<td><strong>MICBISA2</strong></td>
<td>B2</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>麦克风偏置 2A。</td>
</tr>
<tr>
<td><strong>MICBISA2B</strong></td>
<td>C3</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>麦克风偏置 2B。</td>
</tr>
<tr>
<td><strong>MICDET1&#x2F;HPOUTFB2</strong></td>
<td>E11</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>麦克风和配件传感器输入，连接到 1&#x2F;HPOUTL 和 HPOUTR 地线反馈。</td>
</tr>
<tr>
<td><strong>MICVDD</strong></td>
<td>B4</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>LDO 输出解耦引脚（由 CS47L35 内部生成）。可用于外部麦克风的参考&#x2F;供电。</td>
</tr>
<tr>
<td><strong>SPKOUT</strong></td>
<td>P2</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>扬声器负输出。</td>
</tr>
<tr>
<td><strong>SPKOUT</strong></td>
<td>T2</td>
<td>O</td>
<td>Analog I&#x2F;O</td>
<td>扬声器正输出。</td>
</tr>
<tr>
<td><strong>VREFC</strong></td>
<td>J1</td>
<td>I</td>
<td>Analog I&#x2F;O</td>
<td>带隙参考电容连接。</td>
</tr>
<tr>
<td><strong>AIF1BCLK&#x2F;GPIO</strong></td>
<td>T12</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>音频接口 1 帧时钟&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；BCLK 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF1LRCLK&#x2F;GPIO</strong></td>
<td>R11</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>音频接口 1 左右时钟&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；LRCLK 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF1RXDAT&#x2F;GPIO</strong></td>
<td>P10</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>音频接口 1 RX 数字音频数据&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；TXDAT 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF1TXDAT&#x2F;GPIO</strong></td>
<td>T10</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>音频接口 1 TX 数字音频数据&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；TXDAT 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF2BCLK&#x2F;GPIO</strong></td>
<td>P6</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>音频接口 2 帧时钟&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；BCLK 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF2LRCLK&#x2F;GPIO</strong></td>
<td>M6</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>音频接口 2 左右时钟&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；LRCLK 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF2RXDAT&#x2F;GPIO</strong></td>
<td>P8</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>音频接口 2 RX 数字音频数据&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；TXDAT 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF2TXDAT&#x2F;GPIO</strong></td>
<td>M10</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>音频接口 2 TX 数字音频数据&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；TXDAT 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF3BCLK&#x2F;GPIO</strong></td>
<td>R5</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>音频接口 3 帧时钟&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；BCLK 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>AIF3RXDAT&#x2F;GPIO</strong></td>
<td>N5</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>音频接口 3 RX 数字音频数据&#x2F;GPIO。GPIO 输出可以选择 CMOS 或开漏；TXDAT 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>CIF1MSIO</strong></td>
<td>M10</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>控制接口 1 SPI 主模式与从模式。CIF1S 时钟在未选择时为高阻态。</td>
</tr>
<tr>
<td><strong>CIF1SCLK</strong></td>
<td>L9</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>控制接口 1 SPI 时钟。CIF1S 时钟在未选择时为高阻态。</td>
</tr>
<tr>
<td><strong>CIF1CSLCK</strong></td>
<td>K7</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>控制接口 1 SPI 片选信号。</td>
</tr>
<tr>
<td><strong>CIF2SDA</strong></td>
<td>N11</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>控制接口 2 (I²C) 数据输入输出。SDA 输出为开漏。</td>
</tr>
<tr>
<td><strong>IRQ</strong></td>
<td>J9</td>
<td>DBVDD1</td>
<td>I</td>
<td>中断请求输出（低电平有效）。引脚配置可选择 CMOS 或开漏。</td>
</tr>
<tr>
<td><strong>MCLK1</strong></td>
<td>M12</td>
<td>DBVDD1</td>
<td>I</td>
<td>主时钟输入 1。</td>
</tr>
<tr>
<td><strong>MCLK2</strong></td>
<td>T6</td>
<td>DBVDD2</td>
<td>I</td>
<td>主时钟输入 2。</td>
</tr>
<tr>
<td><strong>MIF1SCLK&#x2F;GPIO</strong></td>
<td>T8</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>控制接口 1 时钟输出&#x2F;GPIO。GPIO 输出可选择 CMOS 或开漏；SCLK 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>MIF1SDA&#x2F;GPIO</strong></td>
<td>P6</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>控制接口 1 数据输入&#x2F;GPIO。GPIO 输出可选择 CMOS 或开漏；SDA 输出为开漏。</td>
</tr>
<tr>
<td><strong>RESET</strong></td>
<td>H8</td>
<td>DBVDD1</td>
<td>I</td>
<td>数字复位输入（激活有效）。</td>
</tr>
<tr>
<td><strong>SLIMCLK</strong></td>
<td>R9</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>SLIMbus 时钟输入输出。</td>
</tr>
<tr>
<td><strong>SLIMDAT</strong></td>
<td>N9</td>
<td>DBVDD1</td>
<td>I&#x2F;O</td>
<td>SLIMbus 数据输入输出。</td>
</tr>
<tr>
<td><strong>SPKDAT&#x2F;GPIO</strong></td>
<td>N3</td>
<td>DBVDD2</td>
<td>I&#x2F;O</td>
<td>数字扬声器 (PDM) 数据输出&#x2F;GPIO。GPIO 输出可选择 CMOS 或开漏；SPKDAT 输出为 CMOS。</td>
</tr>
<tr>
<td><strong>TCK</strong></td>
<td>R7</td>
<td>DBVDD2</td>
<td>I</td>
<td>JTAG 时钟输入。内部下拉保持此引脚为逻辑 0，正常工作时有效。</td>
</tr>
<tr>
<td><strong>TDI</strong></td>
<td>N7</td>
<td>DBVDD2</td>
<td>I</td>
<td>JTAG 数据输入。内部下拉保持此引脚为逻辑 0，正常工作时有效。</td>
</tr>
<tr>
<td><strong>TDO</strong></td>
<td>L7</td>
<td>DBVDD2</td>
<td>O</td>
<td>JTAG 数据输出。</td>
</tr>
<tr>
<td><strong>TMS</strong></td>
<td>K8</td>
<td>DBVDD2</td>
<td>I</td>
<td>JTAG 模式选择输入。内部下拉保持此引脚为逻辑 0，正常工作时有效。</td>
</tr>
<tr>
<td><strong>TRST</strong></td>
<td>M8</td>
<td>DBVDD2</td>
<td>I</td>
<td>JTAG 复位输入（激活有效）。内部下拉保持此引脚为逻辑 0，正常工作时有效。</td>
</tr>
<tr>
<td><strong>AGND1</strong></td>
<td>L1</td>
<td>—</td>
<td>I</td>
<td>模拟接地（返回 AVDD1）。</td>
</tr>
<tr>
<td><strong>AGND2</strong></td>
<td>E9</td>
<td>—</td>
<td>I</td>
<td>模拟接地（返回 AVDD2）。</td>
</tr>
<tr>
<td><strong>AVDD1</strong></td>
<td>K2</td>
<td>—</td>
<td>O</td>
<td>模拟电源 1。</td>
</tr>
<tr>
<td><strong>AVDD2</strong></td>
<td>F12</td>
<td>—</td>
<td>O</td>
<td>模拟电源 2。</td>
</tr>
<tr>
<td><strong>CPVDD</strong></td>
<td>D6</td>
<td>—</td>
<td>O</td>
<td>电荷泵电源，供给电荷泵 1 和电荷泵 2。</td>
</tr>
<tr>
<td><strong>DBVDD1</strong></td>
<td>U11</td>
<td>—</td>
<td>O</td>
<td>数字电源（供音频接口、SLIMbus、控制接口等使用）。</td>
</tr>
<tr>
<td><strong>DBVDD2</strong></td>
<td>U5</td>
<td>—</td>
<td>O</td>
<td>数字电源（供音频接口、SLIMbus、控制接口等使用）。</td>
</tr>
<tr>
<td><strong>DCVDD</strong></td>
<td>U7</td>
<td>—</td>
<td>—</td>
<td>数字核心电源供应。</td>
</tr>
<tr>
<td><strong>DGND</strong></td>
<td>J11, T4, U9</td>
<td>—</td>
<td>—</td>
<td>数字地（DCVDD 和 DBVDDn 的返回路径）。</td>
</tr>
<tr>
<td><strong>FLLVDD</strong></td>
<td>K12</td>
<td>—</td>
<td>—</td>
<td>模拟电源（用于 FLL1）。</td>
</tr>
<tr>
<td><strong>SPKGNDN</strong></td>
<td>R3</td>
<td>—</td>
<td>—</td>
<td>扬声器驱动地（SPKVDD 的返回路径）。¹</td>
</tr>
<tr>
<td><strong>SPKGNDP</strong></td>
<td>U3</td>
<td>—</td>
<td>—</td>
<td>扬声器驱动地（SPKVDD 的返回路径）。¹</td>
</tr>
<tr>
<td><strong>SPKVDD</strong></td>
<td>R1, U1</td>
<td>—</td>
<td>—</td>
<td>扬声器驱动电源供应。</td>
</tr>
<tr>
<td><strong>SUBGND</strong></td>
<td>H12, N1</td>
<td>—</td>
<td>—</td>
<td>基板地（Substrate ground）。</td>
</tr>
<tr>
<td><strong>NC</strong></td>
<td>D4, H6, J5, J7</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>本芯片 <strong>CS47L35</strong> 具有丰富的 <strong>音频输入&#x2F;输出接口</strong>、<strong>GPIO</strong>、<strong>I²C&#x2F;SPI 控制接口</strong> 以及 <strong>JTAG 调试接口</strong>，并配备多种 <strong>电源管理和地连接</strong>。主要特点：</p>
<ul>
<li><strong>支持模拟和数字麦克风输入</strong></li>
<li><strong>具备 3 组 I²S 接口，可用于音频数据传输</strong></li>
<li><strong>内置 PDM 扬声器接口</strong></li>
<li><strong>提供 SPI 和 I²C 作为控制接口</strong></li>
<li><strong>具备 JTAG 调试支持</strong></li>
<li><strong>内置充电泵、多个电源域，提高功耗管理</strong></li>
</ul>
</blockquote>
<h2 id="应用电路"><a href="#应用电路" class="headerlink" title="应用电路"></a>应用电路</h2><p>典型应用电路</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/CS47L35/yydl.png" alt="yydl"></p>
<blockquote>
<p><strong>DVDD、DBVDD、FLVDD（1.2V）</strong>：芯片的 <strong>数字核心供电</strong>，通常由 LDO 或 DCDC 提供。</p>
<p><strong>AVDD（1.8V）</strong>：<strong>模拟电路供电</strong>，驱动麦克风偏置和 ADC。</p>
<p><strong>CPVDD（2.5V~4V）</strong>：内部 <strong>电荷泵供电</strong>，用于耳机放大。</p>
<p><strong>SPKVDD（3.3V~5V）</strong>：提供扬声器输出的电源。</p>
<p><strong>电源去耦电容</strong>（如 4.7µF、1µF）：用于降低电源噪声。</p>
<p><strong>RESET</strong>：复位引脚，通常连接到 MCU 以进行芯片复位。</p>
<p><strong>IRQ</strong>：中断信号输出，可通知 MCU 处理特定事件。</p>
<p>SLIMBus &#x2F; I²S（AIFxBCLK、AIFxLRCLK、AIFxRXDAT、AIFxTXDAT）</p>
<ul>
<li>该芯片支持 <strong>SLIMBus 和 I²S&#x2F;TDM 接口</strong>，用于音频数据传输。</li>
<li><strong>I²S 用于与 MCU 或 DSP 通信</strong>，传输麦克风和扬声器数据。</li>
</ul>
<p><strong>麦克风输入（MICBIAS、IN1A&#x2F;IN1B、IN2A&#x2F;IN2B）</strong></p>
<ul>
<li>支持 <strong>差分麦克风</strong> 和 <strong>单端麦克风</strong>。</li>
<li><strong>MICBIAS 提供偏置电压</strong>（2.2kΩ 上拉到 MICBIAS）。</li>
<li>可以连接到 <strong>数字 MEMS 麦克风（PDM）</strong> 通过 I²S&#x2F;TDM 接收音频数据。</li>
</ul>
<p><strong>耳机输出（HPOUTL、HPOUTR）</strong></p>
<ul>
<li>连接到 <strong>3.5mm 耳机插孔</strong>，支持 <strong>立体声耳机</strong>。</li>
<li><strong>HPDETR</strong>（耳机检测引脚）用于检测是否插入耳机。</li>
<li><strong>EPOUTP&#x2F;EPOUTN</strong>：支持 <strong>BTL（桥接负载）耳机驱动</strong>，提供更高功率输出。</li>
</ul>
<p><strong>扬声器输出（SPKOUTP、SPKOUTN）</strong></p>
<ul>
<li>连接到 <strong>扬声器</strong>，支持单声道 <strong>BTL（桥接负载）驱动</strong>。</li>
<li><strong>SPKVDD 提供功率</strong>，支持更大功率输出。</li>
</ul>
<p><strong>数字扬声器输出（SPKDAT）</strong></p>
<ul>
<li>通过数字 I²S&#x2F;TDM 发送音频信号到外部 D 类放大器。</li>
</ul>
<p><strong>GPIOS</strong></p>
<ul>
<li>支持 <strong>多达 16 个 GPIO</strong>，用于控制音频路径、检测插拔、调节增益等。</li>
</ul>
<p><strong>MCLK（时钟输入）</strong></p>
<ul>
<li>提供芯片运行所需的 <strong>主时钟（MCLK1&#x2F;MCLK2）</strong>。</li>
</ul>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="音频信号处理流程"><a href="#音频信号处理流程" class="headerlink" title="音频信号处理流程"></a><strong>音频信号处理流程</strong></h3><p><strong>音频输入</strong>：</p>
<ul>
<li>模拟音频信号（如麦克风输入）通过 ADC（模数转换器）转换为数字信号。</li>
<li>数字音频信号可通过 I²S 或 PDM 接口直接输入芯片。</li>
</ul>
<p><strong>音频信号处理（DSP）</strong>：</p>
<ul>
<li>语音增强（Beamforming、降噪、回声消除等）。</li>
<li>音效处理（如均衡器、混响等）。</li>
</ul>
<p><strong>音频输出</strong>：</p>
<ul>
<li>处理后的音频信号可通过 DAC（数模转换器）转换为模拟信号，并通过耳机放大器驱动耳机或扬声器。</li>
<li>也可以以数字信号的形式通过 I²S 或 TDM 发送到外部设备。</li>
</ul>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h3><p><strong>I2C（Two-Wire）模式下控制接口的时序要求</strong></p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>符号</strong></th>
<th><strong>最小值（Min）</strong></th>
<th><strong>典型值（Typ）</strong></th>
<th><strong>最大值（Max）</strong></th>
<th><strong>单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SCL 时钟频率</strong></td>
<td>f_SCL</td>
<td>—</td>
<td>—</td>
<td>3400</td>
<td>kHz</td>
</tr>
<tr>
<td><strong>SCL 低脉冲宽度</strong></td>
<td>t1</td>
<td>160</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCL 高脉冲宽度</strong></td>
<td>t2</td>
<td>160</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>启动条件保持时间</strong></td>
<td>t3</td>
<td>160</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>启动条件设置时间</strong></td>
<td>t4</td>
<td>160</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA, SCL 上升时间（10%-90%）</strong></td>
<td>t5</td>
<td>SCL 频率 &gt; 1.7MHz</td>
<td>—</td>
<td>80</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA, SCL 上升时间（10%-90%）</strong></td>
<td>t5</td>
<td>SCL 频率 ≤ 1MHz</td>
<td>—</td>
<td>2000</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA, SCL 降落时间（90%-10%）</strong></td>
<td>t6</td>
<td>SCL 频率 &gt; 1.7MHz</td>
<td>—</td>
<td>160</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA, SCL 降落时间（90%-10%）</strong></td>
<td>t6</td>
<td>SCL 频率 ≤ 1MHz</td>
<td>—</td>
<td>200</td>
<td>ns</td>
</tr>
<tr>
<td><strong>停止条件设置时间</strong></td>
<td>t7</td>
<td>160</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA 设置时间（数据输入）</strong></td>
<td>t8</td>
<td>40</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA 保持时间（数据输入&#x2F;ACK 输出）</strong></td>
<td>t9</td>
<td>0</td>
<td>—</td>
<td>40</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA 保持时间（数据输入）</strong></td>
<td>t10</td>
<td>SCL 上升时间（90%-10%）&#x3D; 20ns, C_LOAD（SDA）&#x3D; 15pF</td>
<td>—</td>
<td>40</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA 保持时间（数据输入）</strong></td>
<td>t10</td>
<td>SCL 上升时间（90%-10%）&#x3D; 60ns, C_LOAD（SDA）&#x3D; 100pF</td>
<td>—</td>
<td>130</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA 保持时间（数据输入）</strong></td>
<td>t10</td>
<td>SCL 上升时间（90%-10%）&#x3D; 160ns, C_LOAD（SDA）&#x3D; 400pF</td>
<td>—</td>
<td>190</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SDA 保持时间（数据输入）</strong></td>
<td>t10</td>
<td>SCL 上升时间（90%-10%）&#x3D; 200ns, C_LOAD（SDA）&#x3D; 550pF</td>
<td>—</td>
<td>220</td>
<td>ns</td>
</tr>
<tr>
<td><strong>时序波形脉冲</strong></td>
<td>tps</td>
<td>0</td>
<td>—</td>
<td>25</td>
<td>ns</td>
</tr>
</tbody></table>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/CS47L35/i2cbx.png" alt="i2cbx"></p>
<h3 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h3><p><strong>SPI(Serial Peripheral Interface)四线模式</strong> 的控制接口时序要求</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>符号</strong></th>
<th><strong>最小值（Min）</strong></th>
<th><strong>典型值（Typ）</strong></th>
<th><strong>最大值（Max）</strong></th>
<th><strong>单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SS 到 SCLK 上升沿的时间</strong></td>
<td>t_ssu</td>
<td>2.6</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 到 SS 上升沿的时间</strong></td>
<td>t_sho</td>
<td>0</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 脉冲周期时间</strong></td>
<td>t_scy</td>
<td>50.0</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 脉冲周期时间（系统时钟禁用时）</strong></td>
<td>t_scy</td>
<td>76.8</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 脉冲周期时间（SYSCLK 频率 &gt; 000 时）</strong></td>
<td>t_scy</td>
<td>38.4</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 低电平宽度</strong></td>
<td>t_scl</td>
<td>15.3</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 高电平宽度</strong></td>
<td>t_sch</td>
<td>15.3</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>MOSI 到 SCLK 设置时间</strong></td>
<td>t_msu</td>
<td>1.5</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>MOSI 到 SCLK 保持时间</strong></td>
<td>t_mho</td>
<td>1.7</td>
<td>—</td>
<td>—</td>
<td>ns</td>
</tr>
<tr>
<td><strong>SCLK 上升沿到 MISO 传输的时间</strong></td>
<td>t_su</td>
<td>0</td>
<td>—</td>
<td>12.6</td>
<td>ns</td>
</tr>
</tbody></table>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/CS47L35/spibx.png" alt="spibx"></p>
<h2 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h2>]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>KT6368A</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/KT6368A/</url>
    <content><![CDATA[<p>KT6368A 芯片是一款支持蓝牙双模的纯数据芯片，蓝牙5.1版本。芯片的亮点在超小尺寸，超级价格。以及简单明了的透传和串口AT控制功能。大大降低了嵌入蓝牙在其它产品的开发难度和成本。</p>
<p>同时支持 SPP 和 BLE 。但是只能任选其中一个协议使用。</p>
<p>备注：这款芯片最大的特点，就是便宜，使用简单，生产简单。无其他，便宜才是王道。</p>
<p><strong>请注意，一旦蓝牙被连接之后，芯片自动进入透传模式。不再识别AT指令。所以AT指令只能用于，未连接状态下面使用 。</strong></p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/KT6368A/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="center"><strong>引脚编号</strong></th>
<th><strong>名称</strong></th>
<th><strong>I&#x2F;O 类型</strong></th>
<th><strong>功能</strong></th>
<th><strong>其他功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>VBAT</td>
<td>P</td>
<td>LDO 电源</td>
<td>-</td>
</tr>
<tr>
<td align="center">1</td>
<td>VDDIO</td>
<td>P</td>
<td>IO 电源 3.3V</td>
<td>-</td>
</tr>
<tr>
<td align="center">2</td>
<td>PA9</td>
<td>I&#x2F;O</td>
<td>GPIO（上拉）</td>
<td>长按复位；<br />ADC8：ADC 通道 8；</td>
</tr>
<tr>
<td align="center">3</td>
<td>VSS</td>
<td>P</td>
<td>GND（地）</td>
<td>-</td>
</tr>
<tr>
<td align="center">4</td>
<td>BT_RF</td>
<td>-</td>
<td>射频天线</td>
<td>-</td>
</tr>
<tr>
<td align="center">5</td>
<td>BTOSCI</td>
<td>I</td>
<td>BTOSCI</td>
<td>-</td>
</tr>
<tr>
<td align="center">6</td>
<td>BTOSCO</td>
<td>O</td>
<td>BTOSCO</td>
<td>-</td>
</tr>
<tr>
<td align="center">7</td>
<td>USB0DM</td>
<td>I&#x2F;O</td>
<td>GPIO（下拉）</td>
<td>IIC_SDA_A：IIC 数据线 (A)；<br />ADC11：ADC 通道 11；<br />UART1_RXD：UART1 数据输入(D)；</td>
</tr>
<tr>
<td align="center">8</td>
<td>USB0DP</td>
<td>I&#x2F;O</td>
<td>GPIO（下拉）</td>
<td>IIC_SCL_A：IIC 时钟线 (A)；<br />ADC10：ADC 通道 10；<br />UART1_TXD：UART1 数据输出(D)；</td>
</tr>
</tbody></table>
<h2 id="串口命令"><a href="#串口命令" class="headerlink" title="串口命令"></a>串口命令</h2><p>KT6368A 使用 AT 串口指令进行设置，具体通讯命令请查看用户手册；</p>
<h2 id="上位机实现"><a href="#上位机实现" class="headerlink" title="上位机实现"></a>上位机实现</h2><p>假设我们要通过上位机发送一个 .bin 文件到 MCU</p>
<p><strong>数据发送过程中需要解决的问题</strong></p>
<ul>
<li><p>数据完整性：防止数据丢失或乱序。</p>
</li>
<li><p>数据准确性：确保接收的数据与发送的数据一致，避免传输过程中数据损坏。</p>
</li>
<li><p>传输控制：支持数据分片、确认和重传机制，避免传输中断导致的失败。</p>
</li>
<li><p>文件校验：在文件传输完成后，使用校验（如 CRC 或 MD5）确保文件内容无误。</p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<p>由于 .bin 文件通常比较大，蓝牙传输（尤其是通过 UART 的模块）无法一次发送整个文件，因此需要分片传输。具体步骤如下：</p>
<p><strong>1.文件分片</strong></p>
<ul>
<li>将 .bin 文件按照固定大小（如 512 字节&#x2F;1024 字节）分割为多个数据包。</li>
<li>每个数据包包含以下信息：<ol>
<li>包头：标识数据包起始，如固定值 0xFFAA。</li>
<li>包编号：用于标识每个数据包，防止乱序。</li>
<li>数据长度：本包中数据部分的字节数。</li>
<li>数据内容：文件的实际数据片段。</li>
<li>校验值：如 CRC16 或简单的和校验，用于确保本包内容的完整性。</li>
<li>包尾：标识数据包结束，如固定值 0xFFBB。</li>
</ol>
</li>
</ul>
<p><strong>2.确认与重传机制</strong></p>
<ul>
<li>每发送一个包，上位机等待 MCU 的确认（ACK）。</li>
<li>如果接收到 ACK，则发送下一个数据包。</li>
<li>如果超时未收到 ACK，或者收到 NACK，则重发当前数据包。</li>
</ul>
<p><strong>3.文件完整性校验</strong></p>
<ul>
<li>文件发送完成后，发送整个文件的校验值（如 CRC32、MD5），让 MCU 对接收到的文件进行校验，确保完整性。</li>
<li>如果校验失败，则重新发送。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 上位机示例程序</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> bleak <span class="keyword">import</span> BleakClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置蓝牙设备</span></span><br><span class="line">DEVICE_ADDRESS = <span class="string">&quot;XX:XX:XX:XX:XX:XX&quot;</span>  <span class="comment"># 替换为 KT6368 的蓝牙 MAC 地址</span></span><br><span class="line">SERVICE_UUID = <span class="string">&quot;your-service-uuid&quot;</span>    <span class="comment"># 替换为蓝牙服务 UUID</span></span><br><span class="line">CHAR_UUID = <span class="string">&quot;your-char-uuid&quot;</span>          <span class="comment"># 替换为特征值 UUID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分片大小（根据蓝牙模块和 UART 的实际情况调整）</span></span><br><span class="line">CHUNK_SIZE = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 CRC16（用于数据校验）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_crc16</span>(<span class="params">data: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    crc = <span class="number">0xFFFF</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> data:</span><br><span class="line">        crc ^= byte</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span> crc &amp; <span class="number">1</span>:</span><br><span class="line">                crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xA001</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                crc &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> crc &amp; <span class="number">0xFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分片传输文件</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> BleakClient(DEVICE_ADDRESS) <span class="keyword">as</span> client:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connected to Bluetooth device&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开 .bin 文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            file_data = f.read()</span><br><span class="line"></span><br><span class="line">        total_size = <span class="built_in">len</span>(file_data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;File size: <span class="subst">&#123;total_size&#125;</span> bytes&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按分片大小分割文件</span></span><br><span class="line">        num_chunks = (total_size + CHUNK_SIZE - <span class="number">1</span>) // CHUNK_SIZE</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_chunks):</span><br><span class="line">            <span class="comment"># 获取当前分片数据</span></span><br><span class="line">            start = i * CHUNK_SIZE</span><br><span class="line">            end = <span class="built_in">min</span>(start + CHUNK_SIZE, total_size)</span><br><span class="line">            chunk = file_data[start:end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构造数据包</span></span><br><span class="line">            chunk_len = <span class="built_in">len</span>(chunk)</span><br><span class="line">            crc = calc_crc16(chunk)  <span class="comment"># 计算分片的 CRC 校验</span></span><br><span class="line">            packet = struct.pack(<span class="string">&quot;&lt;HHH&quot;</span>, <span class="number">0x55AA</span>, i, chunk_len) + chunk + struct.pack(<span class="string">&quot;&lt;H&quot;</span>, crc) + struct.pack(<span class="string">&quot;&lt;H&quot;</span>, <span class="number">0xFFBB</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送数据包</span></span><br><span class="line">            <span class="keyword">await</span> client.write_gatt_char(CHAR_UUID, packet)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Sent chunk <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_chunks&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 等待 ACK 确认</span></span><br><span class="line">            ack = <span class="keyword">await</span> client.read_gatt_char(CHAR_UUID)</span><br><span class="line">            <span class="keyword">if</span> ack != <span class="string">b&quot;ACK&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: No ACK for chunk <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>. Retrying...&quot;</span>)</span><br><span class="line">                i -= <span class="number">1</span>  <span class="comment"># 重发当前分片</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 文件发送完成后，发送文件总 CRC32</span></span><br><span class="line">        file_crc = calc_crc16(file_data)</span><br><span class="line">        packet = struct.pack(<span class="string">&quot;&lt;I&quot;</span>, file_crc) + struct.pack(<span class="string">&quot;&lt;H&quot;</span>, <span class="number">0xFFBB</span>)</span><br><span class="line">        <span class="keyword">await</span> client.write_gatt_char(CHAR_UUID, packet)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;File transfer complete. Waiting for MCU confirmation...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收 MCU 响应</span></span><br><span class="line">        response = <span class="keyword">await</span> client.read_gatt_char(CHAR_UUID)</span><br><span class="line">        <span class="keyword">if</span> response == <span class="string">b&quot;SUCCESS&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;File transfer successful!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;File transfer failed. MCU reported an error.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="MCU-实现"><a href="#MCU-实现" class="headerlink" title="MCU 实现"></a>MCU 实现</h2><p>蓝牙模块的 GATT 服务接收这些包后，通过 UART 将每个数据包发送给 MCU。</p>
<p>MCU 的 UART 接口逐字节接收数据，并根据协议（如分片协议、CRC 校验等）处理。</p>
<p>MCU 对每个接收到的数据包进行校验，确认无误后返回 ACK（通过 UART 发送到蓝牙模块）。</p>
<p>蓝牙模块再通过 GATT 将 ACK 发送给上位机。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_START_ADDRESS 0x08020000  <span class="comment">// 固件存储地址（具体地址视情况而定）</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];  <span class="comment">// UART 接收缓冲区</span></span><br><span class="line"><span class="type">uint8_t</span> file_buffer[UART_BUFFER_SIZE];     <span class="comment">// 文件缓冲区</span></span><br><span class="line"><span class="type">uint32_t</span> received_crc = <span class="number">0</span>;                 <span class="comment">// 接收到的 CRC</span></span><br><span class="line"><span class="type">uint32_t</span> file_size = <span class="number">0</span>;                    <span class="comment">// 接收到的文件大小</span></span><br><span class="line"><span class="type">uint32_t</span> current_address = FLASH_START_ADDRESS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CRC16 校验函数</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">calc_crc16</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> length)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> crc = <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        crc ^= data[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint8_t</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (crc &amp; <span class="number">1</span>)</span><br><span class="line">                crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xA001</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UART 接收中断回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (huart-&gt;Instance == USART1) &#123;</span><br><span class="line">        <span class="comment">// 解析分片数据包</span></span><br><span class="line">        <span class="type">uint16_t</span> packet_header = (uart_rx_buffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | uart_rx_buffer[<span class="number">0</span>];</span><br><span class="line">        <span class="type">uint16_t</span> chunk_index = (uart_rx_buffer[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | uart_rx_buffer[<span class="number">2</span>];</span><br><span class="line">        <span class="type">uint16_t</span> chunk_len = (uart_rx_buffer[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | uart_rx_buffer[<span class="number">4</span>];</span><br><span class="line">        <span class="type">uint16_t</span> received_crc = (uart_rx_buffer[chunk_len + <span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | uart_rx_buffer[chunk_len + <span class="number">7</span>];</span><br><span class="line">        <span class="type">uint16_t</span> packet_tail = (uart_rx_buffer[chunk_len + <span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | uart_rx_buffer[chunk_len + <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packet_header == <span class="number">0x55AA</span> &amp;&amp; packet_tail == <span class="number">0xFFBB</span>) &#123;</span><br><span class="line">            <span class="comment">// 校验 CRC</span></span><br><span class="line">            <span class="type">uint16_t</span> calculated_crc = calc_crc16(&amp;uart_rx_buffer[<span class="number">6</span>], chunk_len);</span><br><span class="line">            <span class="keyword">if</span> (calculated_crc == received_crc) &#123;</span><br><span class="line">                <span class="comment">// 存储数据到文件缓冲区或直接写入 Flash</span></span><br><span class="line">                <span class="built_in">memcpy</span>(file_buffer, &amp;uart_rx_buffer[<span class="number">6</span>], chunk_len);</span><br><span class="line">                HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)<span class="string">&quot;ACK&quot;</span>, <span class="number">3</span>, <span class="number">100</span>);  <span class="comment">// 发送 ACK</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)<span class="string">&quot;NACK&quot;</span>, <span class="number">4</span>, <span class="number">100</span>); <span class="comment">// 发送 NACK</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 包头或包尾错误，发送 NACK</span></span><br><span class="line">            HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)<span class="string">&quot;NACK&quot;</span>, <span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备接收下一个数据包</span></span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1, uart_rx_buffer, UART_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/KT6368A/sldl.png" alt="sldl"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>DRV8301</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/</url>
    <content><![CDATA[<p>DRV8301 是德州仪器 (TI) 推出的一款高性能栅极驱动芯片，专为三相无刷直流电机 (BLDC) 和永磁同步电机 (PMSM) 驱动设计。</p>
<p>该器件提供三个半桥驱动器，每个都能驱动两个 N 沟道 MOSFET。DRV8301支持高达 1.7A 的源极电流和 2.3A 的峰值电流能力。DRV8301 可以在 6V~60V 的宽范围内使用单个电源供电。该器件使用自举栅极驱动器架构和涓流充电电路，以支持 100% 的占空比。DRV8301 在高侧或低侧 MOSFET 切换时使用自动握手功能，以防止电流流动。高侧和低侧 MOSFET 的集成 VDS 感应用于保护外部功率级免受过流条件的影响。<br>DRV8301包括两个电流并联放大器，用于精确测量电流。这些放大器支持双向电流传感，并提供可调节的输出偏移，最高可达 3V。<br>DRV8301 还包含一个集成的开关模式降压转换器，具有可调输出和开关频率。降压转换器可以提供高达 1.5A 的电流，以支持 MCU 或额外的系统电源需求。</p>
<blockquote>
<p>这款芯片用不好很容易烧掉</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/jlsyt.png" alt="jlsyt"></p>
<blockquote>
<p><strong>差分放大器（Diff Amps）</strong></p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1NT4y1m7iy?spm_id_from=333.788.videopod.episodes&vd_source=b80c1f86d3f58ac532ffdfaf3c6eeb23&p=16">功能详细说明</a></p>
<h2 id="电器属性"><a href="#电器属性" class="headerlink" title="电器属性"></a>电器属性</h2><ul>
<li><p>工作电源电压范围：6V 至 60V</p>
</li>
<li><p>栅极驱动电流能力：1.7A 源极电流和 2.3A 漏极栅极驱动电流能力</p>
</li>
<li><p>支持斜率控制以减少 EMI</p>
</li>
<li><p>自举栅极驱动器，支持 100% 占空比</p>
</li>
<li><p>支持 6- 或 3-PWM 输入模式</p>
</li>
<li><p>集成双电流分流放大器，具有可调增益和偏移</p>
</li>
<li><p>集成 1.5A 降压转换器</p>
</li>
<li><p>支持 3.3V 和 5V 接口</p>
</li>
<li><p>支持 SPI</p>
</li>
</ul>
<p><strong>保护功能：</strong></p>
<ul>
<li>可编程死区时间控制 (DTC)</li>
<li>可编程过流保护 (OCP)</li>
<li>PVDD 和 GVDD 欠压锁定 (UVLO)</li>
<li>GVDD 过压锁定 (OVLO)</li>
<li>过温警告&#x2F;关断 (OTW&#x2F;OTS)</li>
<li>通过 nFAULT、nOCTW 和 SPI 寄存器报告状态</li>
</ul>
<blockquote>
<p>DRV8301 支持两种不同的控制模式，分别是 <strong>6 路 PWM 模式</strong>和 <strong>3 路 PWM 模式</strong>，而不是指它输出 6 个 或3 个 PWM 信号。实际上 DRV8301 本身并不会生成 PWM 信号，它仅用来接收 MCU 的 PWM 信号，并驱动三相电机。你只需要根据应用选择适合的模式。</p>
</blockquote>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th><strong>引脚名称</strong></th>
<th align="center"><strong>编号</strong></th>
<th align="center"><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RT_CLK</td>
<td align="center">1</td>
<td align="center">输入</td>
<td>用于降压稳压器的电阻定时和外部时钟。电阻应通过非常短的走线接到 GND，以减少由于噪声引起的潜在时钟抖动。</td>
</tr>
<tr>
<td>COMP</td>
<td align="center">2</td>
<td align="center">输出</td>
<td>降压误差放大器的输出，输入到输出开关电流比较器。</td>
</tr>
<tr>
<td>VSENSE</td>
<td align="center">3</td>
<td align="center">输入</td>
<td>降压输出电压检测引脚。误差放大器的反相节点。</td>
</tr>
<tr>
<td>PWRGD</td>
<td align="center">4</td>
<td align="center">输出</td>
<td>开漏输出，需要外部上拉电阻。当由于热关机、电压下降、过电压或 EN_BUCK 关闭导致降压输出电压低时，PWRGD 拉低。</td>
</tr>
<tr>
<td>nOCTW</td>
<td align="center">5</td>
<td align="center">输出</td>
<td>过流和&#x2F;或过温警告指示器。此输出为开漏，需要外部上拉电阻。通过 SPI 寄存器可编程输出模式。</td>
</tr>
<tr>
<td>nFAULT</td>
<td align="center">6</td>
<td align="center">输出</td>
<td>故障报告指示器。此输出为开漏，需要外部上拉电阻。</td>
</tr>
<tr>
<td>DTC</td>
<td align="center">7</td>
<td align="center">输入</td>
<td>通过接地的外部电阻调整死区时间。</td>
</tr>
<tr>
<td>nSCS</td>
<td align="center">8</td>
<td align="center">输入</td>
<td>SPI 芯片选择信号。</td>
</tr>
<tr>
<td>SDI</td>
<td align="center">9</td>
<td align="center">输入</td>
<td>SPI 数据输入。</td>
</tr>
<tr>
<td>SDO</td>
<td align="center">10</td>
<td align="center">输出</td>
<td>SPI 数据输出。</td>
</tr>
<tr>
<td>SCLK</td>
<td align="center">11</td>
<td align="center">输入</td>
<td>SPI 时钟信号。</td>
</tr>
<tr>
<td>DC_CAL</td>
<td align="center">12</td>
<td align="center">输入</td>
<td>当 DC_CAL 拉高时，器件短接分流放大器的输入并断开负载。可通过外部微控制器执行直流偏置校准。</td>
</tr>
<tr>
<td>GVDD</td>
<td align="center">13</td>
<td align="center">电源</td>
<td>内部栅极驱动器电压调节器。GVDD 电容应连接到 GND。</td>
</tr>
<tr>
<td>CP1</td>
<td align="center">14</td>
<td align="center">电源</td>
<td>电荷泵引脚 1，应在 CP1 和 CP2 之间使用陶瓷电容。</td>
</tr>
<tr>
<td>CP2</td>
<td align="center">15</td>
<td align="center">电源</td>
<td>电荷泵引脚 2，应在 CP1 和 CP2 之间使用陶瓷电容。</td>
</tr>
<tr>
<td>EN_GATE</td>
<td align="center">16</td>
<td align="center">输入</td>
<td>启用栅极驱动器和分流电流放大器。通过 EN_BUCK 引脚控制降压功能。</td>
</tr>
<tr>
<td>INH_A</td>
<td align="center">17</td>
<td align="center">输入</td>
<td>PWM 信号输入（高边），半桥 A。</td>
</tr>
<tr>
<td>INL_A</td>
<td align="center">18</td>
<td align="center">输入</td>
<td>PWM 信号输入（低边），半桥 A。</td>
</tr>
<tr>
<td>INH_B</td>
<td align="center">19</td>
<td align="center">输入</td>
<td>PWM 信号输入（高边），半桥 B。</td>
</tr>
<tr>
<td>INL_B</td>
<td align="center">20</td>
<td align="center">输入</td>
<td>PWM 信号输入（低边），半桥 B。</td>
</tr>
<tr>
<td>INH_C</td>
<td align="center">21</td>
<td align="center">输入</td>
<td>PWM 信号输入（高边），半桥 C。</td>
</tr>
<tr>
<td>INL_C</td>
<td align="center">22</td>
<td align="center">输入</td>
<td>PWM 信号输入（低边），半桥 C。</td>
</tr>
<tr>
<td>DVDD</td>
<td align="center">23</td>
<td align="center">电源</td>
<td>内部 3.3V 电源电压。DVDD 电容应连接到 AGND。此引脚为输出，但不用于驱动外部电路。</td>
</tr>
<tr>
<td>REF</td>
<td align="center">24</td>
<td align="center">输入</td>
<td>设置分流放大器输出的参考电压。偏置电压等于此引脚上电压的一半。连接到微控制器的 ADC 参考电压。</td>
</tr>
<tr>
<td>SO1</td>
<td align="center">25</td>
<td align="center">输出</td>
<td>电流放大器 1 的输出。</td>
</tr>
<tr>
<td>SO2</td>
<td align="center">26</td>
<td align="center">输出</td>
<td>电流放大器 2 的输出。</td>
</tr>
<tr>
<td>AVDD</td>
<td align="center">27</td>
<td align="center">电源</td>
<td>内部 6V 电源电压。AVDD 电容应始终安装并连接到 AGND。此引脚为输出，但不用于驱动外部电路。</td>
</tr>
<tr>
<td>AGND</td>
<td align="center">28</td>
<td align="center">电源</td>
<td>模拟地引脚。直接连接到 GND（PowerPAD）。</td>
</tr>
<tr>
<td>PVDD1</td>
<td align="center">29</td>
<td align="center">电源</td>
<td>栅极驱动器、电流分流放大器和 SPI 通信的电源引脚。PVDD1 独立于降压电源 PVDD2。PVDD1 电容应连接到 GND。</td>
</tr>
<tr>
<td>SP2</td>
<td align="center">30</td>
<td align="center">输入</td>
<td>电流放大器 2 的正极输入。建议连接到分流电阻高边的接地端，以获得最佳的共模抑制效果。</td>
</tr>
<tr>
<td>SN2</td>
<td align="center">31</td>
<td align="center">输入</td>
<td>电流放大器 2 的负极输入。</td>
</tr>
<tr>
<td>SP1</td>
<td align="center">32</td>
<td align="center">输入</td>
<td>电流放大器 1 的正极输入。建议连接到分流电阻高边的接地端，以获得最佳的共模抑制效果。</td>
</tr>
<tr>
<td>SN1</td>
<td align="center">33</td>
<td align="center">输入</td>
<td>电流放大器 1 的负极输入。</td>
</tr>
<tr>
<td>SL_C</td>
<td align="center">34</td>
<td align="center">输入</td>
<td>低边 MOSFET 源极连接，半桥 C。低边 VDS 电压测量在此引脚与 SH_C 之间。</td>
</tr>
<tr>
<td>GL_C</td>
<td align="center">35</td>
<td align="center">输出</td>
<td>低边 MOSFET 的栅极驱动输出，半桥 C。</td>
</tr>
<tr>
<td>SH_C</td>
<td align="center">36</td>
<td align="center">输入</td>
<td>高边 MOSFET 源极连接，半桥 C。高边 VDS 电压测量在此引脚与 PVDD1 之间。</td>
</tr>
<tr>
<td>GH_C</td>
<td align="center">37</td>
<td align="center">输出</td>
<td>高边 MOSFET 的栅极驱动输出，半桥 C。</td>
</tr>
<tr>
<td>BST_C</td>
<td align="center">38</td>
<td align="center">电源</td>
<td>半桥 C 的自举电容引脚。</td>
</tr>
<tr>
<td>SL_B</td>
<td align="center">39</td>
<td align="center">输入</td>
<td>低边 MOSFET 源极连接，半桥 B。低边 VDS 电压测量在此引脚与 SH_B 之间。</td>
</tr>
<tr>
<td>GL_B</td>
<td align="center">40</td>
<td align="center">输出</td>
<td>低边 MOSFET 的栅极驱动输出，半桥 B。</td>
</tr>
<tr>
<td>SH_B</td>
<td align="center">41</td>
<td align="center">输入</td>
<td>高边 MOSFET 源极连接，半桥 B。高边 VDS 电压测量在此引脚与 PVDD1 之间。</td>
</tr>
<tr>
<td>GH_B</td>
<td align="center">42</td>
<td align="center">输出</td>
<td>高边 MOSFET 的栅极驱动输出，半桥 B。</td>
</tr>
<tr>
<td>BST_B</td>
<td align="center">43</td>
<td align="center">电源</td>
<td>半桥 B 的自举电容引脚。</td>
</tr>
<tr>
<td>SL_A</td>
<td align="center">44</td>
<td align="center">输入</td>
<td>低边 MOSFET 源极连接，半桥 A。低边 VDS 电压测量在此引脚与 SH_A 之间。</td>
</tr>
<tr>
<td>GL_A</td>
<td align="center">45</td>
<td align="center">输出</td>
<td>低边 MOSFET 的栅极驱动输出，半桥 A。</td>
</tr>
<tr>
<td>SH_A</td>
<td align="center">46</td>
<td align="center">输入</td>
<td>高边 MOSFET 源极连接，半桥 A。高边 VDS 电压测量在此引脚与 PVDD1 之间。</td>
</tr>
<tr>
<td>GH_A</td>
<td align="center">47</td>
<td align="center">输出</td>
<td>高边 MOSFET 的栅极驱动输出，半桥 A。</td>
</tr>
<tr>
<td>BST_A</td>
<td align="center">48</td>
<td align="center">电源</td>
<td>半桥 A 的自举电容引脚。</td>
</tr>
<tr>
<td>VDD_SPI</td>
<td align="center">49</td>
<td align="center">输入</td>
<td>支持 3.3V 或 5V 逻辑的 SPI 电源引脚。连接到 MCU SPI 使用的相同电源。</td>
</tr>
<tr>
<td>PH</td>
<td align="center">50, 51</td>
<td align="center">输出</td>
<td>内部高边 MOSFET 的源极，用于降压转换器。</td>
</tr>
<tr>
<td>BST_BK</td>
<td align="center">52</td>
<td align="center">电源</td>
<td>降压转换器的自举电容引脚。</td>
</tr>
<tr>
<td>PVDD2</td>
<td align="center">53, 54</td>
<td align="center">电源</td>
<td>降压转换器的电源引脚。PVDD2 电容应连接到 GND。</td>
</tr>
<tr>
<td>EN_BUCK</td>
<td align="center">55</td>
<td align="center">输入</td>
<td>启用降压转换器。内部上拉电流源。拉低至 1.2V 以下以禁用。悬空以启用。使用两个电阻调整输入欠压锁定。</td>
</tr>
<tr>
<td>SS_TR</td>
<td align="center">56</td>
<td align="center">输入</td>
<td>降压软启动和跟踪。连接到此引脚的外部电容设置输出上升时间。由于此引脚的电压覆盖内部参考电压，可用于跟踪和时序控制。电容应连接到 GND。</td>
</tr>
<tr>
<td>GND</td>
<td align="center">57</td>
<td align="center">电源</td>
<td>GND 引脚。裸露的电源焊盘必须通过焊接连接到地平面以确保正常运行，并通过过孔连接到 PCB 的底面以改善散热。</td>
</tr>
</tbody></table>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/sldl.png" alt="sldl"></p>
<h2 id="SPI-时序要求"><a href="#SPI-时序要求" class="headerlink" title="SPI 时序要求"></a>SPI 时序要求</h2><table>
<thead>
<tr>
<th>参数</th>
<th>测试条件</th>
<th align="center">最小值 (MIN)</th>
<th align="center">标称值 (NOM)</th>
<th align="center">最大值 (MAX)</th>
<th align="center">单位</th>
</tr>
</thead>
<tbody><tr>
<td><strong>t_SPI_READY</strong></td>
<td>EN_GATE 由低变高后 SPI 准备</td>
<td align="center"></td>
<td align="center">5</td>
<td align="center">10</td>
<td align="center">ms</td>
</tr>
<tr>
<td><strong>t_CLK</strong></td>
<td>最小 SPI 时钟周期</td>
<td align="center">100</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_CLKH</strong></td>
<td>时钟高电平时间</td>
<td align="center">40</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_CLKL</strong></td>
<td>时钟低电平时间</td>
<td align="center">40</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_SU_SDI</strong></td>
<td>SDI 输入数据建立时间</td>
<td align="center">20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_HD_SDI</strong></td>
<td>SDI 输入数据保持时间</td>
<td align="center">30</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_D_SDO</strong></td>
<td>SDO 输出数据延迟时间</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">20</td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_HD_SDO</strong></td>
<td>SDO 输出数据保持时间</td>
<td align="center">40</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_SU_SCS</strong></td>
<td>SCS 建立时间</td>
<td align="center">50</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_HD_SCS</strong></td>
<td>SCS 保持时间</td>
<td align="center">50</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_HI_SCS</strong></td>
<td>SCS 最小高电平时间（SCS 激活为低电平）</td>
<td align="center">40</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_ACC</strong></td>
<td>SCS 接入时间，从 SCS 低到 SDO 不再高阻态</td>
<td align="center"></td>
<td align="center">10</td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
<tr>
<td><strong>t_DIS</strong></td>
<td>SCS 禁用时间，从 SCS 高到 SDO 高阻态</td>
<td align="center"></td>
<td align="center">10</td>
<td align="center"></td>
<td align="center">ns</td>
</tr>
</tbody></table>
<blockquote>
<p>表格中使用了“EN_GATE”的上下沿信号说明。</p>
<p>时序要求均基于 <strong>SPI 从模式（Slave Mode）</strong>，并在 PVDD &gt; 6V 的条件下测试。</p>
<p>参数 t_D_SDO 的测试条件为 <strong>电容 CL &#x3D; 20pF</strong>。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/spisx.png" alt="spisx"></p>
<h2 id="SPI-通信格式"><a href="#SPI-通信格式" class="headerlink" title="SPI 通信格式"></a>SPI 通信格式</h2><p>DRV8301 SPI 以从属方式运行。SPI 输入(SDI)数据格式<strong>由一个 16 位字</strong>组成，其中包含：<strong>1 个读&#x2F;写位、4 个地址位和 11 个数据位</strong>。SPI输出(SDO)数据格式<strong>由一个16位字</strong>组成，其中包含：<strong>1个帧错误位、4个地址位和11个数据位</strong>。当帧无效时，帧错误位将设置为1，剩余位将移出为 0.</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/spiinput.png" alt="spiinput"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8301/spiout.png" alt="spiout"></p>
<blockquote>
<p>由于从机的响应（SDO）是基于主机上一次发送的输入数据（SDI）进行的，因此<strong>完成一次查询&#x2F;响应操作需要两次完整的 16 位数据传输</strong>。<br>这种机制是典型的 <strong>SPI 全双工数据传输中从设备延迟响应的特性</strong>。</p>
<p>假设主机需要向从机发送一个指令并接收其响应：</p>
<ol>
<li><strong>第 1 次传输周期 (N-1)</strong><ul>
<li>主机通过 SDI 发送指令，比如 0x1234。</li>
<li>此时，从机尚未对 0x1234 进行处理，因此 SDO 输出的可能是无意义的默认值，比如 0x0000。</li>
</ul>
</li>
<li><strong>第 2 次传输周期 (N)</strong><ul>
<li>主机可以发送下一条指令，比如 0x5678。</li>
<li>从机通过 SDO 返回上一条指令（0x1234）的处理结果，比如 0x9ABC。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="三相电路的正反转控制"><a href="#三相电路的正反转控制" class="headerlink" title="三相电路的正反转控制"></a>三相电路的正反转控制</h2><p>三相电机通过改变电机<strong>三相绕组的电流方向</strong>（相序），从而调整产生的旋转磁场方向，最终实现正转或反转。</p>
<p><strong>旋转磁场的形成</strong></p>
<ul>
<li>三相电机内部有三组绕组（A相、B相、C相），通以按一定时序切换的电流（例如正弦波、梯形波），会形成一个<strong>旋转磁场</strong>。</li>
<li>这个旋转磁场与电机转子的磁极相互作用，推动转子沿磁场方向旋转。</li>
</ul>
<p><strong>正反转的关键：改变相序</strong></p>
<ul>
<li><strong>正转</strong>：三相电流按 A → B → C 的顺序通电，产生的旋转磁场顺时针（或逆时针）旋转。</li>
<li><strong>反转</strong>：改变相序，例如改为 A → C → B 的顺序，旋转磁场的方向也随之反向，转子反向旋转。</li>
</ul>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>EM7028</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/</url>
    <content><![CDATA[<p>EM7028 是一款专门用于<strong>心率检测</strong>和<strong>血氧检测</strong>的低功耗传感器芯片，广泛应用于可穿戴设备（如智能手表、手环）和健康监测设备。它可以基于 <strong>PPG（光电容积脉搏波）技术</strong>，通过发射光线并接收反射信号来计算心率和血氧饱和度（SpO₂）。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>心率芯片包括发射 LED 和 PD 接收两部分。</p>
<p>芯片工作时，LED 发出的光打到皮肤下并反射回接收端，反射回的光强便包含了脉搏信息，这个光强经过处理后被 ADC 转换为数值，这个值会随着脉搏跳动周期性的变化。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/gzyl.png" alt="gzyl"></p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p><strong>连续模式</strong></p>
<p>在正常 HRS 模式下，其中一个 LED 亮起，HRS 传感器同时检测环境光与绿色 LED 发出的光。光敏度为 1 勒克斯&#x2F;计数，全范围内总共有65536 勒克斯;ADC 的典型分辨率为16位，转换时间为 25 毫秒。<br>在低亮度模式下，选择 8 倍 ADC 增益来接收光线，检测范围为 0.125 亮度到 8192 亮度。</p>
<blockquote>
<p><strong>LED 点亮</strong>：LED1 或 LED2 持续发光。</p>
<p><strong>光检测</strong>：传感器实时接收 <strong>反射光线</strong> 和 <strong>环境光线</strong>，并进行测量。</p>
<p><strong>数据处理</strong>：通过 ADC 转换，将光线信号转化为数字信号，提供给主控 MCU。</p>
<p><strong>输出数据</strong>：数据存储到寄存器（如 HRS_DATA0），主控 MCU 通过 I²C 通信读取数据。</p>
</blockquote>
<p><strong>脉冲模式</strong></p>
<p>脉冲模式下的心率传感器在脉冲状态下打开 LED，检测反射光。</p>
<blockquote>
<p><strong>LED 脉冲点亮</strong>：LED 以一定周期脉冲式点亮，亮起时间较短。</p>
<p><strong>光检测</strong>：在 LED 点亮期间，传感器检测光线反射强度。</p>
<p><strong>ADC 转换</strong>：将检测到的光信号通过 ADC 转换为数字信号。</p>
<p><strong>数据输出</strong>：将数据存储到寄存器，主控 MCU 在需要时读取。</p>
<p><strong>LED 熄灭</strong>：在脉冲关闭期间，LED 熄灭，传感器休眠以节省功耗。</p>
</blockquote>
<p><strong>通过 EMP7028 的寄存器配置工作模式与相关参数</strong></p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="center"><strong>PinNo</strong></th>
<th align="center"><strong>PinName</strong></th>
<th align="center"><strong>Type</strong></th>
<th align="center"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>1</strong></td>
<td align="center"><strong>SDA</strong></td>
<td align="center">I&#x2F;O (开漏)</td>
<td align="center">I²C 数据线：用于 I²C 通信的数据传输，需外接上拉电阻。</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>INT</strong></td>
<td align="center">O (开漏)</td>
<td align="center">中断引脚：当传感器有数据或事件触发时，该引脚输出中断信号。</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center"><strong>LED1</strong></td>
<td align="center">O (开漏)</td>
<td align="center">LED 电流驱动引脚 1：可提供高达 200mA 电流，通常用于驱动高功率 LED 光源。</td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>LED2</strong></td>
<td align="center">O (开漏)</td>
<td align="center">LED 电流驱动引脚 2：可提供高达 12mA 电流，通常用于低功率 LED 光源。</td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>LEDA</strong></td>
<td align="center">I</td>
<td align="center">LED 阳极端：需要连接到 LED 电源 VDD_LED，用于 LED 驱动电路供电。</td>
</tr>
<tr>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>GND</strong></td>
<td align="center">—</td>
<td align="center">电源地：所有电压均参考此引脚接地。</td>
</tr>
<tr>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>SCL</strong></td>
<td align="center">I (开漏)</td>
<td align="center">I²C 时钟线：提供 I²C 通信的时钟信号，需外接上拉电阻。</td>
</tr>
<tr>
<td align="center"><strong>8</strong></td>
<td align="center"><strong>VDD</strong></td>
<td align="center">—</td>
<td align="center">电源电压：为芯片提供供电，通常为 <strong>3.3V</strong> 或符合设备要求的电压。</td>
</tr>
</tbody></table>
<h2 id="I2C-时序特性"><a href="#I2C-时序特性" class="headerlink" title="I2C 时序特性"></a>I2C 时序特性</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/sstx.png" alt="sstx"></p>
<blockquote>
<p>f<sub>clek</sub>：SCL 时钟频率</p>
<ul>
<li><p>在 <strong>Normal Mode</strong> 下，SCL 的最大频率为 <strong>100 kHz</strong>。</p>
</li>
<li><p>在 <strong>Fast Mode</strong> 下，SCL 的最大频率可达 <strong>400 kHz</strong>。</p>
</li>
</ul>
<p>t<sub>SUDAT</sub>：数据设置时间 (tSUDAT)</p>
<ul>
<li>主机在时钟信号（SCL）上升沿前，数据线（SDA）上的数据必须保持稳定的最短时间。</li>
</ul>
<p>t<sub>HDDAT</sub>：数据保持时间 (tHDDAT)</p>
<ul>
<li>在时钟信号（SCL）下降沿之后，数据线（SDA）上的数据必须继续保持的时间。</li>
</ul>
<p>t<sub>rise</sub>：时钟&#x2F;数据上升时间</p>
<ul>
<li><strong>上升时间 (trise)<strong>：SCL 和 SDA 从</strong>低电平到高电平</strong>的时间。</li>
</ul>
<p>t<sub>fall</sub>：时钟&#x2F;数据下降时间</p>
<ul>
<li><strong>下降时间 (tfall)<strong>：SCL 和 SDA 从</strong>高电平到低电平</strong>的时间。</li>
</ul>
<p>t<sub>LOW</sub>：SCL 低电平时间</p>
<p>t<sub>HIGH</sub>：SCL 高电平时间</p>
<p>t<sub>BUF</sub>：起始状态和停止状态之间的空闲时间</p>
<ul>
<li><strong>tBUF</strong> 定义了停止条件与下一次起始条件之间的最小空闲时间。</li>
</ul>
<p>t<sub>HDSTA</sub>：起始条件保持时间（重复启动）</p>
<ul>
<li>起始条件（START）信号的保持时间。</li>
</ul>
<p>t<sub>SUSTA</sub>：起始条件设置时间</p>
<ul>
<li>主机发送起始条件前，数据线 SDA 必须稳定的最短时间。</li>
</ul>
<p>t<sub>SUSTO</sub>：停止条件设置时间</p>
<ul>
<li>主机发送停止条件前，数据线 SDA 必须稳定的最短时间。</li>
</ul>
<p>t<sub>TIMEOUT</sub>：低检测时钟&#x2F;数据超时时间</p>
<p>C<sub>load</sub>：每条总线线的电容负载</p>
<p>R<sub>BUS</sub>：SDA 和 SCL 的上拉电阻</p>
<p>t<sub>VD</sub>：数据有效时间</p>
<p>t<sub>VDACK</sub>：数据有效确认时间</p>
<ul>
<li>定义了数据在传输中的有效性以及接收方发送确认（ACK）时的时序要求。</li>
</ul>
</blockquote>
<h2 id="I2C-状态机"><a href="#I2C-状态机" class="headerlink" title="I2C 状态机"></a>I2C 状态机</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/I2Cztj.png" alt="I2Cztj"></p>
<blockquote>
<p><strong>IDLE</strong></p>
<ul>
<li>初始状态或空闲状态。</li>
<li>系统处于等待信号或数据的状态。</li>
</ul>
<p><strong>Address Dec（Address Decode）</strong></p>
<ul>
<li>解析或解码地址的状态。</li>
<li>设备从总线或数据流中获取地址，并进行地址匹配。</li>
</ul>
<p><strong>ACK（Acknowledge）</strong></p>
<ul>
<li>确认状态。</li>
<li>当设备接收到正确的数据或地址后，会发送 ACK 信号（确认响应）。</li>
</ul>
<p><strong>REV（Receive）</strong></p>
<ul>
<li>数据接收状态。</li>
<li>系统从通信中接收数据。</li>
</ul>
<p><strong>TRANS（Transmit）</strong></p>
<ul>
<li>数据传输状态。</li>
<li>系统将数据传输给通信对方（比如主机或其他设备）。</li>
</ul>
<p><strong>IDLE → Address Dec</strong></p>
<ul>
<li>系统从空闲状态进入地址解析状态，可能是因为接收到通信请求（如 Start 信号）。</li>
</ul>
<p><strong>Address Dec → IDLE</strong></p>
<ul>
<li>如果地址解析失败，系统返回空闲状态，等待下一次请求。</li>
</ul>
<p><strong>Address Dec → ACK</strong></p>
<ul>
<li>当地址成功匹配时，进入 ACK 状态，表示地址有效并响应确认信号。</li>
</ul>
<p><strong>ACK → REV</strong></p>
<ul>
<li>系统进入接收数据状态，表示通信对方发送数据过来，系统开始接收。</li>
</ul>
<p><strong>ACK → TRANS</strong></p>
<ul>
<li>系统进入数据传输状态，表示系统主动发送数据给对方。</li>
</ul>
<p><strong>REV → ACK</strong> 和 <strong>TRANS → ACK</strong></p>
<ul>
<li>数据传输或接收完成后，系统返回 ACK 状态，进行确认或等待下一步操作。</li>
</ul>
<p><strong>ACK → IDLE</strong></p>
<ul>
<li>在某些情况下，数据传输或接收结束，系统返回空闲状态，等待下一次通信。</li>
</ul>
</blockquote>
<h2 id="传输顺序"><a href="#传输顺序" class="headerlink" title="传输顺序"></a>传输顺序</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/cssx.png" alt="cssx"></p>
<h2 id="从设备地址"><a href="#从设备地址" class="headerlink" title="从设备地址"></a>从设备地址</h2><p>The I2C Interface and 7-bit slave address is 0x24.</p>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><strong>HRS2 脉冲模式的典型应用电路(VDD2.6<del>3.6V，VDD PC1.6</del>3.6V、VDD LED 2.6~4.5V)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/mcsldl.png" alt="mcsldl"></p>
<p><strong>HRS1 连续模式下的典型应用电路</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/lxmsdl.png" alt="lxmsdl"></p>
<blockquote>
<p>VDD、VDD_I2C、VDD_LED可以连接在一起，形成VDD3.3V至3.3V的电压。</p>
<p>VDD3.3V应将0.1uF电容器接地。</p>
<p>如果不需要中断模式，INT可以断开。</p>
<p>R0是LED2调节电阻器，R0的典型值为100Ω。</p>
</blockquote>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>利用 I2C 写入对应命令后读取对应寄存器的数值后在利用波峰检算法即可，具体查看对应代码。</p>
<h3 id="波峰检测算法"><a href="#波峰检测算法" class="headerlink" title="波峰检测算法"></a>波峰检测算法</h3><p>波峰检测算法，通过传感器采集到的数据推算出心率值。1</p>
<p>在心率算法中，通过波峰（即心跳信号的峰值）之间的时间间隔计算心率，常用以下公式：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/EM7028/xlsf.png" alt="xlsf"></p>
<blockquote>
<p>人体正常的心率范围一般在 <strong>60 BPM(一分钟 60 次) 到 180 BPM</strong> 之间。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HRAlgorithm.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_SIZE 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int8_t</span> front;</span><br><span class="line">    <span class="type">int8_t</span> rear;</span><br><span class="line">    <span class="type">int8_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> data[QUEUE_SIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 HrList 的平均值，用于平滑处理心率数据，从而减小心率计算中的波动，提高数据稳定性。</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Hr_Ave_Filter</span><span class="params">(<span class="type">uint32_t</span> *HrList, <span class="type">uint8_t</span> lenth)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> ave = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;lenth;i++) &#123;</span><br><span class="line">		ave += HrList[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ave /= lenth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">present_dat：当前时刻传感器采集到的数据值（光信号强度值）。</span></span><br><span class="line"><span class="comment">present_time：当前时刻的时间戳（单位为毫秒）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">HR_Calculate</span><span class="params">(<span class="type">uint16_t</span> present_dat,<span class="type">uint32_t</span> present_time)</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// peaks_time：保存最近检测到的两个波峰的时间戳。</span></span><br><span class="line">    <span class="comment">// peaks_time[0]：当前检测到的波峰时间。</span></span><br><span class="line">    <span class="comment">// peaks_time[1]：上一个波峰的时间。</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> peaks_time[]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 当前计算得到的心率值。</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> HR=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isQueueFull() 判断队列是否以满</span></span><br><span class="line">    <span class="comment">// dequeue() 从队列中移除旧数据。</span></span><br><span class="line">	<span class="keyword">if</span>(isQueueFull(&amp;datas)) &#123;</span><br><span class="line">        dequeue(&amp;datas);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(isQueueFull(&amp;times)) &#123;</span><br><span class="line">        dequeue(&amp;times);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(isQueueFull(&amp;HR_List)) &#123;</span><br><span class="line">        dequeue(&amp;HR_List);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新数据加入队列。</span></span><br><span class="line">	enqueue(&amp;datas,present_dat);</span><br><span class="line">	enqueue(&amp;times,present_time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((datas.data[<span class="number">3</span>]&gt;=datas.data[<span class="number">2</span>]) &amp;&amp; (datas.data[<span class="number">3</span>]&gt;=datas.data[<span class="number">1</span>]) &amp;&amp; (datas.data[<span class="number">3</span>]&gt;datas.data[<span class="number">0</span>]) </span><br><span class="line">		&amp;&amp; (datas.data[<span class="number">3</span>]&gt;=datas.data[<span class="number">4</span>]) &amp;&amp; (datas.data[<span class="number">3</span>]&gt;=datas.data[<span class="number">5</span>]) &amp;&amp; (datas.data[<span class="number">3</span>]&gt;datas.data[<span class="number">6</span>])) &#123;</span><br><span class="line">			<span class="keyword">if</span>((times.data[<span class="number">3</span>]-peaks_time[<span class="number">0</span>]) &gt; <span class="number">425</span>) &#123;</span><br><span class="line">					peaks_time[<span class="number">1</span>] = peaks_time[<span class="number">0</span>];</span><br><span class="line">					peaks_time[<span class="number">0</span>] = times.data[<span class="number">3</span>];</span><br><span class="line">					enqueue(&amp;HR_List,<span class="number">60000</span>/(peaks_time[<span class="number">0</span>]-peaks_time[<span class="number">1</span>]));</span><br><span class="line">					<span class="keyword">if</span>(HR_List.data[<span class="number">6</span>]!=<span class="number">0</span>) &#123;</span><br><span class="line">                        HR = Hr_Ave_Filter(HR_List.data,<span class="number">7</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> HR;</span><br><span class="line">&#125;</span><br><span class="line">==========================================================================</span><br><span class="line"><span class="comment">//user_SendUpdateTask.c</span></span><br><span class="line"><span class="comment">// 周期性地更新心率数据    </span></span><br><span class="line"><span class="type">void</span> HRDataUpdateTask(<span class="type">void</span> *argument)&#123;</span><br><span class="line">	<span class="type">uint8_t</span> IdleBreakstr=<span class="number">0</span>;</span><br><span class="line">	<span class="type">uint16_t</span> dat=<span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> hr_temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(Page_Get_NowPage()-&gt;page_obj == &amp;ui_HRPage)&#123;</span><br><span class="line">			osMessageQueuePut(IdleBreak_MessageQueue, &amp;IdleBreakstr, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//sensor wake up</span></span><br><span class="line">			EM7028_hrs_Enable();</span><br><span class="line">			<span class="comment">//receive the sensor wakeup message, sensor wakeup</span></span><br><span class="line">			<span class="keyword">if</span>(!HWInterface.HR_meter.ConnectionError)&#123;</span><br><span class="line">				<span class="comment">//Hr messure</span></span><br><span class="line">				vTaskSuspendAll();</span><br><span class="line">                <span class="comment">// 调用 HR_Calculate 函数进行心率计算。EM7028_Get_HRS1() 获取心率传感器的数据，</span></span><br><span class="line">				hr_temp = HR_Calculate(EM7028_Get_HRS1(),user_HR_timecount);</span><br><span class="line">				xTaskResumeAll();</span><br><span class="line">				<span class="keyword">if</span>(HWInterface.HR_meter.HrRate != hr_temp &amp;&amp; hr_temp&gt;<span class="number">50</span> &amp;&amp; hr_temp&lt;<span class="number">120</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					HWInterface.HR_meter.HrRate = hr_temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(<span class="number">50</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>维护队列</strong>：</p>
<ul>
<li>如果 datas、times 和 HR_List 队列已满，则先移除最早的数据点。</li>
<li>将当前的传感器数据 present_dat 和时间 present_time 加入队列。</li>
</ul>
<p><strong>波峰检测</strong>：</p>
<ul>
<li>判断 datas.data[3]（第4个数据点）是否为波峰。</li>
<li>判断条件：第4个数据点必须大于前面 3 个和后面 3 个数据点（即满足局部最大值）。</li>
<li><strong>原理</strong>：通过比较前后数据点，检测光信号数据中的局部峰值，通常对应于心跳导致的光反射峰。</li>
</ul>
<p><strong>波峰间隔时间检查</strong>：</p>
<ul>
<li>如果当前检测到的波峰与上一个波峰的时间间隔 times.data[3] - peaks_time[0] &gt; 425（大约 425 毫秒，即心率下限 60&#x2F;0.425 ≈ 141 BPM），则认为是有效波峰。</li>
<li>更新 peaks_time 数组，保存当前和上一个波峰的时间戳。</li>
</ul>
<p><strong>心率计算</strong>：</p>
<ul>
<li>使用公式： \text{HR} &#x3D; \frac{60000}{\text{peaks_time[0]} - \text{peaks_time[1]}} 其中，60000 表示 1 分钟的时间（单位为毫秒）。</li>
<li>将计算得到的心率值存入 HR_List 队列。</li>
</ul>
<p><strong>心率平滑滤波</strong>：</p>
<ul>
<li>当 HR_List 数据满 7 个心率值时，调用 Hr_Ave_Filter 函数对最近 7 个心率值进行平均滤波，减少抖动，提高稳定性。</li>
<li>Hr_Ave_Filter 负责对心率值进行滤波平滑处理，返回最终的平滑心率值。</li>
</ul>
<p><strong>返回心率</strong>：</p>
<ul>
<li>返回当前平滑处理后的心率值 HR。</li>
</ul>
</blockquote>
<p><strong>算法中的固定阈值 425 毫秒（对应心率上限约为 141 BPM）在高心率场景下存在局限性，无法正确检测心率超过 141 BPM 的波峰。因此，波峰间隔阈值不应设为固定值，而是应根据用户状态动态调整，应当结合陀螺仪数据判断用户当前处于静止、运动或剧烈活动状态，从而设置适合的波峰间隔阈值以提高算法的适应性和准确性。</strong></p>
<h3 id="驱动库"><a href="#驱动库" class="headerlink" title="驱动库"></a>驱动库</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// em70x8.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __EM70X8_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __EM70X8_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM7028_ID		 0x36 <span class="comment">// EM7028 默认产品 ID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM7028_ADDR		 0x24 <span class="comment">// EM7028 I2C 设备地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寄存器地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_REG			 0x00 <span class="comment">// 芯片的 PID（产品ID）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS_CFG			 0x01 <span class="comment">// 模式选择寄存器（HRS1 or HRS2）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS_INT_CTRL	 0x02 <span class="comment">// 中断相关寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS_LT_L		 0X03 <span class="comment">// HRS 低八位中断低阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS_LT_H		 0x04 <span class="comment">// HRS 低八位中断高阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS_HT_L		 0x05 <span class="comment">// HRS 高八位中断低阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS_HT_H		 0x06 <span class="comment">// HRS 高八位中断高阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CRT			 0x07 <span class="comment">// LED 电流校准控制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	HRS2_DATA_OFFSET 0x08 <span class="comment">// HRS2 数据偏移</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_CTRL		 0x09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_GAIN_CTRL	 0x0A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_CTRL		 0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_CTRL		 0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFT_RESET		 0x0F <span class="comment">// 重置</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HRS2 数据寄存器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA0_L	 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA0_H	 0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA1_L	 0x22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA1_H	 0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA2_L	 0x24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA2_H	 0x25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA3_L	 0x26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS2_DATA3_H	 0x27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HRS1 数据寄存器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA0_L	 0x28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA0_H	 0x29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA1_L	 0x2A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA1_H	 0x2B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA2_L	 0x2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA2_H	 0x2D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA3_L	 0x2E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HRS1_DATA3_H	 0x2F</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>  <span class="title function_">EM7028_ReadOneReg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> RegAddr)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">EM7028_WriteOneReg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> RegAddr, <span class="type">unsigned</span> <span class="type">char</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_Get_ID</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_hrs_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_hrs_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_hrs_DisEnable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">EM7028_Get_HRS1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">==========================================================================</span><br><span class="line"><span class="comment">// em70x8.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;em70x8.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时钟使能的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLK_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE();</span></span><br><span class="line">    </span><br><span class="line"><span class="type">iic_bus_t</span> EM7028_bus = &#123;</span><br><span class="line">	.IIC_SDA_PORT = GPIOB,</span><br><span class="line">	.IIC_SCL_PORT = GPIOB,</span><br><span class="line">	.IIC_SDA_PIN  = GPIO_PIN_13,</span><br><span class="line">	.IIC_SCL_PIN  = GPIO_PIN_14,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 I2C 总线读取 EM7028 芯片的一个寄存器值</span></span><br><span class="line"><span class="type">uint8_t</span>  <span class="title function_">EM7028_ReadOneReg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> RegAddr)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat;</span><br><span class="line">	dat = IIC_Read_One_Byte(&amp;EM7028_bus, EM7028_ADDR, RegAddr);</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 I2C 总线写入 EM7028 芯片的一个寄存器值</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">EM7028_WriteOneReg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> RegAddr, <span class="type">unsigned</span> <span class="type">char</span> dat)</span>&#123;</span><br><span class="line">	IIC_Write_One_Byte(&amp;EM7028_bus, EM7028_ADDR, RegAddr, dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取芯片的 PID（产品ID）</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_Get_ID</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> EM7028_ReadOneReg(ID_REG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 EM7028 芯片的心率传感器（HRS）模块。</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_hrs_init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">	CLK_ENABLE;</span><br><span class="line">    <span class="comment">// 初始化 I2C 总线</span></span><br><span class="line">	IICInit(&amp;EM7028_bus);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 检查设备 ID,最多五次</span></span><br><span class="line">	<span class="keyword">while</span>(EM7028_Get_ID() != <span class="number">0x36</span> &amp;&amp; i)&#123;</span><br><span class="line">		HAL_Delay(<span class="number">100</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 超时返回</span></span><br><span class="line">	<span class="keyword">if</span>(!i)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">// 启用心率传感器 1（HRS1），禁用心率传感器 2（HRS2），并启用 LED1 来进行心率测量。</span></span><br><span class="line">	EM7028_WriteOneReg(HRS_CFG,<span class="number">0x00</span>);				</span><br><span class="line">    <span class="comment">// 设置传感器数据的偏移量为 0。</span></span><br><span class="line">	EM7028_WriteOneReg(HRS2_DATA_OFFSET, <span class="number">0x00</span>);</span><br><span class="line">	<span class="comment">// 设置 HRS2_GAIN_CTRL 寄存器的增益控制为 0x7f，即增益值为 1。</span></span><br><span class="line">	EM7028_WriteOneReg(HRS2_GAIN_CTRL, <span class="number">0x7f</span>);		</span><br><span class="line">	<span class="comment">//配置 HRS1_CTRL 寄存器，设置心率传感器 1（HRS1）的增益为 1</span></span><br><span class="line">    <span class="comment">// 范围为 8，频率为 2.62144MHz，分辨率为 16 位，并设置为模式工作。</span></span><br><span class="line">	EM7028_WriteOneReg(HRS1_CTRL, <span class="number">0x47</span>);</span><br><span class="line">	设置 INT_CTRL 寄存器，关闭中断控制。</span><br><span class="line">	EM7028_WriteOneReg(INT_CTRL, <span class="number">0x00</span>);</span><br><span class="line">	<span class="comment">//如果所有初始化操作成功完成，函数返回 0，表示初始化成功。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用 EM7028 芯片的心率传感器（HRS）</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_hrs_Enable</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">while</span>(EM7028_Get_ID() != <span class="number">0x36</span> &amp;&amp; i)&#123;</span><br><span class="line">		HAL_Delay(<span class="number">100</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!i)</span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">	EM7028_WriteOneReg(HRS_CFG,<span class="number">0x08</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 EM7028 芯片的心率传感器功能。</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">EM7028_hrs_DisEnable</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">while</span>(EM7028_Get_ID() != <span class="number">0x36</span> &amp;&amp; i)&#123;</span><br><span class="line">		HAL_Delay(<span class="number">100</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!i)</span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">	EM7028_WriteOneReg(HRS_CFG,<span class="number">0x00</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 EM7028 芯片读取心率传感器 1（HRS1）的数据并将其合并为一个 16 位的值</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">EM7028_Get_HRS1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">uint16_t</span> dat;</span><br><span class="line">	dat = EM7028_ReadOneReg(HRS1_DATA0_H);</span><br><span class="line">	dat &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">	dat |= EM7028_ReadOneReg(HRS1_DATA0_L);</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>DRV8833</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8833/</url>
    <content><![CDATA[<p><strong>DRV8833</strong> 是一款由德州仪器（Texas Instruments, TI）推出的双通道 H 桥电机驱动器芯片，广泛应用于直流电机、步进电机和其他低电压驱动场景。</p>
<h2 id="H桥控制电路"><a href="#H桥控制电路" class="headerlink" title="H桥控制电路"></a>H桥控制电路</h2><p>桥是一个比较简单的电路，通常它会包含四个独立控制的开关元器件（例如 MOSFET），它们通常用于驱动电流较大的负载，比如电机，至于为什么要叫H桥（H-Bridge），因为长得比较像 字母H，具体如下图所示</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8833/hqiao.png" alt="hqiao"></p>
<p><strong>正转</strong></p>
<p>此时假设电机正转，这电流依次经过 Q1 ， M ， Q4 ，在图中使用黄色线段进行标注，具体如下图所示</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8833/zhengzhuan.png" alt="zhengzhuan"></p>
<p><strong>反转</strong></p>
<p>此时电机反转（与前面介绍的情况相反），这电流依次经过 Q2 ， M ， Q3 ，在图中使用黄色线段进行标注，具体如下图所示</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8833/fanzhuan.png" alt="fanzhuan"></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>双路 H 桥电流控制电机驱动器</strong>：</p>
<ul>
<li>可驱动两部直流电机或一部步进电机。</li>
<li>低 MOSFET 导通电阻：高侧 (HS) + 低侧 (LS) 为 360mΩ。</li>
</ul>
<p><strong>输出电流</strong>：</p>
<ul>
<li>PWP&#x2F;RTY 封装：每条 H 桥的 RMS 电流为 1.5A，峰值电流为 2A。</li>
<li>PW 封装：每条 H 桥的 RMS 电流为 500mA，峰值电流为 2A。</li>
<li>支持输出并联，PWP 和 RTY 封装可实现 3A RMS 电流和 4A 峰值电流；PW 封装可实现 1A RMS 电流和 4A 峰值电流。</li>
</ul>
<p><strong>宽电源电压范围</strong>：2.7V 至 10.8V。</p>
<p><strong>PWM 绕组电流调节&#x2F;电流限制</strong>。</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p>DRV8833 共有三总封装类型：</p>
<ul>
<li>TSSOP (16)：5.00mm x 4.40mm</li>
<li>HTSSOP (16)：5.00mm x 4.40mm</li>
<li>WQFN (16)：4.00mm x 4.00mm</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/DRV8833/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th align="center"><strong>WQFN</strong></th>
<th align="center"><strong>HTSSOP, TSSOP</strong></th>
<th>I&#x2F;O</th>
<th>描述</th>
<th>外部组件或连接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>电源和接地</strong></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GND</td>
<td align="center">11</td>
<td align="center">13</td>
<td>—</td>
<td>设备接地。HTSSOP 包装具有 PowerPAD。</td>
<td>GND 引脚和电源 PowerPAD 都需要连接到地。</td>
</tr>
<tr>
<td>VINT</td>
<td align="center">12</td>
<td align="center">14</td>
<td>—</td>
<td>内部电源旁路</td>
<td>用 2.2µF、6.3V 电容旁路到地。</td>
</tr>
<tr>
<td>VM</td>
<td align="center">10</td>
<td align="center">12</td>
<td>—</td>
<td>设备电源</td>
<td>连接到电机驱动。推荐使用 10µF（最小值）陶瓷旁路电容到 GND。</td>
</tr>
<tr>
<td>VCP</td>
<td align="center">9</td>
<td align="center">11</td>
<td>IO</td>
<td>高侧门驱动电压</td>
<td>连接到 0.01µF、16V（最小值）X7R 陶瓷电容到 VM。</td>
</tr>
<tr>
<td><strong>控制</strong></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>AIN1</td>
<td align="center">14</td>
<td align="center">16</td>
<td>I</td>
<td>桥 A 输入 1</td>
<td>逻辑输入控制 AOUT1 的状态。内部下拉电阻。</td>
</tr>
<tr>
<td>AIN2</td>
<td align="center">13</td>
<td align="center">15</td>
<td>I</td>
<td>桥 A 输入 2</td>
<td>逻辑输入控制 AOUT2 的状态。内部下拉电阻。</td>
</tr>
<tr>
<td>BIN1</td>
<td align="center">7</td>
<td align="center">9</td>
<td>I</td>
<td>桥 B 输入 1</td>
<td>逻辑输入控制 BOUT1 的状态。内部下拉电阻。</td>
</tr>
<tr>
<td>BIN2</td>
<td align="center">8</td>
<td align="center">10</td>
<td>I</td>
<td>桥 B 输入 2</td>
<td>逻辑输入控制 BOUT2 的状态。内部下拉电阻。</td>
</tr>
<tr>
<td>nSLEEP</td>
<td align="center">15</td>
<td align="center">1</td>
<td>I</td>
<td>睡眠模式</td>
<td>逻辑高使设备进入低功耗睡眠模式，并重置所有内部逻辑。内部下拉电阻。</td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nFAULT</td>
<td align="center">6</td>
<td align="center">8</td>
<td>OD</td>
<td>故障输出</td>
<td>故障条件下（过温、过流）逻辑低电平输出。</td>
</tr>
<tr>
<td><strong>输出</strong></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>AISEN</td>
<td align="center">1</td>
<td align="center">3</td>
<td>IO</td>
<td>桥 A 地面 &#x2F; I_SENSE</td>
<td>连接到桥 A 的电流感测电阻，或如果不需要电流控制，则连接到 GND。</td>
</tr>
<tr>
<td>BISEN</td>
<td align="center">4</td>
<td align="center">6</td>
<td>IO</td>
<td>桥 B 地面 &#x2F; I_SENSE</td>
<td>连接到桥 B 的电流感测电阻，或如果不需要电流控制，则连接到 GND。</td>
</tr>
<tr>
<td>AOUT1</td>
<td align="center">16</td>
<td align="center">2</td>
<td>O</td>
<td>桥 A 输出 1</td>
<td>连接到电机 A 绕组。</td>
</tr>
<tr>
<td>AOUT2</td>
<td align="center">2</td>
<td align="center">4</td>
<td>O</td>
<td>桥 A 输出 2</td>
<td>连接到电机 A 绕组。</td>
</tr>
<tr>
<td>BOUT1</td>
<td align="center">5</td>
<td align="center">7</td>
<td>O</td>
<td>桥 B 输出 1</td>
<td>连接到电机 B 绕组。</td>
</tr>
<tr>
<td>BOUT2</td>
<td align="center">3</td>
<td align="center">5</td>
<td>O</td>
<td>桥 B 输出 2</td>
<td>连接到电机 B 绕组。</td>
</tr>
</tbody></table>
<h2 id="H桥控制逻辑"><a href="#H桥控制逻辑" class="headerlink" title="H桥控制逻辑"></a>H桥控制逻辑</h2><p>DRV8833 的每个 H 桥（A 桥和 B 桥）由两个输入引脚（xIN1 和 xIN2）控制，分别对应两个输出引脚（xOUT1 和 xOUT2）。通过输入引脚的不同逻辑组合，可以实现电机的不同工作状态。</p>
<table>
<thead>
<tr>
<th align="left">xIN1</th>
<th align="left">xIN2</th>
<th align="left">xOUT1</th>
<th align="left">xOUT2</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">Z</td>
<td align="left">Z</td>
<td align="left">滑行&#x2F;快速衰减（Coast&#x2F;Fast Decay）</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">L</td>
<td align="left">H</td>
<td align="left">反转（Reverse）</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">H</td>
<td align="left">L</td>
<td align="left">正转（Forward）</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">L</td>
<td align="left">L</td>
<td align="left">刹车&#x2F;慢速衰减（Brake&#x2F;Slow Decay）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Z</strong>：高阻态（输出断开）。<strong>L</strong>：低电平。<strong>H</strong>：高电平。</p>
</blockquote>
<h2 id="PWM-控制与衰减模式"><a href="#PWM-控制与衰减模式" class="headerlink" title="PWM 控制与衰减模式"></a>PWM 控制与衰减模式</h2><p>当使用 PWM（脉宽调制）控制电机速度时，电机绕组的感性特性会导致电流在 PWM 信号中断后继续流动，这种电流称为<strong>续流电流</strong>。为了处理续流电流，H 桥可以工作在两种不同的衰减模式下：</p>
<p><strong>快速衰减（Fast Decay）</strong></p>
<ul>
<li><strong>工作原理</strong>：H 桥被禁用，续流电流通过 MOSFET 的体二极管流动。</li>
<li><strong>优点</strong>：电流衰减速度快，适合需要快速停止或反转的场景。</li>
<li><strong>控制方式</strong>：<ul>
<li>正转 PWM + 快速衰减：xIN1 &#x3D; PWM，xIN2 &#x3D; 0。</li>
<li>反转 PWM + 快速衰减：xIN1 &#x3D; 0，xIN2 &#x3D; PWM。</li>
</ul>
</li>
</ul>
<p><strong>慢速衰减（Slow Decay）</strong></p>
<ul>
<li><strong>工作原理</strong>：电机绕组被短路，续流电流通过 MOSFET 的低阻抗路径流动。</li>
<li><strong>优点</strong>：电流衰减平稳，适合需要平滑控制的场景。</li>
<li><strong>控制方式</strong>：<ul>
<li>正转 PWM + 慢速衰减：xIN1 &#x3D; 1，xIN2 &#x3D; PWM。</li>
<li>反转 PWM + 慢速衰减：xIN1 &#x3D; PWM，xIN2 &#x3D; 1。</li>
</ul>
</li>
</ul>
<p><strong>PWM 控制逻辑表</strong></p>
<table>
<thead>
<tr>
<th align="left">xIN1</th>
<th align="left">xIN2</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PWM</td>
<td align="left">0</td>
<td align="left">正转 PWM + 快速衰减</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">PWM</td>
<td align="left">正转 PWM + 慢速衰减</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">PWM</td>
<td align="left">反转 PWM + 快速衰减</td>
</tr>
<tr>
<td align="left">PWM</td>
<td align="left">1</td>
<td align="left">反转 PWM + 慢速衰减</td>
</tr>
</tbody></table>
<blockquote>
<p>PWM（脉宽调制信号）、1（高电平）、0（低电平）</p>
</blockquote>
<h2 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drv8833.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRV8833_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRV8833_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32e23x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_AIN1                 RCU_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_AIN1                GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_AIN1                GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AIN1                  GPIO_AF_0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_AIN2                 RCU_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_AIN2                GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_AIN2                GPIO_PIN_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AIN2                  GPIO_AF_0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_BIN1                 RCU_GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_BIN1                GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_BIN1                GPIO_PIN_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BIN1                  GPIO_AF_1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_BIN2                 RCU_GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_BIN2                GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_BIN2                GPIO_PIN_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BIN2                  GPIO_AF_1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_AIN1_TIMER           RCU_TIMER14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_AIN1_TIMER           TIMER14         <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_AIN1_CHANNEL         TIMER_CH_0     <span class="comment">// 定时器通道</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_AIN2_TIMER           RCU_TIMER14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_AIN2_TIMER           TIMER14         <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_AIN2_CHANNEL         TIMER_CH_1     <span class="comment">// 定时器通道</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_BIN1_TIMER           RCU_TIMER2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_BIN1_TIMER           TIMER2         <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_BIN1_CHANNEL         TIMER_CH_2     <span class="comment">// 定时器通道</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCU_BIN2_TIMER           RCU_TIMER2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_BIN2_TIMER           TIMER2         <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_BIN2_CHANNEL         TIMER_CH_3     <span class="comment">// 定时器通道</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN1_OUT(X)  gpio_bit_write(PORT_AIN1, GPIO_AIN1, X?SET:RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN2_OUT(X)  gpio_bit_write(PORT_AIN2, GPIO_AIN2, X?SET:RESET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN1_OUT(X)  gpio_bit_write(PORT_BIN1, GPIO_BIN1, X?SET:RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN2_OUT(X)  gpio_bit_write(PORT_BIN2, GPIO_BIN2, X?SET:RESET)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">(<span class="type">uint16_t</span> pre,<span class="type">uint16_t</span> per)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AO_Control</span><span class="params">(<span class="type">uint8_t</span> dir, <span class="type">uint32_t</span> speed)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BO_Control</span><span class="params">(<span class="type">uint8_t</span> dir, <span class="type">uint32_t</span> speed)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">============================================================================</span><br><span class="line"><span class="comment">//drv8833.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_drv8833.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：DRV8833_Init</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：PWM配置</span></span><br><span class="line"><span class="comment"> * 函 数 形 参： pre定时器时钟预分频值    per周期</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：无</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：PWM频率=200 000 000 /( (pre+1) * (per+1) )</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">void</span> DRV8833_Init(<span class="type">uint16_t</span> pre,<span class="type">uint16_t</span> per)&#123;</span><br><span class="line">    <span class="comment">// 定义定时器结构体</span></span><br><span class="line">    timer_parameter_struct timere_initpara=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="comment">//定时器比较输出结构体</span></span><br><span class="line">    timer_oc_parameter_struct timer_ocintpara=&#123;<span class="number">0</span>&#125;;                                </span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器时钟</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_AIN1_TIMER); <span class="comment">// 开启定时器时钟</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_AIN2_TIMER);</span><br><span class="line">    rcu_periph_clock_enable(RCU_BIN1_TIMER);</span><br><span class="line">    rcu_periph_clock_enable(RCU_BIN2_TIMER);</span><br><span class="line">    <span class="comment">//引脚时钟</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_AIN1);</span><br><span class="line">    rcu_periph_clock_enable(RCU_AIN2);</span><br><span class="line">    rcu_periph_clock_enable(RCU_BIN1);</span><br><span class="line">    rcu_periph_clock_enable(RCU_BIN2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL4); // 配置定时器时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置AIN1*/</span></span><br><span class="line">    gpio_mode_set(PORT_AIN1,GPIO_MODE_AF,GPIO_PUPD_NONE,GPIO_AIN1);</span><br><span class="line">    gpio_output_options_set(PORT_AIN1,GPIO_OTYPE_PP,GPIO_OSPEED_50MHZ,GPIO_AIN1);</span><br><span class="line">    gpio_af_set(PORT_AIN1,AF_AIN1,GPIO_AIN1);</span><br><span class="line">    <span class="comment">/* 配置AIN2*/</span></span><br><span class="line">    gpio_mode_set(PORT_AIN2,GPIO_MODE_AF,GPIO_PUPD_NONE,GPIO_AIN2);</span><br><span class="line">    gpio_output_options_set(PORT_AIN2,GPIO_OTYPE_PP,GPIO_OSPEED_50MHZ,GPIO_AIN2);</span><br><span class="line">    gpio_af_set(PORT_AIN2,AF_AIN2,GPIO_AIN2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置BIN1*/</span></span><br><span class="line">    gpio_mode_set(PORT_BIN1,GPIO_MODE_AF,GPIO_PUPD_NONE,GPIO_BIN1);</span><br><span class="line">    gpio_output_options_set(PORT_BIN1,GPIO_OTYPE_PP,GPIO_OSPEED_50MHZ,GPIO_BIN1);</span><br><span class="line">    gpio_af_set(PORT_BIN1,AF_BIN1,GPIO_BIN1);</span><br><span class="line">    <span class="comment">/* 配置BIN2*/</span></span><br><span class="line">    gpio_mode_set(PORT_BIN2,GPIO_MODE_AF,GPIO_PUPD_NONE,GPIO_BIN2);</span><br><span class="line">    gpio_output_options_set(PORT_BIN2,GPIO_OTYPE_PP,GPIO_OSPEED_50MHZ,GPIO_BIN2);</span><br><span class="line">    gpio_af_set(PORT_BIN2,AF_BIN2,GPIO_BIN2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置定时器参数 */</span></span><br><span class="line">    timer_deinit(BSP_AIN1_TIMER);</span><br><span class="line">    timer_deinit(BSP_AIN2_TIMER);</span><br><span class="line">    timer_deinit(BSP_BIN1_TIMER);</span><br><span class="line">    timer_deinit(BSP_BIN2_TIMER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位定时器</span></span><br><span class="line">    timere_initpara.prescaler = pre<span class="number">-1</span>;      <span class="comment">// 时钟预分频值</span></span><br><span class="line">    timere_initpara.alignedmode = TIMER_COUNTER_EDGE;              <span class="comment">// 边缘对齐</span></span><br><span class="line">    timere_initpara.counterdirection = TIMER_COUNTER_UP;    <span class="comment">// 向上计数</span></span><br><span class="line">    timere_initpara.period = per<span class="number">-1</span>;                                              <span class="comment">// 周期</span></span><br><span class="line">    timere_initpara.clockdivision = TIMER_CKDIV_DIV1;            <span class="comment">// 分频因子</span></span><br><span class="line">    timere_initpara.repetitioncounter = <span class="number">0</span>;                  <span class="comment">// 重复计数器 0-255</span></span><br><span class="line"></span><br><span class="line">    timer_init(BSP_AIN1_TIMER,&amp;timere_initpara); <span class="comment">// 初始化定时器</span></span><br><span class="line">    timer_init(BSP_AIN2_TIMER,&amp;timere_initpara); <span class="comment">// 初始化定时器</span></span><br><span class="line">    timer_init(BSP_BIN1_TIMER,&amp;timere_initpara); <span class="comment">// 初始化定时器</span></span><br><span class="line">    timer_init(BSP_BIN2_TIMER,&amp;timere_initpara); <span class="comment">// 初始化定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置输出结构体 */</span></span><br><span class="line">    timer_ocintpara.ocpolarity = TIMER_OC_POLARITY_HIGH;           <span class="comment">// 有效电平的极性</span></span><br><span class="line">    timer_ocintpara.outputstate = TIMER_CCX_ENABLE;                <span class="comment">// 配置比较输出模式状态 也就是使能PWM输出到端口</span></span><br><span class="line">    timer_ocintpara.ocnpolarity  = TIMER_OCN_POLARITY_HIGH;        <span class="comment">// 通道互补输出极性为高电平</span></span><br><span class="line">    timer_ocintpara.outputnstate = TIMER_CCXN_DISABLE;            <span class="comment">// 通道互补输出状态失能</span></span><br><span class="line">    timer_ocintpara.ocidlestate  = TIMER_OC_IDLE_STATE_LOW;        <span class="comment">// 信道输出的空闲状态为低</span></span><br><span class="line">    timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;<span class="comment">// 信道互补输出的空闲状态为低</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置定时器输出功能 */</span></span><br><span class="line">    timer_channel_output_config(BSP_AIN1_TIMER,BSP_AIN1_CHANNEL,&amp;timer_ocintpara);</span><br><span class="line">    timer_channel_output_config(BSP_AIN2_TIMER,BSP_AIN2_CHANNEL,&amp;timer_ocintpara);</span><br><span class="line">    timer_channel_output_config(BSP_BIN1_TIMER,BSP_BIN1_CHANNEL,&amp;timer_ocintpara);</span><br><span class="line">    timer_channel_output_config(BSP_BIN2_TIMER,BSP_BIN2_CHANNEL,&amp;timer_ocintpara);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置占空比 范围 0 ~ (per-1) */</span></span><br><span class="line">    timer_channel_output_pulse_value_config(BSP_AIN1_TIMER,BSP_AIN1_CHANNEL,<span class="number">1000</span>);</span><br><span class="line">    timer_channel_output_pulse_value_config(BSP_AIN2_TIMER,BSP_AIN2_CHANNEL,<span class="number">1000</span>);</span><br><span class="line">    timer_channel_output_pulse_value_config(BSP_BIN1_TIMER,BSP_BIN1_CHANNEL,<span class="number">1000</span>);</span><br><span class="line">    timer_channel_output_pulse_value_config(BSP_BIN2_TIMER,BSP_BIN2_CHANNEL,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置定时器通道输出比较模式</span></span><br><span class="line">    timer_channel_output_mode_config(BSP_AIN1_TIMER,BSP_AIN1_CHANNEL,TIMER_OC_MODE_PWM0);                       <span class="comment">// 配置定时器通道输出比较模式</span></span><br><span class="line">    timer_channel_output_mode_config(BSP_AIN2_TIMER,BSP_AIN2_CHANNEL,TIMER_OC_MODE_PWM0);                       <span class="comment">// 配置定时器通道输出比较模式</span></span><br><span class="line">    timer_channel_output_mode_config(BSP_BIN1_TIMER,BSP_BIN1_CHANNEL,TIMER_OC_MODE_PWM0);                       <span class="comment">// 配置定时器通道输出比较模式</span></span><br><span class="line">    timer_channel_output_mode_config(BSP_BIN2_TIMER,BSP_BIN2_CHANNEL,TIMER_OC_MODE_PWM0);                       </span><br><span class="line">    <span class="comment">// 配置定时器通道输出影子寄存器</span></span><br><span class="line">    timer_channel_output_shadow_config(BSP_AIN1_TIMER,BSP_AIN1_CHANNEL,TIMER_OC_SHADOW_DISABLE);  </span><br><span class="line">    <span class="comment">// 配置定时器通道输出影子寄存器</span></span><br><span class="line">    timer_channel_output_shadow_config(BSP_AIN2_TIMER,BSP_AIN2_CHANNEL,TIMER_OC_SHADOW_DISABLE); </span><br><span class="line">    <span class="comment">// 配置定时器通道输出影子寄存器</span></span><br><span class="line">    timer_channel_output_shadow_config(BSP_BIN1_TIMER,BSP_BIN1_CHANNEL,TIMER_OC_SHADOW_DISABLE);  </span><br><span class="line">    <span class="comment">// 配置定时器通道输出影子寄存器</span></span><br><span class="line">    timer_channel_output_shadow_config(BSP_BIN2_TIMER,BSP_BIN2_CHANNEL,TIMER_OC_SHADOW_DISABLE);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有高级定时器使用 */</span></span><br><span class="line">    timer_auto_reload_shadow_enable(BSP_AIN1_TIMER);</span><br><span class="line">    timer_auto_reload_shadow_enable(BSP_AIN2_TIMER);</span><br><span class="line">    timer_auto_reload_shadow_enable(BSP_BIN1_TIMER);</span><br><span class="line">    timer_auto_reload_shadow_enable(BSP_BIN2_TIMER);</span><br><span class="line"></span><br><span class="line">    timer_primary_output_config(BSP_AIN1_TIMER, ENABLE);</span><br><span class="line">    timer_primary_output_config(BSP_AIN2_TIMER, ENABLE);</span><br><span class="line">    timer_primary_output_config(BSP_BIN1_TIMER, ENABLE);</span><br><span class="line">    timer_primary_output_config(BSP_BIN2_TIMER, ENABLE);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 使能定时器 */</span></span><br><span class="line">    timer_enable(BSP_AIN1_TIMER);</span><br><span class="line">    timer_enable(BSP_AIN2_TIMER);</span><br><span class="line">    timer_enable(BSP_BIN1_TIMER);</span><br><span class="line">    timer_enable(BSP_BIN2_TIMER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：AO_Control</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：A端口电机控制</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：dir旋转方向 1正转0反转   speed旋转速度，范围（0 ~ per-1）</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：无</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AO_Control</span><span class="params">(<span class="type">uint8_t</span> dir, <span class="type">uint32_t</span> speed)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( dir == <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="comment">//AO1输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_AIN1_TIMER,BSP_AIN1_CHANNEL, <span class="number">0</span> );</span><br><span class="line">                <span class="comment">//AO2输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_AIN2_TIMER,BSP_AIN2_CHANNEL, speed );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//AO1输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_AIN1_TIMER,BSP_AIN1_CHANNEL, speed );</span><br><span class="line">        <span class="comment">//AO2输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_AIN2_TIMER,BSP_AIN2_CHANNEL, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：B0_Control</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：B端口电机控制</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：dir旋转方向 1正转0反转   speed旋转速度，范围（0 ~ per-1）</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：无</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BO_Control</span><span class="params">(<span class="type">uint8_t</span> dir, <span class="type">uint32_t</span> speed)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( dir == <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="comment">//BO1输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_BIN1_TIMER,BSP_BIN1_CHANNEL, <span class="number">0</span> );</span><br><span class="line">        <span class="comment">//BO2输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_BIN2_TIMER,BSP_BIN2_CHANNEL, speed );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//BO1输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_BIN1_TIMER,BSP_BIN1_CHANNEL, speed );</span><br><span class="line">        <span class="comment">//BO2输出</span></span><br><span class="line">        timer_channel_output_pulse_value_config(BSP_BIN2_TIMER,BSP_BIN2_CHANNEL, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32e23x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_drv8833.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    systick_config();             <span class="comment">// 滴答定时器初始化</span></span><br><span class="line">    usart_gpio_config(<span class="number">9600U</span>); <span class="comment">// 串口0初始化</span></span><br><span class="line"></span><br><span class="line">    DRV8833_Init(<span class="number">10</span>,<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            i += <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">8000</span> ) i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            AO_Control(<span class="number">0</span>,i);<span class="comment">//A端电机反转</span></span><br><span class="line">            BO_Control(<span class="number">1</span>,i);<span class="comment">//B端电机正转</span></span><br><span class="line">            delay_1ms(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>LCD</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/LCD/</url>
    <content><![CDATA[<p>LCD（Liquid Crystal Display，液晶显示屏）是一种利用液晶材料的光学特性来显示图像的平面显示技术。LCD 广泛应用于智能手机、电视、电脑显示器、仪表盘、医疗设备等领域。下面是对 LCD 详细的介绍。</p>
<h2 id="LCD工作原理"><a href="#LCD工作原理" class="headerlink" title="LCD工作原理"></a>LCD工作原理</h2><p>LCD 依靠液晶分子的光学特性来控制光的透过率，从而显示图像。其基本原理如下：</p>
<p><strong>背光层</strong>：</p>
<ul>
<li>LCD 本身不发光，需要一个背光源提供均匀的白光。</li>
<li>LED 背光层产生光线，向上穿过 LCD 结构。</li>
</ul>
<p><strong>垂直偏光片</strong>：</p>
<ul>
<li>背光通过这个偏光片后，只有特定方向的偏振光可以透过。</li>
<li>这个偏光片确保进入液晶层的光线是线性偏振光。</li>
</ul>
<p><strong>正极电路和负极电路</strong>：</p>
<ul>
<li>提供控制电场，改变液晶分子的取向，从而控制光的透过率。</li>
<li>通过施加不同的电压，使液晶分子排列方式发生变化。</li>
</ul>
<p><strong>液晶层</strong>：</p>
<ul>
<li>调节光的通过状态。</li>
<li>在没有电场时，液晶分子呈自然扭曲状态，使光的偏振方向发生旋转，最终光可以通过上层偏光片，产生亮度。</li>
<li>在施加电场后，液晶分子排列变得有序，不再旋转光的偏振方向，导致光无法通过上层偏光片，从而显示黑色。</li>
<li>通过调节电压，可以控制液晶的透光率，实现灰阶变化。</li>
</ul>
<p><strong>水平偏光片</strong>：</p>
<ul>
<li>控制光最终的透射状态。</li>
<li>液晶层调制后的光通过水平偏光片，进一步决定最终进入人眼的光量。</li>
<li>如果液晶层已经改变光的偏振方向，使其匹配水平偏光片，则光可以通过，显示亮色。</li>
<li>如果液晶层未改变光的偏振方向，则光被阻挡，显示黑色。</li>
</ul>
<p><strong>彩色滤光片</strong>：</p>
<ul>
<li>提供颜色，生成图像。</li>
<li>由红（R）、绿（G）、蓝（B）三种颜色的滤光片组成。</li>
<li>每个像素由红、绿、蓝子像素组成，通过调节每个子像素的亮度，可以混合出各种颜色。</li>
<li>例如，红色子像素透光时，其他颜色被吸收，最终肉眼看到红色。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/LCD/lcdyl.png" alt="lcdyl"></p>
<blockquote>
<h2 id="偏光片的作用"><a href="#偏光片的作用" class="headerlink" title="偏光片的作用"></a><strong>偏光片的作用</strong></h2><p>LCD 里面的<strong>两个偏光片（偏振片）</strong>，一个<strong>垂直偏光片</strong>（下方），一个<strong>水平偏光片</strong>（上方），它们的主要作用是<strong>控制光的通过和屏幕的亮暗</strong>。</p>
<p>可以把它们想象成<strong>百叶窗</strong>：</p>
<ul>
<li><strong>垂直偏光片</strong>：只能让<strong>垂直方向的光</strong>通过，就像竖着开的百叶窗。</li>
<li><strong>水平偏光片</strong>：只能让<strong>水平方向的光</strong>通过，就像横着开的百叶窗。</li>
</ul>
<p>如果两个偏光片方向一致（比如都是垂直的），光可以通过，屏幕会亮。<br>如果两个偏光片方向正交（一个垂直、一个水平），光无法通过，屏幕是黑的。</p>
<h2 id="液晶层如何影响光"><a href="#液晶层如何影响光" class="headerlink" title="液晶层如何影响光"></a><strong>液晶层如何影响光</strong></h2><p>液晶分子就像“扭动的光学百叶窗”：</p>
<ul>
<li>当液晶层处于自然状态（无电压）：<ul>
<li>它会让光的方向旋转 90°，这样光就能顺利通过<strong>水平偏光片</strong>，屏幕显示亮色。</li>
</ul>
</li>
<li>当液晶层加上电压：<ul>
<li>它会变直，不再旋转光的方向，这时光到达<strong>水平偏光片</strong>时被阻挡，屏幕变黑。</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>MLX90393</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/</url>
    <content><![CDATA[<p>MLX90393 是一款3轴霍尔传感器，能够感知磁场的强度和方向，适合用来实现精确的方向和位置感知。可以通过检测磁场的变化来控制设备的前后、左右移动。</p>
<p>此传感器提供 16 位输出，当 MLX90393 作为总线上的从器件时，将通过 I2C 和 SPI 提供上述数字值。</p>
<h2 id="霍尔传感器工作原理"><a href="#霍尔传感器工作原理" class="headerlink" title="霍尔传感器工作原理"></a>霍尔传感器工作原理</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/hrgzyl.png" alt="hrgzyl"></p>
<p>MLX90393 传感器可以分离并测量磁场的三个分量：</p>
<ul>
<li><p><strong>Bx</strong>：水平磁场分量，红色箭头。</p>
</li>
<li><p><strong>By</strong>：垂直磁场分量（与 X 方向垂直的平面分量），蓝色箭头。</p>
</li>
<li><p><strong>Bz</strong>：垂直于传感器平面的磁场分量，紫色箭头。</p>
</li>
</ul>
<p><strong>应用示例</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/hryysl.png" alt="hryysl"></p>
<p>以操纵杆为例：操纵杆可以在水平和垂直方向上移动（X 轴和 Y 轴）。操控杆底部通常会嵌入一个小型磁铁。当操控杆在不同方向上倾斜时，磁铁会随之移动，改变磁场的方向和强度，霍尔传感器会感知这些变化，从而实现位置和角度的检测。</p>
<h2 id="电器属性"><a href="#电器属性" class="headerlink" title="电器属性"></a>电器属性</h2><p>2.2V-3.6V 电源，适用于电池供电的应用，低至 1.8V 的 I&#x2F;O 电压。</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th><strong>引脚编号</strong></th>
<th><strong>引脚名称</strong></th>
<th><strong>引脚功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>INT</td>
<td>数据准备就绪信号输出引脚，逻辑高有效（DRDY标志）</td>
</tr>
<tr>
<td>2</td>
<td>CS</td>
<td>芯片选择引脚，在 SPI 模式下使用；在 I2C 模式下需拉高</td>
</tr>
<tr>
<td>3</td>
<td>SCLK</td>
<td>SPI 和 I2C 模式下的串行时钟</td>
</tr>
<tr>
<td>4, 9, 10, 14, 16</td>
<td>NC</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>SDA&#x2F;MOSI</td>
<td>SPI 模式下为数据输入引脚，I2C 模式下为数据输入&#x2F;输出引脚</td>
</tr>
<tr>
<td>6</td>
<td>MISO</td>
<td>SPI 模式下的数据输出引脚</td>
</tr>
<tr>
<td>7</td>
<td>INT&#x2F;TRIG</td>
<td>触发引脚，可用于启动测量</td>
</tr>
<tr>
<td>8</td>
<td>VDDIO</td>
<td>数字供电引脚</td>
</tr>
<tr>
<td>11</td>
<td>A1</td>
<td>7 位 I2C 地址的第 1 位 (0 0 0 1 1 A1 A0)</td>
</tr>
<tr>
<td>12</td>
<td>A0</td>
<td>7 位 I2C 地址的第 0 位 (0 0 0 1 1 A1 A0)</td>
</tr>
<tr>
<td>13</td>
<td>VSS</td>
<td>地（GND）引脚</td>
</tr>
<tr>
<td>15</td>
<td>Vdd</td>
<td>电源引脚</td>
</tr>
</tbody></table>
<h2 id="轴定义"><a href="#轴定义" class="headerlink" title="轴定义"></a>轴定义</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/zdy.png" alt="zdy"></p>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/sldl.png" alt="sldl"></p>
<blockquote>
<p>I2C 可以在10kHz（低速模式）、100kHz（标准模式）、400kHz（高速模式）之间进行设置；</p>
<p>通常我们通过 INT&#x2F;TRIG 引脚触发，  INT 引脚作为外部中断触发；</p>
</blockquote>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="I2C地址"><a href="#I2C地址" class="headerlink" title="I2C地址"></a>I2C地址</h3><p>MLX90393 系列芯片不同版本的 I2C 地址是不同的，参考如下</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/I2Cdz.png" alt="I2Cdz"></p>
<p>示例代码中有查询 I2C 地址的方法。</p>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>MLX90393 的 SPI 通信时半双工的所以一般不用。</p>
<h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><p>我们需要使用一些命令与 MLX90393 进行通信</p>
<p>MLX90393 仅接受特定的命令集。除了复位（Reset）命令外，所有命令都会生成一个状态字节（status byte）可供读取。下表列出了 MLX90393 条件接受的 10 个不同命令。即使命令无效，MLX90393 在 I²C 中始终会对命令进行确认。通过解释关联的状态字节可以验证命令是否被接受。</p>
<table>
<thead>
<tr>
<th><strong>Command Name（命令名称）</strong></th>
<th align="center"><strong>Symbol（符号）</strong></th>
<th align="center"><strong>编号</strong></th>
<th><strong>CMD1 Byte（命令字节 1）</strong></th>
<th><strong>CMD2 Byte（命令字节 2）</strong></th>
<th><strong>CMD3 Byte（命令字节 3）</strong></th>
<th><strong>CMD4 Byte（命令字节 4）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Start Burst Mode（开始命令模式）</td>
<td align="center">SB</td>
<td align="center">1</td>
<td>0001 zyxt</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Start Wake-up on Change Mode（开始变化唤醒模式）</td>
<td align="center">SW</td>
<td align="center">2</td>
<td>0010 zyxt</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Start Single Measurement Mode（开始单次测量模式）</td>
<td align="center">SM</td>
<td align="center">3</td>
<td>0011 zyxt</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Read Measurement（读取测量值）</td>
<td align="center">RM</td>
<td align="center">4</td>
<td>0100 zyxt</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Read Register（读取寄存器）</td>
<td align="center">RR</td>
<td align="center">5</td>
<td>0101 0abc</td>
<td>{A5…A0, 0, 0}</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Write Register（写入寄存器）</td>
<td align="center">WR</td>
<td align="center">6</td>
<td>0110 0abc</td>
<td>D15…D8</td>
<td>D7…D0</td>
<td>{A5…A0, 0, 0}</td>
</tr>
<tr>
<td>Exit Mode（退出模式）</td>
<td align="center">EX</td>
<td align="center">8</td>
<td>1000 0000</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Memory Recall（内存回调）</td>
<td align="center">HR</td>
<td align="center">D</td>
<td>1101 0000</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Memory Store（内存存储）</td>
<td align="center">HS</td>
<td align="center">E</td>
<td>1110 0000</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Reset（复位）</td>
<td align="center">RT</td>
<td align="center">F</td>
<td>1111 0000</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<p>对于可变内存访问命令（RR&#x2F;WR）中的 abc 参数，应设置为 0x0，以进行正常的内存读取和写入。</p>
<blockquote>
<p>在所有启动模式的命令（SB&#x2F;SW&#x2F;SM）中，参数是一个<strong>nibble</strong>（4位二进制值），用于指定传感器需要执行的测量转换，按照以下顺序定义：<strong>「zyxt」</strong>。<br>例如，如果只需要在单次测量模式（Single Measurement Mode）中测量 <strong>Y轴</strong> 和 <strong>温度</strong>，那么正确的命令字节应为 <strong>0x35</strong>。</p>
<p>传感器芯片上的测量执行顺序是反转的，按照 <strong>「TXYZ」</strong> 进行测量，因此温度（T）会先被测量，随后依次测量 X、Y 和 Z。</p>
<p>如果发送的「zyxt」 nibble 值全为 0（即 0x00），传感器会使用 RAM 中的 <strong>BURST_SEL</strong> 配置值，作为替代命令中的空参数。</p>
</blockquote>
<h3 id="状态字"><a href="#状态字" class="headerlink" title="状态字"></a>状态字</h3><p>状态字节是 MLX90393 响应主机发出的命令而传输的第一个字节。<br>它由信息位的固定组合组成：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/ztz.png" alt="ztz"></p>
<blockquote>
<p><strong>模式位（MODE bits）</strong></p>
<ul>
<li>这些位定义了 MLX90393 当前的工作模式。</li>
<li>当发生模式切换时，状态字节会清除先前的模式位。</li>
<li>如果命令被拒绝（例如非法命令），会伴随 <strong>ERROR</strong> 位被设置。</li>
<li><strong>SM_MODE</strong> 位可能是由单次测量命令（SM 命令）或通过 TRG 引脚触发时被设置（此时 volatile memory 中启用了 TRG 模式）。</li>
</ul>
<p><strong>错误位（ERROR bit）</strong></p>
<ul>
<li>如果命令被拒绝或在存储器中检测到不可修复的错误（ECC_ERROR），则会设置此位。</li>
<li><strong>ECC_ERROR</strong> 意味着存储器中的单个错误可以被纠正（由 SED 位表示），但两个错误将导致不可修复的 ECC_ERROR。</li>
<li>例如，在突发模式中，RR（读取寄存器）&#x2F;WR（写入寄存器）命令会被拒绝，而此时 <strong>ERROR</strong> 位会被设置。</li>
<li><strong>DRDY 标志为低</strong>时读取数据，<strong>ERROR</strong> 位可能会被设置，但这并不表示命令被拒绝。</li>
</ul>
<p><strong>SED 位（单错误检测）</strong></p>
<ul>
<li>表示在非易失性存储器中检测到单比特错误，但可以被纠正。</li>
<li>该位仅用于提示，对 MLX90393 的操作没有任何影响。</li>
</ul>
<p><strong>RS 位（复位状态）</strong></p>
<ul>
<li>当发出复位（RT）命令时，该状态消息会通过设置 <strong>RS 位</strong>表示复位即将执行。</li>
<li>在复位完成后，RS 位会被清除。</li>
</ul>
<p><strong>D[1:0] 位（数据计数位）</strong></p>
<ul>
<li>仅在 <strong>RR</strong>（读取寄存器）和 <strong>RM</strong>（读取测量数据）命令中有效，用于指示预期返回的数据量。</li>
<li>数据字节数为 2 * D[1:0] + 2，预期返回的字节数可能是 2、4、6 或 8 字节。</li>
<li>对于没有响应数据的命令，这些位的内容将被忽略。</li>
</ul>
</blockquote>
<h2 id="命令流程"><a href="#命令流程" class="headerlink" title="命令流程"></a>命令流程</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/yd.png" alt="yd"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/mllc.png" alt="mllc"></p>
<h2 id="读取测量值"><a href="#读取测量值" class="headerlink" title="读取测量值"></a>读取测量值</h2><p>读取的结果根据 zyxt 的值不同而有所不同。数据以 Status-TXYZ 的顺序返回，跳过设置为零的组件。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MLX90393/dqzlz.png" alt="dqzlz"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>S15OT421</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/S15OT421/</url>
    <content><![CDATA[<p><strong>歌尔（Goertek）</strong> 公司生产的 <strong>MEMS 麦克风</strong>（型号：S15OT421-011）；它的主要作用是将声音信号转换为电信号，以便设备能够处理、传输或存储声音信息。</p>
<h2 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h2><ul>
<li><strong>工作电压范围</strong>：1.5V 到 3.3V。最好是 2V 左右</li>
</ul>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/S15OT421/yjsm.png" alt="yjsm"></p>
<p>它会将采集到的声音转化为模拟型号</p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>MPU6050</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MPU6050/</url>
    <content><![CDATA[<p>MPU-60X0 由三个独立的 MEMS 振动陀螺仪组成，这些陀螺仪检测 X、Y 和 Z 轴的旋转。当陀螺仪绕任何感测轴旋转时，科里奥利效应会产生振动，并由电容式传感器进行检测。产生的信号经过放大、解调和滤波处理后，生成与角速率成正比的电压。该电压通过片上独立的 16 位模数转换器（ADC）进行数字化，以便对每个轴进行采样。陀螺仪的满量程范围可以数字编程选择为 ±250、±500、±1000 或 ±2000 度每秒（dps）。ADC 的采样率可编程，从每秒 8000 个采样降低至每秒 3.9 个采样，并且用户可以选择低通滤波器，以实现不同的截止频率。</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MPU6050/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="center">引脚编号</th>
<th align="center">MPU-6000</th>
<th align="center">MPU-6050</th>
<th align="center">引脚名称</th>
<th align="center">引脚描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">CLKIN</td>
<td align="center">可选的外部参考时钟输入。如果不使用，连接到 GND。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">AUX_DA</td>
<td align="center">I²C 主串行数据，用于连接外部传感器。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">AUX_CL</td>
<td align="center">I²C 主串行时钟，用于连接外部传感器。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">&#x2F;CS</td>
<td align="center">SPI 片选（0 &#x3D; SPI 模式）。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">VLOGIC</td>
<td align="center">数字 I&#x2F;O 供电电压。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">AD0 &#x2F; SDO</td>
<td align="center">I²C 从设备地址最低有效位 (AD0)<br />SPI 串行数据输出 (SDO)</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">AD0</td>
<td align="center">I²C 从设备地址最低有效位 (AD0)。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">REGOUT</td>
<td align="center">稳压滤波器电容器连接。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">FSYNC</td>
<td align="center">帧同步数字输入。未使用时连接到 GND。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">INT</td>
<td align="center">中断数字输出（推挽或开漏）。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">VDD</td>
<td align="center">电源供电电压和数字 I&#x2F;O 供电电压。</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">GND</td>
<td align="center">电源地。</td>
</tr>
<tr>
<td align="center">19, 21</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">RESV</td>
<td align="center">保留引脚。不要连接。</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">CPOUT</td>
<td align="center">电荷泵电容器连接。</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">RESV</td>
<td align="center">保留引脚。不要连接。</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">SCL &#x2F; SCLK</td>
<td align="center">I²C 串行时钟（SCL）；SPI 串行时钟信号（SCLK）。</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">SCL</td>
<td align="center">I²C 串行时钟（SCL）。</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">SDA &#x2F; SDI</td>
<td align="center">I²C 串行数据线（SDA）；SPI 串行数据输入线（SDI）。</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">SDA</td>
<td align="center">I²C 串行数据线（SDA）。</td>
</tr>
<tr>
<td align="center">2, 3, 4, 5, 14, 15, 16, 17</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">NC</td>
<td align="center">未内部连接，可用于 PCB 路由。</td>
</tr>
</tbody></table>
<h2 id="I2C-时序特性"><a href="#I2C-时序特性" class="headerlink" title="I2C 时序特性"></a>I2C 时序特性</h2><table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>含义</strong></th>
<th align="center"><strong>最小值</strong></th>
<th align="center"><strong>典型值</strong></th>
<th align="center"><strong>最大值</strong></th>
<th align="center"><strong>单位</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>f<sub>SCL</sub></strong></td>
<td align="center">SCL 时钟频率</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">400</td>
<td align="center">kHz</td>
<td align="center">I²C Fast-Mode 最大时钟频率。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>HD.STA</sub></strong></td>
<td align="center">START 条件保持时间（重复 START 条件）</td>
<td align="center">0.6</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">START 条件后 SDA 需要保持的时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>LOW</sub></strong></td>
<td align="center">SCL 低电平时间</td>
<td align="center">1.3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">时钟信号 SCL 的低电平周期时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>HIGH</sub></strong></td>
<td align="center">SCL 高电平时间</td>
<td align="center">0.6</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">时钟信号 SCL 的高电平周期时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>SU.STA</sub></strong></td>
<td align="center">START 条件建立时间</td>
<td align="center">0.6</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">START 条件信号开始前 SDA 建立的时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>HD;DAT</sub></strong></td>
<td align="center">数据保持时间</td>
<td align="center">0</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">数据传输后 SDA 保持的时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>SU;DAT</sub></strong></td>
<td align="center">数据建立时间</td>
<td align="center">100</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">ns</td>
<td align="center">数据传输前 SDA 建立的最小时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>R</sub></strong></td>
<td align="center">SCL 和 SDA 的上升时间</td>
<td align="center">-</td>
<td align="center">20+0.1C<sub>b</sub></td>
<td align="center">300</td>
<td align="center">ns</td>
<td align="center">受电容 C<sub>b</sub> 影响的上升时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>F</sub></strong></td>
<td align="center">SCL 和 SDA 的下降时间</td>
<td align="center">-</td>
<td align="center">20+0.1C<sub>b</sub></td>
<td align="center">300</td>
<td align="center">ns</td>
<td align="center">受电容 C<sub>b</sub> 影响的下降时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>SU;STO</sub></strong></td>
<td align="center">STOP 条件建立时间</td>
<td align="center">0.6</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">STOP 条件信号开始前的建立时间。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>BUF</sub></strong></td>
<td align="center">STOP 和下一次 START 之间的空闲时间</td>
<td align="center">1.3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">µs</td>
<td align="center">STOP 条件与下一次 START 之间的最小间隔。</td>
</tr>
<tr>
<td align="center"><strong>C<sub>b</sub></strong></td>
<td align="center">每条总线的电容</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">&lt; 400</td>
<td align="center">pF</td>
<td align="center">I²C 总线允许的最大电容负载。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>VD;DAT</sub></strong></td>
<td align="center">数据有效时间（SDA 数据有效）</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0.9</td>
<td align="center">µs</td>
<td align="center">主机或从机输出数据后，接收方必须等待最多 0.9 µs 才能确认数据是有效的。</td>
</tr>
<tr>
<td align="center"><strong>t<sub>VD;ACK</sub></strong></td>
<td align="center">ACK&#x2F;NACK 信号有效时间（SDA 数据确认）</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0.9</td>
<td align="center">µs</td>
<td align="center">接收端发送 ACK&#x2F;NACK 信号后，发送方最多需要等待 0.9 µs 才能确认这个应答信号是有效的。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>基本条件</strong></p>
<ul>
<li><strong>VDD</strong>：工作电压范围在 <strong>2.375V - 3.46V</strong>。</li>
<li><strong>VLOGIC</strong>：对于 MPU-6050，这个逻辑电压为 <strong>1.8V±5%</strong> 或等于 VDD。</li>
<li><strong>TA &#x3D; 25°C</strong>：所有数据的测量温度为 <strong>25°C</strong>。</li>
</ul>
</blockquote>
<h2 id="I2C-地址"><a href="#I2C-地址" class="headerlink" title="I2C 地址"></a>I2C 地址</h2><p>I2C 接口的从设备地址的最低有效位（<strong>LSB</strong>）由引脚 9（<strong>AD0</strong>）的电平决定，</p>
<ul>
<li><p>如果 <strong>AD0 &#x3D; 0</strong>（接地，逻辑低），LSB 为 <strong>0</strong>，从设备地址为 0x68（1101000）。</p>
</li>
<li><p>如果 <strong>AD0 &#x3D; 1</strong>（接高电平，逻辑高），LSB 为 <strong>1</strong>，从设备地址为 0x69（1101001）。</p>
</li>
</ul>
<p><strong>通过配置 AD0 引脚</strong>，用户可以改变 MPU-60X0 的地址，从而允许两个 MPU-60X0 设备共存于同一条 I2C 总线上，而不会发生地址冲突。</p>
<h2 id="角速度与加速度"><a href="#角速度与加速度" class="headerlink" title="角速度与加速度"></a>角速度与加速度</h2><h3 id="角速度"><a href="#角速度" class="headerlink" title="角速度"></a>角速度</h3><p>角速度描述的是一个物体<strong>绕某个轴旋转的快慢</strong>，即物体在单位时间内旋转的角度。</p>
<p>它是<strong>旋转运动</strong>中的一个重要物理量。</p>
<h3 id="加速度"><a href="#加速度" class="headerlink" title="加速度"></a>加速度</h3><p>加速度是描述<strong>物体速度变化快慢的物理量</strong>。</p>
<p>它表示单位时间内<strong>速度的变化量</strong>，可以描述<strong>直线运动</strong>中的加速、减速，或者<strong>方向变化</strong>引起的加速（如圆周运动）。</p>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MPU6050/sldl.png" alt="sldl"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MPU6050/pwqj.png" alt="pwqj"></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>具体可查看中文手册</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><h4 id="屏幕翻转"><a href="#屏幕翻转" class="headerlink" title="屏幕翻转"></a>屏幕翻转</h4><p>翻转屏幕主要基于 <strong>加速度计的重力方向</strong>。当设备正常摆放时，重力加速度主要作用在 Z 轴方向；当设备翻转（如倒置或侧翻）时，重力方向会改变。</p>
<p><strong>实现原理：</strong></p>
<ul>
<li>重力加速度分布：<ul>
<li>Z 轴朝上时：加速度计输出约 +1g。</li>
<li>Z 轴朝下时：加速度计输出约 -1g。</li>
<li>X 和 Y 轴也会随着设备翻转发生变化。</li>
</ul>
</li>
<li>通过计算加速度计三轴（X、Y、Z）的方向与幅值，判断设备当前的朝向。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Check_Screen_Orientation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">short</span> accelData[<span class="number">3</span>]; <span class="comment">// 存储加速度数据 ax, ay, az</span></span><br><span class="line">    MPU6050ReadAcc(accelData); <span class="comment">// 读取加速度计数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> ax = accelData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span> ay = accelData[<span class="number">1</span>];</span><br><span class="line">    <span class="type">short</span> az = accelData[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (az &gt; <span class="number">8000</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;屏幕正向朝上\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (az &lt; <span class="number">-8000</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;屏幕已翻转\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ax &gt; <span class="number">8000</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;屏幕左侧朝上\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ax &lt; <span class="number">-8000</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;屏幕右侧朝上\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ay &gt; <span class="number">8000</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;屏幕顶部朝上\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ay &lt; <span class="number">-8000</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;屏幕底部朝上\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li>ax, ay, az 是加速度计的三轴数据。</li>
<li>值为 8000 表示加速度接近 1g（取决于量程配置，例如 ±8g 时 1g≈8192）。</li>
</ul>
<h4 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h4><p>睡眠状态的判断通常基于 <strong>加速度计的变化程度</strong>。当设备长时间处于静止状态（加速度变化非常小），可以认为设备处于睡眠状态。</p>
<p><strong>实现原理：</strong></p>
<ul>
<li>计算加速度计三轴数据的 <strong>均方根</strong> 或 <strong>变化幅度</strong>。</li>
<li>如果变化小于某个阈值，并持续一段时间，则进入睡眠状态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THRESHOLD_SLEEP 500  <span class="comment">// 静止状态加速度变化阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEP_TIME 5000      <span class="comment">// 静止持续时间 (毫秒)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Check_Sleep_State</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> u32 sleep_timer = <span class="number">0</span>;</span><br><span class="line">    <span class="type">short</span> accelData[<span class="number">3</span>];</span><br><span class="line">    MPU6050ReadAcc(accelData);</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> ax = accelData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span> ay = accelData[<span class="number">1</span>];</span><br><span class="line">    <span class="type">short</span> az = accelData[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> accel_magnitude = <span class="built_in">sqrt</span>(ax * ax + ay * ay + az * az);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(accel_magnitude - <span class="number">8192</span>) &lt; THRESHOLD_SLEEP) &#123; <span class="comment">// 判断是否接近静止</span></span><br><span class="line">        sleep_timer += <span class="number">10</span>; <span class="comment">// 每10ms调用一次</span></span><br><span class="line">        <span class="keyword">if</span> (sleep_timer &gt;= SLEEP_TIME) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;设备进入睡眠状态\n&quot;</span>);</span><br><span class="line">            sleep_timer = SLEEP_TIME;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep_timer = <span class="number">0</span>; <span class="comment">// 重置计时器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li>静止时加速度幅值接近 1g，即 8192（取决于加速度量程）。</li>
<li>如果加速度变化幅度小于阈值 THRESHOLD_SLEEP 且持续时间大于 SLEEP_TIME，认为设备进入静止。</li>
</ul>
<h4 id="运动状态"><a href="#运动状态" class="headerlink" title="运动状态"></a>运动状态</h4><p>运动状态的检测主要通过 <strong>加速度计或陀螺仪数据的变化</strong>。当设备处于运动中时，加速度或角速度的变化较大。</p>
<p><strong>实现原理：</strong></p>
<ul>
<li><strong>加速度突变</strong>：通过检测加速度值的变化，判断设备是否处于运动中。</li>
<li><strong>陀螺仪角速度变化</strong>：检测旋转运动，增加判断的准确性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THRESHOLD_MOTION_ACCEL 2000 <span class="comment">// 运动检测加速度变化阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRESHOLD_MOTION_GYRO 3000  <span class="comment">// 运动检测角速度变化阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Check_Motion_State</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">short</span> accelData[<span class="number">3</span>], gyroData[<span class="number">3</span>];</span><br><span class="line">    MPU6050ReadAcc(accelData); <span class="comment">// 获取加速度数据</span></span><br><span class="line">    MPU6050ReadGyro(gyroData);  <span class="comment">// 获取陀螺仪数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> ax = accelData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span> ay = accelData[<span class="number">1</span>];</span><br><span class="line">    <span class="type">short</span> az = accelData[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> gx = gyroData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span> gy = gyroData[<span class="number">1</span>];</span><br><span class="line">    <span class="type">short</span> gz = gyroData[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">abs</span>(ax) &gt; THRESHOLD_MOTION_ACCEL) || (<span class="built_in">abs</span>(ay) &gt; THRESHOLD_MOTION_ACCEL) || (<span class="built_in">abs</span>(az) &gt; THRESHOLD_MOTION_ACCEL) ||</span><br><span class="line">        (<span class="built_in">abs</span>(gx) &gt; THRESHOLD_MOTION_GYRO) || (<span class="built_in">abs</span>(gy) &gt; THRESHOLD_MOTION_GYRO) || (<span class="built_in">abs</span>(gz) &gt; THRESHOLD_MOTION_GYRO)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备正在运动中\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备处于静止状态\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li><strong>加速度和角速度</strong> 的变化幅度都可用于判断运动状态。</li>
<li>如果任意轴的加速度或角速度超过设定阈值，则判定为运动。</li>
</ul>
<h4 id="摔倒检测"><a href="#摔倒检测" class="headerlink" title="摔倒检测"></a>摔倒检测</h4><p>摔倒检测是一个较复杂的场景，通常结合 <strong>加速度的剧烈变化</strong> 和 <strong>角速度的瞬时变化</strong>。</p>
<p><strong>实现原理：</strong></p>
<ol>
<li><strong>自由落体检测</strong>：加速度突然接近 <code>0g</code>，表示设备正在快速下坠。</li>
<li><strong>冲击检测</strong>：落地时加速度会瞬间增加，超过一定阈值。</li>
<li><strong>结合角速度变化</strong>：摔倒时通常伴随较大的旋转运动。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_FALL_THRESHOLD 3000 <span class="comment">// 自由落体阈值 (加速度接近0)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPACT_THRESHOLD 16000   <span class="comment">// 冲击检测阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GYRO_THRESHOLD 3000      <span class="comment">// 角速度变化阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Check_Fall_State</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">short</span> accelData[<span class="number">3</span>], gyroData[<span class="number">3</span>];</span><br><span class="line">    MPU6050ReadAcc(accelData); <span class="comment">// 获取加速度数据</span></span><br><span class="line">    MPU6050ReadGyro(gyroData);  <span class="comment">// 获取陀螺仪数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> ax = accelData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span> ay = accelData[<span class="number">1</span>];</span><br><span class="line">    <span class="type">short</span> az = accelData[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> gx = gyroData[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span> gy = gyroData[<span class="number">1</span>];</span><br><span class="line">    <span class="type">short</span> gz = gyroData[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> accel_magnitude = <span class="built_in">sqrt</span>(ax * ax + ay * ay + az * az);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accel_magnitude &lt; FREE_FALL_THRESHOLD) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到自由落体，可能正在下坠！\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (accel_magnitude &gt; IMPACT_THRESHOLD) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到强烈冲击，可能发生摔倒！\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">abs</span>(gx) &gt; GYRO_THRESHOLD) || (<span class="built_in">abs</span>(gy) &gt; GYRO_THRESHOLD) || (<span class="built_in">abs</span>(gz) &gt; GYRO_THRESHOLD)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到大幅度旋转，可能正在摔倒！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li>自由落体：加速度接近 0。</li>
<li>冲击：落地时加速度远大于 1g。</li>
<li>摔倒往往伴随大幅度旋转，因此检测陀螺仪变化。</li>
</ul>
<h3 id="驱动库"><a href="#驱动库" class="headerlink" title="驱动库"></a>驱动库</h3><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>MFRC522</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/</url>
    <content><![CDATA[<p>MFRC522 是一款应用广泛的非接触读卡器芯片,集成了在 13.56MHz 下的多种非接触通信方式和协议，具有很高的技术集成度。</p>
<h2 id="规格说明"><a href="#规格说明" class="headerlink" title="规格说明"></a>规格说明</h2><p><strong>工作电压</strong>：3.3V</p>
<p><strong>工作电流</strong>：10-26mA</p>
<p><strong>控制方式</strong>：SPI、I2C、UART</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="center"><strong>管脚号</strong></th>
<th align="center"><strong>管脚名</strong></th>
<th align="center"><strong>类型</strong></th>
<th><strong>管脚描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A1</td>
<td align="center">G</td>
<td>地地址线</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PVDD</td>
<td align="center">P</td>
<td>管脚电源</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">DVDD</td>
<td align="center">P</td>
<td>数字电源</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DVSS</td>
<td align="center">G</td>
<td>数字地</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">PVSS</td>
<td align="center">G</td>
<td>管脚电源地</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">NRSTPD</td>
<td align="center">I</td>
<td>复位脚。为低电平时，内部功能模块包括振荡器均停止工作，输入管脚与外部断开。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>该管脚上的上升沿可用来开启内部复位相位。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">SIGIN</td>
<td align="center">I</td>
<td>通信接口输入：接收数字数据流、串行数据流</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">SIGOUT</td>
<td align="center">O</td>
<td>通信接口输出：输出串行数据流</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SVDD</td>
<td align="center">P</td>
<td>S²C 管脚电源：向 S²C 管脚供电</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">TVSS</td>
<td align="center">G</td>
<td>发送端 TX1 和 TX2 输出级的地</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">TX1</td>
<td align="center">O</td>
<td>载波发送管脚 1</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">TVDD</td>
<td align="center">P</td>
<td>发送驱动器电源</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">TX2</td>
<td align="center">O</td>
<td>载波发送管脚 2</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">TVSS</td>
<td align="center">G</td>
<td>发送驱动器电源地</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">AVDD</td>
<td align="center">P</td>
<td>模拟电源</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">VMID</td>
<td align="center">P</td>
<td>内部参考电压</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">RX</td>
<td align="center">I</td>
<td>RF 信号输入</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">AVSS</td>
<td align="center">G</td>
<td>模拟地</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">AUX1</td>
<td align="center">O</td>
<td>用于测试的辅助输出</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">AUX2</td>
<td align="center">O</td>
<td>用于测试的辅助输出</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">OSCIN</td>
<td align="center">I</td>
<td>晶振反向放大器；也就是外部时钟输入<br />该引脚还可以作外部时钟（fosc &#x3D; 27.12 MHz）的输入</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">OSCOUT</td>
<td align="center">O</td>
<td>晶振反向放大器输出</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">IRQ</td>
<td align="center">O</td>
<td>中断请求输出：指示一个中断事件</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">ALE</td>
<td align="center">I</td>
<td>地址锁存使能：高电平时将 AD0-AD5 所存到内部地址所存</td>
</tr>
<tr>
<td align="center">25-31</td>
<td align="center">D1-D7</td>
<td align="center">I&#x2F;O</td>
<td>8 位双向数据总线 注：不支持 8 位并行接口<br />注：如果主控制器选择 I2C 作为数字主控制器接口，那么这些管脚可以用来定义 PC 地址<br />注：对于串行接口，这些管脚可以用作测试信号或 I&#x2F;O</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">AO</td>
<td align="center">I</td>
<td>地址线</td>
</tr>
</tbody></table>
<h2 id="读写模式"><a href="#读写模式" class="headerlink" title="读写模式"></a>读写模式</h2><h3 id="ISO-IEC-14443A"><a href="#ISO-IEC-14443A" class="headerlink" title="ISO&#x2F;IEC 14443A"></a>ISO&#x2F;IEC 14443A</h3><p>ISO&#x2F;IEC 14443A 是一种通信协议，用于支持 A 型非接触式智能卡与读写器之间的交互。</p>
<p>典型应用：广泛应用于 MIFARE 卡（如 MIFARE Classic、MIFARE DESFire）等系统。</p>
<p><strong>通信方式：</strong></p>
<ul>
<li>调制方式：<ul>
<li>读写器发出的信号使用<strong>ASK（幅移键控）调制</strong>。</li>
<li>数据传输采用<strong>曼彻斯特编码</strong>。</li>
</ul>
</li>
<li>数据速率：<ul>
<li>支持 106 kbps 的数据传输速率。</li>
</ul>
</li>
<li>防冲突机制：<ul>
<li>支持多卡防冲突机制，可在多张卡同时存在的情况下识别和通信。</li>
</ul>
</li>
</ul>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>读写器初始化</strong>：向周围发送询问信号，检测是否有卡片进入其工作范围。</li>
<li><strong>卡片应答</strong>：卡片收到信号后，回应自己的唯一标识符（UID）。</li>
<li><strong>身份验证</strong>：读写器和卡片进行认证，以确认双方合法性。</li>
<li><strong>数据传输</strong>：开始交换数据，如读卡信息、写入数据等。</li>
<li><strong>终止通信</strong>：完成通信后，读写器发送停止信号。</li>
</ol>
<h3 id="ISO-IEC-14443B"><a href="#ISO-IEC-14443B" class="headerlink" title="ISO&#x2F;IEC 14443B"></a>ISO&#x2F;IEC 14443B</h3><p>ISO&#x2F;IEC 14443B 是另一种通信协议，与 A 型不同，B 型主要用于特定的安全场景和一些非接触式卡片类型（如电子护照、健康卡等）。</p>
<p><strong>通信方式：</strong></p>
<ul>
<li>调制方式：<ul>
<li>读写器发出的信号也使用<strong>ASK 调制</strong>。</li>
<li>数据传输采用<strong>BPSK（二进制相移键控）编码</strong>。</li>
</ul>
</li>
<li>数据速率：<ul>
<li>与 A 型相同，支持 106 kbps 的数据传输速率。</li>
</ul>
</li>
<li>防冲突机制：<ul>
<li>支持独特的防冲突机制，与 A 型不同。</li>
</ul>
</li>
</ul>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>读写器初始化</strong>：向周围发送询问信号，检测是否有卡片进入其工作范围。</li>
<li><strong>卡片应答</strong>：B 型卡片采用不同的应答机制，通常会发送特定的 ATQB 信号。</li>
<li><strong>数据传输</strong>：双方进行数据交换，通常会进行更复杂的加密和验证。</li>
<li><strong>终止通信</strong>：读写器发送停止信号，结束通信。</li>
</ol>
<blockquote>
<p>这是两种<strong>非接触式智能卡通信协议</strong>，它们定义了如何在读卡器（例如 RC522）和非接触式卡之间进行通信。也就是说只要是这两个通信协议的非接触式卡都可以与 RC522 进行通信。</p>
</blockquote>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><p>支持 I2C 总线接口可以使得主机可以用较少的管脚连接到 MFRC522I2C 接口操作遵循 I2C 总线接口规范。该接口只能工作在从机模式。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/I2Cdlt.png" alt="I2Cdlt"></p>
<p>在标准模式、快速模式和高速模式中，MFRC522 可用作从接收器或从发送器 SDA 是一个双向数据线，通过一个上拉电阻连接到正电压。不传输数据时，SDA 和 SCL 均为高电平。标准模式下,I2C 总线的传输速率为 100kBd,快速模式下为 400kBd,高速模式下为 3. 4Mbit&#x2F;s。<br>如果选择 I2C 总线接口，管脚 SCL 和 SDA 管脚具有符合 I2C 接口规范的尖峰脉冲抑制功能。</p>
<p><strong>每个字节后面必须跟一个应答位。数据传输时高位在前。一次数据传输发送的字节数不限，但必须符合读&#x2F;写周期格式。</strong></p>
<p><strong>应答</strong></p>
<p>应答是在一个数据字节结束后强制产生的。应答相应的时钟脉冲由主机产生。在应答时钟脉冲周期内，数据发送器释放 SDA 线(高电平)。在应时钟脉冲期间，<strong>接收器拉低 SDA 线</strong>使得它在该时钟脉冲的高电平时间内保持低电平。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/I2Cyd.png" alt="I2Cyd"></p>
<p><strong>地址</strong></p>
<p>I2C总线地址与EA管脚的定义有关。</p>
<p>如果 EA 管脚为低电平，则对于所有 MFRC522 器件，器件总线地址的高4位固定为 0101b。 器件总线地址剩余的3位(ADR_0，ADR_1，ADR_2)可由用户自由配置，这样就可以防止与其它 I2C 器件产生冲突。</p>
<p>如果 EA 管脚设置为高电平，则 ADR_0-ADR_5 完全由外部管脚来确定。ADR_6 总是设置为0。</p>
<p>在这两种模式下，外部地址编码都在复位条件释放后立即锁定。不考虑使用管脚上的进一步变化。通过配置外部连线，I2C总线的地址管脚还可用作测试信号的输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/I2Cdz.png" alt="I2Cdz"></p>
<h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/UARTlx.png" alt="UARTlx"></p>
<p>通过对 TestPinEnReg寄存器的 RS23LineEn 位清零，信号 DTRQ 和 MX 可以禁止。</p>
<p><strong>传输速度</strong></p>
<p>默认的传输速率为 9.6kBaud。要改变传输速率，主机控制器必须向 SerialSpeedReg 寄存器写 入一个新的传输速率值。位 BR TO[2:0] 和位 BR_T1[4:0] 定义的因数用来设置 SerialSpeedReg 中的传输速率。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/UARTslb.png" alt="UARTslb"></p>
<p><strong>帧格式</strong></p>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">长度</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">起始位</td>
<td align="center">1 位</td>
<td align="left">0</td>
</tr>
<tr>
<td align="center">数据位</td>
<td align="center">8 位</td>
<td align="left">数值</td>
</tr>
<tr>
<td align="center">结束位</td>
<td align="center">1 位</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>对于数据和地址字节，LSB 位必须最先发送。传输过程中不使用奇偶校验位。</p>
<p><strong>发送和读写数据时，第一个字节的内容为地址，第二个字节开始的才是数据</strong></p>
<p>第一个字节的 MSB 位设置使用的模式。MSB 位设置为 1 时从 MFRC522 读取数据，MSB 位设置 为 0 时将数据写入 MFRC522。第一个字节的位6保留为将来使用。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/UARTdz.png" alt="UARTdz"></p>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>MFRC522 支持 SPI 接口与主机的高速通信，接口可处理高达 10Mbit&#x2F;s 的数据速率。在与主机通信时，MFRC522 作为一个从机，从外设主机上接收数据来设置寄存器发送和接 收与 RF 接口通信有关的数据。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/SPItxfs.png" alt="SPItxfs"></p>
<p>在SPI通信中 MFRC522 作为从机。SPI 时钟信号 SCK 必须由主机产生。数据通过 MOSI 线从主机传输到从机。通过 MIS0 线数据从MFRC522 发回到主机。<br>MOSI 和 MISO 传输每个字节时都是<strong>高位在前</strong>。MOSI 和 MISO 上的数据在时钟的上升沿必须保持不变，在时钟的下降沿改变。</p>
<p><strong>地址</strong></p>
<p>第一个字节的 MSB 位定义了使用模式。MSB 位设置为 1 时,从 MFRC522 读取数据 MSB 位设置为 0 时，将数据写入 MFRC522。第一个字节的位 6-1 定义地址，LSB 位应当设置为 0。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/SPIdz.png" alt="SPIdz"></p>
<h3 id="不同接口的接线方式"><a href="#不同接口的接线方式" class="headerlink" title="不同接口的接线方式"></a>不同接口的接线方式</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/MFRC522/jxfs.png" alt="jxfs"></p>
<h2 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h2><p><strong>RFID</strong>（Radio Frequency Identification）是一种通过无线电波进行物体识别和数据交换的技术。RFID 系统可以在没有接触的情况下，从一定距离内读取标签中的信息。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>一个完整的 RFID 系统通常由三部分组成：<strong>RFID 标签</strong>（Tag）、<strong>RFID 读写器</strong>（Reader）、<strong>中间件或计算机系统</strong>（Middleware&#x2F;Backend System）。</p>
<p><strong>RFID 标签（Tag）</strong></p>
<p>RFID 标签是被贴在物品上或集成到物体内的设备，内含一个微芯片和天线。RFID 标签的主要作用是存储与物体相关的信息（如物品编号、存储数据等），并通过无线电波与 RFID 读写器进行通信。</p>
<p><strong>RFID 读写器（Reader）</strong></p>
<p>RFID 读写器负责发送和接收射频信号，它通过天线发射一个射频信号到 RFID 标签，同时接收从标签反射回来的信号并解码，从而获取标签上的数据。</p>
<p><strong>中间件或计算机系统（Middleware&#x2F;Backend System）</strong></p>
<p>这个系统通常负责处理从 RFID 读写器接收到的标签信息。它可能会包括数据库、管理软件、企业资源规划（ERP）系统等，用来存储和分析标签数据，并执行后续的决策或操作。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>激活</strong>：RFID 读写器通过天线发射电磁波（射频信号），激活附近的 RFID 标签。对于被动标签，读写器的信号为其提供能量。</p>
<p><strong>响应</strong>：被激活的 RFID 标签通过其天线将存储的信息（如卡号或其他数据）以无线电波的形式传回读写器。</p>
<p><strong>解码与处理</strong>：读写器接收标签的信号，并将其解码。然后，读写器将信息传输到计算机系统或中间件，以便进一步处理（如查询数据库、进行验证等）。</p>
<p><strong>反馈（可选）</strong>：在某些系统中，读写器可能需要发送反馈或执行其他操作，例如解锁门禁、发送警报等。</p>
<h2 id="IC-卡"><a href="#IC-卡" class="headerlink" title="IC 卡"></a>IC 卡</h2><p>S50 是一种<strong>非接触式智能卡</strong>，可以被 RC522 读写模块读取和写入。</p>
<p>RC522 模块和非接触式 IC 卡的通信是基于射频识别技术（RFID）。当卡片靠近读写器时，读写器发出一个射频信号，IC 卡中的天线通过电磁感应获取能量，并响应 RC522 发来的请求，传输数据。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rc522.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_rc522.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;board.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：RC522_Init</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：IC卡感应模块配置</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：无</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：无</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//开启时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_GPIO, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SDA SCK MOSI RST</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_CS|GPIO_SCK|GPIO_MOSI|GPIO_RST;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(PORT_GPIO, &amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_SetBits(PORT_GPIO, GPIO_CS|GPIO_SCK|GPIO_MOSI|GPIO_RST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MISO</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_MISO;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_Init(PORT_GPIO, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////软件模拟SPI与RC522通信///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/* 软件模拟SPI发送一个字节数据，高位先行 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_SPI_SendByte</span><span class="params">( <span class="type">uint8_t</span> byte )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> n;</span><br><span class="line">    <span class="keyword">for</span>( n=<span class="number">0</span>;n&lt;<span class="number">8</span>;n++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( byte&amp;<span class="number">0x80</span> )</span><br><span class="line">                    RC522_MOSI_1();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                    RC522_MOSI_0();</span><br><span class="line"></span><br><span class="line">            delay_us(<span class="number">200</span>);</span><br><span class="line">            RC522_SCK_0();</span><br><span class="line">            delay_us(<span class="number">200</span>);</span><br><span class="line">            RC522_SCK_1();</span><br><span class="line">            delay_us(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            byte&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 软件模拟SPI读取一个字节数据，先读高位 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">RC522_SPI_ReadByte</span><span class="params">( <span class="type">void</span> )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> n,data;</span><br><span class="line">    <span class="keyword">for</span>( n=<span class="number">0</span>;n&lt;<span class="number">8</span>;n++ )&#123;</span><br><span class="line">            data&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            RC522_SCK_0();</span><br><span class="line">            delay_us(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( RC522_MISO_GET()==<span class="number">1</span> )</span><br><span class="line">                    data|=<span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line">            delay_us(<span class="number">200</span>);</span><br><span class="line">            RC522_SCK_1();</span><br><span class="line">            delay_us(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////STM32对RC522寄存器的操作//////////////////////////////////</span></span><br><span class="line"><span class="comment">/*  读取RC522指定寄存器的值</span></span><br><span class="line"><span class="comment">    向RC522指定寄存器中写入指定的数据</span></span><br><span class="line"><span class="comment">    置位RC522指定寄存器的指定位</span></span><br><span class="line"><span class="comment">    清位RC522指定寄存器的指定位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：读取RC522指定寄存器的值</span></span><br><span class="line"><span class="comment">        * @param  ：Address:寄存器的地址</span></span><br><span class="line"><span class="comment">  * @retval ：寄存器的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">RC522_Read_Register</span><span class="params">( <span class="type">uint8_t</span> Address )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> data,Addr;</span><br><span class="line"></span><br><span class="line">    Addr = ( (Address&lt;&lt;<span class="number">1</span>)&amp;<span class="number">0x7E</span> )|<span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">    RC522_CS_Enable();</span><br><span class="line">    RC522_SPI_SendByte( Addr );</span><br><span class="line">    data = RC522_SPI_ReadByte();<span class="comment">//读取寄存器中的值</span></span><br><span class="line">    RC522_CS_Disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：向RC522指定寄存器中写入指定的数据</span></span><br><span class="line"><span class="comment">  * @param  ：Address：寄存器地址</span></span><br><span class="line"><span class="comment">                                      data：要写入寄存器的数据</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Write_Register</span><span class="params">( <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> data )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Addr;</span><br><span class="line"></span><br><span class="line">    Addr = ( Address&lt;&lt;<span class="number">1</span> )&amp;<span class="number">0x7E</span>;</span><br><span class="line"></span><br><span class="line">    RC522_CS_Enable();</span><br><span class="line">    RC522_SPI_SendByte( Addr );</span><br><span class="line">    RC522_SPI_SendByte( data );</span><br><span class="line">    RC522_CS_Disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：置位RC522指定寄存器的指定位</span></span><br><span class="line"><span class="comment">  * @param  ：Address：寄存器地址</span></span><br><span class="line"><span class="comment">                                      mask：置位值</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_SetBit_Register</span><span class="params">( <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> mask )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="comment">/* 获取寄存器当前值 */</span></span><br><span class="line">    temp = RC522_Read_Register( Address );</span><br><span class="line">    <span class="comment">/* 对指定位进行置位操作后，再将值写入寄存器 */</span></span><br><span class="line">    RC522_Write_Register( Address, temp|mask );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：清位RC522指定寄存器的指定位</span></span><br><span class="line"><span class="comment">  * @param  ：Address：寄存器地址</span></span><br><span class="line"><span class="comment">                      mask：清位值</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_ClearBit_Register</span><span class="params">( <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> mask )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp;</span><br><span class="line">    <span class="comment">/* 获取寄存器当前值 */</span></span><br><span class="line">    temp = RC522_Read_Register( Address );</span><br><span class="line">    <span class="comment">/* 对指定位进行清位操作后，再将值写入寄存器 */</span></span><br><span class="line">    RC522_Write_Register( Address, temp&amp;(~mask) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////STM32对RC522的基础通信///////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    开启天线</span></span><br><span class="line"><span class="comment">    关闭天线</span></span><br><span class="line"><span class="comment">    复位RC522</span></span><br><span class="line"><span class="comment">    设置RC522工作方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：开启天线</span></span><br><span class="line"><span class="comment">  * @param  ：无</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Antenna_On</span><span class="params">( <span class="type">void</span> )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> k;</span><br><span class="line">    k = RC522_Read_Register( TxControlReg );</span><br><span class="line">    <span class="comment">/* 判断天线是否开启 */</span></span><br><span class="line">    <span class="keyword">if</span>( !( k&amp;<span class="number">0x03</span> ) )</span><br><span class="line">       RC522_SetBit_Register( TxControlReg, <span class="number">0x03</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：关闭天线</span></span><br><span class="line"><span class="comment">  * @param  ：无</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Antenna_Off</span><span class="params">( <span class="type">void</span> )</span>&#123;</span><br><span class="line">    <span class="comment">/* 直接对相应位清零 */</span></span><br><span class="line">    RC522_ClearBit_Register( TxControlReg, <span class="number">0x03</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：复位RC522</span></span><br><span class="line"><span class="comment">  * @param  ：无</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Rese</span><span class="params">( <span class="type">void</span> )</span>&#123;</span><br><span class="line">    RC522_Reset_Disable();</span><br><span class="line">    delay_us ( <span class="number">1</span> );</span><br><span class="line">    RC522_Reset_Enable();</span><br><span class="line">    delay_us ( <span class="number">1</span> );</span><br><span class="line">    RC522_Reset_Disable();</span><br><span class="line">    delay_us ( <span class="number">1</span> );</span><br><span class="line">    RC522_Write_Register( CommandReg, <span class="number">0x0F</span> );</span><br><span class="line">    <span class="keyword">while</span>( RC522_Read_Register( CommandReg )&amp;<span class="number">0x10</span> )</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 缓冲一下 */</span></span><br><span class="line">    delay_us ( <span class="number">1</span> );</span><br><span class="line">    RC522_Write_Register( ModeReg, <span class="number">0x3D</span> );       <span class="comment">//定义发送和接收常用模式</span></span><br><span class="line">    RC522_Write_Register( TReloadRegL, <span class="number">30</span> );     <span class="comment">//16位定时器低位</span></span><br><span class="line">    RC522_Write_Register( TReloadRegH, <span class="number">0</span> );      <span class="comment">//16位定时器高位</span></span><br><span class="line">    RC522_Write_Register( TModeReg, <span class="number">0x8D</span> );      <span class="comment">//内部定时器的设置</span></span><br><span class="line">    RC522_Write_Register( TPrescalerReg, <span class="number">0x3E</span> ); <span class="comment">//设置定时器分频系数</span></span><br><span class="line">    RC522_Write_Register( TxAutoReg, <span class="number">0x40</span> );     <span class="comment">//调制发送信号为100%ASK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：设置RC522的工作方式</span></span><br><span class="line"><span class="comment">  * @param  ：Type：工作方式</span></span><br><span class="line"><span class="comment">  * @retval ：无</span></span><br><span class="line"><span class="comment">  M500PcdConfigISOType</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Config_Type</span><span class="params">( <span class="type">char</span> Type )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Type==<span class="string">&#x27;A&#x27;</span> )&#123;</span><br><span class="line">        RC522_ClearBit_Register( Status2Reg, <span class="number">0x08</span> );</span><br><span class="line">        RC522_Write_Register( ModeReg, <span class="number">0x3D</span> );</span><br><span class="line">        RC522_Write_Register( RxSelReg, <span class="number">0x86</span> );</span><br><span class="line">        RC522_Write_Register( RFCfgReg, <span class="number">0x7F</span> );</span><br><span class="line">        RC522_Write_Register( TReloadRegL, <span class="number">30</span> );</span><br><span class="line">        RC522_Write_Register( TReloadRegH, <span class="number">0</span> );</span><br><span class="line">        RC522_Write_Register( TModeReg, <span class="number">0x8D</span> );</span><br><span class="line">        RC522_Write_Register( TPrescalerReg, <span class="number">0x3E</span> );</span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/* 开天线 */</span></span><br><span class="line">        RC522_Antenna_On();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////STM32控制RC522与M1卡的通信///////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过RC522和M1卡通讯（数据的双向传输）</span></span><br><span class="line"><span class="comment">    寻卡</span></span><br><span class="line"><span class="comment">    防冲突</span></span><br><span class="line"><span class="comment">    用RC522计算CRC16（循环冗余校验）</span></span><br><span class="line"><span class="comment">    选定卡片</span></span><br><span class="line"><span class="comment">    校验卡片密码</span></span><br><span class="line"><span class="comment">    在M1卡的指定块地址写入指定数据</span></span><br><span class="line"><span class="comment">    读取M1卡的指定块地址的数据</span></span><br><span class="line"><span class="comment">    让卡片进入休眠模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：通过RC522和ISO14443卡通讯</span></span><br><span class="line"><span class="comment">* @param  ：ucCommand：RC522命令字</span></span><br><span class="line"><span class="comment"> *          pInData：通过RC522发送到卡片的数据</span></span><br><span class="line"><span class="comment"> *          ucInLenByte：发送数据的字节长度</span></span><br><span class="line"><span class="comment"> *          pOutData：接收到的卡片返回数据</span></span><br><span class="line"><span class="comment"> *          pOutLenBit：返回数据的位长度</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdComMF522</span> <span class="params">( <span class="type">uint8_t</span> ucCommand, <span class="type">uint8_t</span> * pInData, <span class="type">uint8_t</span> ucInLenByte, <span class="type">uint8_t</span> * pOutData, <span class="type">uint32_t</span> * pOutLenBit )</span>&#123;</span><br><span class="line">    <span class="type">char</span> cStatus = MI_ERR;</span><br><span class="line">    <span class="type">uint8_t</span> ucIrqEn   = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">uint8_t</span> ucWaitFor = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">uint8_t</span> ucLastBits;</span><br><span class="line">    <span class="type">uint8_t</span> ucN;</span><br><span class="line">    <span class="type">uint32_t</span> ul;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ( ucCommand )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">case</span> PCD_AUTHENT:                <span class="comment">//Mifare认证</span></span><br><span class="line">          ucIrqEn   = <span class="number">0x12</span>;                <span class="comment">//允许错误中断请求ErrIEn  允许空闲中断IdleIEn</span></span><br><span class="line">          ucWaitFor = <span class="number">0x10</span>;                <span class="comment">//认证寻卡等待时候 查询空闲中断标志位</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> PCD_TRANSCEIVE:                <span class="comment">//接收发送 发送接收</span></span><br><span class="line">          ucIrqEn   = <span class="number">0x77</span>;                <span class="comment">//允许TxIEn RxIEn IdleIEn LoAlertIEn ErrIEn TimerIEn</span></span><br><span class="line">          ucWaitFor = <span class="number">0x30</span>;                <span class="comment">//寻卡等待时候 查询接收中断标志位与 空闲中断标志位</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RC522_Write_Register ( ComIEnReg, ucIrqEn | <span class="number">0x80</span> );                <span class="comment">//IRqInv置位管脚IRQ与Status1Reg的IRq位的值相反</span></span><br><span class="line">    RC522_ClearBit_Register ( ComIrqReg, <span class="number">0x80</span> );                        <span class="comment">//Set1该位清零时，CommIRqReg的屏蔽位清零</span></span><br><span class="line">    RC522_Write_Register ( CommandReg, PCD_IDLE );                <span class="comment">//写空闲命令</span></span><br><span class="line">    RC522_SetBit_Register ( FIFOLevelReg, <span class="number">0x80</span> );                        <span class="comment">//置位FlushBuffer清除内部FIFO的读和写指针以及ErrReg的BufferOvfl标志位被清除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ul = <span class="number">0</span>; ul &lt; ucInLenByte; ul ++ )</span><br><span class="line">                  RC522_Write_Register ( FIFODataReg, pInData [ ul ] );                    <span class="comment">//写数据进FIFOdata</span></span><br><span class="line"></span><br><span class="line">    RC522_Write_Register ( CommandReg, ucCommand );                                        <span class="comment">//写命令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ucCommand == PCD_TRANSCEIVE )</span><br><span class="line">                        RC522_SetBit_Register(BitFramingReg,<span class="number">0x80</span>);                                  <span class="comment">//StartSend置位启动数据发送 该位与收发命令使用时才有效</span></span><br><span class="line"></span><br><span class="line">    ul = <span class="number">1000</span>;<span class="comment">//根据时钟频率调整，操作M1卡最大等待时间25ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>                                                                                                                 <span class="comment">//认证 与寻卡等待时间</span></span><br><span class="line">    &#123;</span><br><span class="line">         ucN = RC522_Read_Register ( ComIrqReg );                                                        <span class="comment">//查询事件中断</span></span><br><span class="line">         ul --;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ( ul != <span class="number">0</span> ) &amp;&amp; ( ! ( ucN &amp; <span class="number">0x01</span> ) ) &amp;&amp; ( ! ( ucN &amp; ucWaitFor ) ) );                <span class="comment">//退出条件i=0,定时器中断，与写空闲命令</span></span><br><span class="line"></span><br><span class="line">    RC522_ClearBit_Register ( BitFramingReg, <span class="number">0x80</span> );                                        <span class="comment">//清理允许StartSend位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ul != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( ! ( RC522_Read_Register ( ErrorReg ) &amp; <span class="number">0x1B</span> ) )                        <span class="comment">//读错误标志寄存器BufferOfI CollErr ParityErr ProtocolErr</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                cStatus = MI_OK;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> ( ucN &amp; ucIrqEn &amp; <span class="number">0x01</span> )                                        <span class="comment">//是否发生定时器中断</span></span><br><span class="line">                                  cStatus = MI_NOTAGERR;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> ( ucCommand == PCD_TRANSCEIVE )</span><br><span class="line">                                &#123;</span><br><span class="line">                                        ucN = RC522_Read_Register ( FIFOLevelReg );                        <span class="comment">//读FIFO中保存的字节数</span></span><br><span class="line"></span><br><span class="line">                                        ucLastBits = RC522_Read_Register ( ControlReg ) &amp; <span class="number">0x07</span>;        <span class="comment">//最后接收到得字节的有效位数</span></span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> ( ucLastBits )</span><br><span class="line">                                                * pOutLenBit = ( ucN - <span class="number">1</span> ) * <span class="number">8</span> + ucLastBits;           <span class="comment">//N个字节数减去1（最后一个字节）+最后一位的位数 读取到的数据总位数</span></span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                                * pOutLenBit = ucN * <span class="number">8</span>;                                           <span class="comment">//最后接收到的字节整个字节有效</span></span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> ( ucN == <span class="number">0</span> )</span><br><span class="line">            ucN = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> ( ucN &gt; MAXRLEN )</span><br><span class="line">                                                ucN = MAXRLEN;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">for</span> ( ul = <span class="number">0</span>; ul &lt; ucN; ul ++ )</span><br><span class="line">                                          pOutData [ ul ] = RC522_Read_Register ( FIFODataReg );</span><br><span class="line">                                        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                cStatus = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   RC522_SetBit_Register ( ControlReg, <span class="number">0x80</span> );           <span class="comment">// stop timer now</span></span><br><span class="line">   RC522_Write_Register ( CommandReg, PCD_IDLE );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：寻卡</span></span><br><span class="line"><span class="comment">* @param  ucReq_code，寻卡方式</span></span><br><span class="line"><span class="comment">*                      = 0x52：寻感应区内所有符合14443A标准的卡</span></span><br><span class="line"><span class="comment"> *                     = 0x26：寻未进入休眠状态的卡</span></span><br><span class="line"><span class="comment"> *         pTagType，卡片类型代码</span></span><br><span class="line"><span class="comment"> *                   = 0x4400：Mifare_UltraLight</span></span><br><span class="line"><span class="comment"> *                   = 0x0400：Mifare_One(S50)</span></span><br><span class="line"><span class="comment"> *                   = 0x0200：Mifare_One(S70)</span></span><br><span class="line"><span class="comment"> *                   = 0x0800：Mifare_Pro(X))</span></span><br><span class="line"><span class="comment"> *                   = 0x4403：Mifare_DESFire</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdRequest</span> <span class="params">( <span class="type">uint8_t</span> ucReq_code, <span class="type">uint8_t</span> * pTagType )</span>&#123;</span><br><span class="line">   <span class="type">char</span> cStatus;</span><br><span class="line">   <span class="type">uint8_t</span> ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">   <span class="type">uint32_t</span> ulLen;</span><br><span class="line"></span><br><span class="line">   RC522_ClearBit_Register ( Status2Reg, <span class="number">0x08</span> );        <span class="comment">//清理指示MIFARECyptol单元接通以及所有卡的数据通信被加密的情况</span></span><br><span class="line">   RC522_Write_Register ( BitFramingReg, <span class="number">0x07</span> );        <span class="comment">//        发送的最后一个字节的 七位</span></span><br><span class="line">   RC522_SetBit_Register ( TxControlReg, <span class="number">0x03</span> );        <span class="comment">//TX1,TX2管脚的输出信号传递经发送调制的13.46的能量载波信号</span></span><br><span class="line"></span><br><span class="line">   ucComMF522Buf [ <span class="number">0</span> ] = ucReq_code;                <span class="comment">//存入寻卡方式</span></span><br><span class="line">        <span class="comment">/* PCD_TRANSCEIVE：发送并接收数据的命令，RC522向卡片发送寻卡命令，卡片返回卡的型号代码到ucComMF522Buf中 */</span></span><br><span class="line">   cStatus = PcdComMF522 ( PCD_TRANSCEIVE,        ucComMF522Buf, <span class="number">1</span>, ucComMF522Buf, &amp; ulLen );        <span class="comment">//寻卡</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( ( cStatus == MI_OK ) &amp;&amp; ( ulLen == <span class="number">0x10</span> ) )        <span class="comment">//寻卡成功返回卡类型</span></span><br><span class="line">   &#123;</span><br><span class="line">                 <span class="comment">/* 接收卡片的型号代码 */</span></span><br><span class="line">       * pTagType = ucComMF522Buf [ <span class="number">0</span> ];</span><br><span class="line">       * ( pTagType + <span class="number">1</span> ) = ucComMF522Buf [ <span class="number">1</span> ];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     cStatus = MI_ERR;</span><br><span class="line">     <span class="keyword">return</span> cStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  ：防冲突</span></span><br><span class="line"><span class="comment">        * @param  ：Snr：卡片序列，4字节，会返回选中卡片的序列</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdAnticoll</span> <span class="params">( <span class="type">uint8_t</span> * pSnr )</span>&#123;</span><br><span class="line">    <span class="type">char</span> cStatus;</span><br><span class="line">    <span class="type">uint8_t</span> uc, ucSnr_check = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">          <span class="type">uint32_t</span> ulLen;</span><br><span class="line"></span><br><span class="line">    RC522_ClearBit_Register ( Status2Reg, <span class="number">0x08</span> );                <span class="comment">//清MFCryptol On位 只有成功执行MFAuthent命令后，该位才能置位</span></span><br><span class="line">    RC522_Write_Register ( BitFramingReg, <span class="number">0x00</span>);                <span class="comment">//清理寄存器 停止收发</span></span><br><span class="line">    RC522_ClearBit_Register ( CollReg, <span class="number">0x80</span> );                        <span class="comment">//清ValuesAfterColl所有接收的位在冲突后被清除</span></span><br><span class="line"></span><br><span class="line">    ucComMF522Buf [ <span class="number">0</span> ] = <span class="number">0x93</span>;        <span class="comment">//卡片防冲突命令</span></span><br><span class="line">    ucComMF522Buf [ <span class="number">1</span> ] = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 将卡片防冲突命令通过RC522传到卡片中，返回的是被选中卡片的序列 */</span></span><br><span class="line">    cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">2</span>, ucComMF522Buf, &amp; ulLen);<span class="comment">//与卡片通信</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( cStatus == MI_OK)                <span class="comment">//通信成功</span></span><br><span class="line">    &#123;</span><br><span class="line">                        <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; <span class="number">4</span>; uc ++ )</span><br><span class="line">                        &#123;</span><br><span class="line">         * ( pSnr + uc )  = ucComMF522Buf [ uc ];                        <span class="comment">//读出UID</span></span><br><span class="line">         ucSnr_check ^= ucComMF522Buf [ uc ];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( ucSnr_check != ucComMF522Buf [ uc ] )</span><br><span class="line">                                cStatus = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    RC522_SetBit_Register ( CollReg, <span class="number">0x80</span> );</span><br><span class="line">    <span class="keyword">return</span> cStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   :用RC522计算CRC16（循环冗余校验）</span></span><br><span class="line"><span class="comment">        * @param  ：pIndata：计算CRC16的数组</span></span><br><span class="line"><span class="comment"> *            ucLen：计算CRC16的数组字节长度</span></span><br><span class="line"><span class="comment"> *            pOutData：存放计算结果存放的首地址</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalulateCRC</span> <span class="params">( <span class="type">uint8_t</span> * pIndata, u8 ucLen, <span class="type">uint8_t</span> * pOutData )</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> uc, ucN;</span><br><span class="line"></span><br><span class="line">    RC522_ClearBit_Register(DivIrqReg,<span class="number">0x04</span>);</span><br><span class="line">    RC522_Write_Register(CommandReg,PCD_IDLE);</span><br><span class="line">    RC522_SetBit_Register(FIFOLevelReg,<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; ucLen; uc ++)</span><br><span class="line">            RC522_Write_Register ( FIFODataReg, * ( pIndata + uc ) );</span><br><span class="line"></span><br><span class="line">    RC522_Write_Register ( CommandReg, PCD_CALCCRC );</span><br><span class="line"></span><br><span class="line">    uc = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ucN = RC522_Read_Register ( DivIrqReg );</span><br><span class="line">        uc --;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ( uc != <span class="number">0</span> ) &amp;&amp; ! ( ucN &amp; <span class="number">0x04</span> ) );</span><br><span class="line"></span><br><span class="line">    pOutData [ <span class="number">0</span> ] = RC522_Read_Register ( CRCResultRegL );</span><br><span class="line">    pOutData [ <span class="number">1</span> ] = RC522_Read_Register ( CRCResultRegM );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   :选定卡片</span></span><br><span class="line"><span class="comment">  * @param  ：pSnr：卡片序列号，4字节</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdSelect</span> <span class="params">( <span class="type">uint8_t</span> * pSnr )</span>&#123;</span><br><span class="line">    <span class="type">char</span> ucN;</span><br><span class="line">    <span class="type">uint8_t</span> uc;</span><br><span class="line">          <span class="type">uint8_t</span> ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">    <span class="type">uint32_t</span>  ulLen;</span><br><span class="line">    <span class="comment">/* PICC_ANTICOLL1：防冲突命令 */</span></span><br><span class="line">    ucComMF522Buf [ <span class="number">0</span> ] = PICC_ANTICOLL1;</span><br><span class="line">    ucComMF522Buf [ <span class="number">1</span> ] = <span class="number">0x70</span>;</span><br><span class="line">    ucComMF522Buf [ <span class="number">6</span> ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; <span class="number">4</span>; uc ++ )</span><br><span class="line">    &#123;</span><br><span class="line">            ucComMF522Buf [ uc + <span class="number">2</span> ] = * ( pSnr + uc );</span><br><span class="line">            ucComMF522Buf [ <span class="number">6</span> ] ^= * ( pSnr + uc );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CalulateCRC ( ucComMF522Buf, <span class="number">7</span>, &amp; ucComMF522Buf [ <span class="number">7</span> ] );</span><br><span class="line"></span><br><span class="line">    RC522_ClearBit_Register ( Status2Reg, <span class="number">0x08</span> );</span><br><span class="line"></span><br><span class="line">    ucN = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">9</span>, ucComMF522Buf, &amp; ulLen );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ( ucN == MI_OK ) &amp;&amp; ( ulLen == <span class="number">0x18</span> ) )</span><br><span class="line">      ucN = MI_OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ucN = MI_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ucN;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   :校验卡片密码</span></span><br><span class="line"><span class="comment">  * @param  ：ucAuth_mode：密码验证模式</span></span><br><span class="line"><span class="comment">  *                     = 0x60，验证A密钥</span></span><br><span class="line"><span class="comment">  *                     = 0x61，验证B密钥</span></span><br><span class="line"><span class="comment">  *           ucAddr：块地址</span></span><br><span class="line"><span class="comment">  *           pKey：密码</span></span><br><span class="line"><span class="comment">  *           pSnr：卡片序列号，4字节</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdAuthState</span> <span class="params">( <span class="type">uint8_t</span> ucAuth_mode, <span class="type">uint8_t</span> ucAddr, <span class="type">uint8_t</span> * pKey, <span class="type">uint8_t</span> * pSnr )</span>&#123;</span><br><span class="line">    <span class="type">char</span> cStatus;</span><br><span class="line">          <span class="type">uint8_t</span> uc, ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">    <span class="type">uint32_t</span> ulLen;</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf [ <span class="number">0</span> ] = ucAuth_mode;</span><br><span class="line">    ucComMF522Buf [ <span class="number">1</span> ] = ucAddr;</span><br><span class="line">          <span class="comment">/* 前俩字节存储验证模式和块地址，2~8字节存储密码（6个字节），8~14字节存储序列号 */</span></span><br><span class="line">    <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; <span class="number">6</span>; uc ++ )</span><br><span class="line">            ucComMF522Buf [ uc + <span class="number">2</span> ] = * ( pKey + uc );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; <span class="number">6</span>; uc ++ )</span><br><span class="line">            ucComMF522Buf [ uc + <span class="number">8</span> ] = * ( pSnr + uc );</span><br><span class="line">    <span class="comment">/* 进行冗余校验，14~16俩个字节存储校验结果 */</span></span><br><span class="line">    cStatus = PcdComMF522 ( PCD_AUTHENT, ucComMF522Buf, <span class="number">12</span>, ucComMF522Buf, &amp; ulLen );</span><br><span class="line">          <span class="comment">/* 判断验证是否成功 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( cStatus != MI_OK ) || ( ! ( RC522_Read_Register ( Status2Reg ) &amp; <span class="number">0x08</span> ) ) )</span><br><span class="line">      cStatus = MI_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cStatus;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   :在M1卡的指定块地址写入指定数据</span></span><br><span class="line"><span class="comment">  * @param  ：ucAddr：块地址</span></span><br><span class="line"><span class="comment">  *           pData：写入的数据，16字节</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdWrite</span> <span class="params">( <span class="type">uint8_t</span> ucAddr, <span class="type">uint8_t</span> * pData )</span>&#123;</span><br><span class="line">    <span class="type">char</span> cStatus;</span><br><span class="line">          <span class="type">uint8_t</span> uc, ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">    <span class="type">uint32_t</span> ulLen;</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf [ <span class="number">0</span> ] = PICC_WRITE;<span class="comment">//写块命令</span></span><br><span class="line">    ucComMF522Buf [ <span class="number">1</span> ] = ucAddr;<span class="comment">//写块地址</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 进行循环冗余校验，将结果存储在&amp; ucComMF522Buf [ 2 ] */</span></span><br><span class="line">    CalulateCRC ( ucComMF522Buf, <span class="number">2</span>, &amp; ucComMF522Buf [ <span class="number">2</span> ] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PCD_TRANSCEIVE:发送并接收数据命令，通过RC522向卡片发送写块命令 */</span></span><br><span class="line">    cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp; ulLen );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 通过卡片返回的信息判断，RC522是否与卡片正常通信 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( cStatus != MI_OK ) || ( ulLen != <span class="number">4</span> ) || ( ( ucComMF522Buf [ <span class="number">0</span> ] &amp; <span class="number">0x0F</span> ) != <span class="number">0x0A</span> ) )</span><br><span class="line">      cStatus = MI_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( cStatus == MI_OK )</span><br><span class="line">    &#123;</span><br><span class="line">                        <span class="comment">//memcpy(ucComMF522Buf, pData, 16);</span></span><br><span class="line">                        <span class="comment">/* 将要写入的16字节的数据，传入ucComMF522Buf数组中 */</span></span><br><span class="line">      <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; <span class="number">16</span>; uc ++ )</span><br><span class="line">                          ucComMF522Buf [ uc ] = * ( pData + uc );</span><br><span class="line">                        <span class="comment">/* 冗余校验 */</span></span><br><span class="line">      CalulateCRC ( ucComMF522Buf, <span class="number">16</span>, &amp; ucComMF522Buf [ <span class="number">16</span> ] );</span><br><span class="line">      <span class="comment">/* 通过RC522，将16字节数据包括2字节校验结果写入卡片中 */</span></span><br><span class="line">      cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">18</span>, ucComMF522Buf, &amp; ulLen );</span><br><span class="line">                        <span class="comment">/* 判断写地址是否成功 */</span></span><br><span class="line">                        <span class="keyword">if</span> ( ( cStatus != MI_OK ) || ( ulLen != <span class="number">4</span> ) || ( ( ucComMF522Buf [ <span class="number">0</span> ] &amp; <span class="number">0x0F</span> ) != <span class="number">0x0A</span> ) )</span><br><span class="line">        cStatus = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   :读取M1卡的指定块地址的数据</span></span><br><span class="line"><span class="comment">  * @param  ：ucAddr：块地址</span></span><br><span class="line"><span class="comment">  *           pData：读出的数据，16字节</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdRead</span> <span class="params">( <span class="type">uint8_t</span> ucAddr, <span class="type">uint8_t</span> * pData )</span>&#123;</span><br><span class="line">    <span class="type">char</span> cStatus;</span><br><span class="line">          <span class="type">uint8_t</span> uc, ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">    <span class="type">uint32_t</span> ulLen;</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf [ <span class="number">0</span> ] = PICC_READ;</span><br><span class="line">    ucComMF522Buf [ <span class="number">1</span> ] = ucAddr;</span><br><span class="line">          <span class="comment">/* 冗余校验 */</span></span><br><span class="line">    CalulateCRC ( ucComMF522Buf, <span class="number">2</span>, &amp; ucComMF522Buf [ <span class="number">2</span> ] );</span><br><span class="line">    <span class="comment">/* 通过RC522将命令传给卡片 */</span></span><br><span class="line">    cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp; ulLen );</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 如果传输正常，将读取到的数据传入pData中 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( cStatus == MI_OK ) &amp;&amp; ( ulLen == <span class="number">0x90</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">                        <span class="keyword">for</span> ( uc = <span class="number">0</span>; uc &lt; <span class="number">16</span>; uc ++ )</span><br><span class="line">        * ( pData + uc ) = ucComMF522Buf [ uc ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cStatus = MI_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cStatus;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief   :让卡片进入休眠模式</span></span><br><span class="line"><span class="comment">  * @param  ：无</span></span><br><span class="line"><span class="comment">  * @retval ：状态值MI_OK，成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdHalt</span><span class="params">( <span class="type">void</span> )</span>&#123;</span><br><span class="line">        <span class="type">uint8_t</span> ucComMF522Buf [ MAXRLEN ];</span><br><span class="line">        <span class="type">uint32_t</span>  ulLen;</span><br><span class="line"></span><br><span class="line">  ucComMF522Buf [ <span class="number">0</span> ] = PICC_HALT;</span><br><span class="line">  ucComMF522Buf [ <span class="number">1</span> ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  CalulateCRC ( ucComMF522Buf, <span class="number">2</span>, &amp; ucComMF522Buf [ <span class="number">2</span> ] );</span><br><span class="line">         PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp; ulLen );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MI_OK;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br><span class="line">==================================================================</span><br><span class="line"><span class="comment">// rc522.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BSP_RC522_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSP_RC522_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> u8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u8 uint8_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> u16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u16 uint16_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> u32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u32 uint32_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_GPIO        RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_GPIO       GPIOA</span></span><br><span class="line"><span class="comment">//SDA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_CS         GPIO_Pin_1</span></span><br><span class="line"><span class="comment">//SCK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SCK        GPIO_Pin_2</span></span><br><span class="line"><span class="comment">//MOSI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MOSI       GPIO_Pin_3</span></span><br><span class="line"><span class="comment">//RST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_RST        GPIO_Pin_5</span></span><br><span class="line"><span class="comment">//MISO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_MISO       GPIO_Pin_4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IO口操作函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_CS_Enable()         GPIO_WriteBit(PORT_GPIO, GPIO_CS,Bit_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_CS_Disable()        GPIO_WriteBit(PORT_GPIO, GPIO_CS,Bit_SET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_Reset_Enable()      GPIO_WriteBit(PORT_GPIO, GPIO_RST,Bit_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_Reset_Disable()     GPIO_WriteBit(PORT_GPIO, GPIO_RST,Bit_SET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_SCK_0()             GPIO_WriteBit(PORT_GPIO, GPIO_SCK,Bit_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_SCK_1()             GPIO_WriteBit(PORT_GPIO, GPIO_SCK,Bit_SET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_MOSI_0()            GPIO_WriteBit(PORT_GPIO, GPIO_MOSI,Bit_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_MOSI_1()            GPIO_WriteBit(PORT_GPIO, GPIO_MOSI,Bit_SET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   RC522_MISO_GET()          GPIO_ReadInputDataBit(PORT_GPIO, GPIO_MISO)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RC522命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_IDLE              0x00               <span class="comment">//取消当前命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_AUTHENT           0x0E               <span class="comment">//验证密钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RECEIVE           0x08               <span class="comment">//接收数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSMIT          0x04               <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSCEIVE        0x0C               <span class="comment">//发送并接收数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RESETPHASE        0x0F               <span class="comment">//复位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_CALCCRC           0x03               <span class="comment">//CRC计算</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mifare_One卡片命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQIDL           0x26               <span class="comment">//寻天线区内未进入休眠状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQALL           0x52               <span class="comment">//寻天线区内全部卡</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL1        0x93               <span class="comment">//防冲撞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL2        0x95               <span class="comment">//防冲撞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1A        0x60               <span class="comment">//验证A密钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1B        0x61               <span class="comment">//验证B密钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_READ             0x30               <span class="comment">//读块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_WRITE            0xA0               <span class="comment">//写块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_DECREMENT        0xC0               <span class="comment">//扣款</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_INCREMENT        0xC1               <span class="comment">//充值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_RESTORE          0xC2               <span class="comment">//调块数据到缓冲区</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_TRANSFER         0xB0               <span class="comment">//保存缓冲区中数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_HALT             0x50               <span class="comment">//休眠</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RC522  FIFO长度定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FIFO_LENGTH       64                 <span class="comment">//FIFO size=64byte</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXRLEN  18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RC522寄存器定义 */</span></span><br><span class="line"><span class="comment">// PAGE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU00                 0x00    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CommandReg            0x01    <span class="comment">//启动和停止命令的执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ComIEnReg             0x02    <span class="comment">//中断请求传递的使能（Enable/Disable）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DivlEnReg             0x03    <span class="comment">//中断请求传递的使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ComIrqReg             0x04    <span class="comment">//包含中断请求标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DivIrqReg             0x05    <span class="comment">//包含中断请求标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ErrorReg              0x06    <span class="comment">//错误标志，指示执行的上个命令的错误状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Status1Reg            0x07    <span class="comment">//包含通信的状态标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Status2Reg            0x08    <span class="comment">//包含接收器和发送器的状态标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FIFODataReg           0x09    <span class="comment">//64字节FIFO缓冲区的输入和输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FIFOLevelReg          0x0A    <span class="comment">//指示FIFO中存储的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     WaterLevelReg         0x0B    <span class="comment">//定义FIFO下溢和上溢报警的FIFO深度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ControlReg            0x0C    <span class="comment">//不同的控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     BitFramingReg         0x0D    <span class="comment">//面向位的帧的调节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CollReg               0x0E    <span class="comment">//RF接口上检测到的第一个位冲突的位的位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU0F                 0x0F    <span class="comment">//保留</span></span></span><br><span class="line"><span class="comment">// PAGE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU10                 0x10    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModeReg               0x11    <span class="comment">//定义发送和接收的常用模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxModeReg             0x12    <span class="comment">//定义发送过程的数据传输速率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxModeReg             0x13    <span class="comment">//定义接收过程中的数据传输速率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxControlReg          0x14    <span class="comment">//控制天线驱动器管教TX1和TX2的逻辑特性</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxAutoReg             0x15    <span class="comment">//控制天线驱动器的设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxSelReg              0x16    <span class="comment">//选择天线驱动器的内部源</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxSelReg              0x17    <span class="comment">//选择内部的接收器设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxThresholdReg        0x18    <span class="comment">//选择位译码器的阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DemodReg              0x19    <span class="comment">//定义解调器的设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1A                 0x1A    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1B                 0x1B    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     MifareReg             0x1C    <span class="comment">//控制ISO 14443/MIFARE模式中106kbit/s的通信</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1D                 0x1D    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1E                 0x1E    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SerialSpeedReg        0x1F    <span class="comment">//选择串行UART接口的速率</span></span></span><br><span class="line"><span class="comment">// PAGE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU20                 0x20    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CRCResultRegM         0x21    <span class="comment">//显示CRC计算的实际MSB值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CRCResultRegL         0x22    <span class="comment">//显示CRC计算的实际LSB值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU23                 0x23    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModWidthReg           0x24    <span class="comment">//控制ModWidth的设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU25                 0x25    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFCfgReg              0x26    <span class="comment">//配置接收器增益</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GsNReg                0x27    <span class="comment">//选择天线驱动器管脚（TX1和TX2）的调制电导</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CWGsCfgReg            0x28    <span class="comment">//选择天线驱动器管脚的调制电导</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModGsCfgReg           0x29    <span class="comment">//选择天线驱动器管脚的调制电导</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TModeReg              0x2A    <span class="comment">//定义内部定时器的设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TPrescalerReg         0x2B    <span class="comment">//定义内部定时器的设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TReloadRegH           0x2C    <span class="comment">//描述16位长的定时器重装值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TReloadRegL           0x2D    <span class="comment">//描述16位长的定时器重装值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TCounterValueRegH     0x2E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TCounterValueRegL     0x2F    <span class="comment">//显示16位长的实际定时器值</span></span></span><br><span class="line"><span class="comment">// PAGE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU30                 0x30    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestSel1Reg           0x31    <span class="comment">//常用测试信号配置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestSel2Reg           0x32    <span class="comment">//常用测试信号配置和PRBS控制</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestPinEnReg          0x33    <span class="comment">//D1-D7输出驱动器的使能管脚（仅用于串行接口）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestPinValueReg       0x34    <span class="comment">//定义D1-D7用作I/O总线时的值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestBusReg            0x35    <span class="comment">//显示内部测试总线的状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     AutoTestReg           0x36    <span class="comment">//控制数字自测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     VersionReg            0x37    <span class="comment">//显示版本</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     AnalogTestReg         0x38    <span class="comment">//控制管脚AUX1和AUX2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestDAC1Reg           0x39    <span class="comment">//定义TestDAC1的测试值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestDAC2Reg           0x3A    <span class="comment">//定义TestDAC2的测试值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestADCReg            0x3B    <span class="comment">//显示ADCI和Q通道的实际值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3C                 0x3C    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3D                 0x3D    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3E                 0x3E    <span class="comment">//保留</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3F                                          0x3F    <span class="comment">//保留</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 和RC522通信时返回的错误代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         MI_OK                 0x26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         MI_NOTAGERR           0xcc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         MI_ERR                0xbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> RC522_Init(<span class="type">void</span>);<span class="comment">/* IO口初始化 */</span></span><br><span class="line"><span class="comment">////////////////软件模拟SPI与RC522通信///////////////////////////////////////////</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_SPI_SendByte</span><span class="params">( <span class="type">uint8_t</span> byte )</span>;<span class="comment">/* 软件模拟SPI发送一个字节数据，高位先行 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">RC522_SPI_ReadByte</span><span class="params">( <span class="type">void</span> )</span>;<span class="comment">/* 软件模拟SPI读取一个字节数据，先读高位 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">RC522_Read_Register</span><span class="params">( <span class="type">uint8_t</span> Address )</span>;<span class="comment">//读取RC522指定寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Write_Register</span><span class="params">( <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> data )</span>;<span class="comment">//向RC522指定寄存器中写入指定的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_SetBit_Register</span><span class="params">( <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> mask )</span>;<span class="comment">//置位RC522指定寄存器的指定位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_ClearBit_Register</span><span class="params">( <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> mask )</span>;<span class="comment">//清位RC522指定寄存器的指定位</span></span><br><span class="line"><span class="comment">/////////////////////STM32对RC522的基础通信///////////////////////////////////</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Antenna_On</span><span class="params">( <span class="type">void</span> )</span>;<span class="comment">//开启天线</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Antenna_Off</span><span class="params">( <span class="type">void</span> )</span>;<span class="comment">//关闭天线</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Rese</span><span class="params">( <span class="type">void</span> )</span>;<span class="comment">//复位RC522</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC522_Config_Type</span><span class="params">( <span class="type">char</span> Type )</span>;<span class="comment">//设置RC522的工作方式</span></span><br><span class="line"><span class="comment">/////////////////////////STM32控制RC522与M1的通信///////////////////////////////////////</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdComMF522</span> <span class="params">( <span class="type">uint8_t</span> ucCommand, <span class="type">uint8_t</span> * pInData, <span class="type">uint8_t</span> ucInLenByte, <span class="type">uint8_t</span> * pOutData, <span class="type">uint32_t</span> * pOutLenBit )</span>;<span class="comment">//通过RC522和ISO14443卡通讯</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdRequest</span> <span class="params">( <span class="type">uint8_t</span> ucReq_code, <span class="type">uint8_t</span> * pTagType )</span>;<span class="comment">//寻卡</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdAnticoll</span> <span class="params">( <span class="type">uint8_t</span> * pSnr )</span>;<span class="comment">//防冲突</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CalulateCRC</span> <span class="params">( <span class="type">uint8_t</span> * pIndata, u8 ucLen, <span class="type">uint8_t</span> * pOutData )</span>;<span class="comment">//用RC522计算CRC16（循环冗余校验）</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdSelect</span> <span class="params">( <span class="type">uint8_t</span> * pSnr )</span>;<span class="comment">//选定卡片</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdAuthState</span> <span class="params">( <span class="type">uint8_t</span> ucAuth_mode, <span class="type">uint8_t</span> ucAddr, <span class="type">uint8_t</span> * pKey, <span class="type">uint8_t</span> * pSnr )</span>;<span class="comment">//校验卡片密码</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdWrite</span> <span class="params">( <span class="type">uint8_t</span> ucAddr, <span class="type">uint8_t</span> * pData )</span>;<span class="comment">//在M1卡的指定块地址写入指定数据</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdRead</span> <span class="params">( <span class="type">uint8_t</span> ucAddr, <span class="type">uint8_t</span> * pData )</span>;<span class="comment">//读取M1卡的指定块地址的数据</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PcdHalt</span><span class="params">( <span class="type">void</span> )</span>;<span class="comment">//让卡片进入休眠模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;board.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_rc522.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 卡的ID存储，32位,4字节 */</span></span><br><span class="line">u8 ucArray_ID [ <span class="number">4</span> ];</span><br><span class="line"><span class="type">uint8_t</span> ucStatusReturn;    <span class="comment">//返回状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> read_write_data[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//读写数据缓存</span></span><br><span class="line">    <span class="type">uint8_t</span> card_KEY[<span class="number">6</span>] =&#123;<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>&#125;;<span class="comment">//默认密码</span></span><br><span class="line"></span><br><span class="line">    board_init();</span><br><span class="line">    uart1_init(<span class="number">115200U</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Init....\r\n&quot;</span>);</span><br><span class="line">    RC522_Init( );<span class="comment">//IC卡IO口初始化</span></span><br><span class="line">    RC522_Rese( );<span class="comment">//复位RC522</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Start!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 寻卡（方式：范围内全部），第一次寻卡失败后再进行一次，寻卡成功时卡片序列传入数组ucArray_ID中 */</span></span><br><span class="line">        <span class="keyword">if</span> ( ( ucStatusReturn = PcdRequest ( PICC_REQALL, ucArray_ID ) ) != MI_OK )&#123;</span><br><span class="line">                        ucStatusReturn = PcdRequest ( PICC_REQALL, ucArray_ID );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( ucStatusReturn == MI_OK  )&#123;</span><br><span class="line">                <span class="comment">/* 防冲突操作，被选中的卡片序列传入数组ucArray_ID中 */</span></span><br><span class="line">                <span class="keyword">if</span> ( PcdAnticoll ( ucArray_ID ) == MI_OK )&#123;</span><br><span class="line">                        <span class="comment">//输出卡ID</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;ID: %X %X %X %X\r\n&quot;</span>, ucArray_ID [ <span class="number">0</span> ], ucArray_ID [ <span class="number">1</span> ], ucArray_ID [ <span class="number">2</span> ], ucArray_ID [ <span class="number">3</span> ]);</span><br><span class="line"></span><br><span class="line">                         <span class="comment">//选卡</span></span><br><span class="line">                        <span class="keyword">if</span>( PcdSelect(ucArray_ID) != MI_OK )&#123;    </span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;PcdSelect failure\r\n&quot;</span>);         </span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//校验卡片密码</span></span><br><span class="line">                        <span class="comment">//数据块6的密码A进行校验（所有密码默认为16个字节的0xff）</span></span><br><span class="line">                        <span class="keyword">if</span>( PcdAuthState(PICC_AUTHENT1B, <span class="number">6</span>, card_KEY,  ucArray_ID) != MI_OK )</span><br><span class="line">                        &#123;    <span class="built_in">printf</span>(<span class="string">&quot;PcdAuthState failure\r\n&quot;</span>);      &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//往数据块4写入数据read_write_data</span></span><br><span class="line">                        read_write_data[<span class="number">0</span>] = <span class="number">0xaa</span>;<span class="comment">//将read_write_data的第一位数据改为0xaa</span></span><br><span class="line">                        <span class="keyword">if</span>( PcdWrite(<span class="number">4</span>,read_write_data) != MI_OK )</span><br><span class="line">                        &#123;    <span class="built_in">printf</span>(<span class="string">&quot;PcdWrite failure\r\n&quot;</span>);          &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//将read_write_data的16位数据，填充为0（清除数据的意思）</span></span><br><span class="line">                        <span class="built_in">memset</span>(read_write_data,<span class="number">0</span>,<span class="number">16</span>);</span><br><span class="line">                        delay_us(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//读取数据块4的数据</span></span><br><span class="line">                        <span class="keyword">if</span>( PcdRead(<span class="number">4</span>,read_write_data) != MI_OK )</span><br><span class="line">                        &#123;    <span class="built_in">printf</span>(<span class="string">&quot;PcdRead failure\r\n&quot;</span>);           &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//输出读出的数据</span></span><br><span class="line">                        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ )</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,read_write_data[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>TTP224</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TTP224/</url>
    <content><![CDATA[<p>TTP224 是一款使用电容式感应原理设计的触摸 IC，其稳定的感应方式可以应用到各种不同电子类产品；面板介质可以是完全绝源的材料，专为取代传统的机械结构开关或普通按键而设计，提供4个触摸输入端口及4个直接输出端口。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>工作电压 2.4V~5.5V。   </li>
<li>可以由外部 Option 选择是否启用内部稳压电路功能。</li>
<li>工作电流 @VDD&#x3D;3V 无负载时:     <ul>
<li>低功耗模式下典型值 2.5uA  </li>
<li>快速模式下典型值9uA</li>
</ul>
</li>
<li>@VDD&#x3D;3V 时,在快速模式下 KEY 最快响应时间为100mS，低功耗模式下为 200mS。</li>
<li>各 KEY 灵敏度可以由外部电容进行调节(0~50pF)。</li>
<li>提供 LPMB 端口选择快速模式或低功耗模式。</li>
<li>提供直接输出模式，触发模式,开漏输出，CMOS 高电平有效或低电平有效输出, 经由 TOG&#x2F;AHLB&#x2F;OD 端口选择。</li>
<li>提供两个无二极管保护的输出端口 TPQ0D，TPQ2D 仅限于低电平有效。</li>
<li>提供 MOT1, MOT0 端口选择最大输出时间:120秒&#x2F;64秒&#x2F;16秒&#x2F;无穷大。</li>
<li>上电后约有 0.5 秒的系统稳定时间,在此期间内不要触摸 Touch PAD 且触摸功能无效。 </li>
<li>有自动校准功能，当无按键被触摸时，系统重新校准周期约为4.0秒。</li>
</ul>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TTP224/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th><strong>管脚序号</strong></th>
<th><strong>管脚名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>管脚描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TP0</td>
<td>I&#x2F;O</td>
<td>触摸输入端口</td>
</tr>
<tr>
<td>2</td>
<td>TP1</td>
<td>I&#x2F;O</td>
<td>触摸输入端口</td>
</tr>
<tr>
<td>3</td>
<td>TP2</td>
<td>I&#x2F;O</td>
<td>触摸输入端口</td>
</tr>
<tr>
<td>4</td>
<td>TP3</td>
<td>I&#x2F;O</td>
<td>触摸输入端口</td>
</tr>
<tr>
<td>5</td>
<td>AHLB</td>
<td>I-PL</td>
<td>输出高、低有效平选择，默认值：0</td>
</tr>
<tr>
<td>6</td>
<td>VDD</td>
<td>P</td>
<td>正电源电压</td>
</tr>
<tr>
<td>7</td>
<td>VREG</td>
<td>P</td>
<td>内部稳压电路输出端口</td>
</tr>
<tr>
<td>8</td>
<td>TOG</td>
<td>I-PL</td>
<td>输出类型选择，默认值：0</td>
</tr>
<tr>
<td>9</td>
<td>LPMB</td>
<td>I-PL</td>
<td>低功耗&#x2F;快速模式选择，默认值：1</td>
</tr>
<tr>
<td>10</td>
<td>MOT0</td>
<td>I-PH</td>
<td>最长输出时间选择，默认值：1</td>
</tr>
<tr>
<td>11</td>
<td>VSS</td>
<td>P</td>
<td>负电源电压，接地</td>
</tr>
<tr>
<td>12</td>
<td>DIS13</td>
<td>I-PH</td>
<td>TP1、TP3 禁用选择端口，默认值：1</td>
</tr>
<tr>
<td>13</td>
<td>REGEN</td>
<td>I-PH</td>
<td>内部稳压电路启用&#x2F;禁用选择，默认值：1</td>
</tr>
<tr>
<td>14</td>
<td>OD</td>
<td>I-PH</td>
<td>开漏输出选择，默认值：1</td>
</tr>
<tr>
<td>15</td>
<td>SM</td>
<td>I-PH</td>
<td>单键&#x2F;多键输出选择，默认值：1</td>
</tr>
<tr>
<td>16</td>
<td>TPQ3</td>
<td>O</td>
<td>直接输出端口</td>
</tr>
<tr>
<td>17</td>
<td>TPQ1</td>
<td>O</td>
<td>直接输出端口</td>
</tr>
<tr>
<td>18</td>
<td>TPQ2D</td>
<td>OD</td>
<td>开漏输出口（无二极管保护电路），低电平有效</td>
</tr>
<tr>
<td>19</td>
<td>TPQ0</td>
<td>O</td>
<td>直接输出端口</td>
</tr>
<tr>
<td>20</td>
<td>TPQ2</td>
<td>O</td>
<td>直接输出端口</td>
</tr>
<tr>
<td>21</td>
<td>TPQ1D</td>
<td>OD</td>
<td>开漏输出端口（无二极管保护电路），低电平有效</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>I</strong> → 仅作为 CMOS 输入</p>
<p><strong>O</strong> → CMOS 输出</p>
<p><strong>I&#x2F;O</strong> → CMOS 输入&#x2F;输出</p>
<p><strong>I-PH</strong> → CMOS 输入带上拉电阻</p>
<p><strong>I-PL</strong> → CMOS 输入带下拉电阻</p>
<p><strong>OD</strong> → 开漏输出，无二极管保护电路</p>
</blockquote>
<h2 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ttp224.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ttp224.h&quot;</span></span></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：TTP224_GPIO_Init</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：对电容式触摸芯片TTP224进行初始化</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：无</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：无</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TTP224_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">        RCC_APB2PeriphClockCmd(RCC_TTP, ENABLE);</span><br><span class="line"></span><br><span class="line">        GPIO_InitStructure.GPIO_Pin = GPIO_IN1|GPIO_IN2|GPIO_IN3|GPIO_IN4;</span><br><span class="line">        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;    <span class="comment">// 下拉输入</span></span><br><span class="line">        GPIO_Init(PORT_TTP, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">        GPIO_ResetBits(PORT_TTP, GPIO_IN1|GPIO_IN2|GPIO_IN3|GPIO_IN4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：Key_IN1_Scanf</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：返回触摸键1引脚电平状态</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：无</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：0=未检测到有触摸  1=检测到触摸</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN1_Scanf</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> KEY_IN1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：Key_IN2_Scanf</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：返回触摸键2引脚电平状态</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：无</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：0=未检测到有触摸  1=检测到触摸</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN2_Scanf</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> KEY_IN2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：Key_IN3_Scanf</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：返回触摸键3引脚电平状态</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：无</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：0=未检测到有触摸  1=检测到触摸</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN3_Scanf</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> KEY_IN3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment"> * 函 数 名 称：Key_IN4_Scanf</span></span><br><span class="line"><span class="comment"> * 函 数 说 明：返回触摸键4引脚电平状态</span></span><br><span class="line"><span class="comment"> * 函 数 形 参：无</span></span><br><span class="line"><span class="comment"> * 函 数 返 回：0=未检测到有触摸  1=检测到触摸</span></span><br><span class="line"><span class="comment"> * 作       者：LC</span></span><br><span class="line"><span class="comment"> * 备       注：无</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN4_Scanf</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> KEY_IN4;</span><br><span class="line">&#125;</span><br><span class="line">=================================================================</span><br><span class="line"><span class="comment">//ttp224.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TTP224_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TTP224_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_TTP     RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_TTP    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_IN1    GPIO_Pin_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_IN2    GPIO_Pin_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_IN3    GPIO_Pin_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_IN4    GPIO_Pin_4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_IN1   GPIO_ReadInputDataBit(PORT_TTP, GPIO_IN1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_IN2   GPIO_ReadInputDataBit(PORT_TTP, GPIO_IN2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_IN3   GPIO_ReadInputDataBit(PORT_TTP, GPIO_IN3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_IN4   GPIO_ReadInputDataBit(PORT_TTP, GPIO_IN4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> TTP224_GPIO_Init(<span class="type">void</span>);<span class="comment">//引脚初始化</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN1_Scanf</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//触摸按键1的输入状态</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN2_Scanf</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//触摸按键2的输入状态</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN3_Scanf</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//触摸按键3的输入状态</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">Key_IN4_Scanf</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//触摸按键4的输入状态</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;board.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_touchkey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)&#123;</span><br><span class="line"></span><br><span class="line">    board_init();</span><br><span class="line"></span><br><span class="line">    uart1_init(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">    TTP224_GPIO_Init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ttp224 demo start\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Key_IN1_Scanf() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[1]-Touch!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Key_IN2_Scanf() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[2]-Touch!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Key_IN3_Scanf() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[3]-Touch!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Key_IN4_Scanf() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[4]-Touch!\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delay_ms(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>LVGL介绍</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/LVGL%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>LVGL（轻量级多功能图形库）是一个免费的开源图形库，提供创建嵌入式 GUI 所需的一切，具有易于使用的图形元素、漂亮的视觉效果和低内存占用。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>基本上，每个能够驱动显示器的现代控制器都适合运行 LVGL。最低要求是：</p>
<ul>
<li><p>16、32 或 64 位微控制器或处理器</p>
</li>
<li><p>&gt; 建议时钟速度为 16 MHz</p>
</li>
<li><p>Flash&#x2F;ROM：&gt; 64 kB（用于非常重要的组件）（建议&gt; 180 kB）</p>
</li>
<li><p>内存：</p>
<ul>
<li><p>静态 RAM 使用量：~2 kB，取决于使用的功能和 Widget 类型</p>
</li>
<li><p>堆栈：&gt; 2kB（建议&gt; 8 kB）</p>
</li>
<li><p>动态数据（堆）：&gt; 2 KB（如果使用许多 GUI 小部件，建议&gt; 48 kB）。</p>
<p>LV_MEM_SIZE 在  lv_conf.h 中设置。</p>
</li>
<li><p>显示缓冲区：&gt; <em>“水平分辨率”</em>像素（建议&gt;10 X <em>“水平分辨率” ）</em></p>
</li>
<li><p>MCU 或外部显示控制器中的一个帧缓冲器</p>
</li>
</ul>
</li>
<li><p>C99 或更新的编译器</p>
</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p><strong>Display（显示器）</strong>：指的是物理硬件设备，也就是用于实际显示图像和像素的物理设备（例如 LCD 屏幕、OLED 屏幕等）。</p>
<p><strong>lv_display_t（显示对象）</strong>：是 LVGL 中表示显示器的一个内存对象，它表示一个显示设备，但它并不是物理设备，而是一个存在于内存中的数据结构，用来管理与物理显示设备的交互。LVGL 会通过这个对象来控制显示设备上的内容，例如更新屏幕上的图形或文本。</p>
<p><strong>Screen（屏幕）</strong>：是一个小部件，是整个界面布局的根，包含所有其他的 UI 元素，并附加到一个具体的 lv_display 上来进行显示。</p>
<blockquote>
<p>当第一个显示 (lv_display) 对象被创建时，它将成为默认显示。</p>
</blockquote>
<h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>屏幕只是任何没有父级的 Widget（即 parent 在创建期间传递 NULL 作为参数）。因此，它们构成了 <strong>Widget 树</strong>的“根”。</p>
<p>所有屏幕：</p>
<ul>
<li>在创建屏幕时自动附加到当前的默认显示；</li>
<li>自动占据相关显示器的全部区域；</li>
<li>无法移动，即 lv_obj_set_pos() 和 lv_obj_set_size() 等功能无法在屏幕上使用。</li>
</ul>
<blockquote>
<p>所有的组件的位置都是相对于父组件的，Screen 没有父控件，所以也就无法移动他的位置；</p>
</blockquote>
<p>当一个 lv_display_t 对象被创建时，LVGL 会自动为其创建四个“屏幕”（或层），并将这些屏幕附加到 lv_display_t 对象上。这些屏幕是显示界面上不同部分的图层管理。</p>
<ol>
<li>底层（活动屏幕下方，透明，不可滚动，但可点击）</li>
<li>活动屏幕（这是当前正在显示的屏幕）</li>
<li>顶层（活动屏幕上方，透明且不可滚动或点击）</li>
<li>系统层（位于顶层之上，透明，不可滚动，不可点击）</li>
</ol>
<blockquote>
<p>为了使底层可见，活动屏幕的背景必须至少部分透明（如果不是完全透明的话）。</p>
</blockquote>
<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>初始化 LVGL 后，为了创建交互式用户界面，应用程序接下来创建一个 Widget 树，LVGL 可将其渲染到相关显示器，并可与用户进行交互。</p>
<p>Widget 是“智能” LVGL 图形元素，例如<a href="https://docs.lvgl.io/master/details/base-widget/index.html#base-widget-overview">基本小部件</a>（简单的矩形和<a href="https://docs.lvgl.io/master/details/base-widget/obj.html#screens">屏幕</a>）、按钮、标签、复选框、开关、滑块、图表等。</p>
<blockquote>
<p>初始化：</p>
<ol>
<li>在系统执行早期通过调用 lv_init()初始化 LVGL。这需要在进行任何其他 LVGL 调用之前完成。</li>
<li>初始化您的驱动程序。</li>
</ol>
<ul>
<li><p>连接<a href="https://docs.lvgl.io/master/intro/add-lvgl-to-your-project/connecting_lvgl.html#tick-interface">Tick 接口</a>。</p>
</li>
<li><p>连接<a href="https://docs.lvgl.io/master/intro/add-lvgl-to-your-project/connecting_lvgl.html#display-interface">显示接口</a>。</p>
</li>
<li><p>连接<a href="https://docs.lvgl.io/master/intro/add-lvgl-to-your-project/connecting_lvgl.html#indev-interface">输入设备接口</a>。</p>
</li>
</ul>
<ol start="3">
<li><p>lv_timer_handler()通过每隔几毫秒调用一次来管理 LVGL 计时器，从而驱动 LVGL 时间相关任务。</p>
</li>
<li><p>可选择使用 来设置主题 lv_display_set_theme()。</p>
</li>
<li><p>此后，在需要使用 LVGL 函数的源文件中 #include “lvgl&#x2F;lvgl.h”。</p>
</li>
</ol>
</blockquote>
<h2 id="LGL-数据流"><a href="#LGL-数据流" class="headerlink" title="LGL 数据流"></a>LGL 数据流</h2><p><img src="C:\Users\kay\Desktop\intro_data_flow.png" alt="intro_data_flow"></p>
<h2 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h2><p>把每个显示的页面看作一个“<strong>图层</strong>”，然后在这个图层上我们添加不同的 <strong>组件</strong>（按钮、文本框、进度条等）。</p>
<h3 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h3><p>在图层上我们可以自由地添加各种 <strong>UI 组件</strong>，比如按钮、文本框、图片等。</p>
<p>图层就是<strong>显示的背景</strong>，它决定了界面显示的整体内容和顺序。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在图层上创建的每个 <strong>UI 组件</strong> 都是一个“对象”。</p>
<p>比如，一个按钮就是一个对象，一个标签也是一个对象。</p>
<p>每个对象都有自己的 <strong>位置、大小、样式</strong>（如颜色、边框、字体等），以及 <strong>功能</strong>（如点击按钮后的反应）。</p>
<h3 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h3><p><strong>每个对象的显示顺序是由它的“层级”决定的</strong>。</p>
<ul>
<li><strong>层级</strong> 就是指对象显示的前后顺序。可以理解为 <strong>z-index</strong>，值越大，越靠前显示，覆盖在其他对象之上。</li>
<li>比如，背景图层会被放在最底层，按钮、文字等会放在更上层。</li>
</ul>
<p>通过设置不同的<strong>层级</strong>，你可以控制哪些组件显示在最前面，哪些在后面。</p>
<h3 id="更新与绘制"><a href="#更新与绘制" class="headerlink" title="更新与绘制"></a>更新与绘制</h3><p><strong>每当有事件发生时</strong>（比如按钮被点击，文本框内容变化），界面上相应的组件需要 <strong>重新绘制</strong>。</p>
<ul>
<li><strong>绘制</strong> 是指将组件的内容更新到屏幕上。例如，当按钮被按下时，按钮的颜色和样式可能会改变，系统会重新绘制这个按钮。</li>
<li><strong>局部刷新</strong>：只更新有变化的部分，而不是重新绘制整个屏幕，这样可以提高效率。</li>
</ul>
<h3 id="最终显示"><a href="#最终显示" class="headerlink" title="最终显示"></a>最终显示</h3><p>所有的组件渲染（绘制）操作会先在 <strong>内存中的缓冲区</strong> 完成，这个缓冲区就像是一个“虚拟屏幕”。</p>
<p>当所有组件都准备好之后，系统会把缓冲区的内容 <strong>一次性显示</strong> 到屏幕上。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LVGL</tag>
      </tags>
  </entry>
  <entry>
    <title>TP4056</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TP4056/</url>
    <content><![CDATA[<p>TP4056 是一款完整的单节锂离子电池充电器，采用恒定电流&#x2F;恒定电压线性充电方式。其 ESOP8&#x2F;EMSOP8 封装带有散热片，且外部元件较少，非常适合便携式应用。TP4056 可以适配 USB 电源和适配器电源工作。</p>
<p>由于采用了内部 PMOSFET 架构和防倒充电路，TP4056 不需要外部隔离二极管。其热反馈功能可以自动调节充电电流，以在高功率操作或高温环境下限制芯片温度。<strong>充电电压固定为 4.2V，充电电流可通过外部电阻设置。当充电电流降至设定值的 1&#x2F;10 时，TP4056 会自动终止充电循环。</strong></p>
<p>当输入电压（如 USB 电源或适配器）断开时，TP4056 会自动进入低电流状态，将电池漏电流降至 2µA 以下。TP4056 还支持停机模式，将供电电流降至 55µA。此外，TP4056 具有电池温度检测、欠压闭锁、自动再充电和两个用于指示充电状态的 LED 引脚。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>输入电源电压 Vcc</strong>：0.3V ~ 8V</p>
<p><strong>PROG 引脚电压</strong>：-0.3V ~ Vcc+0.3V<em>V**cc</em>+0.3<em>V</em></p>
<p><strong>BAT 引脚电压</strong>：-0.3V ~ 7V</p>
<p><strong>CHRG、STDBY、TEMP、CE 引脚电压</strong>：-0.3V ~ 10V</p>
<p><strong>BAT 短路持续时间</strong>：连续</p>
<p><strong>BAT 引脚电流</strong>：1200mA</p>
<p><strong>PROG 引脚电流</strong>：1200µA</p>
<p><strong>最大结温</strong>：145℃</p>
<p><strong>工作环境温度范围</strong>：-40℃ ~ 85℃</p>
<p><strong>贮存温度范围</strong>：-65℃ ~ 125℃</p>
<p><strong>引脚温度（焊接时间 10 秒）</strong>：260℃</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TP4056/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="left">引脚名称</th>
<th align="left">引脚编号</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>TEMP</strong></td>
<td align="left">1</td>
<td align="left">电池温度检测输入端。连接到电池的 NTC 传感器输出端。如果 TEMP 引脚电压小于输入电压的 45% 或大于 80%，充电暂停。如果 TEMP 直接接地，电池温度检测功能取消，其他充电功能正常。</td>
</tr>
<tr>
<td align="left"><strong>PROG</strong></td>
<td align="left">2</td>
<td align="left">恒流充电电流设置和充电电流监测端。通过外部电阻连接到地端设置充电电流。预充电阶段，引脚电压为 0.1V；恒流充电阶段，引脚电压为 1V。可通过测量该引脚电压估算充电电流。</td>
</tr>
<tr>
<td align="left"><strong>GND</strong></td>
<td align="left">3</td>
<td align="left">地端。</td>
</tr>
<tr>
<td align="left"><strong>VCC</strong></td>
<td align="left">4</td>
<td align="left">电源输入端。</td>
</tr>
<tr>
<td align="left"><strong>BAT</strong></td>
<td align="left">5</td>
<td align="left">电池连接端。连接电池正极。在芯片禁用或睡眠模式下，漏电流小于 2µA。提供充电电流和 4.2V 的限制电压。</td>
</tr>
<tr>
<td align="left"><strong>STDBY</strong></td>
<td align="left">6</td>
<td align="left">电池充电完成指示端。充电完成时，引脚被内部开关拉低；否则为高阻态。</td>
</tr>
<tr>
<td align="left"><strong>CHRG</strong></td>
<td align="left">7</td>
<td align="left">漏极开路输出的充电状态指示端。充电时，引脚被内部开关拉低；否则为高阻态。</td>
</tr>
<tr>
<td align="left"><strong>CE</strong></td>
<td align="left">8</td>
<td align="left">芯片使能输入端。高电平使 TP4056 正常工作；低电平禁止充电。支持 TTL 或 CMOS 电平驱动。</td>
</tr>
</tbody></table>
<h2 id="经典电路"><a href="#经典电路" class="headerlink" title="经典电路"></a>经典电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TP4056/jddl.png" alt="jddl"></p>
<blockquote>
<p><strong>电源输入（VCC）</strong></p>
<ul>
<li><strong>VCC 连接 5V</strong>，为 TP4056 提供充电电源。</li>
<li><strong>输入端并联 10uF 电容</strong>，用于滤波和稳定输入电压。</li>
<li><strong>0.4Ω 串联电阻</strong> 用于限流，防止过流冲击。</li>
</ul>
<p><strong>充电状态指示</strong></p>
<ul>
<li>CHRG（引脚 6）：充电指示<ul>
<li>连接 <strong>LED 红灯</strong>，表示<strong>正在充电</strong>。</li>
</ul>
</li>
<li>STDBY（引脚 7）：充满指示<ul>
<li>连接 <strong>LED 绿灯</strong>，表示<strong>充电完成</strong>。</li>
<li><strong>LED 通过 1kΩ 电阻限流</strong>。</li>
</ul>
</li>
</ul>
<p><strong>充电电流设置</strong></p>
<ul>
<li>PROG（引脚 2）：充电电流设定<ul>
<li>连接 <strong>RPROG 电阻</strong> 来设定最大充电电流，计算公式： I<sub>charge</sub> &#x3D; 1200 &#x2F; R<sub>PROG</sub> (mA)</li>
</ul>
</li>
<li>例如：<ul>
<li>RPROG &#x3D; 1.2kΩ → 充电电流 <strong>1000mA（1A）</strong></li>
<li>RPROG &#x3D; 2.4kΩ → 充电电流 <strong>500mA</strong></li>
</ul>
</li>
</ul>
<p><strong>电池连接（BAT，PIN 5）</strong></p>
<ul>
<li><strong>连接到锂电池的正极（Bat+），负极（Bat-）</strong>。</li>
<li>并联一个 <strong>10uF 滤波电容</strong> 来稳定输出电压。</li>
</ul>
<p><strong>温度监测（TEMP，PIN 1）</strong></p>
<ul>
<li><p>该引脚用于连接 </p>
<p>NTC（负温度系数热敏电阻）</p>
<p> 来检测电池温度：</p>
<ul>
<li>若 <strong>NTC 电阻值在安全范围内</strong>，则充电正常。</li>
<li>若 <strong>温度超出安全范围</strong>，则 TP4056 停止充电。</li>
</ul>
</li>
<li><p><strong>如果不使用温度检测功能</strong>，可以将 TEMP 直接接地（GND）。</p>
</li>
</ul>
</blockquote>
<p><strong>充电电流设定</strong></p>
<p>充电电流是采用一个连接在PROG引脚与地之间的电阻器来设定的。设定电阻器和充电电流采用下列公式来计算： </p>
<p>根据需要的充电电流来确定电阻器阻值</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TP4056/cddlsd.png" alt="cddlsd"></p>
<p>客户应用中，可根据需求选取合适大小的R<sub>PROG</sub>，R<sub>PROG</sub>与充电电流的关系确定可参考下表：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/TP4056/cddlsdb.png" alt="cddlsdb"></p>
<h2 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h2><p><strong>TP4056</strong> 是一款 <strong>硬件控制的线性充电芯片</strong>，它不需要编写驱动代码，只需要通过 <strong>硬件电路连接</strong> 和 <strong>外部元件配置</strong> 即可实现充电功能。</p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>W25Q128</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/W25Q128/</url>
    <content><![CDATA[<p>W25Q128 是一种常见的串行闪存器件，它采用 SPI（Serial Peripheral Interface）接口协议，具有高速读写和擦除功能，可用于存储和读取数据。W25Q128 芯片容量为 128 Mbit（16 MB），其中名称后的数字代表不同的容量选项。不同的型号和容量选项可以满足不同应用的需求，通常被用于嵌入式设备、存储设备、路由器等高性能电子设备中。</p>
<p>W25Q128 闪存芯片的内存分配是按照扇区（Sector）和块（Block）进行的，每个扇区的大小为 4KB，每个块包含 16 个扇区，即一个块的大小为 64KB。</p>
<p><strong>存储结构图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/W25Q128/ccjgt.png" alt="ccjgt"></p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/W25Q128/yjsm.png" alt="yjsm"></p>
<table>
<thead>
<tr>
<th align="center"><strong>引脚编号</strong></th>
<th align="left"><strong>引脚名称</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">&#x2F;CS</td>
<td align="left">芯片选择引脚（Chip Select）</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">DO (IO₁)</td>
<td align="left">数据输出引脚（Data Out，I&#x2F;O1）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">&#x2F;WP (IO₂)</td>
<td align="left">写保护引脚（Write Protect，I&#x2F;O2）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">GND</td>
<td align="left">地引脚（Ground）</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">DI (IO₀)</td>
<td align="left">数据输入引脚（Data In，I&#x2F;O0）</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">CLK</td>
<td align="left">时钟信号引脚（Clock）</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">&#x2F;HOLD or &#x2F;RESET (IO₃)</td>
<td align="left">保持或复位引脚（Hold&#x2F;Reset，I&#x2F;O3）</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">VCC</td>
<td align="left">电源引脚（Power Supply）</td>
</tr>
</tbody></table>
<blockquote>
<p>&#x2F; 表示引脚是<strong>低电平有效</strong>。</p>
<p>HOLD：当它有效时允许设备暂停，低电平：DO 引脚高阻态，DI CLK 引脚的信号被忽略。高电平：设备重新开始，当多个设备共享相同的 SPI 信 号的时候该功能可能会被用到。</p>
</blockquote>
<h2 id="示例电路"><a href="#示例电路" class="headerlink" title="示例电路"></a>示例电路</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/IC/W25Q128/sjdl.png" alt="sjdl"></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>根据 W25Q128 的数据手册，得到以下配置：</p>
<ul>
<li>SPI 配置为了全双工模式，可以同时发送与接收数据；</li>
<li>STM32F407 配置为主机模式，由 STM32F407 产生时钟，与从机 W25Q128 进行通信；</li>
<li>数据的传输以 8 位进行传输。</li>
<li>片选方式选择软件控制片选。在硬件 SPI 中，一个 SPI 只有一个片选线，这会导致硬件 SPI 如果选择硬件控制片选信号，只能控制一个从机。我们是希望能够一个 SPI 可以控制多个从机，因此选择软件方式片选，片选线可以随意设定。</li>
<li>时钟分频选择 4 分频，根据 W25Q128 的数据手册说明，W25Q128 的 SPI 时钟可以达到 30MHz，而我们的 SPI0 的时钟来源为 PCLK2&#x3D;84MHz，SPI 的配置中必须要求进行分频，分频之后的频率是 21MH，低于 30Mhz，W25Q1282 完全可以兼容。</li>
<li>字节顺序选择高位在前。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPI_InitTypeDef  SPI_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FLASH_SPI 模式配置 */</span></span><br><span class="line">SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; <span class="comment">// 传输模式全双工</span></span><br><span class="line">SPI_InitStructure.SPI_Mode = SPI_Mode_Master;                <span class="comment">// 配置为主机</span></span><br><span class="line">SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;        <span class="comment">// 8位数据</span></span><br><span class="line">SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;</span><br><span class="line">SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;                <span class="comment">// 极性相位</span></span><br><span class="line">SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;                        <span class="comment">// 软件cs</span></span><br><span class="line">SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2; <span class="comment">// SPI时钟预调因数为2</span></span><br><span class="line">SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;        <span class="comment">//高位在前</span></span><br><span class="line">SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">SPI_Init(BSP_SPI, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使能 FLASH_SPI  */</span></span><br><span class="line">SPI_Cmd(BSP_SPI, ENABLE);</span><br></pre></td></tr></table></figure>

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;board.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        board_init();</span><br><span class="line">        uart1_init(<span class="number">115200U</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* SPI初始化 */</span></span><br><span class="line">        bsp_spi_init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存区数组定义</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n=========【开始】========\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 擦除Flash扇区0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n【1】擦除Flash扇区0......\r\n&quot;</span>);</span><br><span class="line">        W25Q128_erase_sector(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flash扇区0擦除完成！！\r\n&quot;</span>);</span><br><span class="line">        delay_ms(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取W25Q128的设备ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n【2】读取设备的id......\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备ID = %X\r\n&quot;</span>,W25Q128_readID());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取0地址长度为10个字节的数据到buff</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n【3】读取0地址长度为10个字节的数据到buff......\r\n&quot;</span>);</span><br><span class="line">        W25Q128_read(buff, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//输出读取到的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取到的数据= %s\r\n&quot;</span>,buff);</span><br><span class="line">        delay_ms(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往0地址写入10个字节的数据 “立创开发板”</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n【4】往0地址写入8个字节的数据 “TooUpper”......\r\n&quot;</span>);</span><br><span class="line">        W25Q128_write((<span class="type">uint8_t</span> *)<span class="string">&quot;TooUpper&quot;</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 等待写入完成</span></span><br><span class="line">        delay_ms(<span class="number">200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功！\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取0地址长度为10个字节的数据到buff</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n【5】读取0地址长度为8个字节的数据到buff......\r\n&quot;</span>);</span><br><span class="line">        W25Q128_read(buff, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">//输出读取到的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取到的数据= %s\r\n&quot;</span>,buff);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为是从0地址写的，所以擦除第0个扇区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n【6】功能测试完毕擦除写入的数据......\r\n&quot;</span>);</span><br><span class="line">        W25Q128_erase_sector(<span class="number">0</span>);</span><br><span class="line">        delay_ms(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除缓存区</span></span><br><span class="line">        <span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="keyword">sizeof</span>(buff));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r\n=========【结束】========\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                delay_ms(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>IC</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟环境搭建</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><strong>编译器：</strong></p>
<ul>
<li><p><a href="https://code.visualstudio.com/Download#"><strong>vscode</strong></a></p>
<p>安装 C&#x2F;C++ Extension Pack 插件</p>
<p>最好也将 vscode 添加到环境变量中</p>
</li>
</ul>
<p><strong>编译工具链：</strong></p>
<ul>
<li><p><a href="https://github.com/niXman/mingw-builds-binaries/releases"><strong>MinGW-64</strong></a></p>
<p>安装后记得要添加到环境变量，使用  gcc -v 验证是否配置成功</p>
</li>
</ul>
<p><strong>编译环境</strong></p>
<ul>
<li><a href="https://cmake.org/download/">Download CMake</a>，安装后要添加到环境变量 &#x2F;bin</li>
</ul>
<p><strong>工具包：</strong></p>
<ul>
<li><a href="https://github.com/lvgl/lvgl"><strong>lvgl(内核)</strong></a></li>
<li><a href="https://github.com/lvgl/lv_drivers"><strong>lv_drivers(驱动)</strong></a></li>
<li><a href="https://github.com/lvgl/lv_port_pc_eclipse"><strong>lv_port_pc_eclipse(模拟器)</strong></a></li>
<li><a href="https://github.com/libsdl-org/SDL"><strong>SDL2(开源的图形库)</strong></a> 下载 SDL2-devel-2.32.0-mingw 这个版本的</li>
</ul>
<blockquote>
<p>lvgl、lvgl_drivers、lvgl_port_pc_eclipse 三者最好保证版本一致以防出现兼容性错误；示例中统一使用的是 8.3 版本</p>
<p>SDL2 是一个开源的图形库能够直接在屏幕上绘制像素、图像、文本等，lvgl_port_pc_eclipse 需要依赖于该图形库；</p>
</blockquote>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="工具链配置"><a href="#工具链配置" class="headerlink" title="工具链配置"></a>工具链配置</h3><p>解压 SDL2 这个库，将其中的 cmake 和 x86_64-w64-mingw32 复制到 MinGW-64 的目录下：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/lvglgjlml.png" alt="lvglgjlml"></p>
<h3 id="编码准备"><a href="#编码准备" class="headerlink" title="编码准备"></a>编码准备</h3><p>新建一个目录 lvgl_Demo 作为工程目录：</p>
<ul>
<li>将 lvgl 目录和其文件拷贝到 lvgl_Demo 目录下</li>
<li>将 lvgl_drivers 目录和其文件拷贝到 lvgl_Demo 目录下</li>
<li>将 lvgl_port_pc_eclipse 下的所有文件拷贝到 lvgl_Demo  目录下（不是将 lvgl_port_pc_eclipse 这个目录拷贝到 lvgl_Demo 目录下）</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/lvglmlgxyg.png" alt="lvglmlgxyg"></p>
<h3 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h3><p>准备完成后后可以通过命令面板 (Ctrl+Shift+P)，输入并选择 <strong>CMake: Select a Kit</strong>，选择 GCC 编译器；</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/lcglvscodekits.png" alt="lcglvscodekits"></p>
<p>在选择完工具链后，点击底部 <strong>CMake Tools</strong> 工具栏中的 <strong>生成</strong> 按钮，即可生成对应的 .exe 文件。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/lvglcmaketoolsbg.png" alt="lvglcmaketoolsbg"></p>
<p>构建完成后，生成的可执行文件会位于工程目录下的 bin 文件夹中。</p>
<p>需要注意的是，如果直接运行 .exe 文件，可能会提示缺少 SDL2.dll 文件。这是因为运行程序需要动态链接库支持。为了解决这个问题，需要将 SDL2&#x2F;x86_64-w64-mingw32&#x2F;bin 目录下的 SDL2.dll 文件复制到生成的 .exe 文件所在的目录中。</p>
<p>完成上述操作后，运行程序即可正常启动，运行效果如下所示：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/lvgldjjg.png" alt="lvgldjjg"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LVGL</tag>
      </tags>
  </entry>
  <entry>
    <title>SquareLineStudio</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/SquareLineStudio/</url>
    <content><![CDATA[<p><strong>SquareLine Studio</strong> 是一个专为 LVGL 图形库设计的<strong>可视化界面开发工具</strong>，由 LVGL 团队官方推出。它旨在帮助开发者快速设计和生成基于 <strong>LVGL 图形库</strong> 的用户界面。这个工具集成了图形设计、事件管理和代码生成等功能，使开发者可以通过拖拽和简单配置来完成复杂界面设计，无需深入学习底层 LVGL API。</p>
<p><a href="https://squareline.io/downloads#lastRelease">SquareLine Studio官网下载</a></p>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>打开 SquareLine Studio 如下图所示</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/guinew.png" alt="guinew"></p>
<table>
<thead>
<tr>
<th align="left"><strong>参数</strong></th>
<th align="left"><strong>说明</strong></th>
<th align="left"><strong>选项&#x2F;值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Project Name</strong></td>
<td align="left">工程名</td>
<td align="left">自定义（不建议修改）</td>
</tr>
<tr>
<td align="left"><strong>工程存放的位置</strong></td>
<td align="left">工程存放的位置</td>
<td align="left">自定义（不同的工程需要指定不同的存放路径）</td>
</tr>
<tr>
<td align="left"><strong>Resolution</strong></td>
<td align="left">屏幕分辨率，根据硬件屏幕的实际分辨率来设置。可以查看屏幕手册或询问硬件提供人员。</td>
<td align="left">如 320x240、480x320、800x480 等</td>
</tr>
<tr>
<td align="left"><strong>Rotation</strong></td>
<td align="left">设置屏幕的旋转方向。</td>
<td align="left">0°（横屏）、90°（竖屏）、180°（上下颠倒）、270°（逆时针旋转 270°）</td>
</tr>
<tr>
<td align="left"><strong>Offset</strong></td>
<td align="left">设置屏幕内容的偏移量，通常用于有效显示区域不在起始位置时。</td>
<td align="left">(0, 0)（默认），例如 (10, 10)</td>
</tr>
<tr>
<td align="left"><strong>Shape</strong></td>
<td align="left">屏幕的物理形状，影响显示内容布局。</td>
<td align="left">Rectangular（矩形）、Circle（圆形）</td>
</tr>
<tr>
<td align="left"><strong>Color Depth</strong></td>
<td align="left">屏幕每个像素的颜色数据位数，影响颜色显示质量和存储空间。</td>
<td align="left">8 bit、16 bit（RGB565）、16 bit swap(BGR565)、32 bit（ARGB8888）</td>
</tr>
<tr>
<td align="left"><strong>LVGL Version</strong></td>
<td align="left">LVGL 图形库的版本。选择与项目使用的 LVGL 版本一致。</td>
<td align="left">根据需要选择，例如 v7.x、v8.x 等</td>
</tr>
<tr>
<td align="left"><strong>Theme</strong></td>
<td align="left">LVGL 提供的 UI 样式和设计预设。</td>
<td align="left">Default（默认）、Material（现代化）、Mono（黑白）、自定义主题</td>
</tr>
<tr>
<td align="left"><strong>Multilanguage</strong></td>
<td align="left">是否支持界面多语言显示。</td>
<td align="left">Enable（启用）、Disable（禁用）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Color Depth：</strong>选择硬件所支持的位数</p>
<ul>
<li><p>8 位：每个像素用 8 位表示，通常用于黑白显示或色彩非常有限的设备（最多 256 种颜色）。</p>
</li>
<li><p>16 位（RGB565）：支持 65,536 种颜色，常用于嵌入式设备。</p>
</li>
<li><p>16 位 swap：与 16 bit（RGB565）相同，只是字节顺序颠倒，通常用来匹配硬件的特定要求。</p>
</li>
<li><p>32 位（ARGB8888）：支持全彩和透明度，适合高端设备。</p>
</li>
</ul>
<p><strong>Multilanguage：</strong>是否支持界面的多语言显示。</p>
<ul>
<li>如果你的设备需要切换语言（如中文&#x2F;英文界面切换），选择 Enable。</li>
<li>不需要多语言时可禁用，减少代码和内存占用。</li>
</ul>
</blockquote>
<h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><p><strong>修改创建项目时的一些参数</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LVGL</tag>
      </tags>
  </entry>
  <entry>
    <title>布局</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>所有 Widget 都使用指针作为句柄进行引用<a href="https://docs.lvgl.io/master/API/misc/lv_types.html#_CPPv48lv_obj_t"><code>lv_obj_t</code></a>。此指针稍后可用于读取或更改 Widget 的属性。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LVGL</tag>
      </tags>
  </entry>
  <entry>
    <title>移植流程</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/%E7%A7%BB%E6%A4%8D%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>LVGL（LittlevGL）</strong> 是一个功能强大的<strong>开源图形用户界面（GUI）库</strong>，主要应用于嵌入式设备。为了在不同的硬件平台上运行 <strong>LVGL</strong>，我们需要进行移植（porting）。移植的目标是让 <strong>LVGL</strong> 库能够在特定的硬件和操作环境下正常运行，从而显示图形界面并响应用户输入。</p>
<h2 id="测试屏幕"><a href="#测试屏幕" class="headerlink" title="测试屏幕"></a>测试屏幕</h2><p>在移植 LVGL 之前我们最好先测试一个我们的 LED 显示屏是否可以正常工作，如果可以正常工作再将 LVGL 生成的图像渲染到屏幕上；</p>
<p>我们这里使用的是 P169H002-CTP 型号的 1.69 寸显示屏；他的显示芯片为 ST7789V，触控芯片为 CST816T，我们可以先通过官方提供的驱动函数先试着点亮屏幕，看屏幕是否可以支持工作</p>
<p><strong>显示驱动</strong></p>
<p>拷贝官方 ST7789 的驱动程序等到我们工程中；</p>
<p>我们需要修改官方驱动程序的引脚与我们板子上所使用的是一致的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// st7789.h</span></span><br><span class="line"><span class="comment">/* choose a Hardware SPI port to use. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_SPIX_RCU RCU_SPI0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_SPIX_PORT SPI0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define the pins tp connect */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_RST_RCU	RCU_GPIOD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_RST_PORT GPIOD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_RST_PIN GPIO_PIN_6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_DC_RCU	RCU_GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_DC_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_DC_PIN GPIO_PIN_1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_CS_RCU	RCU_GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_CS_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_CS_PIN GPIO_PIN_0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_BLK_RCU	RCU_GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_BLK_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST7789_BLK_PIN GPIO_PIN_10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// st77789.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK_RCU RCU_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK_PIN GPIO_PIN_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK_AF GPIO_AF_5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_SDA_RCU RCU_GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_SDA_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_SDA_PIN GPIO_PIN_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_SDA_AF GPIO_AF_5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;st7789.h&quot;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ST7789_Init();</span><br><span class="line">    <span class="comment">// 铺满颜色，也就是背景</span></span><br><span class="line">    ST7789_Fill_Color(<span class="number">0xFFFF</span>);</span><br><span class="line">    <span class="comment">// 画一条线	</span></span><br><span class="line">    ST7789_DrawLine(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0xFF00</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>在修改时候一定要注意，如果官方提供的代码示例（SPI 实现）是通过硬件实现的，我们在修改引脚后一定不要忘记修改引脚的复用编号，和具体使用的复用功能（SPI几）的编号；</p>
</blockquote>
<p><strong>触控驱动</strong></p>
<p>拷贝官方 CST816T 的驱动程序等到我们工程中，因为触控驱动使用的是 I2C 进行通信所以这里还需要拷贝 I2C 的实现代码；</p>
<p>修改驱动引脚；</p>
<p>这里要知道触控的实现是我们点击屏幕，然后它对应的引脚就会产生变化，我们需要去监听这个引脚的变化，也就是需要一个外部中断；所以官方提供的驱动中有引脚是需要外部中断的；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cst816t.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_RESET_RCU     		RCU_GPIOD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_RESET_GPIO          GPIOD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_RESET_GPIO_PIN      GPIO_PIN_7</span></span><br><span class="line"><span class="comment">// PA7</span></span><br><span class="line"><span class="comment">// #define CST816T_IRQ 				PBout(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_IRQ_RCU     	 	RCU_GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_IRQ_GPIO         	GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_IRQ_GPIO_PIN    	GPIO_PIN_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CST816T_EXTI_Line			EXTI_4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cst816t.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CST816T_GPIOInit</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="comment">//PA_6(RST)</span></span><br><span class="line">	rcu_periph_clock_enable(CST816T_RESET_RCU);</span><br><span class="line">	gpio_mode_set(CST816T_RESET_GPIO, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, CST816T_RESET_GPIO_PIN);</span><br><span class="line">	gpio_output_options_set(CST816T_RESET_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, CST816T_RESET_GPIO_PIN);</span><br><span class="line">	<span class="comment">//PA_7(INT)</span></span><br><span class="line">	rcu_periph_clock_enable(CST816T_IRQ_RCU);</span><br><span class="line">	gpio_mode_set(CST816T_IRQ_GPIO, GPIO_MODE_INPUT, GPIO_PUPD_PULLUP, CST816T_IRQ_GPIO_PIN);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//1.2 开启系统配置时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_SYSCFG); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*3.使能NVIC中断并配置优先级*/</span></span><br><span class="line">	<span class="comment">//3.1 设置中断优先级分组(只需要配置一次  可以放在main中)</span></span><br><span class="line">	<span class="comment">//	nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span></span><br><span class="line">	<span class="comment">//3.2 配置中断的抢占优先级和响应优先级 抢占优先级3,子优先级3</span></span><br><span class="line">	nvic_irq_enable(EXTI4_IRQn,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/*4.配置GPIO中断 中断引脚资源端口和中断引脚*/</span></span><br><span class="line">	syscfg_exti_line_config(EXTI_SOURCE_GPIOB,EXTI_SOURCE_PIN4);</span><br><span class="line">	<span class="comment">/*5.初始化中断线  第三个参数指定上升沿和下降沿均触发*/</span></span><br><span class="line">	exti_init(CST816T_EXTI_Line,EXTI_INTERRUPT,EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/*6.使能中断和清除中断标志位*/</span></span><br><span class="line">	<span class="comment">//清除中断标志位</span></span><br><span class="line">	exti_interrupt_flag_clear(CST816T_EXTI_Line);</span><br><span class="line">	<span class="comment">//使能中断</span></span><br><span class="line">	exti_interrupt_enable(CST816T_EXTI_Line);</span><br><span class="line">	<span class="comment">/*7.编写中断服务函数*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	_CST816T_RESET_HIGH_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;	 </span><br><span class="line">	 <span class="keyword">if</span>(exti_interrupt_flag_get(CST816T_EXTI_Line) == SET) &#123;</span><br><span class="line">			exti_interrupt_flag_clear(CST816T_EXTI_Line);</span><br><span class="line">			CST816_GetAction();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;touch down\r\n&quot;</span>);</span><br><span class="line">	 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		  CST816_GetAction();</span><br><span class="line">			<span class="comment">//CST816T_ClrBaseDatas();</span></span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">&quot;touch release\r\n&quot;</span>);</span><br><span class="line">	 &#125;	 </span><br><span class="line">	 exti_interrupt_flag_clear(CST816T_EXTI_Line); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改的时候细心些，修改完引脚后，中断配置中的一些也需要修改，不要漏了，否则会导致中断无法触发；</p>
</blockquote>
<p>如果上面正确，会在屏幕上显示一条线，并且点击屏幕会在中断中有打印输出；</p>
<h2 id="移植流程"><a href="#移植流程" class="headerlink" title="移植流程"></a>移植流程</h2><h3 id="获取-LVGL"><a href="#获取-LVGL" class="headerlink" title="获取 LVGL"></a>获取 LVGL</h3><p>获取 <a href="https://github.com/lvgl/lvgl">LVGL</a>（为了保证与 LVGL 图形化工具生成的代码兼容，二者最好选择一样的版本 v8.3）</p>
<p>lvgl 图形库下包含多个子目录，要移植 LVGL，只需要 src 目录下的 <strong>.c</strong> 和 <strong>.h</strong> 文件，以及根目录下的 <strong>lvgl.h</strong> 这个文件即可。</p>
<blockquote>
<p><strong>lvgl</strong> 官方库中还包含了 <strong>examples</strong> 和 <strong>demos</strong> 目录。如果你的项目需要示例或演示，你可以将这些目录添加到你的项目中。如果使用 <strong>make</strong> 或 <strong>CMake</strong> 来处理 <strong>examples</strong> 和 <strong>demos</strong> 目录，那么就不需要额外的操作。</p>
<p>LVGL 本身只是一个 GUI 的图形库，他将图像生成后，需要通过驱动程序将数据发送给屏幕；</p>
<p>为了检测移植是否成功所以我们需要保留 examples 和 demos 目录</p>
</blockquote>
<h3 id="创建-lv-conf-h"><a href="#创建-lv-conf-h" class="headerlink" title="创建 lv_conf.h"></a>创建 lv_conf.h</h3><p>当你第一次设置项目时，首先将 lvgl 目录下的 lv_conf_template.h 重命名为 lv_conf.h。</p>
<p>接着，将文件中第一个 #if 0 改为 #if 1，以启用该文件的内容。</p>
<p>然后，根据你使用的显示屏的颜色深度，设置 LV_COLOR_DEPTH 这个宏。有关详细信息，请查看 <strong>lv_conf.h</strong> 文件中的注释。</p>
<blockquote>
<p>这里我们需要去看下我们屏幕所使用的颜色格式或者说颜色深度，我们使用的屏幕显示部分驱动用的是 ST7789 芯片，颜色深度为可选择为 6&#x2F;16&#x2F;18 色，这里我们让二者保持一致都选择呢 16 色即可； </p>
<p>#define LV_COLOR_DEPTH 16</p>
</blockquote>
<p>此时我们需要的目录结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lvgl/</span><br><span class="line">├── demos/        # 演示代码目录</span><br><span class="line">│   └── ...       # 演示代码</span><br><span class="line">│</span><br><span class="line">├── examples/     # 示例代码目录</span><br><span class="line">│   └── ...       # 示例代码</span><br><span class="line">│</span><br><span class="line">├── src/          # LVGL 核心源代码</span><br><span class="line">│   └── ...       # 核心实现</span><br><span class="line">│</span><br><span class="line">├── lvgl.h        # LVGL 主头文件</span><br><span class="line">├── lv_version.h  # LVGL 版本信息 <span class="comment">// 如果没有可以不拷贝</span></span><br><span class="line">└── lv_conf.h     # LVGL 配置文件</span><br></pre></td></tr></table></figure>

<h3 id="代码移植"><a href="#代码移植" class="headerlink" title="代码移植"></a>代码移植</h3><ol>
<li><p>此时我们需要将裁剪后的代码添加到我们的项目中去，将 lvgl 目录下裁剪后的代码复制到我们工程下的 Middleware&#x2F;LVGL 目录中；</p>
</li>
<li><p>在 Keil 中添加 lvgl 相关文件时候，要注意我们并不是要拷贝 src 下的所有代码，他有些代码是为了兼容其他架构的我们就不需要添加进来;</p>
</li>
</ol>
<p>兼容性驱动代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Middlewares/</span><br><span class="line">└── lvgl/</span><br><span class="line">    │   ├── draw/	# 渲染方案</span><br><span class="line">    │   │   ├── arm2d/        # 针对 ARM2D 硬件加速库相关的代码</span><br><span class="line">    │   │   ├── nxp/          # 针对 NXP 处理器相关的代码</span><br><span class="line">    │   │   ├── renesas/      # 针对 Renesas 处理器相关的代码</span><br><span class="line">    │   │   ├── sdl/          # 针对 SDL 图形库相关的代码</span><br><span class="line">    │   │   ├── stm32_dma2d/  # 针对 STM32 的 DMA2D 图形加速的代码</span><br><span class="line">    │   │   ├── sw/           # 纯 CPU 软件渲染的实现（这个目录下的代码是需要添加进去的）</span><br><span class="line">    │   │   ├── swm341_dma2d/ # 针对 SWM341 的 DMA2D 图形加速的代码</span><br><span class="line">    └── └── └── ...           # 其他必要的渲染实现代码</span><br></pre></td></tr></table></figure>

<p>我们再添加代码时候，上述目录中与我们使用的硬件不相关管的代码可以不用添加到我们的 Keil 工程中去；</p>
<ol start="3">
<li>src 目录下的代码负责生成 2D 图像的像素数据，但要将这些数据传输到屏幕并正确显示出来，还需要具体硬件的驱动程序来完成屏幕的初始化和数据传输。因此，我们需要添加并移植显示设备驱动和输入设备驱动的<strong>模板文件</strong>，以实现屏幕显示功能和输入交互功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Middleware/</span><br><span class="line">└── LVGL/</span><br><span class="line">    └── examples/                        </span><br><span class="line">        └── porting/                     </span><br><span class="line">            └── lv_port_disp_template.c   # 显示驱动的移植模板</span><br><span class="line">    	    └── lv_port_fs_template.c     # 文件系统驱动的移植模板。</span><br><span class="line">            └── lv_port_indev_template.c  # 输入设备驱动的移植模板。</span><br><span class="line">            └── lv_port_disp_template.h   # 显示驱动的移植模板头文件</span><br><span class="line">    	    └── lv_port_fs_template.h     # 文件系统驱动的移植模板头文件</span><br><span class="line">            └── lv_port_indev_template.h  # 输入设备驱动的移植模板头文件 </span><br></pre></td></tr></table></figure>

<p>我们需要将图像显示在屏幕中，并通过触摸屏去操控屏幕，所以这里我们还需要添加 lv_port_disp_template.c 和 lv_port_indev_template.c 两个文件；</p>
<blockquote>
<p>添加完成后记得将头文件目录加到项目中去；</p>
<p> lv_conf.h ;</p>
<p>Middleware&#x2F;LVGL&#x2F;examples&#x2F;porting 下驱动程序相关的头文件</p>
</blockquote>
<p>如果编译不报错，则代表初步移植完成，但它此时他还会爆一些警告，因为我们还没有添加一些必须要的参数信息；</p>
<h3 id="配置驱动"><a href="#配置驱动" class="headerlink" title="配置驱动"></a>配置驱动</h3><h4 id="显示驱动"><a href="#显示驱动" class="headerlink" title="显示驱动"></a>显示驱动</h4><p><strong>启用输出模板代码</strong></p>
<p>我们虽然添加了显示的驱动程序模板，但是它默认是不启用的，所以我们这里需要配置以启用它；</p>
<p>我们需要修改 lv_port_disp_template.c 和 lv_port_disp_template.h 中的条件编译选项以启用他的输出模板代码；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0 修改为 #<span class="keyword">if</span> 1</span></span><br></pre></td></tr></table></figure>

<p><strong>在输出模板中初始化我们的屏幕驱动</strong></p>
<ol>
<li>我们要先设置显示屏的分辨率，这样可以让 LVGL 生成的图像适配我们的屏幕</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lv_port_disp_template.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_DISP_HOR_RES 240     <span class="comment">//水平分辨率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_DISP_VER_RES 280     <span class="comment">//垂直分辨率</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化我们屏幕驱动</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lv_port_disp_template.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;st7789.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_disp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*-------------------------</span></span><br><span class="line"><span class="comment">     * Initialize your display</span></span><br><span class="line"><span class="comment">     * -----------------------*/</span></span><br><span class="line">    disp_init();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*You code here*/</span></span><br><span class="line">	ST7789_Init();		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相当于官方给我们提供了一个统一的显示接口，所有的显示都放在这个模板文件中，在 LVGL 层面起到了一个屏蔽不同硬件差异的一个效果</p>
</blockquote>
<p>屏幕显示驱动的代码一般是由硬件的供应商提供的，我们只需要引入到我们的工程目录下并在显示驱动文件中调用即可</p>
<ol start="3">
<li>配置我们的输出缓冲区</li>
</ol>
<p>LVGL 的渲染流程是先将生成的图像存放在一个缓冲区中，然后通过硬件的显示驱动，将缓冲区中的数据显示到屏幕上。</p>
<p>LVGL 提供了三种不同的缓冲区类型，这里我们需要配置其中选择一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lv_port_disp_template.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lv_port_disp_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">/* Example for 1) */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span> draw_buf_dsc_1;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_color_t</span> buf_1[MY_DISP_HOR_RES * <span class="number">10</span>]; <span class="comment">/*A buffer for 10 rows*/</span></span><br><span class="line">    <span class="comment">/*Initialize the display buffer*/</span></span><br><span class="line">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_1, buf_1, <span class="literal">NULL</span>, MY_DISP_HOR_RES * <span class="number">10</span>);   </span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">     Example for 2) </span></span><br><span class="line"><span class="comment">    static lv_disp_draw_buf_t draw_buf_dsc_2;</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_2_1[MY_DISP_HOR_RES * 10];  // A buffer for 10 rows</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_2_2[MY_DISP_HOR_RES * 10];  // An other buffer for 10 rows</span></span><br><span class="line"><span class="comment">    // Initialize the display buffer</span></span><br><span class="line"><span class="comment">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_2, buf_2_1, buf_2_2, MY_DISP_HOR_RES * 10);   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // Example for 3) also set disp_drv.full_refresh = 1 below</span></span><br><span class="line"><span class="comment">    static lv_disp_draw_buf_t draw_buf_dsc_3;</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES]; // A screen sized buffer</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES]; //  Another screen sized buffer</span></span><br><span class="line"><span class="comment">     // Initialize the display buffer  </span></span><br><span class="line"><span class="comment">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_3, buf_3_1, buf_3_2,MY_DISP_VER_RES * LV_VER_RES_MAX);    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lv_port_disp_init 函数中包含了显示驱动和显示器绘图缓冲区的配置</p>
</blockquote>
<p><strong>在 disp_flush 函数中配置打点输出</strong></p>
<p>在配置完后，它会调用 disp_flush  这个函数将图形缓冲区中的内容正式的推送或者说刷新到屏幕上进行显示；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lv_port_disp_template.c</span></span><br><span class="line"><span class="comment">// 他的代码逻辑是这样的 如果需要刷新，那么将需要刷新的区域给我，（通过 x1,y1 和 x2, y2 确定）area</span></span><br><span class="line"><span class="comment">// 然后将你需要刷新到屏幕上的数据也就是缓冲区的地址给我 color_p</span></span><br><span class="line"><span class="comment">// 然后我们就可以调用屏幕驱动提供的代码将输入写入到屏幕中去了</span></span><br><span class="line"><span class="comment">// lv_disp_flush_ready 用于通知 LVGL 本次刷新已经完成，可以进行下一次绘制了</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="type">lv_disp_drv_t</span> * disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> * area, <span class="type">lv_color_t</span> * color_p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(disp_flush_enabled) &#123;</span><br><span class="line">        <span class="comment">/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/</span></span><br><span class="line">        <span class="type">int32_t</span> x;</span><br><span class="line">        <span class="type">int32_t</span> y;</span><br><span class="line">        <span class="keyword">for</span>(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) &#123;</span><br><span class="line">                <span class="comment">/*Put a pixel to the display. For example:*/</span></span><br><span class="line">                <span class="comment">/*put_px(x, y, *color_p)*/</span></span><br><span class="line">                color_p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*IMPORTANT!!!</span></span><br><span class="line"><span class="comment">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class="line">    lv_disp_flush_ready(disp_drv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 ST7789 提供了刷新屏幕的代码所以我们这里需要一下替换</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="type">lv_disp_drv_t</span> * disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> * area, <span class="type">lv_color_t</span> * color_p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(disp_flush_enabled) &#123;</span><br><span class="line">    	ST7789_Fill(area-&gt;x1,area-&gt;y1,area-&gt;x2,area-&gt;y2,(<span class="type">uint16_t</span>*)color_p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*IMPORTANT!!!</span></span><br><span class="line"><span class="comment">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class="line">    lv_disp_flush_ready(disp_drv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们需要在 LVGL 官方提供的输出模板中初始化我们屏幕的显示芯片，然后调用显示函数将 LVGL 生成的图像显示在我们的屏幕上；</p>
</blockquote>
<h4 id="触摸驱动"><a href="#触摸驱动" class="headerlink" title="触摸驱动"></a>触摸驱动</h4><p>配置触摸驱动与显示流程是一样的，区别在于文件换成了 lv_port_indev_template.h 和 lv_port_indev_template.c</p>
<p><strong>注释不必要的代码</strong></p>
<p>这里要注意的是，LVGL 支持多种输入方式，而我们硬件只支持触摸的方式，所以我们需要先将除了触摸意外的输如配置给删掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lv_port_indev_template.c</span></span><br><span class="line"><span class="comment">// 只保留触屏相关的代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_read</span><span class="params">(<span class="type">lv_indev_drv_t</span> * indev_drv, <span class="type">lv_indev_data_t</span> * data)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">touchpad_is_pressed</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_get_xy</span><span class="params">(<span class="type">lv_coord_t</span> * x, <span class="type">lv_coord_t</span> * y)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static void mouse_init(void);</span></span><br><span class="line"><span class="comment">static void mouse_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">static bool mouse_is_pressed(void);</span></span><br><span class="line"><span class="comment">static void mouse_get_xy(lv_coord_t * x, lv_coord_t * y);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void keypad_init(void);</span></span><br><span class="line"><span class="comment">static void keypad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">static uint32_t keypad_get_key(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void encoder_init(void);</span></span><br><span class="line"><span class="comment">static void encoder_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">static void encoder_handler(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void button_init(void);</span></span><br><span class="line"><span class="comment">static void button_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">static int8_t button_get_pressed_id(void);</span></span><br><span class="line"><span class="comment">static bool button_is_pressed(uint8_t id);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 删除上面不需要的具体的方法</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化驱动配置</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Initialize your touchpad*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">	CST816T_Init();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断屏幕是否被按下</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Return true is the touchpad is pressed*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">touchpad_is_pressed</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">		<span class="keyword">return</span> CST816T_is_pressed();</span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取被按下位置的坐标</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Get the x and y coordinates if the touchpad is pressed*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_get_xy</span><span class="params">(<span class="type">lv_coord_t</span> * x, <span class="type">lv_coord_t</span> * y)</span> &#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">	CST816T_get_xy((<span class="type">uint16_t</span>*)x,(<span class="type">uint16_t</span>*)y);</span><br><span class="line">    <span class="comment">//(*x) = 0;</span></span><br><span class="line">    <span class="comment">//(*y) = 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以通过触控芯片判断是否被按下和获取坐标，这里为什么还需要多此一举在封装一次呢？</p>
<p>1.规范化，LVGL 提供了一个统一的接口这样可以避免硬件之间的差异化，</p>
<p>2.LVGL 本身他也有一些事件的处理机制，如果我们直接通过触控芯片去判断是否有操作，那么就相当于绕过 LVGL 的事件处理机制，他不知道屏幕上有一些操作，也就会导致UI 元件的事件回调将无法被触发，我们需要手动触发，这样就太麻烦了；</p>
<p>LVGL 的事件处理机制是当他检测到有操作时候，会去执行对应的回调函数，然后等到 lv_timer_handler() 执行时就会将图像缓冲区的内容显示到屏幕上，如果绕过去，他就无法判断是否有操作，那么也就无法执行回调函数，那么他就会认为图像缓冲区中的内存没有改动，他也就不会将内容显示在屏幕上；</p>
</blockquote>
<h3 id="初始化-LVGL"><a href="#初始化-LVGL" class="headerlink" title="初始化 LVGL"></a>初始化 LVGL</h3><p>按照官方示例，初始化 LVGL 步骤如下：</p>
<ol>
<li><p>在系统执行早期通过调用初始化 LVGL 一次 lv_init()。这需要在进行任何其他 LVGL 调用之前完成。</p>
<p>lv_init();</p>
</li>
<li><p>初始化您的驱动程序。</p>
<p>lv_port_disp_init();、lv_port_indev_init();</p>
</li>
<li><p>连接 Tick 接口。</p>
<p>lv_tick_inc(1)</p>
</li>
<li><p>连接显示接口。</p>
</li>
<li><p>连接输入设备接口。</p>
</li>
<li><p>lv_timer_handler() 通过每隔几毫秒调用一次来管理 LVGL 计时器，从而驱动 LVGL 时间相关任务。请参阅计时器处理程序以了解执行此操作的不同方法。</p>
<p>lv_timer_handler()</p>
</li>
<li><p>可选择使用 来设置主题 lv_display_set_theme()。</p>
</li>
<li><p>此后，在需要使用 LVGL 函数的源文件中 #include “lvgl&#x2F;lvgl.h”。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    systick_config();</span><br><span class="line">	nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span><br><span class="line">	usart0_init();</span><br><span class="line">	</span><br><span class="line">	bsp_hard_iic_config();</span><br><span class="line">     <span class="comment">// 1. LVGL 初始化</span></span><br><span class="line">	lv_init();</span><br><span class="line">    <span class="comment">// 2. 驱动初始化</span></span><br><span class="line">	lv_port_disp_init();</span><br><span class="line">	lv_port_indev_init();</span><br><span class="line">	</span><br><span class="line">	ST7789_Test();	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;App_start...\n&quot;</span>);	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 6.调用回调函数</span></span><br><span class="line">			lv_timer_handler();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 3. 连接 Tick 接口</span></span><br><span class="line">		lv_tick_inc(<span class="number">1</span>);		</span><br><span class="line">		delay_1ms(<span class="number">1</span>);</span><br><span class="line">		count++;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.我们要使用 LVGL 图像库，必须要在使用前需要先初始化 LVGL，他会初始化其内部的数据结构和功能模块（例如，任务管理器、显示缓冲区管理等）。不初始化会导致后续的 LVGL 代码无法执行。</p>
<p>2.我们要将图像显示在屏幕上，并通过触屏去操控屏幕，所以需要初始化屏幕和触控的驱动，他会初始化显示缓冲区等。</p>
<p>3.连接 Tick 接口，因为 LVGL 有些任务是和时间挂钩的，他需要感知时间的流逝，他不像我们板子可以依靠晶振去计数时间，所以需要我们给他提供一个计数的方式（时基或者心跳）, lv_tick_inc(1) 中 1 表示 1ms 也就是说这个函数调用一次就表示过去了 1 ms，LVGL 通过这种函数调用的方式来进行计数；</p>
<p>4.连接显示接口，LVGL 只是一个图形库，它本身并不会直接操控屏幕；为了让 LVGL 能将绘制的内容显示到屏幕上，我们需要将使用的显示驱动添加或者说注册 LVGL 中，它会将一些配置，比如缓冲区的内容、屏幕像素的大小添加进 LVGL 中；这一步在初始化屏幕时候它会自动调用，我们通常不需要显示的去手动执行；lv_disp_drv_register(&amp;disp_drv);</p>
<p>5.连接输入设备接口同上，但要注意的是我们需要给输出设备提供一个回调函数用于处理 LVGL 返回的数据； </p>
<p>6.定期调用 lv_timer_handler() 函数，这个函数它会检查并执行所有定时器任务、动画任务，以及更新显示缓冲区并触发渲染；</p>
</blockquote>
<h2 id="移植到-FreeRTOS"><a href="#移植到-FreeRTOS" class="headerlink" title="移植到 FreeRTOS"></a>移植到 FreeRTOS</h2><p>移植到 FreeRTOS 就是在项目中同时导入 FreeRTOS 和 LVGL，然后将 LVGL 的时基和中断回调函数放在 FreeRTOS 的任务中去执行；</p>
<p><strong>修改 stm43fxxx.h 中 __NVIC_PRIO_BITS 的值</strong></p>
<p>将 __NVIC_PRIO_BITS 的值从 4U 改为 4；</p>
<p>__NVIC_PRIO_BITS 是一个宏，它定义了<strong>中断优先级字段的位数</strong>；FreeRTOS 会通过这个宏去适配 STM32 的优先级，让二者能够保持一致，而在 FreeRTOS 中类型（5 &lt;&lt; (8 - 4U)）这种写法他是不识别的，在以前的 ARM 编译器中他是不支持这种写法的，他会认为这是两种不同的类（常量类型和一种未定义的类型）他会认为这二者是不可以进行逻辑运算的所以我们需要修改这个宏将 4U 改为4</p>
<blockquote>
<p>在当前的版本中如果不报错一般可以不用进行修改，1 是在 STM32fxxx.h 中 __NVIC_PRIO_BITS 它被定义为了 4，二是在高版本的 ARM 编译器中，他已经可以识别 4U 这种写法并会去做一些优化；</p>
</blockquote>
<p><strong>在 lv_conf.h 文件中配置自定义时钟源</strong></p>
<p>在不用 FreeRTOS 之前我们是将 LVGL 的时基或者说心跳直接写在我们的main函数或者定时器中的，既然使用了 FreeRTOS 我们就需要将时基交给 FreeRTOS 去处理；</p>
<p>LVGL 提供了自定义时钟源的配置，可以让我们指定时基时从哪产生的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LV_TICK_CUSTOM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LV_TICK_CUSTOM</span></span><br><span class="line">	<span class="comment">// Header for the system time function</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_TICK_CUSTOM_INCLUDE <span class="string">&quot;FreeRTOS.h&quot;</span>         </span></span><br><span class="line">    <span class="comment">// Expression evaluating to current system time in ms</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_TICK_CUSTOM_SYS_TIME_EXPR (xTaskGetCount())    </span></span><br><span class="line">    <span class="comment">/*If using lvgl as ESP32 component*/</span></span><br><span class="line">    <span class="comment">// #define LV_TICK_CUSTOM_INCLUDE &quot;esp_timer.h&quot;</span></span><br><span class="line">    <span class="comment">// #define LV_TICK_CUSTOM_SYS_TIME_EXPR ((esp_timer_get_time() / 1000LL))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   <span class="comment">/*LV_TICK_CUSTOM*/</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>#define LV_TICK_CUSTOM 1，启用自定义时钟源</p>
<p>#if LV_TICK_CUSTOM，相当于一个开关，非 0 时执行下面的代码</p>
<p>#define LV_TICK_CUSTOM_INCLUDE “FreeRTOS.h”，定义一个宏指向 “FreeRTOS.h” 这个头文件，这个文件提供了 FreeRTOS 中的各种任务管理、调度器、时间管理等接口函数。</p>
<p>#define LV_TICK_CUSTOM_SYS_TIME_EXPR (xTaskGetCount())，指向了 xTaskGetCount()) 这个函数，该函数用于获取系统启动以来的 tick 数（时钟节拍次数），它相当于系统的 <strong>tick 计数器</strong>；每个 tick 通常是 1 毫秒（或更小，具体由 configTICK_RATE_HZ 配置决定）。</p>
</blockquote>
<p><strong>编写 FreeRTOS 任务函数进行 LVGL 任务调度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lv_Timer_task</span><span class="params">(<span class="type">void</span>* pvParameters)</span> &#123;</span><br><span class="line">    pvParameters = pvParameters;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        lv_timer_handler();</span><br><span class="line">        vTaskDelay(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个任务专门用于 LVGL 的任务调度，这样就成功将 FreeRTOS 与 LVGL 结合在一起了；</p>
<h2 id="外部-SRAM"><a href="#外部-SRAM" class="headerlink" title="外部 SRAM"></a>外部 SRAM</h2><p>外部 SRAM 是个硬件，当内部 SRAM 不足以存放所需的数据时，我们就需要外接一个 SRAM 用来提供额外的存储空间；</p>
<p>由于 LVGL 是一个图形库，涉及大量的界面渲染和控件更新，这些操作会消耗较多的内存。如果系统内部的 SRAM 不够用，尤其是在处理较大的 GUI 元素或图形时，外部 SRAM 就变得非常重要。</p>
<p>我们就正常把 SRAM 当成一个外设芯片，将他的驱动添加到我们的工程中去使用就可以了；</p>
<p><strong>使用</strong></p>
<ol>
<li><p>将 LVGL 管理的内存空间放到外部 SRAM 中（非常不推荐，因为速度会变慢）</p>
<ol>
<li>确定外部 SDRAM 首地址，根据需求确定地址偏移</li>
<li>在 lv_conf.h 中将 LV_MEN_ADR 定义到外部的 SRAM 中去（不一定是首地址）</li>
</ol>
</li>
<li><p>将 绘图缓冲区放到外部 SARM 中去（如果内存不够用时候可以采取）</p>
<ol>
<li>确定外部 SDRAM 首地址，根据需求确定地址偏移</li>
<li>在 lv_port_disp_template.c 中创建全屏分辨率大小的数组，并将其定位到外部 SRAM 的地址</li>
</ol>
</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="LVGL-内存报错"><a href="#LVGL-内存报错" class="headerlink" title="LVGL 内存报错"></a>LVGL 内存报错</h2><p>LVGL 本身渲染会占用一定的内存如果报错我们可以从以下几个角度去分析：</p>
<p>1.修改 lv_conf.h，适当减小分配给 LVGL 管理的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1: use custom malloc/free, 0: use the built-in `lv_mem_alloc()` and `lv_mem_free()`*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LV_MEM_CUSTOM 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LV_MEM_CUSTOM == 0</span></span><br><span class="line">    <span class="comment">/*Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB)*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_MEM_SIZE (48U * 1024U)          <span class="comment">/*[bytes]*/</span></span></span><br><span class="line">    <span class="comment">/*Set an address for the memory pool instead of allocating it as a normal array. Can be in external SRAM too.*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_MEM_ADR 0     <span class="comment">/*0: unused*/</span></span></span><br><span class="line">    <span class="comment">/*Instead of an address give a memory allocator that will be called to get a memory pool for LVGL. E.g. my_malloc*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> LV_MEM_ADR == 0</span></span><br><span class="line">        <span class="meta">#<span class="keyword">undef</span> LV_MEM_POOL_INCLUDE</span></span><br><span class="line">        <span class="meta">#<span class="keyword">undef</span> LV_MEM_POOL_ALLOC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>       <span class="comment">/*LV_MEM_CUSTOM*/</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_MEM_CUSTOM_INCLUDE <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">/*Header for the dynamic memory function*/</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_MEM_CUSTOM_ALLOC   malloc</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_MEM_CUSTOM_FREE    free</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_MEM_CUSTOM_REALLOC realloc</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>     <span class="comment">/*LV_MEM_CUSTOM*/</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>#define LV_MEM_CUSTOM 0 表示是使用自动内存管理的方式，我们不去动他；我们只需要修改  #define LV_MEM_SIZE (48U * 1024U) 定义的大小即可，要保证可以显示 LVGL 的所有小组件，但是又不能太大；可以试着一点一点去进行调试；</p>
</blockquote>
<p>2.lv_port_diso_timplate.c，适当减小图像缓冲区的大小，同时需要兼顾运行效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/* Example for 1) */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span> draw_buf_dsc_1;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_color_t</span> buf_1[MY_DISP_HOR_RES * <span class="number">10</span>]; <span class="comment">/*A buffer for 10 rows*/</span></span><br><span class="line">    <span class="comment">/*Initialize the display buffer*/</span></span><br><span class="line">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_1, buf_1, <span class="literal">NULL</span>, MY_DISP_HOR_RES * <span class="number">10</span>);   </span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">     Example for 2) </span></span><br><span class="line"><span class="comment">    static lv_disp_draw_buf_t draw_buf_dsc_2;</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_2_1[MY_DISP_HOR_RES * 10];  // A buffer for 10 rows</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_2_2[MY_DISP_HOR_RES * 10];  // An other buffer for 10 rows</span></span><br><span class="line"><span class="comment">    // Initialize the display buffer</span></span><br><span class="line"><span class="comment">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_2, buf_2_1, buf_2_2, MY_DISP_HOR_RES * 10);   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // Example for 3) also set disp_drv.full_refresh = 1 below</span></span><br><span class="line"><span class="comment">    static lv_disp_draw_buf_t draw_buf_dsc_3;</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES]; // A screen sized buffer</span></span><br><span class="line"><span class="comment">    static lv_color_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES]; //  Another screen sized buffer</span></span><br><span class="line"><span class="comment">     // Initialize the display buffer  </span></span><br><span class="line"><span class="comment">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_3, buf_3_1, buf_3_2,MY_DISP_VER_RES * LV_VER_RES_MAX);    </span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<p>这个空间越大，理论上运行的效果越好，我们尽量不是去给他调的太小；</p>
<p>3.FreeRTOSConfig.h，适当减小分配给 FreeRTOS 的内存，简单的工程一般 10~20k 就够了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 75 * 1024 ) ) <span class="comment">// 堆的大小，单位是字节</span></span></span><br></pre></td></tr></table></figure>

<p>这里设置减小但一般不要小于 10~20k;</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>一、**..&#x2F;Middleware&#x2F;LVGL&#x2F;src&#x2F;core..&#x2F;lv_conf_internal.h(41): error: ‘..&#x2F;..&#x2F;lv_conf.h’ file not found**</p>
<p>说明没有添加 lv_conf.h 头文件目录，添加即可；</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LVGL</tag>
      </tags>
  </entry>
  <entry>
    <title>基础控件</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Label-文本"><a href="#Label-文本" class="headerlink" title="Label 文本"></a>Label 文本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">first_screen</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// lv_scr_act() 获取当前的活动屏幕并返回   </span></span><br><span class="line">  <span class="type">lv_obj_t</span>* label = lv_label_create(lv_scr_act());</span><br><span class="line">  <span class="comment">// 设置 label 控件的长宽  </span></span><br><span class="line">  lv_obj_set_size(label,<span class="number">100</span>,<span class="number">80</span>);</span><br><span class="line">  <span class="comment">// 设置 label 元素的对齐方式 </span></span><br><span class="line">  lv_obj_set_align(label,LV_ALIGN_CENTER);</span><br><span class="line">  <span class="comment">// 设置 label 控件的文本值   </span></span><br><span class="line">  lv_label_set_text(label,<span class="string">&quot;Hello itheima&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">first_screen</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">// 创建按钮</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* btn = lv_btn_create(lv_scr_act());</span><br><span class="line">  <span class="comment">// 设置对齐方式，并允许你指定对齐的偏移量（x 和 y 偏移）  </span></span><br><span class="line">  lv_obj_align(btn,LV_ALIGN_CENTER,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 创建按钮上的文本</span></span><br><span class="line">  <span class="type">lv_obj_t</span>* label = lv_label_create(btn);</span><br><span class="line">  lv_label_set_text(label,<span class="string">&quot;button&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><h2 id="Button-Matrix"><a href="#Button-Matrix" class="headerlink" title="Button Matrix"></a>Button Matrix</h2><h2 id="Text-area-文本框"><a href="#Text-area-文本框" class="headerlink" title="Text area 文本框"></a>Text area 文本框</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/LVGL/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>LVGL</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%9D%A2%E8%AF%95%E9%A2%98/C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>一、<strong>C 语言中大小端的概念</strong></p>
<p>大小端是 CPU架构对于多数据存储的一种管理方式：</p>
<p>大端序中，数据的<strong>高字节存储在低地址</strong>，低字节存储在高地址。</p>
<p>小端序中，数据的<strong>低字节存储在低地址</strong>，高字节存储在高地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 0x12345678 为例</span></span><br><span class="line"><span class="comment">// 大端序</span></span><br><span class="line">地址:   <span class="number">0x00</span>    <span class="number">0x01</span>    <span class="number">0x02</span>    <span class="number">0x03</span></span><br><span class="line">数据:   <span class="number">0x12</span>    <span class="number">0x34</span>    <span class="number">0x56</span>    <span class="number">0x78</span></span><br><span class="line"><span class="comment">// 小端序</span></span><br><span class="line">地址:   <span class="number">0x00</span>    <span class="number">0x01</span>    <span class="number">0x02</span>    <span class="number">0x03</span></span><br><span class="line">数据:   <span class="number">0x78</span>    <span class="number">0x56</span>    <span class="number">0x34</span>    <span class="number">0x12</span>  </span><br></pre></td></tr></table></figure>

<p>二、<strong>static 关键字</strong></p>
<p>static 关键字用于修饰变量或函数，改变其生命周期、作用域和可见性。</p>
<ul>
<li>static 修饰的<strong>局部变量</strong>创建于全局数据区（拥有程序生命周期）</li>
<li>static 修饰的<strong>全局变量</strong>只有文件作用域（超出对应文件外无法访问，作用域被缩小了）</li>
<li>static <strong>局部变量只会初始化一次</strong>，作用域与普通变量无异</li>
</ul>
<p><strong>对于局部变量而言，static 只是改变了它的生命周期，其本身的作用域不变</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>BootLoader</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/BootLoader/</url>
    <content><![CDATA[<p>在嵌入式系统中，<strong>BootLoader（引导加载程序）</strong> 是系统上电后首先执行的程序，主要用于系统启动和固件升级。它的作用至关重要，既是系统的“启动引导者”，也是固件更新的重要保障。</p>
<h2 id="BootLoader-定义"><a href="#BootLoader-定义" class="headerlink" title="BootLoader 定义"></a>BootLoader 定义</h2><p>BootLoader 是一个运行在嵌入式设备上的小程序，位于系统的最底层，通常存储在 Flash 的特定区域。它的主要任务包括：</p>
<ol>
<li><strong>硬件初始化</strong>：配置时钟、存储器、引脚、外设等。</li>
<li><strong>加载主程序</strong>：将用户应用程序加载到 RAM 并跳转执行。</li>
<li><strong>固件升级</strong>：支持本地或无线方式的固件更新，如 UART、CAN、SPI、I2C 或 OTA（Over-The-Air）等。</li>
<li><strong>系统恢复</strong>：在系统主程序损坏时，可以引导恢复程序执行。</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>嵌入式设备在上电复位后，CPU 会从一个固定的地址开始执行程序（通常是 Flash 的 0x00000000 地址）。</p>
<ul>
<li>此时，BootLoader 程序首先运行，它会进行一系列初始化操作，并判断是否需要执行特殊任务（如固件升级）。</li>
<li>如果不需要升级，则跳转到主程序的入口地址，运行用户应用程序。</li>
</ul>
<p><strong>启动流程图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+---------------------------+  </span><br><span class="line">|    上电或复位             |  </span><br><span class="line">+---------------------------+  </span><br><span class="line">             ↓  </span><br><span class="line">+---------------------------+  </span><br><span class="line">|    CPU 执行 BootLoader    |  </span><br><span class="line">+---------------------------+  </span><br><span class="line">             ↓  </span><br><span class="line">| 是否进入升级模式？        |——— 是 —→ [ 进入升级模式 ]  </span><br><span class="line">             ↓ 否  </span><br><span class="line">+---------------------------+  </span><br><span class="line">|    初始化外设与硬件       |  </span><br><span class="line">+---------------------------+  </span><br><span class="line">             ↓  </span><br><span class="line">| 跳转到用户程序入口地址    |  </span><br><span class="line">             ↓  </span><br><span class="line">+---------------------------+  </span><br><span class="line">|      运行用户程序         |  </span><br><span class="line">+---------------------------+  </span><br></pre></td></tr></table></figure>

<h2 id="固件升级"><a href="#固件升级" class="headerlink" title="固件升级"></a>固件升级</h2><p>BootLoader 支持对系统固件进行升级，这在嵌入式开发中非常重要。例如：</p>
<ul>
<li><strong>本地升级</strong>：通过串口（UART）、USB、SD 卡等传输新固件。</li>
<li><strong>无线升级（OTA）</strong>：通过蓝牙、Wi-Fi 等通信方式远程传输固件。</li>
</ul>
<p><strong>实现步骤</strong></p>
<ol>
<li><strong>接收新固件</strong>：通过通信接口接收新固件数据（分包接收）。</li>
<li><strong>数据校验</strong>：对接收到的数据进行校验（如 CRC16 校验）以确保完整性。</li>
<li><strong>擦除 Flash 区域</strong>：擦除旧的程序存储区。</li>
<li><strong>写入新固件</strong>：将接收到的数据写入 Flash。</li>
<li><strong>重启执行新固件</strong>：升级完成后重启 MCU，BootLoader 跳转执行新程序。</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>OTA</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/OTA/</url>
    <content><![CDATA[<p>OTA（Over-The-Air）即“空中升级”，指通过无线通信（如蓝牙、Wi-Fi、蜂窝网络等）向设备发送数据包进行远程更新的一种技术。它可以用于更新设备的固件、软件应用程序或配置数据，无需通过物理接口（如 USB、JTAG）连接设备。这种技术广泛用于 IoT 设备、嵌入式系统、智能设备（如手表、家电）、汽车电子等领域。</p>
<h2 id="OTA-的核心概念"><a href="#OTA-的核心概念" class="headerlink" title="OTA 的核心概念"></a>OTA 的核心概念</h2><ol>
<li><strong>固件更新（Firmware Update）</strong><br>OTA 中最常见的用途是更新 MCU 的固件。固件是嵌入式设备运行的核心程序。通过 OTA 更新固件，可以修复漏洞、添加新功能或优化性能。</li>
<li><strong>增量更新（Delta Update）</strong><br>增量更新指只发送固件中修改的部分数据，而不是整个固件，从而减少传输数据量，提高更新效率。</li>
<li><strong>数据传输协议</strong><br>OTA 通常依赖蓝牙（如 BLE）、Wi-Fi（MQTT&#x2F;HTTP）、LoRa 或蜂窝网络。蓝牙设备常用 GATT 服务进行数据传输，而 Wi-Fi 设备则常用 HTTP 或自定义协议。</li>
<li><strong>可靠性保证</strong><br>为了确保 OTA 更新的可靠性，通常需要以下机制：<ul>
<li><strong>校验机制</strong>：通过校验和（Checksum）、CRC 或数字签名验证数据完整性和来源可信性。</li>
<li><strong>回滚机制</strong>：更新失败后，系统应能够恢复到之前的稳定版本。</li>
<li><strong>双分区机制</strong>：设备固件分为两个分区（Active&#x2F;Backup），更新时在备用分区写入新固件，测试成功后切换分区。</li>
</ul>
</li>
</ol>
<h2 id="OTA-升级的存储需求"><a href="#OTA-升级的存储需求" class="headerlink" title="OTA 升级的存储需求"></a>OTA 升级的存储需求</h2><p>为了实现 OTA 升级及回滚，典型的存储需求如下：</p>
<ol>
<li><strong>当前固件</strong>：即设备当前正在运行的固件。</li>
<li><strong>新固件</strong>：从上位机通过 OTA 下载的新固件。</li>
<li><strong>BootLoader</strong>：负责固件加载、升级验证以及回滚逻辑。</li>
<li><strong>元数据区域</strong>：OTA 升级标志位、固件版本信息、存储升级状态、校验信息（如 CRC32）等。</li>
</ol>
<p>如果 MCU 内部 Flash 空间不足，可以通过以下两种方式解决：</p>
<ul>
<li><strong>压缩升级固件</strong>（如使用差分升级）。</li>
<li><strong>使用外部 Flash</strong>（SPI Flash、NOR Flash 等）。</li>
</ul>
<h2 id="OTA-的实现流程"><a href="#OTA-的实现流程" class="headerlink" title="OTA 的实现流程"></a>OTA 的实现流程</h2><p>1.<strong>新固件存储到外部 Flash</strong></p>
<ul>
<li>在 OTA 数据接收阶段，通过蓝牙、Wi-Fi 等无线协议接收新固件，将其逐包写入外部 Flash 的指定存储区。</li>
<li>写入完成后，可以通过校验（如 CRC32、MD5）验证固件数据的完整性。</li>
<li>如果校验失败，可以删除这部分数据或通知上位机重新上传。</li>
<li>当新的固件下载完成后设置 OAT_Flag &#x3D; 1，表示固件准备好了。</li>
</ul>
<p>2.<strong>等待触发升级</strong></p>
<ul>
<li><strong>触发方式</strong>：升级可以通过多种方式触发，例如：<ul>
<li>按键触发：当用户按下特定按键（例如 UI 上的“升级”按钮或硬件按键）时，MCU 检查 OAT_Flag。如果标志位为 1，则进入 BootLoader 执行固件升级。</li>
<li>定时器触发：可以设置定时器，在设备空闲时自动检查 OAT_Flag。如果标志位为 1，则自动进入 BootLoader 执行升级流程。</li>
<li>外部指令触发：可以通过外部设备（如手机 App 或云端）发送指令，MCU 在接收到指令后检查 OAT_Flag，如果标志位为 1，则进入 BootLoader 执行固件升级。</li>
</ul>
</li>
<li>升级时机：<ul>
<li>选择在设备空闲时进行，避免正在运行的任务中断。</li>
<li>如果设备有低功耗模式，确保升级期间设备有足够的电量支持完成升级流程。</li>
</ul>
</li>
</ul>
<p>3.<strong>固件升级（BootLoader 阶段）</strong></p>
<ul>
<li>MCU 的 BootLoader 程序负责从外部 Flash 中读取新固件，并将其烧录到内部 Flash。</li>
<li>升级步骤如下：<ol>
<li>BootLoader 检测到 OAT_Flag 标志位为 1。</li>
<li>将外部 Flash 中存储的新固件逐页（Page）拷贝到 MCU 的内部 Flash。</li>
<li>拷贝完成后，通过固件校验机制（如再次校验 CRC32）验证固件是否完整无误。</li>
<li>如果验证通过，设置启动标志位，指向新固件所在地址，将 OAT_Flag 标志位为 0。</li>
<li>重启 MCU，运行新固件。</li>
</ol>
</li>
</ul>
<p>4.<strong>回滚机制</strong></p>
<ul>
<li>如果新固件启动失败或校验失败：<ol>
<li>BootLoader 将回滚到旧固件（通常存储在 Flash 的固定分区或另一个镜像中）。</li>
<li>设备恢复正常运行，避免完全不可用的情况。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>断点续传</strong></p>
<ul>
<li>MCU 需要跟踪已下载和写入的分片偏移地址，记录进度到非易失性存储（如内部 Flash 或 EEPROM）。</li>
<li>在断电或升级中断后，MCU 可以从上次中断的位置继续下载，而无需重新开始。</li>
</ul>
<p>CRC32 校验</p>
<ul>
<li><p><strong>CRC（Cyclic Redundancy Check，循环冗余校验）</strong> 是一种常用的数据校验算法，用于检测数据在传输或存储过程中是否发生错误。</p>
</li>
<li><p>CRC32</p>
<p> 是一种常见的 CRC 校验方法，产生一个 32 位的校验值（校验码），用于验证数据的完整性。</p>
<ul>
<li>输入：一段数据（比如 256 字节、4 KB 等）。</li>
<li>输出：一个 32 位校验值（通常表示为十六进制数）。</li>
</ul>
</li>
</ul>
<p>校验的核心思想是通过算法将一段数据压缩为一个固定长度的校验值。如果两次计算的校验值相同，则认为数据完整无误；否则说明数据有损坏。</p>
</blockquote>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="Flash-划分"><a href="#Flash-划分" class="headerlink" title="Flash 划分"></a>Flash 划分</h3><p><strong>内部 Flash</strong></p>
<table>
<thead>
<tr>
<th>区域</th>
<th>地址范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BootLoader</strong></td>
<td>固定区域，0x0000~0x3FFF</td>
<td>系统启动区，用于引导新旧固件运行和升级管理</td>
</tr>
<tr>
<td><strong>运行固件区</strong></td>
<td>0x4000~0xBFFF</td>
<td>当前正在运行的固件</td>
</tr>
</tbody></table>
<p><strong>外部 Flash</strong></p>
<table>
<thead>
<tr>
<th>区域</th>
<th>地址范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>运行固件区</strong></td>
<td>0x4000~0xBFFF</td>
<td>当前正在运行的固件（旧固件）</td>
</tr>
<tr>
<td><strong>备份固件区</strong></td>
<td>0xC000~0x13FFF</td>
<td>用于存储新固件，升级后切换到此区域</td>
</tr>
<tr>
<td><strong>配置区</strong></td>
<td>0x14000~0x14FFF</td>
<td>存储固件状态、版本信息、升级标志等元数据</td>
</tr>
</tbody></table>
<h3 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h3><p><strong>擦写外部 Flash</strong></p>
<ul>
<li>蓝牙模块通过 UART 向 MCU 发送数据。</li>
<li>MCU 将数据包解析后，写入外部 Flash 的固件存储区。</li>
<li>每写完一部分数据（比如一页），立即读取并校验，确保写入正确。</li>
<li>在写入完成后，保存校验信息（如 CRC32）到 Flash 的校验区。</li>
</ul>
<p><strong>擦写内部 Flash</strong></p>
<ul>
<li><p>将 BootLoader 的代码烧写到 BootLoader 区中</p>
</li>
<li><p>将运行代码烧录到运行固件区中</p>
</li>
<li><p>注意要将 BootLoader 放在前面，保证上电第一时间执行的是 BootLoader 中的代码</p>
</li>
</ul>
<h3 id="BootLoader-流程"><a href="#BootLoader-流程" class="headerlink" title="BootLoader 流程"></a>BootLoader 流程</h3><p>BootLoader 的主要工作是：</p>
<ul>
<li>判断是否需要进行升级：<ul>
<li>通过读取外部 Flash 的升级标志位，确认是否存在新的固件需要烧录。</li>
</ul>
</li>
<li>如果需要升级：<ul>
<li>读取外部 Flash 的固件校验信息，验证其完整性。</li>
<li>将新固件逐页写入 MCU 内部 Flash 的应用区。</li>
<li>写入完成后，修改升级标志位 OTA_Flag。</li>
</ul>
</li>
<li>如果不需要升级：<ul>
<li>设置栈指针（SP），指向运行区的地址</li>
<li>设置程序计数器 PC（Reset_Handler） 指向运行区中程序的地址</li>
<li>复位 B 区中使用的一些外设</li>
<li>跳转到 A 区开始执行</li>
</ul>
</li>
<li>如果升级失败：<ul>
<li>清除新固件的升级标志位。</li>
<li>回滚到旧固件，确保设备稳定运行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 Cortex-M 微控制器中，<strong>程序起始位置存储的内容是栈指针（SP）初始值，而不是程序的入口地址</strong>。程序入口地址存储在 <strong>起始位置 + 4 的地址</strong>中。这是 ARM Cortex-M 系列的芯片设计规定的一部分。</p>
</blockquote>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BootLoader.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BOOTLOADER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BOOTLOADER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootloader版本号 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BooTLoader_VERSION  <span class="string">&quot;0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备序号 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NO        1      <span class="comment">//根据设备名进行更改，定死写在bootloader中</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*=====用户配置(根据自己的分区进行配置)=====*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCU_FLASH 			0x80000U 						   <span class="comment">// MCU 的 Flash 大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCU_FALSH_ADDR		0x08000000U				   		   <span class="comment">// MCU 的 Flash 首地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BootLoader_SIZE		0x20000U						   <span class="comment">// BootLoader 的大小 128K</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Application_SIZE	(MCU_FLASH - BootLoader_SIZE) 	   <span class="comment">// 应用程序的大小 384K</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Application_1_Addr	(MCU_FALSH_ADDR + BootLoader_SIZE) <span class="comment">// 运行固件区的首地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKUP_ADDR =  <span class="comment">// 备份固件区的首地址，我们的备份固件存放在外部 Flash 中</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*==========================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动的步骤 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Startup_Normal 0xFFFFFFFF	<span class="comment">// 正常启动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Startup_Update 0xAAAAAAAA	<span class="comment">// 升级再启动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Startup_Reset  0x5555AAAA	<span class="comment">// ***恢复出厂 目前没使用***</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Start_BootLoader</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__BOOTLER_H_</span></span></span><br><span class="line">===========================================</span><br><span class="line"><span class="comment">// BootLoader.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bootloader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 串口重定向（需要开启Use MicroLIB）</span></span><br><span class="line"><span class="comment"> * @param ch  		发送的数据	</span></span><br><span class="line"><span class="comment"> * @param f         文件流</span></span><br><span class="line"><span class="comment"> * @return ch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> fputc(<span class="type">int</span> ch, FILE *f) &#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch,<span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取地址所在的 Flash 扇区</span></span><br><span class="line"><span class="comment"> * @param address 起始地址</span></span><br><span class="line"><span class="comment"> * @return 返回地址所在的 Flash 扇区编号，若地址无效则返回一个错误标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">Get_Sector</span><span class="params">(<span class="type">uint32_t</span> address)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查地址是否在有效的 Flash 区间内</span></span><br><span class="line">    <span class="keyword">if</span> (address &lt; FLASH_BASE || address &gt; FLASH_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_SECTOR;  <span class="comment">// 返回无效扇区标志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bank 1 扇区划分</span></span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x0802C000</span> &amp;&amp; address &lt; <span class="number">0x08030000</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08028000</span> &amp;&amp; address &lt; <span class="number">0x0802C000</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08024000</span> &amp;&amp; address &lt; <span class="number">0x08028000</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08020000</span> &amp;&amp; address &lt; <span class="number">0x08024000</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x0801C000</span> &amp;&amp; address &lt; <span class="number">0x08020000</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08018000</span> &amp;&amp; address &lt; <span class="number">0x0801C000</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08014000</span> &amp;&amp; address &lt; <span class="number">0x08018000</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08010000</span> &amp;&amp; address &lt; <span class="number">0x08014000</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x0800C000</span> &amp;&amp; address &lt; <span class="number">0x08010000</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08008000</span> &amp;&amp; address &lt; <span class="number">0x0800C000</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08004000</span> &amp;&amp; address &lt; <span class="number">0x08008000</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08000000</span> &amp;&amp; address &lt; <span class="number">0x08004000</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bank 2 扇区划分</span></span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08060000</span> &amp;&amp; address &lt; <span class="number">0x08064000</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08058000</span> &amp;&amp; address &lt; <span class="number">0x0805C000</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08054000</span> &amp;&amp; address &lt; <span class="number">0x08058000</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08050000</span> &amp;&amp; address &lt; <span class="number">0x08054000</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08048000</span> &amp;&amp; address &lt; <span class="number">0x0804C000</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08044000</span> &amp;&amp; address &lt; <span class="number">0x08048000</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08040000</span> &amp;&amp; address &lt; <span class="number">0x08044000</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x0803C000</span> &amp;&amp; address &lt; <span class="number">0x08040000</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08038000</span> &amp;&amp; address &lt; <span class="number">0x0803C000</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08034000</span> &amp;&amp; address &lt; <span class="number">0x08038000</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (address &gt;= <span class="number">0x08030000</span> &amp;&amp; address &lt; <span class="number">0x08034000</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INVALID_SECTOR;  <span class="comment">// 返回无效扇区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Flash擦除指定范围的扇区</span></span><br><span class="line"><span class="comment"> * @param start_addr 起始地址</span></span><br><span class="line"><span class="comment"> * @param end_addr   结束地址</span></span><br><span class="line"><span class="comment"> * @return 0 成功, 非0 失败，返回错误代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Flash_Erase_Sector</span><span class="params">(<span class="type">uint32_t</span> start_addr, <span class="type">uint32_t</span> end_addr)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> UserStartSector;</span><br><span class="line">    <span class="type">uint32_t</span> UserEndSector;</span><br><span class="line">    <span class="type">uint32_t</span> SectorError = <span class="number">0</span>;</span><br><span class="line">    FLASH_EraseInitTypeDef FlashSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁flash</span></span><br><span class="line">    HAL_FLASH_Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取起始地址和结束地址的扇区号</span></span><br><span class="line">    UserStartSector = Get_Sector(start_addr);</span><br><span class="line">    UserEndSector = Get_Sector(end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保起始扇区不大于结束扇区</span></span><br><span class="line">    <span class="keyword">if</span> (UserStartSector &gt; UserEndSector) &#123;</span><br><span class="line">        HAL_FLASH_Lock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 错误：起始扇区大于结束扇区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置擦除参数</span></span><br><span class="line">    FlashSet.TypeErase = TYPEERASE_SECTORS;</span><br><span class="line">    FlashSet.Sector = UserStartSector;</span><br><span class="line">    FlashSet.NbSectors = UserEndSector - UserStartSector + <span class="number">1</span>;</span><br><span class="line">    FlashSet.VoltageRange = VOLTAGE_RANGE_3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用擦除函数</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_FLASHEx_Erase(&amp;FlashSet, &amp;SectorError) != HAL_OK) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        HAL_FLASH_Lock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// 错误：擦除操作失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定flash</span></span><br><span class="line">    HAL_FLASH_Lock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Flash写若干个数据（word）</span></span><br><span class="line"><span class="comment"> * @param addr       写入的地址</span></span><br><span class="line"><span class="comment"> * @param buf        写入数据的起始地址</span></span><br><span class="line"><span class="comment"> * @param word_size  数据的单词数量</span></span><br><span class="line"><span class="comment"> * @return 0 成功，其他值表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Flash_Write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> *buf, <span class="type">uint32_t</span> word_size)</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁 flash</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_FLASH_Unlock() != HAL_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 解锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word_size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, addr + <span class="number">4</span> * i, buf[i]) != HAL_OK) &#123;</span><br><span class="line">            HAL_FLASH_Lock(); <span class="comment">// 写入失败后锁定 Flash</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// 写入失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定 flash</span></span><br><span class="line">    HAL_FLASH_Lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief flash读若干个数据(word)</span></span><br><span class="line"><span class="comment"> * @param addr       读数据的地址</span></span><br><span class="line"><span class="comment"> * @param buf        读出数据的数组指针</span></span><br><span class="line"><span class="comment"> * @param word_size  长度</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">Flash_Read</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> *buf,<span class="type">uint32_t</span> word_size)</span> &#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(buf, (<span class="type">uint32_t</span>*) addr, word_size * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  将固件从源地址拷贝到目标地址</span></span><br><span class="line"><span class="comment"> * @param  src_addr   源地址</span></span><br><span class="line"><span class="comment"> * @param  des_addr   目标地址</span></span><br><span class="line"><span class="comment"> * @param  byte_size  拷贝的字节大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Flash_CopyFirmware</span><span class="params">(<span class="type">uint32_t</span> src_addr, <span class="type">uint32_t</span> des_addr, <span class="type">uint32_t</span> byte_size)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt; Starting firmware copy...\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除目的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Erasing destination flash (0x%X - 0x%X)...\r\n&quot;</span>, des_addr, des_addr + byte_size - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// FLASH_SUCCESS 表示擦除成功</span></span><br><span class="line">    <span class="keyword">if</span> (Flash_Erase_Sector(des_addr, des_addr + byte_size - <span class="number">1</span>) != FLASH_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Failed to erase destination flash!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Destination flash erased successfully.\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配临时缓冲区</span></span><br><span class="line">	<span class="comment">// Flash 通常不可以同时进行读写操作，所以要使用一个缓冲区进行过度</span></span><br><span class="line">	<span class="comment">// 为了适配同一个 Flash 的操作</span></span><br><span class="line">    <span class="type">uint8_t</span> *buffer = (<span class="type">uint8_t</span> *)<span class="built_in">calloc</span>(<span class="number">256</span>, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Memory allocation failed!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始拷贝</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copying firmware from 0x%X to 0x%X, total size: %d bytes.\r\n&quot;</span>, src_addr, des_addr, byte_size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> offset = <span class="number">0</span>; offset &lt; byte_size; offset += <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Flash_Read(src_addr + offset, buffer, <span class="number">256</span>) != FLASH_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error: Flash read failed at 0x%X!\r\n&quot;</span>, src_addr + offset);</span><br><span class="line">            <span class="built_in">free</span>(buffer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Flash_Write(des_addr + offset, buffer, <span class="number">256</span>) != FLASH_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error: Flash write failed at 0x%X!\r\n&quot;</span>, des_addr + offset);</span><br><span class="line">            <span class="built_in">free</span>(buffer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Copied %d KB...\r\n&quot;</span>, (offset + <span class="number">1024</span>) / <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Firmware copy completed successfully.\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 采用汇编设置栈的值</span></span><br><span class="line"><span class="comment"> * @param  ulAddr	地址</span></span><br><span class="line"><span class="comment"> * @return NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">MSR_MSP</span><span class="params">(<span class="type">uint32_t</span> ulAddr)</span> &#123;</span><br><span class="line">    MSR MSP, r0</span><br><span class="line">    BX r14</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*Jump_Fun)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 程序跳转函数</span></span><br><span class="line"><span class="comment"> * @param  App_Addr 应用程序地址</span></span><br><span class="line"><span class="comment"> * @return NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">JumpToApplication</span><span class="params">(<span class="type">uint32_t</span> App_Addr)</span> &#123;</span><br><span class="line">    Jump_Fun JumpToApp;</span><br><span class="line">    <span class="type">uint32_t</span> reset_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查应用程序的栈顶地址是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (((*(__IO <span class="type">uint32_t</span> *) App_Addr) &amp; <span class="number">0x2FFE0000</span>) == <span class="number">0x20000000</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取复位处理函数地址</span></span><br><span class="line">        reset_handler = *(__IO <span class="type">uint32_t</span> *)(App_Addr + <span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果复位地址无效，打印错误信息并退出</span></span><br><span class="line">        <span class="keyword">if</span> (reset_handler == <span class="number">0xFFFFFFFF</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Reset Handler at address: %08X\n&quot;</span>, App_Addr + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置应用程序的栈顶地址</span></span><br><span class="line">        MSR_MSP(*(__IO <span class="type">uint32_t</span> *) App_Addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用所有中断，清除中断标志</span></span><br><span class="line">        __disable_irq();  <span class="comment">// 直接使用 CMSIS 的宏来禁用中断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：如果时钟配置需要重置，可以选择调用 HAL_RCC_DeInit()</span></span><br><span class="line">        <span class="comment">// 如果需要保留时钟配置，跳过这一步</span></span><br><span class="line">        HAL_RCC_DeInit();</span><br><span class="line">        SysTick-&gt;CTRL = <span class="number">0</span>;</span><br><span class="line">        SysTick-&gt;LOAD = <span class="number">0</span>;</span><br><span class="line">        SysTick-&gt;VAL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳转到应用程序的复位处理函数</span></span><br><span class="line">        JumpToApp = (Jump_Fun)reset_handler;</span><br><span class="line">        <span class="keyword">if</span> (JumpToApp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            JumpToApp();  <span class="comment">// 执行跳转</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid JumpToApp function!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Stack Pointer address! (Address: %08X)\n&quot;</span>, App_Addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 进行BootLoader的启动</span></span><br><span class="line"><span class="comment"> * @param NULL</span></span><br><span class="line"><span class="comment"> * @return NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Start_BootLoader</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* Bootloader 信息打印 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Bootloader %s %s\r\n&quot;</span>,__DATE__,__TIME__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Bootloader Version %s\r\n&quot;</span>,BooTLoader_VERSION);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device Name: D%d\r\n&quot;</span>,DEVICE_NO);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MCU: STM32F407ZGT6 Running at 168MHz\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Bootloader Area from %#x - %#x\r\n&quot;</span>,MCU_FALSH_ADDR,APPLICATION_ADDR - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Application_1 Area from %#x - %#x\r\n&quot;</span>,APPLICATION_ADDR,APPLICATION_ADDR + Application_SIZE <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先读取外部 Flash 中的 OTA_Flag 标志位判断是否需要升级</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(OTA.OTA_Flag) &#123;</span><br><span class="line">		<span class="comment">// 更新固件</span></span><br><span class="line">		<span class="comment">// 修改 OTA_Flag 标志位</span></span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 跳转到 A 区执行代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 跳转到应用程序 */</span></span><br><span class="line">	__disable_irq(); 	<span class="comment">//关闭中断</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;=&gt; Start Application_1......\r\n\r\n&quot;</span>);	</span><br><span class="line">	JumpToApplication(APPLICATION_ADDR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你的 MCU 的内部 Flash 已经可以存放完整的固件，并且足以支持所有应用功能，那么也可以考虑以下优化方案：</p>
<ul>
<li>将运行固件完全存储在 MCU 的内部 Flash 中，避免对外部 Flash 的依赖。</li>
<li>外部 Flash 仅用于存储备份固件或临时数据。</li>
<li>通过 BootLoader 动态加载外部 Flash 中的新固件到内部 Flash，完成固件更新。</li>
</ul>
<p>这种方法的优点是：</p>
<ul>
<li><strong>启动速度更快：</strong> 固件直接从内部 Flash 加载，无需访问外存。</li>
<li><strong>功耗更低：</strong> 外部 Flash 的读取会增加系统功耗，尤其是在频繁启动的场景下。</li>
<li><strong>更高的可靠性：</strong> 外部 Flash 的稳定性可能不如内部 Flash（如受电源波动或环境温度影响）。</li>
</ul>
<p>二、<strong>什么时候更新外部 Flash 代码</strong></p>
<p>什么时候将外部 Flash 中<strong>备份固件区</strong>的代码更新到<strong>运行固件区</strong>：</p>
<p>OAT_flag &#x3D; 0；表示当前不需要进行固件升级，执行的固件是最新的</p>
<p>运行固件区与备份固件区的代码版本不一致；不一致就执行更新，一致就说明不需要更新；</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>bevy基础</title>
    <url>/game/rust/Bevy/bevy%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Bevy-基础"><a href="#Bevy-基础" class="headerlink" title="Bevy 基础"></a>Bevy 基础</h1><h2 id="Bevy设置"><a href="#Bevy设置" class="headerlink" title="Bevy设置"></a>Bevy设置</h2><h3 id="加快编译优化"><a href="#加快编译优化" class="headerlink" title="加快编译优化"></a>加快编译优化</h3><p>在<code>Cargo.toml</code>或<code>.cargo/config.toml</code>:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对依赖项启用最大优化，但不对我们的代码启用最大优化：</span></span><br><span class="line"><span class="section">[profile.dev.package.&quot;*&quot;]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调试/开发模式下仅启用少量优化</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际发布模式下最积极的优化配置：</span></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span> <span class="comment"># 设置为 true 时编译器会进行链接时间优化，但会增加编译时间。</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span> <span class="comment"># 设置优化级别为最高。</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span> <span class="comment"># 控制了代码生成的单元数量。当设置为 1 时，整个 crate 会被编译成一个单独的代码生成单元。</span></span><br><span class="line"><span class="attr">incremental</span> = <span class="literal">false</span> <span class="comment"># 不启用增量编译：增量编译允许 Cargo 只重新编译自上次构建以来已更改的文件和依赖项，从而加快编译速度。</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">false</span> <span class="comment"># 当设置为false时，编译器不会生成调试信息。</span></span><br></pre></td></tr></table></figure>

<p><strong>警告！</strong>如果您使用调试器（如<code>gdb</code>或<code>lldb</code>）来逐步执行代码，任何程度的编译器优化都会影响体验。您的断点可能会被跳过，并且代码流可能会以意想不到的方式跳来跳去。如果您想调试&#x2F;逐步执行代码，您可能需要 <code>opt-level = 0</code>。</p>
<h3 id="加速-Rust-Analyzer"><a href="#加速-Rust-Analyzer" class="headerlink" title="加速 Rust-Analyzer"></a>加速 Rust-Analyzer</h3><p><em>Powershell</em> 中键入 <strong>rustup shwo</strong> 来显示你的Rust构建工具链</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\cnkay&gt; rustup show</span><br><span class="line">Default host: x86_64<span class="literal">-pc-windows-msvc</span></span><br><span class="line">rustup home:  D:\tools\SDK\rust\.rustup</span><br><span class="line"></span><br><span class="line">stable<span class="literal">-x86_64-pc-windows-msvc</span> (default)</span><br><span class="line">rustc <span class="number">1.78</span>.<span class="number">0</span> (<span class="number">9</span>b00956e5 <span class="number">2024</span><span class="literal">-04-29</span>)</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 <em>MSVC</em> 工具链那么连接器是<code>link.exe</code>。</p>
<p>为了实现快速编译，需要设置非默认链接器。在 <em>VSCode</em> 中设置<code>settings.json</code> 添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Windows<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=rust-lld.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Linux(mold)<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=clang -Clink-arg=-fuse-ld=mold&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Linux (lld)<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=clang -Clink-arg=-fuse-ld=lld&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CI设置"><a href="#CI设置" class="headerlink" title="CI设置"></a>CI设置</h2><p><code>CI</code>是<strong>GitHub Actions</strong>的简称</p>
<h2 id="ECS-模式"><a href="#ECS-模式" class="headerlink" title="ECS 模式"></a>ECS 模式</h2><p>ECS 是*实体(Entity)<em>、</em>组件(Component)<em>、</em>系统(System)*的简称，是一种将<strong>数据</strong>和<strong>行为</strong>分开的编程范式。</p>
<p><strong>系统(System)</strong></p>
<p>系统是处理实体和组件的逻辑单元，负责执行特定的功能或行为。</p>
<p>系统是基于组件的存在于否，以及它们的状态来执行逻辑单元。</p>
<p>系统通常是独立于特定实体的，可以处理多个具有相似组件结构的实体。</p>
<p><strong>实体(Entity)</strong></p>
<p>实体是系统中的基本对象，可以是游戏中的角色、物体或者其他有意义的实体。</p>
<p>实体本身通常只是一个标识符，没有行为或状态。</p>
<p><strong>组件(Component)</strong></p>
<p>组件是实体的属性或数据单元，描述了实体的特征和状态。</p>
<p>不同的组件可以包含不同类型的数据，例如位置、渲染信息、健康状态等。</p>
<p>一个实体可以关联多个组件，组件之间是相互独立的。</p>
<p><strong>总结</strong></p>
<p><strong>实体只是指向组件的唯一ID或引用，本质上他将所有的组件连接在一起，构成游戏中的单个对象。</strong></p>
<p><strong>组件只是存粹的数据结构，如坦克对象的大小和速度。</strong></p>
<p><strong>系统只是对具有特定组件功能的实体进行操作的功能。</strong></p>
<p>在Bevy中<strong>实体(Entity)</strong> 是指向一群<strong>组件(Component)</strong> 的唯一 <strong>事物(things)</strong>, 然后使用 <strong>系统(System)</strong> 处理其过程.</p>
<p>例如，一个实体可能有<code>位置(Position)</code>和<code>速度(Velocity)</code>组件，而另一个实体可能有<code>位置(Position)</code>和<code>UI</code>组件。系统是在一组特定组件上运行的逻辑， 你可能有一个运行在所有带有<code>位置(Position)</code>和<code>速度(Velocity)</code>组件的实体上的<code>移动</code>系统。</p>
<h2 id="ECS-中的数据"><a href="#ECS-中的数据" class="headerlink" title="ECS 中的数据"></a>ECS 中的数据</h2><h3 id="World"><a href="#World" class="headerlink" title="World"></a>World</h3><p>定义：<em>World</em>是<strong>系统</strong>和<strong>实体</strong>的集合。在<code>ECS</code>架构中，<em>World</em>是最高级别的组织单位，它包含了<strong>游戏中的所有实体（Entity）以及处理这些实体的系统（System）</strong>。</p>
<p>当程序启动时，默认会生成一个World,可以存在多个World对象。</p>
<h3 id="Entities-Components"><a href="#Entities-Components" class="headerlink" title="Entities&#x2F;Components"></a>Entities&#x2F;Components</h3><p>概念上类似于在数据库或电子表格。</p>
<p>每一行数据就是一个对象，<code>(Entity)</code>与<code>ID</code>或者行号类似，<code>(Components)</code>类似于 表的<em>列</em>，可以有任意多个<em>行</em>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体</span></span><br><span class="line"><span class="meta">#[derive(Component)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Xp</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="meta">#[derive(Component)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Health</span> &#123;</span><br><span class="line">    current: <span class="type">u32</span>,</span><br><span class="line">    max: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">level_up</span>(<span class="keyword">mut</span> query: Query&lt;(&amp;<span class="keyword">mut</span> Xp, &amp;<span class="keyword">mut</span> Health)&gt;,) &#123;</span><br><span class="line">    <span class="comment">// process all relevant entities</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">mut</span> xp, <span class="keyword">mut</span> health) <span class="keyword">in</span> query.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> xp.<span class="number">0</span> &gt; <span class="number">1000</span> &#123;</span><br><span class="line">            xp.<span class="number">0</span> -= <span class="number">1000</span>;</span><br><span class="line">            health.max += <span class="number">25</span>;</span><br><span class="line">            health.current = health.max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>如果某物只有一个全局实例（单例），并且它是独立（不与其他数据关联），那么你就可以创建一个<code>Resources</code></p>
<p>例如，您可以创建一个资源来存储游戏的图形 设置，或指向非 Bevy 库的接口。</p>
<p>这是一种存储数据的简单方法，当你不需要<code>实体/组件</code>的灵活性的时候。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Resource)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameSettings</span> &#123;</span><br><span class="line">    current_level: <span class="type">u32</span>,</span><br><span class="line">    difficulty: <span class="type">u32</span>,</span><br><span class="line">    max_time_seconds: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">setup_game</span>(</span><br><span class="line">    <span class="keyword">mut</span> commands: Commands,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Add the GameSettings resource to the ECS</span></span><br><span class="line">    <span class="comment">// (if one already exists, it will be overwritten)</span></span><br><span class="line">    commands.<span class="title function_ invoke__">insert_resource</span>(GameSettings &#123;</span><br><span class="line">        current_level: <span class="number">1</span>,</span><br><span class="line">        difficulty: <span class="number">100</span>,</span><br><span class="line">        max_time_seconds: <span class="number">60</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">spawn_extra_enemies</span>(</span><br><span class="line">    <span class="keyword">mut</span> commands: Commands,</span><br><span class="line">    <span class="comment">// we can easily access our resource from any system</span></span><br><span class="line">    game_settings: Res&lt;GameSettings&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> game_settings.difficulty &gt; <span class="number">50</span> &#123;</span><br><span class="line">        commands.<span class="title function_ invoke__">spawn</span>((</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>bevy</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/ADC/</url>
    <content><![CDATA[<p>ADC(Analog to Digital Converter 模数转换器）是一种将<strong>模拟信号转换为数字信号</strong>的<strong>电路</strong>。在电子系统中，模拟信号常常需要转换为数字信号进行处理和存储。模数转换的基本原理是将模拟信号进行<strong>采样</strong>，并将采样值<strong>量化</strong>为数字表示。</p>
<ul>
<li>采样：是指在一定时间间隔内对模拟信号进行测量，并将测量值存储在数字形式的数据中</li>
<li>量化：是将这些连续的模拟信号值离散化为一系列数字值，通常使用二进制表示。</li>
</ul>
<p>简单理解，<strong>ADC是把模拟信号转换为数字信号的工具</strong>，我们可以认为，一个信号有强弱之分，强弱的体现为电压的高低。在数字电路中，只有0和1之分，也就是高电平或低电平。那么体现不了这个强弱。ADC的作用就是体现强弱，精确化的拿到具体的值。</p>
<p>只有那些在硬件设计中具备 ADC 模块连接的引脚才能执行模数转换操作。</p>
<p>ADC（模数转换器）采样获取的是<strong>电压值</strong>。</p>
<p><strong>ADC 转换流程图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuanliuchengtu.png" alt="ADCzhuanhuanliuchengtu"></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H 芯片有 15 个通道的 ADC 功能引脚</p>
<p>通过控制滑动变阻器，来观察电压变化。</p>
<p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/dianweiqiyinjiaotu.png" alt="dianweiqiyinjiaotu"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到引脚需要配置 GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ADC引脚</span></span><br><span class="line">     GPIO_Init.Mode = GPIO_HighZ;</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_5</span><br><span class="line">    GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);</span><br><span class="line">    <span class="comment">// UART 引脚</span></span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要用到 UART 查看数值输出也要配置 UART</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">    UART_Init.UART_BaudRate = <span class="number">115200ul</span>;</span><br><span class="line">    UART_Init.Morecommunicate = DISABLE; </span><br><span class="line">    UART_Init.UART_RxEnable = ENABLE;</span><br><span class="line">    UART_Init.BaudRateDouble = DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UART 必须要通过中断，故要设置下开启中断，并设置中断优先级</span></span><br><span class="line">    NVIC_UART1_Init(ENABLE, Priority_1);</span><br><span class="line">    <span class="comment">// 引脚选择</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到 ADC 需要配置ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC_INitTypeDef ADC_Init;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ADC 模拟信号采样时间控制, 0~31（注意： SMPDUTY 一定不能设置小于 10）</span></span><br><span class="line">    ADC_Init.ADC_SMPduty = <span class="number">31</span>; </span><br><span class="line">    <span class="comment">// 设置 ADC 工作时钟频率 ADC_SPEED_2X1T~ADC_SPEED_2X16T</span></span><br><span class="line">    <span class="comment">// 可以理解为 ADC 采样的频率或者说次数，一秒钟采样多少次</span></span><br><span class="line">    ADC_Init.ADC_Speed = ADC_SPEED_2X1T;</span><br><span class="line">    <span class="comment">// ADC结果调整,	ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIFIED</span></span><br><span class="line">    ADC_Init.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;</span><br><span class="line">    <span class="comment">//ADC 通道选择时间控制 0(默认),1</span></span><br><span class="line">    ADC_Init.ADC_CsSetup = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ADC 通道选择保持时间控制 0,1(默认),2,3</span></span><br><span class="line">    ADC_Init.ADC_CsHold = <span class="number">1</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ADC_Inilize(&amp;ADC_Init);</span><br><span class="line">    <span class="comment">//中断使能,</span></span><br><span class="line">    NVIC_ADC_Init(DISABLE,Priority_0);		</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ADC 电源控制 ENABLE或DISABLE.</span></span><br><span class="line">    ADC_PowerControl(ENABLE);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> adc_v = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 中断总控</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    GPIO_Config();</span><br><span class="line">    UART_Config();</span><br><span class="line">    ADC_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 查询一次ADC转换结果. 得到的是一个数值</span></span><br><span class="line">        <span class="comment">// ADC_CH13 是我们所使用的引脚，也就是硬件连接的引脚</span></span><br><span class="line">        u16 adc_result = Get_ADCResult(ADC_CH13)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;adc_result = %d&quot;</span>, adc_result);</span><br><span class="line">        </span><br><span class="line">        adc_v = adc_result * <span class="number">2.5</span> / <span class="number">4096</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;adc_v = %d&quot;</span>, adc_v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>什么是模拟信号采样控制时间</strong></p>
<p>这里的“采样时间控制”指的是 ADC 在开始转换之前对输入的模拟信号进行采样的时间长短。</p>
<p>具体来说，采样时间是指 ADC 在转换开始前，<strong>输入模拟信号与内部采样电容相连的时间</strong>。采样时间的长短会影响采样电容对输入信号充电的充分程度。如果采样时间太短，采样电容无法完全充电，导致输入信号没有被准确读取，从而影响 ADC 转换后的数值精度。</p>
<p>在 STC8H 的 ADC 模块中，采样时间可以通过软件配置</p>
<p>二、<strong>什么是ADC结果调整</strong></p>
<p>就是 AD 转换结果对齐方式 设置ADC 转换的结果是左对齐还是右对齐，因为 STC8H 系列的单片机内部分别集成了一个 10 &#x2F; 12 位高速 A&#x2F;D 转换器；</p>
<p>ADC 转换结果的数据格式有两种，左对齐和右对齐。可以方便用户进行读取；</p>
<p>在 STC8H 系列中 STC8H1K28、STC8H1K08 是10 位高速 A&#x2F;D 转换器，其他都是 12位的</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuankongzhi.png" alt="ADCzhuanhuankongzhi"></p>
<p>三、<strong>什么是通道选择时间</strong></p>
<p>见下图</p>
<p>四、<strong>什么是通道选择保持时间控制</strong></p>
<p>见下图</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuanshijian.png" alt="ADCzhuanhuanshijian"></p>
<p>五、<strong>12位 ADC 采样计算中，2 的十二次方最大时 4095，为何我们在换算时通常是除以 4096</strong></p>
<p>12 位的寄存器用来存储采样数值，那么这种情况下 12 位全零的状态也应该作为一个采样数值，即 寄存器最大值+1</p>
<p>12位 ADC 的 ADCn 通道的输入电压 &#x3D; 采样数值 &#x2F; 4096 * ADC_VRef 是正解;</p>
<p>六、<strong>ADC 中也有中断，它的使用场景是什么</strong></p>
<p>ADC 中断是在 <strong>模数转换完成后</strong> 自动触发的。当 ADC 完成了一次从模拟信号到数字信号的转换时，系统会自动生成一个中断请求（ADC 中断标志位被置位），通知处理器模数转换已经完成，可以读取转换结果。</p>
<p>七、<strong>为何在计算时用到的是 2.5v 进行计算，而不是 Vcc 提供的 3.3V</strong></p>
<p>在电路电位器设计中接入了一个芯片 CJ431&#x2F;CD431，这是一款电压基准芯片，会恒定的输出 2.5V 电压。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>EEPROM读写</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/EEPROM%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<p><strong>EEPROM</strong>（<strong>Electrically Erasable Programmable Read-Only Memory</strong>，电可擦除可编程只读存储器）是一种<strong>非易失性存储器</strong>，可以在<strong>掉电后仍保留数据</strong>。它允许<strong>单字节</strong>或<strong>多字节</strong>的数据被擦除和重新写入，而不需要整个芯片被擦除。嵌入式系统、微控制器以及各种电子设备中常使用 EEPROM 来存储需要在掉电后保留的数据，比如用户配置、校准参数等。</p>
<p><strong>ISP（In-System Programming）</strong></p>
<p>ISP，即在系统编，是一种允许开发者在目标系统（如电路板）上直接对芯片进行编程的技术。这意味着开发者无需将芯片从电路板上取下，即可通过特定的接口（如串口、JTAG、SPI等）将程序代码烧录到芯片内部的 Flash 存储器中。</p>
<p><strong>IAP（In-Application Programming）</strong></p>
<p>IAP，即在应用编程，是一种允许在应用程序运行时对芯片内部存储器进行编程或更新的技术。与 ISP 不同，IAP 通常需要在芯片内部划分出特定的存储区域（如引导区、运行程序区和下载区），并在应用程序中集成相应的编程逻辑。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>官方文档介绍</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ROMguanfangwendangjieshao.png" alt="ROMguanfangwendangjieshao"></p>
<p><strong>官方文档内部结构图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ROMjiegoutu.png" alt="ROMjiegoutu"></p>
<p>STC8 系列单片机中都包含有 Flash 数据存储器（EEPROM）。以字节为单位进行读&#x2F;写数据，以 512 字节为页单位进行擦除，可在线反复编程擦写 10 万次以上，提高了使用的灵活性和方便性。</p>
<p><strong>数据存储器</strong></p>
<p>STC8H系列单片机内部集成的RAM可用于存放程序执行的中间结果和过程数据。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/shujucunchuqi.png" alt="shujucunchuqi.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读写 String 字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EEPROM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// &gt;&gt;&gt; 记得添加 NVIC.c, UART.c, UART_Isr.c &lt;&lt;&lt;</span></span><br><span class="line">    COMx_InitDefine		COMx_InitStructure;					<span class="comment">//结构定义</span></span><br><span class="line">    COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;	<span class="comment">//模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;			<span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    COMx_InitStructure.UART_BaudRate  = <span class="number">115200ul</span>;			<span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    COMx_InitStructure.UART_RxEnable  = ENABLE;				<span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    COMx_InitStructure.BaudRateDouble = DISABLE;			<span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_InitStructure);		<span class="comment">//初始化串口1 UART1,UART2,UART3,UART4</span></span><br><span class="line"></span><br><span class="line">    NVIC_UART1_Init(ENABLE,Priority_1);		<span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);		<span class="comment">// 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Max_Length          100      <span class="comment">//读写EEPROM缓冲长度</span></span></span><br><span class="line">u8  xdata   tmp[Max_Length];        <span class="comment">//EEPROM操作缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    u16 addr_sector = <span class="number">0x0000</span>;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;HelloWorld!abc123!&quot;</span>;</span><br><span class="line">    u16 str_length = <span class="built_in">strlen</span>(str);	<span class="comment">// 获取str的长度</span></span><br><span class="line"></span><br><span class="line">    UART_config();</span><br><span class="line">		</span><br><span class="line">		EA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 擦除扇区, 一次性擦除一个扇区512字节, 从0x0000开始, 0x01FF</span></span><br><span class="line"><span class="comment">//    EEPROM_SectorErase(u16 EE_address);</span></span><br><span class="line">    EEPROM_SectorErase(addr_sector);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 写入数据. 字符串\int\long\float</span></span><br><span class="line"><span class="comment">////    EEPROM_write_n(u16 EE_address,u8 *DataAddress,u16 number);</span></span><br><span class="line">    EEPROM_write_n(addr_sector, str, str_length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据. 字符串\int\long\float</span></span><br><span class="line"><span class="comment">//    EEPROM_read_n(u16 EE_address,u8 *DataAddress,u16 number);</span></span><br><span class="line">    EEPROM_read_n(addr_sector, tmp, str_length);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 添加字符串结束符</span></span><br><span class="line">		tmp[str_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;存储的字符串: %s\n&quot;</span>, str);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;读到的字符串: %s\n&quot;</span>, tmp);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(str, tmp) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;两个字符串相等\n&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;两个字符串不等\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/GPIO/</url>
    <content><![CDATA[<p>GPIO（General Purpose Input&#x2F;Output）是“通用输入输出”的缩写，它是微控制器（MCU）或单片机（MCU）、处理器或其他数字电子设备上用来处理各种信号的基本接口。<strong>是一种能够配置为不同模式的引脚或端口</strong>，用于与外部世界进行交互。能够配置为输入模式或输出模式，以实现不同的功能。</p>
<h3 id="GPIO-的主要特性"><a href="#GPIO-的主要特性" class="headerlink" title="GPIO 的主要特性"></a>GPIO 的主要特性</h3><p><strong>可配置性</strong>：</p>
<ul>
<li><strong>输入模式</strong>：当 GPIO 引脚被配置为输入时，微控制器可以通过该引脚<strong>读取外部信号的状态</strong>，通常是高电平（1）或低电平（0）。输入模式常用于读取传感器、按键、开关的状态。</li>
<li><strong>输出模式</strong>：当 GPIO 引脚被配置为输出时，微控制器可以通过该引脚<strong>驱动外部设备</strong>，如点亮 LED、驱动电机、控制继电器等。</li>
<li><strong>双向引脚</strong>：大多数 GPIO 引脚既可以作为输入，也可以作为输出，通常通过软件控制配置。</li>
</ul>
<p><strong>电平高低</strong>：</p>
<ul>
<li><strong>高电平（逻辑 1）</strong>：通常表示接近电源电压（如 3.3V 或 5V）。</li>
<li><strong>低电平（逻辑 0）</strong>：通常表示接近地电压（0V）。</li>
</ul>
<p><strong>输入&#x2F;输出电流能力</strong>： GPIO 引脚的输入和输出电流能力有限，一般只能驱动较小的负载。如果需要驱动更大的负载（如电机），通常需要使用额外的驱动器件（如晶体管或 MOSFET）。</p>
<p><strong>中断支持</strong>： 有些 GPIO 引脚支持中断，<strong>当引脚的状态变化（如从高电平变为低电平，或从低电平变为高电平）时，能够触发中断信号</strong>，让处理器及时响应。这在按钮按下、传感器信号变化等场景下非常有用。</p>
<p><strong>上拉&#x2F;下拉电阻</strong>： 为了确保输入引脚在未连接任何信号时有稳定的电平状态，GPIO 通常提供<strong>内部上拉电阻</strong>或<strong>下拉电阻</strong>。上拉电阻将引脚默认拉到高电平，而下拉电阻将引脚默认拉到低电平。这样可以防止引脚悬空时处于不确定状态。</p>
<h3 id="GPIO-的工作模式"><a href="#GPIO-的工作模式" class="headerlink" title="GPIO 的工作模式"></a>GPIO 的工作模式</h3><p><strong>输入模式</strong>：</p>
<ul>
<li><strong>功能</strong>：读取外部设备的电平状态。</li>
<li><strong>应用场景</strong>：检测按钮按下&#x2F;松开、读取传感器数据、检测信号电平。</li>
<li><strong>操作</strong>：配置 GPIO 为输入模式后，通过读取引脚的值（通常为 0 或 1）来获得外部设备的状态。</li>
</ul>
<p><strong>输出模式</strong>：</p>
<ul>
<li><strong>功能</strong>：通过 GPIO 向外部设备输出高电平或低电平信号。</li>
<li><strong>应用场景</strong>：控制 LED 点亮&#x2F;熄灭、驱动蜂鸣器、开关继电器等。</li>
<li><strong>操作</strong>：配置 GPIO 为输出模式后，可以设置引脚为高电平或低电平，控制外部设备。</li>
</ul>
<p><strong>中断模式</strong>：</p>
<ul>
<li><strong>功能</strong>：当 GPIO 引脚的电平状态发生变化时触发中断，处理器执行相应的中断服务程序（ISR）。</li>
<li><strong>应用场景</strong>：按钮按下时触发中断，传感器信号变化时立即响应。</li>
<li><strong>操作</strong>：配置 GPIO 为中断模式，并指定触发条件（如上升沿、下降沿或电平变化）。</li>
</ul>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>在 <strong>STC8H</strong> 系列单片机中，GPIO（通用输入输出）引脚具有四种主要模式，分别是<strong>准双向口模式</strong>、<strong>推挽输出模式</strong>、<strong>开漏输出模式</strong>和<strong>高阻输入模式</strong>。</p>
<h3 id="准双向模式"><a href="#准双向模式" class="headerlink" title="准双向模式"></a><strong>准双向模式</strong></h3><p>默认状态下引脚处于高电平状态，且引脚内部连接了一个弱上拉电阻，既可以作为输入，也可以作为输出，不需要额外设置方向寄存器。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOzhunshuangxiang.png" alt="GPIOzhunshuangxiang"></p>
<h3 id="推挽输出模式"><a href="#推挽输出模式" class="headerlink" title="推挽输出模式"></a><strong>推挽输出模式</strong></h3><p>强推挽输出配置的下拉结构与开漏模式以及准双向口的下拉结构相同，但当锁存器为1时提供持续<br>的强上拉。推挽模式- -般用于需要更大驱动电流的情况。</p>
<p>强推挽引脚配置如下图所示:</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOtuiwanshuchu.png" alt="GPIOtuiwanshuchu"></p>
<h3 id="开漏输出模式"><a href="#开漏输出模式" class="headerlink" title="开漏输出模式"></a><strong>开漏输出模式</strong></h3><p>【开漏工作模式】，对外设置输出为 1，等同于 【高阻输入】</p>
<p>【开漏工作模式】,【打开内部上拉电阻 | 或外部加上拉电阻】，简单等同于 【准双向口】</p>
<p>开漏模式既可读外部状态也可对外输出(高电平或低电平)。如要正确读外部状态或需要对外输出高电平，需外加上拉电阻。</p>
<p>当端口锁存器为 0 时，开漏模式关闭所有上拉晶体管。当作为一个逻辑输出高电平时，这种配置方式必须有外部上拉，一般通过电阻外接到 Vcc。如果外部有上拉电阻，开漏的 I&#x2F;O 口还可读外部状态，即此时被配置为开漏模式的 I&#x2F;O 口还可作为输入 I&#x2F;O 口。这种方式的下拉与准双向口相同。</p>
<p>开漏端口带有一个施密特触发输入以及一个干扰抑制电路。</p>
<p>输出端口配置如下图所示:</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOkailou.png" alt="GPIOkailou"></p>
<h3 id="高阻输入模式"><a href="#高阻输入模式" class="headerlink" title="高阻输入模式"></a><strong>高阻输入模式</strong></h3><p> 电流既不能流入也不能流出。通常由三态缓冲器等电路元件实现。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/GPIOgaozu.png" alt="GPIOgaozu"></p>
<p><strong>高阻的实现方式</strong></p>
<p><strong>输入缓冲器（双反相器）禁用</strong>：</p>
<ul>
<li>电路中的两个反相器通常用于传输输入数据，但如果你将这两个反相器禁用（比如通过控制信号使其不工作），那么该引脚的输入路径就相当于被断开了。</li>
<li>当输入缓冲器被禁用时，输入信号将不会传播到引脚，因此引脚没有驱动信号，也不会产生输出。</li>
</ul>
<p><strong>上拉电阻</strong>：</p>
<ul>
<li>该电路中的上拉电阻将引脚连接到 VCC。如果没有其他驱动器作用于引脚，那么引脚会通过上拉电阻保持在高电平状态。</li>
<li>如果输入缓冲器禁用，输出逻辑不会控制引脚电平，此时引脚实际上处于高阻态，即无驱动电平的状态。</li>
</ul>
<p><strong>高阻态定义</strong>：</p>
<ul>
<li>高阻态意味着引脚既不输出高电平，也不输出低电平。它就像断开一样，既不会拉高也不会拉低，而是由外部电路（如上拉或下拉电阻）决定引脚的电平状态。</li>
<li>在这个电路图中，当输入缓冲器关闭时，引脚处于高阻态，引脚电平由上拉电阻决定，通常会保持高电平。</li>
</ul>
<p><strong>电气特性：</strong></p>
<p>1、高电阻值：高阻态的管脚<strong>电阻极高</strong>，这使得通过该管脚的电流非常小，<strong>接近于零</strong>。这样的特性使得该管脚在电路中的电流驱动能力极弱，对电路中的电流分布影响极小。<br>2、电平不确定性：处于高阻态的管脚，其<strong>电平状态不确定</strong>。如果用万用表测量，测量结果可能是高电平，也可能是低电平，具体取决于该<strong>管脚后面所连接的电路元件</strong>。</p>
<p>内阻非常大，管脚输入电流有轻微波动都能识别到，电压等于电阻乘以电流。如果设为高阻态，当管脚连接的外设驱动能力非常弱，也不会误读电平状态。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在进行嵌入式开发中为什么需要多次指定同一个引脚，比如在使用 UART 时，需要 GPIO 和UART 分别指定一次引脚</strong></p>
<p>在嵌入式开发中，可能需要多次指定同一个引脚，例如在使用 UART 时，需要在 GPIO 和 UART 模块中分别进行引脚指定。这是因为<strong>引脚的功能配置和电气特性配置是独立的</strong>，并且涉及到不同的系统组件。下面详细解释为什么需要这样做，并且解释每个配置的角色和原因。</p>
<p><strong>配置方式</strong></p>
<ul>
<li><strong>GPIO 配置：</strong> 配置引脚的电气特性，如上拉&#x2F;下拉电阻、输入&#x2F;输出模式等。</li>
<li><strong>外设配置：</strong> 配置引脚用于特定的外设功能，如 UART 的 TX&#x2F;RX。外设模块需要知道具体的引脚用于什么功能，以便正确地处理信号。</li>
</ul>
<p>在嵌入式开发中，尽管一个引脚可能在物理上是相同的，但为了实现不同功能（如 GPIO 和 UART），需要在不同的配置阶段分别指定引脚。这是因为 GPIO 配置关注<strong>电气特性</strong>，而外设配置关注功能模式和功能启用。这种分离允许微控制器的引脚支持多种功能，并确保每种功能能够正常工作。</p>
<p>二、<strong>什么是电气特性</strong></p>
<p>在嵌入式系统和单片机开发中，”电气特性”（Electrical Characteristics）指的是引脚在<strong>不同工作模式下的电气行为和性能参数</strong>。这些特性决定了引脚如何与外部电路交互，并影响其在实际应用中的功能和可靠性。</p>
<p>举个例子，在一个典型的微控制器中，如果你配置一个引脚为输入模式并启用内部上拉电阻，这样可以确保在引脚没有外部信号连接时，它会稳定地保持在高电平。相反，如果配置为输出模式，你可以设置引脚为高电平或低电平，并确保它能够提供足够的电流来驱动连接的设备，如 LED。</p>
<p>简单来说，<strong>电气特性</strong>指的就是引脚在不同工作模式下的<strong>电压和电流</strong>相关的参数和行为。这些特性包括了引脚如何表现电压、电流的能力以及它如何响应不同的电气信号。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>HID_模拟鼠标</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/HID_%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 STC8H 的矩阵键盘模拟 鼠标的功能</span></span><br><span class="line"><span class="comment">// 按照我们自己的需求修改描述符配置</span></span><br><span class="line"><span class="comment">// usb_desc.c</span></span><br><span class="line"><span class="comment">// 定义 鼠标的 配置描述符</span></span><br><span class="line"><span class="comment">/* 我们加了一个 scroll 也就是鼠标滚轮的功能</span></span><br><span class="line"><span class="comment">Input Report:</span></span><br><span class="line"><span class="comment">0   Buttons (D0:LButton D1:RButton D2:MButton [D3:D7]:Pad)</span></span><br><span class="line"><span class="comment">1	X displacement (&gt;0:right; &lt;0:left)</span></span><br><span class="line"><span class="comment">2	Y displacement (&gt;0:down; &lt;0:up)</span></span><br><span class="line"><span class="comment">3 scroll</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 此处我们需要修改的地方有：</span></span><br><span class="line"><span class="comment">// 1. 添加鼠标滚轮的描述符内容：0x09,0x38,Wheel;  鼠标滚轮   修改 1</span></span><br><span class="line"><span class="comment">// 2. 将原本报告的计数从 2 改为3 // 0x95,0x03,REPORT_COUNT(3);   修改2</span></span><br><span class="line"><span class="comment">// 3. 将整个报告描述符的总长度进行修改 HIDREPORTDESC[52]，0x05,0x01, (包括头文件中的内容)</span></span><br><span class="line"><span class="comment">// 4. 将配置描述符中发送的最大字节数从 3 改为 4</span></span><br><span class="line"><span class="comment">// 5. 将配置描述符中的协议长度改为 52 与报告描述符的总长度要一致</span></span><br><span class="line"><span class="comment">// 注意：当我们将鼠标滚轮的功能追加在第四个字节也就是末尾的时候，对应 HIDREPORTDESC </span></span><br><span class="line"><span class="comment">// 中的位置也要在 x、y，的下面，要保证发送的内容与报告描述符的内容对应起来；</span></span><br><span class="line"><span class="type">char</span> code HIDREPORTDESC[<span class="number">52</span>] =  <span class="comment">// 修改3 --- 头文件的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x01</span>,              <span class="comment">//USAGE_PAGE(Generic Desktop);</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x02</span>,              <span class="comment">//USAGE(Mouse);</span></span><br><span class="line">    <span class="number">0xa1</span>,<span class="number">0x01</span>,              <span class="comment">//COLLECTION(Application);</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x01</span>,              <span class="comment">//  USAGE(Pointer);</span></span><br><span class="line">    <span class="number">0xa1</span>,<span class="number">0x00</span>,              <span class="comment">//  COLLECTION(Physical);</span></span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x09</span>,              <span class="comment">//    USAGE_PAGE(Buttons);</span></span><br><span class="line">    <span class="number">0x19</span>,<span class="number">0x01</span>,              <span class="comment">//    USAGE_MINIMUM(1);</span></span><br><span class="line">    <span class="number">0x29</span>,<span class="number">0x03</span>,              <span class="comment">//    USAGE_MAXIMUM(3);</span></span><br><span class="line">    <span class="number">0x15</span>,<span class="number">0x00</span>,              <span class="comment">//    LOGICAL_MINIMUM(0);</span></span><br><span class="line">    <span class="number">0x25</span>,<span class="number">0x01</span>,              <span class="comment">//    LOGICAL_MAXIMUM(1);</span></span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x01</span>,              <span class="comment">//    REPORT_SIZE(1);</span></span><br><span class="line">    <span class="number">0x95</span>,<span class="number">0x03</span>,              <span class="comment">//    REPORT_COUNT(3);</span></span><br><span class="line">    <span class="number">0x81</span>,<span class="number">0x02</span>,              <span class="comment">//    INPUT(Data,Variable,Absolute);</span></span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x05</span>,              <span class="comment">//    REPORT_SIZE(5);</span></span><br><span class="line">    <span class="number">0x95</span>,<span class="number">0x01</span>,              <span class="comment">//    REPORT_COUNT(1);</span></span><br><span class="line">    <span class="number">0x81</span>,<span class="number">0x01</span>,              <span class="comment">//    INPUT(Constant);</span></span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x01</span>,              <span class="comment">//    USAGE_PAGE(Generic Desktop);</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x30</span>,              <span class="comment">//    USAGE(X);  x方向移动</span></span><br><span class="line">    <span class="number">0x09</span>,<span class="number">0x31</span>,              <span class="comment">//    USAGE(Y);  y方向移动</span></span><br><span class="line">	<span class="number">0x09</span>,<span class="number">0x38</span>,              <span class="comment">//    Wheel;  鼠标滚轮   修改 1</span></span><br><span class="line">    <span class="number">0x15</span>,<span class="number">0x81</span>,              <span class="comment">//    LOGICAL_MINIMUM(-127);</span></span><br><span class="line">    <span class="number">0x25</span>,<span class="number">0x7f</span>,              <span class="comment">//    LOGICAL_MAXIMUM(127);</span></span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x08</span>,              <span class="comment">//    REPORT_SIZE(8);</span></span><br><span class="line">    <span class="number">0x95</span>,<span class="number">0x03</span>,              <span class="comment">//    REPORT_COUNT(3);   修改2</span></span><br><span class="line">    <span class="number">0x81</span>,<span class="number">0x06</span>,              <span class="comment">//    INPUT(Data, Variable, Relative);</span></span><br><span class="line">    <span class="number">0xc0</span>,                   <span class="comment">//  END_COLLECTION;</span></span><br><span class="line">    <span class="number">0xc0</span>,                   <span class="comment">//END_COLLECTION;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置描述符</span></span><br><span class="line"><span class="type">char</span> code CONFIGDESC[<span class="number">41</span>] = &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 遵循的协议版本 HID 1.01协议</span></span><br><span class="line">    <span class="number">0x09</span>,                   <span class="comment">//bLength(9);</span></span><br><span class="line">    <span class="number">0x21</span>,                   <span class="comment">//bDescriptorType(HID);</span></span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0x01</span>,              <span class="comment">//bcdHID(1.01);</span></span><br><span class="line">    <span class="number">0x00</span>,                   <span class="comment">//bCountryCode(0);</span></span><br><span class="line">    <span class="number">0x01</span>,                   <span class="comment">//bNumDescriptors(1);</span></span><br><span class="line">    <span class="number">0x22</span>,                   <span class="comment">//bDescriptorType(HID Report);</span></span><br><span class="line">    <span class="number">0x34</span>,<span class="number">0x00</span>,              <span class="comment">//wDescriptorLength(52);</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 描述鼠标给PC发的数据信息</span></span><br><span class="line">    <span class="number">0x07</span>,                   <span class="comment">//bLength(7);</span></span><br><span class="line">    <span class="number">0x05</span>,                   <span class="comment">//bDescriptorType(Endpoint);</span></span><br><span class="line">    <span class="number">0x81</span>,                   <span class="comment">//bEndpointAddress(EndPoint1 as IN);</span></span><br><span class="line">    <span class="number">0x03</span>,                   <span class="comment">//bmAttributes(Interrupt);</span></span><br><span class="line">    <span class="number">0x04</span>,<span class="number">0x00</span>,              <span class="comment">//wMaxPacketSize(4);   修改4 鼠标1次会给PC发送4个字节</span></span><br><span class="line">    <span class="number">0x0a</span>,                   <span class="comment">//bInterval(10ms); </span></span><br><span class="line">&#125;;</span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">// usb_req_class.c</span></span><br><span class="line"><span class="comment">// 修改处理函数</span></span><br><span class="line"><span class="type">void</span> usb_class_in(BYTE button[<span class="number">4</span>]) &#123;</span><br><span class="line">    BYTE i;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (DeviceState != DEVSTATE_CONFIGURED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!UsbInBusy )&#123;</span><br><span class="line">        IE2 &amp;= ~<span class="number">0x80</span>;   <span class="comment">//EUSB = 0;</span></span><br><span class="line">        UsbInBusy = <span class="number">1</span>;</span><br><span class="line">        usb_write_reg(INDEX, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            usb_write_reg(FIFO1, button[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        usb_write_reg(INCSR1, INIPRDY);</span><br><span class="line">        IE2 |= <span class="number">0x80</span>;    <span class="comment">//EUSB = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">===============================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb_req_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">	<span class="comment">// &gt;&gt;&gt; 记得添加 NVIC.c, UART.c, UART_Isr.c &lt;&lt;&lt;</span></span><br><span class="line">    COMx_InitDefine		COMx_InitStructure;					<span class="comment">//结构定义</span></span><br><span class="line">    COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;	<span class="comment">//模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;			<span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    COMx_InitStructure.UART_BaudRate  = <span class="number">115200ul</span>;			<span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    COMx_InitStructure.UART_RxEnable  = ENABLE;				<span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    COMx_InitStructure.BaudRateDouble = DISABLE;			<span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_InitStructure);		<span class="comment">//初始化串口1 UART1,UART2,UART3,UART4</span></span><br><span class="line"></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		<span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);		<span class="comment">// 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0、L_Button、M_Button、R_Button</span></span><br><span class="line"><span class="comment">																	    </span></span><br><span class="line"><span class="comment">0	  0			-y		 -s</span></span><br><span class="line"><span class="comment">																	    </span></span><br><span class="line"><span class="comment">0	  -x		0		 +x</span></span><br><span class="line"><span class="comment">																	    </span></span><br><span class="line"><span class="comment">0	  0			+y		 +s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 按下按键...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_down</span><span class="params">(u8 row, u8 col)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 准备好4个字节长度的数组，初值都是 0</span></span><br><span class="line">	u8 dat[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//2. 判定按下的哪个键位，组装数据	</span></span><br><span class="line">	<span class="comment">//2.1 判定按键</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">0</span> &amp;&amp; col ==<span class="number">1</span>) dat[<span class="number">0</span>] |= <span class="number">1</span>&lt;&lt;<span class="number">0</span>; <span class="comment">// 左键</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">0</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">0</span>] |= <span class="number">1</span>&lt;&lt;<span class="number">1</span>; <span class="comment">// 右键</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">0</span> &amp;&amp; col ==<span class="number">2</span>) dat[<span class="number">0</span>] |= <span class="number">1</span>&lt;&lt;<span class="number">2</span>; <span class="comment">// 中键</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.2 判定x方向</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">2</span> &amp;&amp; col ==<span class="number">1</span>) dat[<span class="number">1</span>] = <span class="number">-10</span>;  <span class="comment">// 向左移动</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">2</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">1</span>] = <span class="number">10</span>;   <span class="comment">// 向右移动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.3 判定y方向</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">1</span> &amp;&amp; col ==<span class="number">2</span>) dat[<span class="number">2</span>] = <span class="number">-10</span>;  <span class="comment">// -y 向上移动</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">3</span> &amp;&amp; col ==<span class="number">2</span>) dat[<span class="number">2</span>] = <span class="number">10</span>;   <span class="comment">// +y 向下移动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.4 判定滚轮</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">1</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">3</span>] = <span class="number">-10</span>;  <span class="comment">// -s 向下滚动</span></span><br><span class="line">	<span class="keyword">if</span>(row ==<span class="number">3</span> &amp;&amp; col ==<span class="number">3</span>) dat[<span class="number">3</span>] = <span class="number">10</span>;   <span class="comment">// +s 向上滚动</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 发数据</span></span><br><span class="line">	usb_class_in(dat);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//printf(&quot;dat[0]=%d\n&quot;, (int)dat[0]);</span></span><br><span class="line">	<span class="comment">//printf(&quot;dat[1]=%d\n&quot;, (int)dat[1]);</span></span><br><span class="line">	<span class="comment">//printf(&quot;dat[2]=%d\n&quot;, (int)dat[2]);</span></span><br><span class="line">	<span class="comment">//printf(&quot;dat[3]=%d\n&quot;, (int)dat[3]);	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_up</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">	u8 dat[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;up..\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	usb_class_in(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	P_SW2 |= <span class="number">0x80</span>;  <span class="comment">//扩展寄存器(XFR)访问使能</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// usb初始化</span></span><br><span class="line">    usb_init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化矩阵键盘</span></span><br><span class="line">	MK_Init();</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">	UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		MK_Scan( key_down, key_up );        </span><br><span class="line">        delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>HID协议</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/HID%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>HID（Human Interface Device）协议是一种用于<strong>连接人机交互设备（如键盘、鼠标、游戏控制器等）到计算机</strong>或其他主机设备的通信协议。它是 <strong>USB（通用串行总线）设备的一部分</strong>，专门用于<strong>处理和管理人机交互设备的数据传输</strong>。</p>
<p><strong>HID 协议概述</strong></p>
<p>HID 协议最初是为 USB 而设计的，但随着技术的发展，它也被应用在其他通信方式上，例如 <strong>蓝牙</strong>。HID 设备以一种标准化的方式报告其数据，使得主机可以理解设备的输入和输出，无需依赖具体的硬件驱动。HID 的典型设备包括：</p>
<ul>
<li>键盘、鼠标、触控板、游戏手柄、条码扫描仪、远程控制设备</li>
</ul>
<p><strong>HID 设备的工作原理</strong></p>
<p>HID 协议定义了<strong>如何描述设备的功能</strong>以及<strong>如何传输数据</strong>。通过使用 HID 协议，<strong>设备和主机之间可以在无需特定驱动程序的情况下通信</strong>。</p>
<p>HID 设备通过 <strong>描述符（Descriptor）</strong> 向主机传达其自身信息。描述符是一个<strong>数据结构</strong>（例如数组），详细说明了设备的输入&#x2F;输出功能、设备的类型、报告格式等。主机通过解析描述符，可以知道如何与设备交互和处理其数据。</p>
<p><strong>通信流程</strong></p>
<p>USB HID通讯时序可以大致分为以下几个步骤：</p>
<ol>
<li>设备连接和初始化：设备被插入USB端口后，会进行初始化和配置，包括分配USB地址和设置通信端点等。</li>
<li>主机发送设备描述符：主机会向设备发送请求，要求设备提供自己的描述符信息，包括设备类型、厂商信息、设备功能等。</li>
<li>设备响应描述符请求：设备接收到主机的请求后，会根据请求提供相应的设备描述符信息，包括设备类型、厂商信息、设备功能等。</li>
<li>主机发送配置描述符：主机会向设备发送请求，要求设备提供自己的配置描述符信息，包括端点数量、数据传输速率、电源需求等。</li>
<li>设备响应配置描述符请求：设备接收到主机的请求后，会根据请求提供相应的配置描述符信息，包括端点数量、数据传输速率、电源需求等。</li>
<li>主机发送数据：主机会向设备发送数据包，数据包中包含了控制信息和数据内容。</li>
<li>设备接收和处理数据：设备接收到主机发送的数据包后，会进行处理和响应，包括识别控制信息和处理数据内容。</li>
<li>设备发送数据：设备会向主机发送数据包，数据包中包含了控制信息和数据内容。</li>
<li>主机接收和处理数据：主机接收到设备发送的数据包后，会进行处理和响应，包括识别控制信息和处理数据内容。</li>
<li>完成通讯：通讯完成后，设备和主机会进行断开连接和资源释放等操作。</li>
</ol>
<p>需要注意的是，USB HID通讯过程中的具体时序和流程可能会因为具体的应用场景和设备而有所不同，上述步骤仅供参考。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/HIDtongxinliucheng.png" alt="HIDtongxinliucheng"></p>
<p><strong>通信方式：中断传输</strong></p>
<p><strong>中断传输（Interrupt Transfer）</strong> 是 HID 协议中的核心通信方式。主机会定期轮询 HID 设备，询问其是否有新的输入数据。这种传输方式确保主机能够及时接收到输入数据（例如鼠标移动、按键输入等）。</p>
<p>当有数据变化时，设备通过中断传输将输入报告发送给主机，主机根据报告内容执行相应的操作，如在屏幕上移动鼠标光标、显示键盘输入的字符等。</p>
<blockquote>
<p>也就是说，当我通过单片机按键输入 Q 之后必须也要判断按键弹起不然他就会一直输出 Q</p>
</blockquote>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>学习官方 USB HID 范例</strong></p>
<ol>
<li><p>下载<a href="https://www.stcaimcu.com/forum.php?mod=attachment&aid=ODg3Mnw1NTVmMzc3NXwxNzEzNDMzODM4fDF8MTUyNQ==">8H试验箱</a>中的代码（60-HID(Human Interface Device)协议范例）使用其中的示例编译并烧录到开发板中；</p>
</li>
<li><p>将开发板的开关拨动到 HID</p>
</li>
<li><p>打开”设置“ -&gt; 搜索”蓝牙和其他设备设置“并点击 -&gt; 查看 ”输入“中的设备</p>
</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/HIDshili.png" alt="HIDshili"></p>
<blockquote>
<p>如果提示 ”其他设备“ USB-SERIAL CH340(COM3) 则说明没有将开关拨动到 HID</p>
<p>如果按照上述步骤执行，但是不显示”STC UST Keyboard“则可能需要多烧录几次（重复1、2、3步骤）</p>
</blockquote>
<p>官方示例的作用，就是帮助我们构建了一个HID设备，将设备注册到了PC机中。</p>
<p><strong>文件说明</strong></p>
<ul>
<li>usb.c 和 usb.h：  USB入口文件，提供USB所有功能，设备信息，配置信息，通讯过程等</li>
<li>usb_req_std.c 和 usb_req_std.h：设备信息和配置信息通讯过程中的逻辑实现。</li>
<li>usb_req_class.c 和 usb_req_class.h：通讯过程中的逻辑实现</li>
<li>usb_vendor.c 和 usb_vendor.h：初始化配置逻辑</li>
<li>usb_desc.c 和 usb_desc.h: 协议描述信息，内部是协议的常量信息。</li>
</ul>
<p><strong>修改 PC 端的显示</strong></p>
<p>修改 usb_desc.c 中间的内容即可：</p>
<ol>
<li>MANUFACTDESC 制造商信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原代码</span></span><br><span class="line"><span class="type">char</span> code MANUFACTDESC[<span class="number">8</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x08</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">===================================</span><br><span class="line"><span class="comment">// 修改后代码</span></span><br><span class="line"><span class="type">char</span> code MANUFACTDESC[<span class="number">18</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x12</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>, <span class="comment">// &#x27;T&#x27; 的 Unicode 表示：0x0054</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>, <span class="comment">// &#x27;O&#x27; 的 Unicode 表示：0x004F</span></span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;E&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>0x12</code> 和 <code>0x03</code> 是用于 USB 描述符中的两个特定字节，</p>
<p><code>0x12</code> 是 <strong>18（十进制）</strong>，表示该字符串描述符的总长度为 <strong>18 字节</strong>。字符串描述符的第一个字节通常用来表示整个描述符的长度，包括描述符本身的所有数据。</p>
<p><code>0x03</code> 是 USB 标准中定义的 <strong>描述符类型代码</strong>，表示这是一个 <strong>字符串描述符（String Descriptor）</strong>。</p>
</blockquote>
<p>在上面的代码中要注意除了<strong>字符串描述类型代码</strong>之外要按照<strong>小端序</strong>，即<strong>低位在前，高位在后</strong>。</p>
<p>小端序是指<strong>低字节存储在低地址</strong>，高字节存储在高地址。在多字节数据类型（例如 16 位、32 位、64 位）中，小端序总是将数值的<strong>最低有效字节（LSB, Least Significant Byte）</strong>存储在最前面的地址位置，而<strong>最高有效字节（MSB, Most Significant Byte）</strong>放在最后的地址。（以 ‘T’ 为例在 0x0054 中，54 存储在数组中的低位也就是下标为 2 的位置，00 存储在数组的高位也就是下标为 3 的位置）</p>
<ol start="2">
<li>PRODUCTDESC 产品信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的</span></span><br><span class="line"><span class="type">char</span> code PRODUCTDESC[<span class="number">26</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x1a</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;I&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line">=============================================</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="type">char</span> code PRODUCTDESC[<span class="number">34</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x22</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;Z&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;I&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;i&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27; &#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0x2e</span>, <span class="number">0x95</span>, <span class="number">0xd8</span>, <span class="number">0x76</span>,  <span class="comment">//\u952e \u76d8 键盘</span></span><br><span class="line">	<span class="string">&#x27;4&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;3&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改后长度发生变化，长度由第一个字符描述决定。</p>
<p>需要同时修改头文件长度配置信息</p>
<p>如果是中文，需要把中文转化为ASCII码格式（<a href="https://www.ip138.com/ascii/">ASCII在线转换</a>），写入其中</p>
<p>例如：</p>
<ul>
<li><code>今晚打母驴</code>对应ASCII码：<code>\u4eca\u665a\u6253\u6bcd\u9a74</code></li>
<li>汉字低位在前，添加<code>今</code>为：<code>0xca</code>, <code>0x4e</code></li>
</ul>
</blockquote>
<p><strong>兼容库函数</strong></p>
<p>由于提供的官方示例中，<code>stc.h</code> <code>STC8H.h</code> <code>config.h</code>，这些文件和我们需要用到的库函数，在变量定义或者是文件命名上，存在重名等冲突，需要进行修改。</p>
<p>将 STC8H 删掉用我们自己的，config.h 中有用到的不能删，就改个名字，stc.h 中有重复定义的删掉就行；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Soft_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MAtrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb_req_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">URAT_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine COMx_InitStructure;					</span><br><span class="line">    COMx_InitStructure.UART_Mode = UART_8bit_BRTx;	</span><br><span class="line">    COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;			</span><br><span class="line">    COMx_InitStructure.UART_BaudRate  = <span class="number">115200ul</span>;			</span><br><span class="line">    COMx_InitStructure.UART_RxEnable  = ENABLE;				</span><br><span class="line">    COMx_InitStructure.BaudRateDouble = DISABLE;			</span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_InitStructure);	</span><br><span class="line"></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);	</span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kay_down</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    u8 dat[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    dat[<span class="number">2</span>] = <span class="number">0x14</span> <span class="comment">// Q</span></span><br><span class="line">    usb_class_in(dat);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kay_up</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    u8 dat[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    usb_class_in(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    P_SW2 |= <span class="number">0x80</span>;  <span class="comment">//扩展寄存器(XFR)访问使能</span></span><br><span class="line"></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    usb_init();</span><br><span class="line">    <span class="comment">//URAT_Config();</span></span><br><span class="line">	MK_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        MK_Scan(kay_down, kay_up);</span><br><span class="line">        delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">===================================================</span><br><span class="line"><span class="type">char</span> code CONFIGDESC[<span class="number">41</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x07</span>,                   <span class="comment">//bLength(7);</span></span><br><span class="line">    <span class="number">0x05</span>,                   <span class="comment">//bDescriptorType(Endpoint);</span></span><br><span class="line">    <span class="number">0x81</span>,                   <span class="comment">//bEndpointAddress(EndPoint1 as IN);</span></span><br><span class="line">    <span class="number">0x03</span>,                   <span class="comment">//bmAttributes(Interrupt);</span></span><br><span class="line">    <span class="number">0x08</span>,<span class="number">0x00</span>,              <span class="comment">//wMaxPacketSize(8);	// 设备向主机传输最大不能超过 8 个字节</span></span><br><span class="line">    <span class="number">0x0a</span>,                   <span class="comment">//bInterval(10ms);</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x07</span>,                   <span class="comment">//bLength(7);</span></span><br><span class="line">    <span class="number">0x05</span>,                   <span class="comment">//bDescriptorType(Endpoint);</span></span><br><span class="line">    <span class="number">0x01</span>,                   <span class="comment">//bEndpointAddress(EndPoint1 as OUT);</span></span><br><span class="line">    <span class="number">0x03</span>,                   <span class="comment">//bmAttributes(Interrupt);</span></span><br><span class="line">    <span class="number">0x01</span>,<span class="number">0x00</span>,              <span class="comment">//wMaxPacketSize(1); // 设备接收主机传输最大不能超过 1 个字节</span></span><br><span class="line">    <span class="number">0x0a</span>,                   <span class="comment">//bInterval(10ms);</span></span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>既然 通信方式为中断传输 那为什么我在单片机中写代码时要将语句放入 while(1) 循环中呢？</strong></p>
<p>虽然 HID 协议使用的是 <strong>中断传输</strong>，但在嵌入式系统中，通常还是需要将相关处理代码放在循环中。这是因为中断传输并不意味着单片机会自动处理所有的通信细节，尤其是在嵌入式开发中。具体原因如下：</p>
<ol>
<li><strong>中断传输与轮询机制的区别</strong></li>
</ol>
<ul>
<li><strong>中断传输</strong> 是一种 <strong>USB 通信方式</strong>，它表示<strong>主机</strong>会定期轮询 HID 设备，询问设备是否有新的数据。这是主机端的行为，即在 <strong>USB 层面</strong>，主机会定时查询设备，确保数据能及时获取。</li>
<li>然而，在嵌入式系统（如单片机）中，代码逻辑仍需要主动处理数据的接收、发送和状态检查，这通常通过循环来实现。</li>
</ul>
<blockquote>
<p>在 USB 或 HID 协议中，中断传输指的是 <strong>主机周期性地轮询设备</strong>，检查设备是否有数据需要传输。</p>
</blockquote>
<ol start="2">
<li><strong>单片机代码中的循环</strong></li>
</ol>
<ul>
<li><strong>实时响应与轮询</strong>：单片机的代码中，放入循环的目的是为了轮询设备的状态。例如，单片机在等待新数据或判断是否有新的中断信号产生时，需要在循环中反复检查某些状态寄存器或标志位。这样，当有数据到达或状态变化时，代码可以及时做出反应。</li>
<li><strong>中断并不是自动执行</strong>：中断传输并不意味着所有的数据传输都是自动完成的。中断传输指的是 USB 主机会定期轮询设备，但单片机仍然需要执行具体的处理代码，例如读写数据、处理中断信号等，这些都需要在主循环中完成。</li>
</ul>
<p>虽然 HID 协议使用中断传输方式，主机（如 PC）会定期轮询 HID 设备，但在嵌入式开发中，单片机的程序仍然需要通过循环来实现持续的任务调度、轮询状态和处理数据。循环确保代码可以实时检查设备的状态，及时响应中断请求。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>HID_模拟键盘按键</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/HID_%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p><strong>如何去阅读 USB HID 设备开发指南</strong></p>
<p><strong>如何去看得懂官方的示例教程</strong></p>
<p><strong>按照我们的需求改造示例教程</strong></p>
<p>PC 通过 HID 协议与键盘进行交互，那么就可以分为两部分：</p>
<p><strong>STC8H 向 PC 发送按键报告</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usb_desc.c</span></span><br><span class="line"><span class="comment">// 按照我们自己的需求修改描述符中的内容</span></span><br><span class="line"><span class="comment">// 1.修改产品描述符 -&gt; 也就是 PC 端中所显示的文本信息</span></span><br><span class="line"><span class="type">char</span> code PRODUCTDESC[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">0x0c</span>,<span class="number">0x03</span>, <span class="comment">// 0x0ec 为描述符的长度，与 PRODUCTDESC[12] 中的 12 对应   </span></span><br><span class="line">	<span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,     </span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="string">&#x27;-&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0x2e</span>,<span class="number">0x95</span>, <span class="comment">// 键盘的 ASCII: \u952e\u76d8</span></span><br><span class="line">	<span class="number">0xd8</span>,<span class="number">0x76</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.修改制造商信息 </span></span><br><span class="line"><span class="comment">// 修改方式同上</span></span><br><span class="line"><span class="type">char</span> code MANUFACTDESC[<span class="number">18</span>] = &#123;</span><br><span class="line">    <span class="number">0x12</span>,<span class="number">0x03</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 其他内容照 STC8H 示例即可</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 注意查看 HIDREPORTDESC -&gt; HID 报告的内容</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// usb_desc.h</span></span><br><span class="line"><span class="comment">// 修改对应的头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> code MANUFACTDESC[<span class="number">18</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> code PRODUCTDESC[<span class="number">12</span>];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// usb_req_class.c</span></span><br><span class="line"><span class="comment">// 按照我们自己的需求修改实现的方式</span></span><br><span class="line"><span class="comment">// 发送数据给PC，要传递进来8个字节长度的数组</span></span><br><span class="line"><span class="type">void</span> usb_class_in(BYTE key[<span class="number">8</span>]) &#123;</span><br><span class="line">    BYTE i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DeviceState != DEVSTATE_CONFIGURED)</span><br><span class="line">        <span class="keyword">return</span>;		</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (!UsbInBusy) &#123;</span><br><span class="line">        IE2 &amp;= ~<span class="number">0x80</span>;   <span class="comment">//EUSB = 0;</span></span><br><span class="line">        UsbInBusy = <span class="number">1</span>;</span><br><span class="line">        usb_write_reg(INDEX, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">            usb_write_reg(FIFO1, key[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        usb_write_reg(INCSR1, INIPRDY);</span><br><span class="line">        IE2 |= <span class="number">0x80</span>;    <span class="comment">//EUSB = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// MatrixKey.c    </span></span><br><span class="line"><span class="comment">/*	扫描按键，如果需要感知按下或者弹起的状态，那么就传递进来按下和弹起的函数</span></span><br><span class="line"><span class="comment">	如果有某一个方向不想感知，那么可以直接传递 NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">u16 MK_Scan( <span class="type">void</span>(*key_down)(u8,u8), <span class="type">void</span> (*key_up)(u8,u8)) &#123;	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//1. 拉低第1行</span></span><br><span class="line">		set_row(i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//2. 判定列</span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(get_col(j) == <span class="number">0</span> &amp;&amp; is_up(status,i ,j)	)&#123; <span class="comment">// 按下了</span></span><br><span class="line">				set_down(status ,i , j);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span>(key_down != <span class="literal">NULL</span>) key_down(i,j);</span><br><span class="line">					</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(get_col(j) == <span class="number">1</span> &amp;&amp; is_down(status,i,j) )&#123; <span class="comment">// 弹起了</span></span><br><span class="line">				set_up(status,i,j);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span>(key_up != <span class="literal">NULL</span>) key_up(i,j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> status; <span class="comment">// 返回16个按键的状态</span></span><br><span class="line">&#125;</span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb_req_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    COMx_InitDefine COMx_Init;				</span><br><span class="line">    COMx_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    COMx_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">    COMx_Init.UART_BaudRate  = <span class="number">115200ul</span>;</span><br><span class="line">    COMx_Init.UART_RxEnable  = ENABLE;	</span><br><span class="line">    COMx_Init.BaudRateDouble = DISABLE;			</span><br><span class="line">    UART_Configuration(UART1, &amp;COMx_Init);	</span><br><span class="line">    </span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		</span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 准备好的键位对应的字母、功能键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Q		 W	 E	   R	</span></span><br><span class="line"><span class="comment">											  					   </span></span><br><span class="line"><span class="comment">A		 S	 D	   F	</span></span><br><span class="line"><span class="comment">											  					   </span></span><br><span class="line"><span class="comment">CapsLock C	 V     Backspace	</span></span><br><span class="line"><span class="comment">											  					   </span></span><br><span class="line"><span class="comment">Ctrl_L	 Gui Space Enter					</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 准备好键位对应的字节数据</span></span><br><span class="line"><span class="comment">0x14、0x1A、0x08、0x15</span></span><br><span class="line"><span class="comment">				   				   </span></span><br><span class="line"><span class="comment">0x04、0x16、0x07、0x09</span></span><br><span class="line"><span class="comment">				   				   </span></span><br><span class="line"><span class="comment">0x39、0x06、0x19、0x2A				   </span></span><br><span class="line"><span class="comment">				   </span></span><br><span class="line"><span class="comment">0xE0、0xE3、0x2C、0x58</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了更好的对应键位和字节，需要使用一个二维数组来组装字节数据</span></span><br><span class="line">u8 key_arr[<span class="number">4</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0x14</span>		,   <span class="number">0x1A</span> 		,		<span class="number">0x08</span>		, <span class="number">0x15</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>		,   <span class="number">0x16</span>		,		<span class="number">0x07</span>		,	<span class="number">0x09</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x39</span>		,   <span class="number">0x06</span>		,		<span class="number">0x19</span>		,	<span class="number">0x2A</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xE0</span>		,   <span class="number">0xE3</span>		,		<span class="number">0x2C</span>		,	<span class="number">0x58</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">u16 key_arr2[] = &#123;</span><br><span class="line">	<span class="number">0x14</span>, <span class="number">0x1A</span>, <span class="number">0x08</span>, <span class="number">0x15</span>,</span><br><span class="line">	<span class="number">0x04</span>, <span class="number">0x16</span>, <span class="number">0x07</span>,	<span class="number">0x09</span>,</span><br><span class="line">  <span class="number">0x39</span>, <span class="number">0x06</span>, <span class="number">0x19</span>,	<span class="number">0x2A</span>,</span><br><span class="line">  <span class="number">0xE0</span>, <span class="number">0xE3</span>, <span class="number">0x2C</span>,	<span class="number">0x58</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 num = <span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_down</span><span class="params">(u8 row, u8 col)</span>&#123;	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_up</span><span class="params">(u8 row, u8 col)</span>&#123;</span><br><span class="line">	<span class="comment">// 如果我们要做成键盘，那么就必须走HID协议，此时串口就无法使用了</span></span><br><span class="line">	<span class="comment">//printf(&quot;up: %d-%d\n&quot; , (int)row , (int)col);	</span></span><br><span class="line">	u8 dat[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">// 一开始就是8个0</span></span><br><span class="line">	</span><br><span class="line">	num--;</span><br><span class="line">	</span><br><span class="line">	usb_class_in(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 last_status;  <span class="comment">// 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	P_SW2 |= <span class="number">0x80</span>;  <span class="comment">//扩展寄存器(XFR)访问使能   EAXSFR();</span></span><br><span class="line"></span><br><span class="line">    usb_init(); <span class="comment">//初始化USB信息，这样PC就知道我们是键盘了.</span></span><br><span class="line"></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己的代码</span></span><br><span class="line">	UART_Config();</span><br><span class="line">	MK_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;       </span><br><span class="line">		u8 dat[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		u8 num = <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//usb_class_in();  // 发送按键数据给PC</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//1. 先扫描16个按键的状态，并且获取到16个按键的数据【按的是哪些键】</span></span><br><span class="line">		u16 status = MK_Scan(key_down , key_up);   <span class="comment">// 1111 1101 1011 1111</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">// 如果这次的键位数据和以前的键位数据一样，那么就不用发送键盘数据给PC了。</span></span><br><span class="line">		<span class="keyword">if</span>(status == last_status)&#123;</span><br><span class="line">			delay_ms(<span class="number">20</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">//2. 遍历取出status的每一个二进制位，看看这个bit是否是 0 。 0-按下，1-弹起</span></span><br><span class="line">			<span class="keyword">for</span>( i= <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)&#123;  <span class="comment">// 1111 1111  1011 0110</span></span><br><span class="line">				</span><br><span class="line">			<span class="comment">//3. 依次取出来二进制位，判定是否是 0</span></span><br><span class="line">				</span><br><span class="line">			<span class="comment">//3.1 status是16位 ，判断 第 0 位是否是 0,  status &amp; (1&lt;&lt;0) == 0 </span></span><br><span class="line">			<span class="comment">//3.2 status是16位 ，判断 第 1 位是否是 0， status &amp; (1&lt;&lt;1) == 0 </span></span><br><span class="line">			<span class="comment">//3.2 status是16位 ，判断 第 2 位是否是 0， status &amp; (1&lt;&lt;2) == 0 </span></span><br><span class="line">			<span class="comment">//3.2 status是16位 ，判断 第 4 位是否是 0， status &amp; (1&lt;&lt;3) == 0 </span></span><br><span class="line">				<span class="keyword">if</span>( ( status &amp; (<span class="number">1</span>&lt;&lt;i) ) == <span class="number">0</span>)&#123; <span class="comment">// 是按下</span></span><br><span class="line">										</span><br><span class="line">					<span class="comment">//4. 判断是功能键吗？组装功能键  0   Modifierkeys (D0:LCtrl D1:LShift D2:LAlt D3:LGui D4:RCtrl D5:RShift D6:RAlt D7:RGui)</span></span><br><span class="line">					<span class="keyword">if</span>(i == <span class="number">12</span>)&#123;  <span class="comment">//  Ctrl_L</span></span><br><span class="line">						dat[<span class="number">0</span>] |=  <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">13</span>)&#123;  <span class="comment">// Windows键</span></span><br><span class="line">						dat[<span class="number">0</span>] |=  <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">						<span class="comment">//5. 判断是普通键吗？组装普通键 第 2 ~ 7 字节，用来装普通的按键 </span></span><br><span class="line">						dat[num++] = key_arr2[i];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//5. 处理num的问题</span></span><br><span class="line">					<span class="keyword">if</span>(num &gt; <span class="number">7</span>) num = <span class="number">7</span>;					</span><br><span class="line">				&#125;				</span><br><span class="line">			&#125;																			</span><br><span class="line">			<span class="comment">//2.7. 发送数据</span></span><br><span class="line">			usb_class_in(dat);   <span class="comment">// 0000 0000</span></span><br><span class="line">			</span><br><span class="line">		  <span class="comment">//为了记录这次发送键位数据给PC的时候，16个按键是个什么状态。</span></span><br><span class="line">			last_status = status;  <span class="comment">// 1111 1111 1111 1111</span></span><br><span class="line">		</span><br><span class="line">			delay_ms(<span class="number">20</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PC 向 STC8H 发送状态更新报告</strong></p>
<p>接收 PC 端发送过来的报告是模拟功能键的功能</p>
<p>例如：按下 NumLock键：指示灯亮起，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 PC 返回的报告进行响应或者处理是 STC8H 自动响应的我们只需找到处理函数然后调用我们的代码即可</span></span><br><span class="line"><span class="comment">// 当PC发送数据给键盘的时候，会调用这个函数</span></span><br><span class="line"><span class="comment">// 查看 usb_desc.c中返回值内容的格式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output Report:  【要站在PC的角度看输出的输入】  PC --------u8 dat--------&gt; 键盘</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数字锁定键 NumLock    大小写切换键  CapsLock   滚动锁定键  ScrollLock</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0   LEDs (D0:NumLock D1:CapLock D2:ScrollLock)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// usb_req_class.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hanlde_usb_out</span><span class="params">(BYTE led)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">usb_class_out</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">	 <span class="keyword">if</span> (usb_bulk_intr_out(UsbBuffer, <span class="number">1</span>) == <span class="number">1</span>)&#123;		</span><br><span class="line">			<span class="comment">//直接调用我们的函数</span></span><br><span class="line">			hanlde_usb_out( UsbBuffer[<span class="number">0</span>]);		 </span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    BYTE led;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    if (usb_bulk_intr_out(UsbBuffer, 1) == 1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        P4M0 &amp;= ~0x01;</span></span><br><span class="line"><span class="comment">        P4M1 &amp;= ~0x01;</span></span><br><span class="line"><span class="comment">        P6M0 &amp;= ~0xe0;</span></span><br><span class="line"><span class="comment">        P6M1 &amp;= ~0xe0;</span></span><br><span class="line"><span class="comment">        P40 = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        led = UsbBuffer[0];</span></span><br><span class="line"><span class="comment">        LED_NUM = !(led &amp; 0x01);</span></span><br><span class="line"><span class="comment">        LED_CAPS = !(led &amp; 0x02);</span></span><br><span class="line"><span class="comment">        LED_SCROLL = !(led &amp; 0x04);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">===============================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">//处理键盘收到PC的数据  </span></span><br><span class="line"><span class="comment">// 0   LEDs (D0:NumLock D1:CapLock D2:ScrollLock)</span></span><br><span class="line"><span class="type">void</span> hanlde_usb_out(BYTE led)&#123; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		PC返回的值是这样的，按下第一次返回0，按下第二次就返回1，按下第三次就返回0，按下第四次就返回1，以此类推...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//LED1 = led &amp; 0x01;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//if( led &amp; (1&lt;&lt;0) ) LED1 = ~LED1; //亮起来;  按下了数字锁定键</span></span><br><span class="line">	<span class="comment">//if( led &amp; (1&lt;&lt;1) ) LED2 = ~LED2; //亮起来;  按下了大小写切换键</span></span><br><span class="line">	<span class="comment">//if( led &amp; (1&lt;&lt;2) ) LED3 = ~LED3; //亮起来;  按下了滚动锁定键</span></span><br><span class="line">	</span><br><span class="line">	LED1 = !(led &amp; <span class="number">0x01</span>);     <span class="comment">//亮起来;  按下了数字锁定键</span></span><br><span class="line">	LED5 = !(led &amp; <span class="number">0x02</span>);     <span class="comment">//亮起来;  按下了大小写切换键</span></span><br><span class="line">	LED8 = !(led &amp; <span class="number">0x04</span>);     <span class="comment">//亮起来;  按下了滚动锁定键	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C_OLED显示</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/I2C_OLED%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p><strong>OLED（有机发光二极管，Organic Light-Emitting Diode）</strong> 是一种显示技术，通过使用有机材料在电流通过时自发光来产生图像。与传统的 LCD（液晶显示器）不同，OLED 不需要背光源，因此可以实现更薄的显示器，并且具备许多独特的优点。</p>
<h2 id="I2C-协议"><a href="#I2C-协议" class="headerlink" title="I2C 协议"></a>I2C 协议</h2><p>I2C（Inter-Integrated Circuit）协议是一种广泛使用的<strong>双线同步串行通信协议</strong>，由飞利浦半导体（现为恩智浦半导体）在1982年发明。该协议以其简单的硬件连接和灵活的设备支持，在嵌入式系统和各种电子设备中得到了广泛应用。</p>
<p><strong>I2C 特点</strong></p>
<ul>
<li><strong>双线通信</strong>：I2C 是一种<strong>双线通信</strong>协议，使用两条线进行数据传输<ul>
<li><strong>SDA（Serial Data Line）</strong>: 用于数据传输的双向数据线。</li>
<li><strong>SCL（Serial Clock Line）</strong>: 用于同步数据传输的时钟线，由主设备生成时钟信号。</li>
</ul>
</li>
<li><strong>主从架构</strong>：支持<strong>多个主设备</strong>和<strong>多个从设备</strong>，可以灵活配置<ul>
<li><strong>主设备（Master）</strong>: 控制通信过程，生成时钟信号，并决定是发送数据还是接收数据。</li>
<li><strong>从设备（Slave）</strong>: 被动响应主设备的操作，它根据主设备发出的指令接收或发送数据。</li>
<li><strong>唯一地址</strong>: 每个从设备在总线上都有一个唯一的 7 位或 10 位地址，主设备通过地址识别与哪个从设备通信。</li>
</ul>
</li>
<li><strong>同步通信</strong>：时钟信号由主设备控制，从设备被动接收；但多主设备时主设备之间不能同时发起通信。</li>
<li><strong>寻址机制</strong>：每个从设备都有一个唯一的地址，主设备通过地址来选择与哪个从设备通信。</li>
</ul>
<p><strong>I2C 的通信过程</strong></p>
<ol>
<li><p><strong>起始条件（START Condition）</strong></p>
<ul>
<li>主设备将 SDA 线从<strong>高电平拉低</strong>，同时 SCL 保持高电平。这告诉所有从设备即将开始通信。</li>
</ul>
</li>
<li><p><strong>发送设备地址（Address Phase）</strong></p>
<ul>
<li><p>主设备接着发送从设备的<strong>7 位地址</strong>（或 10 位地址，视协议扩展），紧接着一个<strong>读&#x2F;写位</strong>（1 表示读，0 表示写）。SDA 在 SCL 时钟的<strong>高电平期间</strong>发送地址。</p>
</li>
<li><p>从设备检查地址是否与自身匹配，匹配的设备将准备回应。</p>
</li>
</ul>
</li>
<li><p><strong>应答（ACK&#x2F;NACK）</strong></p>
<ul>
<li>在地址发送后，从设备将<strong>拉低 SDA 线</strong>表示应答（ACK）。如果 SDA 保持高电平，则表示无应答（NACK），通信终止。</li>
</ul>
</li>
<li><p><strong>数据传输（Data Transfer Phase）</strong></p>
<ul>
<li><p>主设备开始发送或接收数据（视读&#x2F;写位）。每次数据传输是 8 位，数据在 SCL 线的<strong>高电平期间</strong>稳定，接收端读取数据。</p>
</li>
<li><p>每 8 位数据后，接收端发送一个应答信号（ACK&#x2F;NACK）。如果发送结束，接收端会发 NACK，表示数据结束。</p>
</li>
</ul>
</li>
<li><p><strong>停止条件（STOP Condition）</strong></p>
<ul>
<li>主设备将 SDA 从<strong>低电平拉高</strong>，同时 SCL 保持高电平，表示数据传输结束，释放总线。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>通信流程总结：</strong></p>
<ol>
<li>起始条件（START）</li>
<li>发送设备地址 + 读&#x2F;写位</li>
<li>应答信号（ACK）</li>
<li>传输数据（8 位）</li>
<li>接收设备发送应答（ACK&#x2F;NACK）</li>
<li>如果有更多数据，重复步骤 4-5</li>
<li>发送停止条件（STOP）</li>
</ol>
<p>这种过程可以让主设备与多个从设备通信，因为每个从设备都有独立的地址。</p>
</blockquote>
<h2 id="SSD1306"><a href="#SSD1306" class="headerlink" title="SSD1306"></a>SSD1306</h2><p><strong>SSD1306</strong> 是一款常用的单色 OLED（有机发光二极管）显示控制器驱动芯片，广泛用于小型OLED屏幕中，如 128x64 或 128x32 分辨率的显示屏。它的设计专为驱动OLED面板，并通过 I2C、SPI 或并行接口与微控制器或单片机通信。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/OLEDyinjioatu.png" alt="OLEDyinjioatu"></p>
<h4 id="软件模拟"><a href="#软件模拟" class="headerlink" title="软件模拟"></a>软件模拟</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////	 </span></span><br><span class="line"><span class="comment">//本程序只供学习使用，未经作者许可，不得用于其它任何用途</span></span><br><span class="line"><span class="comment">//中景园电子</span></span><br><span class="line"><span class="comment">//店铺地址：http://shop73023976.taobao.com/?spm=2013.1.0.0.M4PqC2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  文 件 名   : main.c</span></span><br><span class="line"><span class="comment">//  版 本 号   : v2.0</span></span><br><span class="line"><span class="comment">//  作    者   : HuangKai</span></span><br><span class="line"><span class="comment">//  生成日期   : 2014-0101</span></span><br><span class="line"><span class="comment">//  最近修改   : </span></span><br><span class="line"><span class="comment">//  功能描述   : OLED 4接口演示例程(51系列)</span></span><br><span class="line"><span class="comment">//              说明: </span></span><br><span class="line"><span class="comment">//              ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//              GND    电源地</span></span><br><span class="line"><span class="comment">//              VCC  接5V或3.3v电源</span></span><br><span class="line"><span class="comment">//              SCL  P10（SCL）</span></span><br><span class="line"><span class="comment">//              SDA  P11（SDA）</span></span><br><span class="line"><span class="comment">//              RES  P12 注：SPI接口显示屏改成IIC接口时需要接RES引脚</span></span><br><span class="line"><span class="comment">//                           IIC接口显示屏用户请忽略</span></span><br><span class="line"><span class="comment">//              ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 修改历史   :</span></span><br><span class="line"><span class="comment">// 日    期   : </span></span><br><span class="line"><span class="comment">// 作    者   : HuangKai</span></span><br><span class="line"><span class="comment">// 修改内容   : 创建文件</span></span><br><span class="line"><span class="comment">//版权所有，盗版必究。</span></span><br><span class="line"><span class="comment">//Copyright(C) 中景园电子2014/3/16</span></span><br><span class="line"><span class="comment">//All rights reserved</span></span><br><span class="line"><span class="comment">//******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bmp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">	GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">	GPIO_Init.Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line"></span><br><span class="line">	GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">		u8 t=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">	GPIO_Config();</span><br><span class="line">	OLED_Init();<span class="comment">//初始化OLED</span></span><br><span class="line">	</span><br><span class="line">	OLED_ColorTurn(<span class="number">0</span>);<span class="comment">//0正常显示，1 反色显示</span></span><br><span class="line">  	OLED_DisplayTurn(<span class="number">0</span>);<span class="comment">//0正常显示 1 屏幕翻转显示</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;		</span><br><span class="line">		OLED_DrawBMP(<span class="number">0</span>,<span class="number">0</span>,<span class="number">128</span>,<span class="number">64</span>,BMP1);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_Clear();</span><br><span class="line">		OLED_ShowChinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">16</span>);<span class="comment">//中</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">16</span>);<span class="comment">//景</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">16</span>);<span class="comment">//园</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">16</span>);<span class="comment">//电</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">16</span>);<span class="comment">//子</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">16</span>);<span class="comment">//科</span></span><br><span class="line">		OLED_ShowChinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">16</span>);<span class="comment">//技</span></span><br><span class="line">		OLED_ShowString(<span class="number">8</span>,<span class="number">2</span>,<span class="string">&quot;ZHONGJINGYUAN&quot;</span>,<span class="number">16</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">20</span>,<span class="number">4</span>,<span class="string">&quot;2014/05/01&quot;</span>,<span class="number">16</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">0</span>,<span class="number">6</span>,<span class="string">&quot;ASCII:&quot;</span>,<span class="number">16</span>);  </span><br><span class="line">		OLED_ShowString(<span class="number">63</span>,<span class="number">6</span>,<span class="string">&quot;CODE:&quot;</span>,<span class="number">16</span>);</span><br><span class="line">		OLED_ShowChar(<span class="number">48</span>,<span class="number">6</span>,t,<span class="number">16</span>);</span><br><span class="line">		t++;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;<span class="string">&#x27;~&#x27;</span>)t=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		OLED_ShowNum(<span class="number">103</span>,<span class="number">6</span>,t,<span class="number">3</span>,<span class="number">16</span>);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_Clear();</span><br><span class="line">	&#125;	  	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">// olde.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span>	  	 </span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD  0	<span class="comment">//写命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 1	<span class="comment">//写数据</span></span></span><br><span class="line"></span><br><span class="line">sbit OLED_SCL=P3^<span class="number">2</span>;<span class="comment">//SCL</span></span><br><span class="line">sbit OLED_SDA=P3^<span class="number">3</span>;<span class="comment">//SDA</span></span><br><span class="line">sbit OLED_RES =P1^<span class="number">2</span>;<span class="comment">//RES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------OLED端口定义----------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCL_Clr() OLED_SCL=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCL_Set() OLED_SCL=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SDA_Clr() OLED_SDA=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SDA_Set() OLED_SDA=1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_RES_Clr() OLED_RES=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_RES_Set() OLED_RES=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED控制用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ColorTurn</span><span class="params">(u8 i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DisplayTurn</span><span class="params">(u8 i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 sizey)</span>;</span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 sizey)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 sizey)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(u8 x,u8 y,u8 no,u8 sizey)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(u8 x,u8 y,u8 sizex, u8 sizey,u8 BMP[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// olde.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span>  	 </span></span><br><span class="line"><span class="comment">//OLED的显存</span></span><br><span class="line"><span class="comment">//存放格式如下.</span></span><br><span class="line"><span class="comment">//[0]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[1]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[2]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[3]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[4]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[5]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[6]0 1 2 3 ... 127	</span></span><br><span class="line"><span class="comment">//[7]0 1 2 3 ... 127 			   </span></span><br><span class="line"><span class="type">void</span> delay_ms(<span class="type">unsigned</span> <span class="type">int</span> ms) &#123;                         </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">while</span>(ms) &#123;</span><br><span class="line">		a=<span class="number">1800</span>;</span><br><span class="line">		<span class="keyword">while</span>(a--);</span><br><span class="line">		ms--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反显函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ColorTurn</span><span class="params">(u8 i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//正常显示</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA7</span>,OLED_CMD);<span class="comment">//反色显示</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕旋转180度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DisplayTurn</span><span class="params">(u8 i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//正常显示</span></span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			OLED_WR_Byte(<span class="number">0xC0</span>,OLED_CMD);<span class="comment">//反转显示</span></span><br><span class="line">			OLED_WR_Byte(<span class="number">0xA0</span>,OLED_CMD);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_delay</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u8 t=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//起始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_SDA_Set();</span><br><span class="line">	OLED_SCL_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SDA_Clr();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SCL_Clr();	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_SDA_Clr();</span><br><span class="line">	OLED_SCL_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SDA_Set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待信号响应</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_WaitAck</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">//测数据信号的电平</span></span><br><span class="line">	OLED_SDA_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SCL_Set();</span><br><span class="line">	IIC_delay();</span><br><span class="line">	OLED_SCL_Clr();</span><br><span class="line">	IIC_delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Send_Byte</span><span class="params">(u8 dat)</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;        </span><br><span class="line">		OLED_SCL_Clr();<span class="comment">//将时钟信号设置为低电平</span></span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>) &#123; <span class="comment">//将dat的8位从最高位依次写入</span></span><br><span class="line">			OLED_SDA_Set();</span><br><span class="line">    	&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			OLED_SDA_Clr();</span><br><span class="line">    	&#125;</span><br><span class="line">		IIC_delay(); <span class="comment">// 延时</span></span><br><span class="line">		OLED_SCL_Set(); <span class="comment">// 拉高信号线（高电平时写入）</span></span><br><span class="line">		IIC_delay(); 	<span class="comment">// 延时</span></span><br><span class="line">		OLED_SCL_Clr(); <span class="comment">// 拉低信号线</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送一个字节</span></span><br><span class="line"><span class="comment">//向SSD1306写入一个字节。</span></span><br><span class="line"><span class="comment">//mode:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(u8 dat,u8 mode)</span> &#123;</span><br><span class="line">	I2C_Start();</span><br><span class="line">	Send_Byte(<span class="number">0x78</span>);</span><br><span class="line">	I2C_WaitAck();</span><br><span class="line">	<span class="keyword">if</span>(mode)&#123;Send_Byte(<span class="number">0x40</span>);&#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;Send_Byte(<span class="number">0x00</span>);&#125;</span><br><span class="line">	I2C_WaitAck();</span><br><span class="line">	Send_Byte(dat);</span><br><span class="line">	I2C_WaitAck();</span><br><span class="line">	I2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(u8 x, u8 y)</span> &#123; </span><br><span class="line">	OLED_WR_Byte(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">	OLED_WR_Byte(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">	OLED_WR_Byte((x&amp;<span class="number">0x0f</span>),OLED_CMD);</span><br><span class="line">&#125;   	  </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;		   			 </span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!	  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span> &#123;  </span><br><span class="line">	u8 i,n;		    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;  </span><br><span class="line">		OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">		OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">		OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line">		<span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">0</span>,OLED_DATA); </span><br><span class="line">	&#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63				 </span></span><br><span class="line"><span class="comment">//sizey:选择字体 6x8  8x16</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 sizey)</span> &#123;      	</span><br><span class="line">	u8 c=<span class="number">0</span>,sizex=sizey/<span class="number">2</span>;</span><br><span class="line">	u16 i=<span class="number">0</span>,size1;</span><br><span class="line">	<span class="keyword">if</span>(sizey==<span class="number">8</span>)size1=<span class="number">6</span>;</span><br><span class="line">	<span class="keyword">else</span> size1=(sizey/<span class="number">8</span>+((sizey%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*(sizey/<span class="number">2</span>);</span><br><span class="line">	c=chr-<span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值</span></span><br><span class="line">	OLED_Set_Pos(x,y);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size1;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i%sizex==<span class="number">0</span>&amp;&amp;sizey!=<span class="number">8</span>) OLED_Set_Pos(x,y++);</span><br><span class="line">		<span class="keyword">if</span>(sizey==<span class="number">8</span>) OLED_WR_Byte(asc2_0806[c][i],OLED_DATA);<span class="comment">//6X8字号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">16</span>) OLED_WR_Byte(asc2_1608[c][i],OLED_DATA);<span class="comment">//8x16字号</span></span><br><span class="line"><span class="comment">//		else if(sizey==xx) OLED_WR_Byte(asc2_xxxx[c][i],OLED_DATA);//用户添加字号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span> &#123;</span><br><span class="line">	u32 result=<span class="number">1</span>;	 </span><br><span class="line">	<span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;				  </span><br><span class="line"><span class="comment">//显示数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标</span></span><br><span class="line"><span class="comment">//num:要显示的数字</span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//sizey:字体大小		  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 sizey)</span> &#123;         	</span><br><span class="line">	u8 t,temp,m=<span class="number">0</span>;</span><br><span class="line">	u8 enshow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(sizey==<span class="number">8</span>)m=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++) &#123;</span><br><span class="line">		temp=(num/oled_pow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp==<span class="number">0</span>) &#123;</span><br><span class="line">				OLED_ShowChar(x+(sizey/<span class="number">2</span>+m)*t,y,<span class="string">&#x27; &#x27;</span>,sizey);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 	OLED_ShowChar(x+(sizey/<span class="number">2</span>+m)*t,y,temp+<span class="string">&#x27;0&#x27;</span>,sizey);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 sizey)</span> &#123;</span><br><span class="line">	u8 j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>) &#123;		</span><br><span class="line">		OLED_ShowChar(x,y,chr[j++],sizey);</span><br><span class="line">		<span class="keyword">if</span>(sizey==<span class="number">8</span>)x+=<span class="number">6</span>;</span><br><span class="line">		<span class="keyword">else</span> x+=sizey/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(u8 x,u8 y,u8 no,u8 sizey)</span> &#123;</span><br><span class="line">	u16 i,size1=(sizey/<span class="number">8</span>+((sizey%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*sizey;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size1;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i%sizey==<span class="number">0</span>) OLED_Set_Pos(x,y++);</span><br><span class="line">		<span class="keyword">if</span>(sizey==<span class="number">16</span>) OLED_WR_Byte(Hzk[no][i],OLED_DATA);<span class="comment">//16x16字号</span></span><br><span class="line"><span class="comment">//		else if(sizey==xx) OLED_WR_Byte(xxx[c][i],OLED_DATA);//用户添加字号</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示图片</span></span><br><span class="line"><span class="comment">//x,y显示坐标</span></span><br><span class="line"><span class="comment">//sizex,sizey,图片长宽</span></span><br><span class="line"><span class="comment">//BMP：要显示的图片</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(u8 x,u8 y,u8 sizex, u8 sizey,u8 BMP[])</span> &#123; 	</span><br><span class="line">  u16 j=<span class="number">0</span>;</span><br><span class="line">	u8 i,m;</span><br><span class="line">	sizey=sizey/<span class="number">8</span>+((sizey%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sizey;i++) &#123;</span><br><span class="line">		OLED_Set_Pos(x,i+y);</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;sizex;m++) &#123;      </span><br><span class="line">			OLED_WR_Byte(BMP[j++],OLED_DATA);	    	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化				    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	OLED_RES_Clr();</span><br><span class="line">	delay_ms(<span class="number">200</span>);</span><br><span class="line">	OLED_RES_Set();</span><br><span class="line">	</span><br><span class="line">	OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD);<span class="comment">//--turn off oled panel</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//---set low column address</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//---set high column address</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD);<span class="comment">//--set contrast control register</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xCF</span>,OLED_CMD); <span class="comment">// Set SEG Output Current Brightness</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);<span class="comment">//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//--set normal display</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//--1/64 duty</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD);<span class="comment">//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//-not offset</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//--set display clock divide ratio/oscillator frequency</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//--set divide ratio, Set Clock as 100 Frames/Sec</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD);<span class="comment">//--set pre-charge period</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xF1</span>,OLED_CMD);<span class="comment">//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD);<span class="comment">//--set com pins hardware configuration</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD);</span><br><span class="line">	OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD);<span class="comment">//--set vcomh</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//Set VCOM Deselect Level</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x20</span>,OLED_CMD);<span class="comment">//-Set Page Addressing Mode (0x00/0x01/0x02)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x02</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD);<span class="comment">//--set Charge Pump enable/disable</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//--set(0x10) disable</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA4</span>,OLED_CMD);<span class="comment">// Disable Entire Display On (0xa4/0xa5)</span></span><br><span class="line">	OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">// Disable Inverse Display On (0xa6/a7) </span></span><br><span class="line">	OLED_Clear();</span><br><span class="line">	OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD); <span class="comment">/*display ON*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>STC8H 本身支持硬件实现，就是不用上面他们写的函数，给换成我们 STC8H 库函数中的读写函数就可以了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C总线</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/I2C%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p><strong>I2C（Inter-Integrated Circuit）是一种用于短距离通信</strong>的<strong>半双工同步串行</strong>通信<strong>协议</strong>，通常用于在电子设备中连接微控制器、传感器、显示器、EEPROM、ADC&#x2F;DAC 等外围器件。它由飞利浦公司在1982年发明，目的是简化不同集成电路之间的通信需求。</p>
<p>I2C协议采用了<strong>双线</strong>设计，使得多个设备可以通过<strong>同一条总线（数据线）</strong>互相通信，具有简单、灵活和高效的特点，广泛应用于嵌入式系统中。</p>
<p><strong>半双工：</strong>半双工通信是指在同一时间内，数据可以在两个方向上传输，但不能同时进行。换句话说，通信设备可以在发送和接收之间切换，但在任何给定的时刻只能进行一种操作。即使在同一总线上，主设备不能同时向从设备发送数据并接收数据。</p>
<p><strong>同步：</strong>同步通信是指数据的传输是通过一个共同的时钟信号进行协调的。所有参与通信的设备都依赖于同一时钟信号来发送和接收数据。</p>
<p><strong>串行通信：</strong>串行通信是指数据以逐位（bit）的形式进行传输，而不是一次传输多个数据位。</p>
<h2 id="I2C-的关键特性"><a href="#I2C-的关键特性" class="headerlink" title="I2C 的关键特性"></a>I2C 的关键特性</h2><ol>
<li><p><strong>主从结构</strong>：I2C是一种<strong>主从通信协议</strong>，其中<strong>主设备（Master）</strong>负责<strong>控制</strong>总线，启动和停止数据传输，管理时钟信号，而<strong>从设备（Slave）</strong>则<strong>被动响应</strong>主设备的请求。通常只有一个主设备，也支持多个主设备共存的架构。</p>
</li>
<li><p><strong>双线设计</strong>：I2C协议使用两条主要的信号线：</p>
<ul>
<li><p><strong>SDA（数据线，Serial Data Line）</strong>：用于传输数据。</p>
</li>
<li><p><strong>SCL（时钟线，Serial Clock Line）</strong>：用于同步数据传输。</p>
</li>
</ul>
<p>两根线都使用<strong>开漏（Open-drain）</strong>设计，需要外部上拉电阻来将信号线拉到高电平。</p>
</li>
<li><p><strong>设备寻址</strong>：I2C 总线上可以连接多个从设备，每个从设备有唯一的<strong>7位或10位地址</strong>。主设备通过发送目标从设备的地址来选择与哪个从设备通信。</p>
</li>
<li><p><strong>双向通信</strong>：</p>
<ul>
<li>I2C 支持<strong>半双工通信</strong>，数据可以在SDA线上<strong>双向传输</strong>，即主设备既可以发送数据给从设备，也可以从从设备接收数据。</li>
</ul>
</li>
<li><p><strong>同步通信</strong>：</p>
<ul>
<li>I2C 使用时钟信号（SCL）同步主设备和从设备之间的数据传输，保证每个数据位都在时钟信号的上升或下降沿有效。</li>
</ul>
</li>
</ol>
<blockquote>
<p>I2C协议使用开漏设计来实现 SDA 和 SCL 线的多设备连接。由于 I2C 总线上的多个设备需要共享 SDA 和 SCL 线，开漏设计允许多个设备通过<strong>拉低信号线来发送数据</strong>，而不会干扰其他设备的通信。上拉电阻确保信号线在没有设备拉低时维持高电平状态。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Czhuchong.png" alt="I2Czhuchong"></p>
<blockquote>
<ol>
<li>Master: 主设备。通常是主控 MCU</li>
<li>Slave：从设备。通常是功能芯片，例如 RTC 时钟，陀螺仪，温湿度等等。</li>
<li>SCL：时钟线，控制数据传输的速度和时序。</li>
<li>SDA：数据线。传输数据的。</li>
<li>地址：从设备地址。主设备通过地址进行访问。在总线中，每个从设备地址唯一，设备的地址通常是由设备制造商确定的，并在设备的数据手册中公布。。</li>
</ol>
</blockquote>
<h4 id="上拉电阻"><a href="#上拉电阻" class="headerlink" title="上拉电阻"></a>上拉电阻</h4><p>在 I2C 总线中，上拉电阻的大小通常是由以下几个因素决定的：</p>
<ol>
<li>总线长度：总线长度越长，上拉电阻的阻值就应该越小，以保证信号的稳定性。这是因为，总线长度越长，线路上的电容就越大，需要更多的电流来充电和放电，因此上拉电阻的阻值也应该相应地减小。</li>
<li>总线上的设备数量：总线上连接的设备数量越多，需要更大的电流来充电和放电，以确保信号的稳定性。因此，当总线上连接的设备数量增加时，上拉电阻的阻值也应该相应地减小。</li>
<li>总线上设备的最高工作频率：I2C 总线的时钟频率通常在 100kHz 到 400kHz 之间。如果总线上的设备需要使用更高的时钟频率，则上拉电阻的阻值应该相应地减小，以确保设备能够在规定的时间内完成数据的传输。</li>
</ol>
<p>总的来说，I2C 总线中上拉电阻的大小需要根据具体的情况来确定，以保证总线的稳定性和可靠性。一般来说，上拉电阻的阻值应该在 1kΩ 到 10kΩ 之间。</p>
<h4 id="信号电平"><a href="#信号电平" class="headerlink" title="信号电平"></a><strong>信号电平</strong></h4><p>I2C 总线的信号电平是基于器件的供电电压而定的，通常为 3.3V 或 5V。在 I2C 总线上，<strong>SDA 和 SCL 信号线都是开漏模式</strong>，因此需要外接上拉电阻，以避免信号电平的不确定性。（默认高电平）</p>
<h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>I2C 总线的速度是由其<strong>时钟频率</strong>决定的。I2C 总线的时钟频率通常在 100kHz 到 400kHz 之间，其中 100kHz 是标准模式（Standard Mode），400kHz 是快速模式（Fast Mode）。</p>
<ul>
<li>在标准模式下，I2C 总线的时钟频率为 100kHz，数据传输速率最高可以达到每秒约 10kbps。标准模式适用于大多数的应用场景，可以满足许多设备的数据传输需求。</li>
<li>在快速模式下，I2C 总线的时钟频率为 400kHz，数据传输速率最高可以达到每秒约 40kbps。快速模式适用于一些需要更高速度的应用场景，例如传感器数据采集等。</li>
</ul>
<p>此外，I2C 总线还支持更高速度的高速模式（High Speed Mode）和超高速模式（Ultra-Fast Mode），它们的时钟频率分别为 1MHz 和 5MHz。这些高速模式通常用于一些需要非常高速数据传输的应用场景。</p>
<p>需要注意的是，总线的速度不仅受时钟频率的影响，还受到总线长度、电容负载、上拉电阻大小等因素的影响。因此，在实际应用中，需要根据具体情况来确定总线的速度以确保数据传输的稳定性和可靠性。</p>
<h3 id="I2C-的实现方式"><a href="#I2C-的实现方式" class="headerlink" title="I2C 的实现方式"></a>I2C 的实现方式</h3><p>I2C 通信可以通过两种主要方式实现：<strong>硬件实现</strong>和<strong>软件模拟</strong>。</p>
<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>硬件实现指的是使用微控制器（MCU）或其他芯片<strong>内置的 I2C 硬件模块</strong>来进行通信。这种方式利用了专门设计的电路来管理I2C通信的所有细节，如时钟同步、地址识别和数据传输。</p>
<p><strong>优点</strong></p>
<ol>
<li><strong>效率高</strong>：硬件处理所有通信细节，无需软件干预，减少了 CPU 的负担。</li>
<li><strong>实时性强</strong>：通信快速且时序准确，不会受到软件处理速度的影响。</li>
<li><strong>简化编程</strong>：大多数硬件 I2C 模块提供简单的接口用于发送和接收数据，无需编写复杂的控制代码。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><strong>灵活性较低</strong>：硬件实现通常固定支持一定的速率和模式，难以适应特殊的通信需求。</li>
<li><strong>硬件依赖</strong>：只能在支持硬件 I2C 模块的芯片上使用。</li>
</ol>
<p><strong>注意点</strong></p>
<ul>
<li><strong>正确配置</strong>：确保正确设置 I2C 模块的时钟频率、从设备地址等参数。</li>
<li><strong>错误处理</strong>：编写代码时要考虑如何处理通信错误，如未应答、总线冲突等。</li>
<li><strong>电气特性</strong>：确保外围电路符合 I2C 的电气标准，例如上拉电阻的选择。</li>
</ul>
<h4 id="软件模拟（Bit-Banging）"><a href="#软件模拟（Bit-Banging）" class="headerlink" title="软件模拟（Bit-Banging）"></a>软件模拟（Bit-Banging）</h4><p>软件模拟，也称为Bit-Banging，是指通过软件<strong>控制普通的I&#x2F;O端口来模拟I2C通信</strong>。这种方式不依赖于硬件I2C模块，更加灵活。</p>
<p><strong>优点</strong></p>
<ol>
<li><strong>灵活性高</strong>：可以在任何具有GPIO功能的微控制器上实现。</li>
<li><strong>自定义能力强</strong>：可以根据需求自定义通信速率、时序等参数。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><strong>占用CPU资源</strong>：所有的通信过程都需要CPU来手动控制，可能影响程序的其他部分。</li>
<li><strong>实时性差</strong>：通信质量和速度受CPU处理能力和当前任务负载的影响。</li>
</ol>
<p><strong>注意点</strong></p>
<ul>
<li><strong>精确时序</strong>：软件模拟需要精确控制时序，特别是在高速通信时。</li>
<li><strong>中断管理</strong>：需要处理可能在通信过程中发生的中断，确保数据的完整性。</li>
<li><strong>跨平台兼容性</strong>：在不同的硬件平台上，相同的软件模拟代码可能需要调整以适应特定的时钟和性能特性。</li>
</ul>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>在开发中使用I2C协议进行通信的流程可以分为以下几个步骤：</p>
<p><strong>硬件连接</strong></p>
<p><strong>选择主设备和从设备地址</strong></p>
<p><strong>软件的初始化</strong></p>
<p>操作<strong>I2C 库函数 &#x2F; 寄存器</strong></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H 系列的单片机内部集成了一个 <strong>I2C 串行总线控制器</strong>。I2C 是一种高速同步通讯总线，通讯使用  SCL (时钟线)和 SDA (数据线)两线进行同步通讯。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Cyinjiao.png" alt="I2Cyinjiao"></p>
<blockquote>
<p>在 STC8H 中 I2C 的控制器位于特殊寄存器地址范围内，所以访问使用时需要开启特殊寄存器允许使能</p>
</blockquote>
<h3 id="I2C-的读写"><a href="#I2C-的读写" class="headerlink" title="I2C 的读写"></a>I2C 的读写</h3><p>I2C 总线使用一条数据线（SDA）和一条时钟线（SCL）进行通信，由主设备控制整个总线，通过<strong>发送从设备地址</strong>来指定目标设备，然后进行数据的读取或写入。以下是I2C协议下读取和写入数据的流程</p>
<p><strong>I2C 写数据时序图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Cxieshujushixutu.png" alt="I2Cxieshujushixutu.png"></p>
<p><strong>在 I²C 协议中，数据线 SDA 的变化需要在 SCL 为低电平时完成，而数据是由 SCL 时钟线的上升沿来锁定的。</strong></p>
<h4 id="I2C-的读取流程"><a href="#I2C-的读取流程" class="headerlink" title="I2C 的读取流程"></a>I2C 的读取流程</h4><ol>
<li><p><strong>发送起始命令</strong>：主设备产生起始信号，SDA 在 SCL 为高电平时从高电平<strong>拉低</strong>，标志通信的开始。</p>
</li>
<li><p><strong>发送从设备地址 + 写入信号</strong>：主设备将从设备的地址加上写入方向位（RW&#x3D;0表示写）发送到总线上。总共发送8位数据：7位地址 + 1位方向。</p>
<ul>
<li>从设备地址。I2C 总线上，每个从设备都有唯一的地址，用于主设备识别通信对象。</li>
</ul>
</li>
<li><p><strong>等待从设备应答（ACK）</strong>：从设备收到地址后，若该地址匹配，会返回一个 <strong>ACK 信号</strong>（将SDA线拉低）。主设备检测 ACK 信号确认从设备准备好了，主设备准备接收数据。</p>
</li>
<li><p><strong>发送存储地址</strong>：主设备发送存储地址（mem_addr），发送完成后，再次调用 <code>RecvACK()</code>，等待 ACK 信号。</p>
<ul>
<li>存储地址为从设备中的寄存器地址</li>
</ul>
</li>
<li><p><strong>再次发送起始命令</strong>：在准备读取数据之前，主设备重新生成 I2C 的<strong>起始条件</strong>，通知总线上所有设备通信重新开始。这是因为从设备现在需要进入读取模式。</p>
</li>
<li><p><strong>发送设备地址+读命令</strong>：主设备发送从设备地址，这次地址的最低位为1，表示要进行读取操作。dev_addr | 1 通过将写位设置为 1，表示主设备希望从从设备读取数据。</p>
</li>
<li><p><strong>等待从设备应答</strong>：发送完从设备地址后的读命令，主设备再次等待从设备返回一个 ACK 信号，确认从设备已经准备好开始数据传输。</p>
</li>
<li><p><strong>接收数据</strong>：主设备从从设备接收数据，每接收一个字节后，主设备可以发送一个 ACK 信号，表明数据接收成功，继续接收下一个字节。通常，在接收最后一个字节时，主设备会发送 NACK（非应答）信号，表示结束接收。</p>
</li>
<li><p><strong>发送停止型号</strong>：最后，主设备生成 I2C 的<strong>停止条件</strong>，表示通信结束。停止信号通过 SDA 线在 SCL 线为高电平时从低电平拉高产生，告诉从设备数据传输已完成，总线释放。(将 SDA 拉高)</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: void I2C_ReadNbyte(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span></span><br><span class="line"><span class="comment">// 描述: I2C读取数据函数.</span></span><br><span class="line"><span class="comment">// 参数: dev_addr: 设备地址, mem_addr: 存储地址, *p读取数据存储位置, number读取数据个数.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-15</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">/*  DeviceAddress,WordAddress,First Data Address,Byte lenth   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ReadNbyte</span><span class="params">(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span>   </span><br><span class="line">&#123;</span><br><span class="line">	Start();                                <span class="comment">//发送起始命令</span></span><br><span class="line">	SendData(dev_addr);                     <span class="comment">//发送设备地址+写命令</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	SendData(mem_addr);                     <span class="comment">//发送存储地址</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	Start();                                <span class="comment">//发送起始命令</span></span><br><span class="line">	SendData(dev_addr|<span class="number">1</span>);                   <span class="comment">//发送设备地址+读命令</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		*p = RecvData(); <span class="comment">// 读取数据并存储到缓冲区</span></span><br><span class="line">		p++;</span><br><span class="line">		<span class="keyword">if</span>(number != <span class="number">1</span>) SendACK();          <span class="comment">//send ACK</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(--number);</span><br><span class="line">	SendNAK();                              <span class="comment">//send no ACK	</span></span><br><span class="line">	Stop();                                 <span class="comment">//发送停止命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="I2C-的写入流程"><a href="#I2C-的写入流程" class="headerlink" title="I2C 的写入流程"></a>I2C 的写入流程</h4><p>写入流程与读取流程类似~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: void I2C_WriteNbyte(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span></span><br><span class="line"><span class="comment">// 描述: I2C写入数据函数.</span></span><br><span class="line"><span class="comment">// 参数: dev_addr: 设备地址, mem_addr: 存储地址, *p写入数据存储位置, number写入数据个数.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-15</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">/*  DeviceAddress,WordAddress,First Data Address,Byte lenth   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_WriteNbyte</span><span class="params">(u8 dev_addr, u8 mem_addr, u8 *p, u8 number)</span>  </span><br><span class="line">&#123;</span><br><span class="line">	Start();                                <span class="comment">//发送起始命令</span></span><br><span class="line">	SendData(dev_addr);                     <span class="comment">//发送设备地址+写命令</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	SendData(mem_addr);                     <span class="comment">//发送存储地址</span></span><br><span class="line">	RecvACK();</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendData(*p++);</span><br><span class="line">		RecvACK();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(--number);</span><br><span class="line">	Stop();                                 <span class="comment">//发送停止命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>I2C 是个通信协议，那为啥还有什么 I2C 的串行控制总线控制器呢，我不理解的地方在于，协议直接遵守实用就好了，为什么还需要配个控制器?</strong></p>
<ul>
<li><p><strong>I2C协议</strong>：是一个<strong>通信协议</strong>，定义了设备间如何通过两条线（SDA 数据线，SCL 时钟线）进行数据交换。这个协议规定了设备如何开始通信、发送数据、确认数据接收、结束通信等细节。</p>
</li>
<li><p><strong>I2C控制器</strong>：是<strong>硬件上的实现</strong>，用于帮助微控制器（MCU）或处理器遵守 I2C 协议进行通信。I2C 控制器负责处理协议中的细节，比如生成时钟信号、发送和接收数据、处理起始条件、停止条件、应答信号等。</p>
</li>
</ul>
<p>二、<strong>为什么需要 I2C 控制器?</strong></p>
<p>虽然 I2C 协议是一个标准，但协议本身只是一套规则，实际通信的实现需要底层的硬件电路来处理时序、信号生成、数据传输等任务。如果没有 I2C 控制器，微控制器将需要通过软件代码逐位操作引脚，手动处理所有协议细节。这是非常复杂且低效的。</p>
<p>三、<strong>在使用时，如何知道是传入写地址为设备从地址，还是传入读地址作为设备从地址？</strong></p>
<p>在 I2C 通信中，当要求传入从设备地址时，通常只需要传入 7 位的 <strong>从设备地址</strong>，即不需要区分读地址和写地址，传入的是设备的基础地址。</p>
<p>当然在一些微控制器中，比如 STC8H，它内部的 I2C 寄存器不自动处理 7 位地址和 R&#x2F;W 位，所以需要手动提供完整的 8 位地址；这时候就需要去查看<strong>数据手册</strong>、或者示例代码、又或者是具体的实现方式，查看他具体传输的是哪一个(当然一般在有 I2C 寄存器的芯片中，传输的从设备地址都是写地址)。</p>
<p>四、<strong>什么是开漏模式</strong></p>
<p><strong>开漏（open-drain）</strong> 指设备内部<strong>只能通过拉低引脚来输出低电平，而不能主动输出高电平(也就是说将引脚置 1 时，它是通过上拉电阻输出高电平的)。引脚的高电平由外部的上拉电阻提供</strong>，当设备不拉低引脚时，电压通过上拉电阻升高到逻辑高电平。</p>
<p>五、<strong>默认情况下（因为有上拉电阻），数据线不是一直是1么，他是一直向从设备传输1么？</strong></p>
<p>在 I2C 通信中，虽然数据线 <strong>SDA</strong> 和时钟线 <strong>SCL</strong> 默认情况下通过上拉电阻处于高电平（<strong>1</strong>），但这并不意味着总线在默认状态下一直传输 <strong>1</strong>。实际上，I2C 通信的关键在于时钟线 <strong>SCL</strong> 的配合，数据传输只在时钟有效时发生。下面是更详细的解释：</p>
<ol>
<li><strong>默认高电平的含义</strong></li>
</ol>
<ul>
<li><p><strong>SDA 和 SCL</strong> 默认处于高电平状态是为了表示 <strong>总线空闲</strong>。高电平表示当前没有通信正在进行。</p>
</li>
<li><p>高电平是因为没有设备主动拉低 SDA 或 SCL，这只是表示线路空闲，并不是传输 <strong>1</strong>。</p>
</li>
</ul>
<ol start="2">
<li><strong>通信开始（起始条件）</strong></li>
</ol>
<p>​	通信的开始由 <strong>主设备</strong> 发送<strong>起始条件</strong>来触发，起始条件的定义是：</p>
<ul>
<li><strong>SCL 处于高电平</strong> 时，主设备将 <strong>SDA</strong> 由 <strong>高电平拉低到低电平</strong>，这标志着通信的开始。</li>
<li>在此之后，主设备会根据时钟信号 <strong>SCL</strong> 控制 SDA 的电平，开始发送数据位。</li>
</ul>
<ol start="3">
<li><strong>数据传输的机制</strong></li>
</ol>
<p>​	数据的传输发生在 <strong>SCL 时钟信号的高电平周期</strong>，这时候 <strong>SDA</strong> 线上传输的是有效数据。</p>
<ul>
<li><strong>发送 0</strong>：主设备或从设备会主动拉低 <strong>SDA</strong> 线。</li>
<li><strong>发送 1</strong>：设备不会拉低 <strong>SDA</strong> 线，SDA 保持由上拉电阻提供的高电平。</li>
</ul>
<p>​	只有在 <strong>SCL 高电平</strong> 时，SDA 上的电平才会被解读为有效数据（<strong>0 或 1</strong>）。如果 SCL 处于低电平，SDA 的变化不被视为数据。</p>
<ol start="4">
<li><strong>数据线高电平不代表传输 1</strong></li>
</ol>
<ul>
<li><p><strong>SDA 默认高电平</strong> 并不意味着设备在传输 <strong>1</strong>。I²C 通信遵循特定的时序，只有在 <strong>SCL 高电平期间</strong> 读取 SDA 的状态，才能确定传输的是 <strong>0</strong> 还是 <strong>1</strong>。</p>
</li>
<li><p>当 <strong>总线空闲</strong>（即没有通信）时，SDA 和 SCL 线都保持高电平。但通信没有开始，所以没有传输任何有效数据。</p>
</li>
</ul>
<p>当 I²C 总线空闲时，<strong>SDA 和 SCL</strong> 都是高电平，这表示 <strong>没有通信正在进行</strong>，而不是在传输 <strong>1</strong>。</p>
<p><strong>数据传输</strong> 只会在通信启动（即发送起始条件）后，根据 <strong>SCL 时钟线的高低电平周期</strong>，在 SDA 线上传输有效数据位（0 或 1）。</p>
<p><strong>默认高电平</strong> 只是空闲状态，数据的传输取决于时钟信号的配合和 SDA 线的实际电平状态。</p>
<p>因此，虽然 SDA 线在空闲时是高电平，但它不会一直向从设备传输 <strong>1</strong>，只有在配合时钟信号的情况下，才会通过 SDA 传输有效的 <strong>0 或 1</strong>。</p>
<p>六、<strong>在下面这函数中我将最后的 OLED_SCL_Clr(); &#x2F;&#x2F; 拉低 SCL 去掉可以么，有什么影响？，为什么每个循环结束都要拉低 SCL</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Send_Byte</span><span class="params">(u8 dat)</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">		OLED_SCL_Clr();<span class="comment">// 将时钟信号设置为低电平</span></span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>) &#123; <span class="comment">// 将 dat 的 8 位从最高位依次写入</span></span><br><span class="line">			OLED_SDA_Set(); <span class="comment">// 将数据信号设置为高电平</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			OLED_SDA_Clr(); <span class="comment">// 将数据信号设置为低电平</span></span><br><span class="line">    &#125;</span><br><span class="line">		IIC_delay();</span><br><span class="line">		OLED_SCL_Set(); <span class="comment">// 将时钟信号设置为高电平，写入数据信号</span></span><br><span class="line">		IIC_delay();</span><br><span class="line">		OLED_SCL_Clr(); <span class="comment">// 将时钟信号设置为低电平</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你将最后的 <code>OLED_SCL_Clr();</code>（拉低 SCL）去掉，会导致 <strong>I2C 时钟线 SCL</strong> 一直处于 <strong>高电平</strong>，这会对整个 I2C 通信产生不良影响。</p>
<p>在 <strong>I2C 协议</strong> 中，SCL 的高低电平交替用于同步数据传输。如果你不在传输完一个位之后将 <strong>SCL 拉低</strong>，SCL 就会一直保持在 <strong>高电平</strong>。</p>
<p>当 <strong>SCL 一直保持高电平</strong> 时，会导致以下两个主要问题：</p>
<ol>
<li><p><strong>时钟信号被认为未结束</strong></p>
<ul>
<li><p>I2C 的通信是基于 <strong>SCL 的上升沿和下降沿</strong> 来控制数据传输和同步的。</p>
</li>
<li><p>每一位数据传输后，<strong>SCL 必须回到低电平</strong> 才能标志着该位传输完成。</p>
</li>
<li><p>如果没有拉低 SCL，下一个数据位的传输将无法开始，通信也可能陷入死锁或混乱状态。</p>
</li>
</ul>
</li>
<li><p><strong>I2C 从设备无法正确同步数据</strong></p>
<ul>
<li><strong>从设备</strong> 在每次 <strong>SCL 下降沿</strong> 后才准备好接收下一位数据。如果 SCL 没有被拉低，从设备可能会认为当前数据还在传输，无法同步到下一个时钟周期。</li>
</ul>
</li>
</ol>
<p>尽管在循环开始时已经拉低了 SCL，但是 <strong>在每次数据位传输后（也就是循环的结尾），需要再次拉低 SCL</strong>，确保时钟周期完整，并为下一个数据位的传输做准备。</p>
<p><strong>SCL 需要周期性地升高和降低</strong>，形成时钟信号，这样 I2C 通信才能正常进行。</p>
<p>七、<strong>SCL 的时钟是如何产生的</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>PWM</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/PWM/</url>
    <content><![CDATA[<p><strong>PWM（Pulse Width Modulation，脉宽调制）</strong> 是嵌入式开发中一种非常常见的信号调制技术。它通过调节<strong>脉冲信号的宽度</strong>（占空比），来控制电流或电压的平均值，以达到对设备（如电机、LED、音频设备等）的精确控制。</p>
<p><strong>PWM的基本概念：</strong></p>
<ol>
<li><strong>脉冲信号</strong>：<ul>
<li>PWM 信号是一个方波信号，它在一定时间周期内反复地在高电平（“开”）和低电平（“关”）之间切换。</li>
</ul>
</li>
<li><strong>周期（T）</strong>：<ul>
<li>PWM信号的周期是指一个完整方波的<strong>时间</strong>长度。通常用频率（Hz）来表示，频率是周期的倒数，即 <strong>频率 &#x3D; 1&#x2F;周期</strong>。</li>
<li>例如，如果 PWM 信号的周期为 2 毫秒（ms），那么频率 &#x3D; 1 &#x2F; (2 * 10<sup>-3</sup>) &#x3D; 500 Hz</li>
<li>频率是<strong>单位时间</strong>（一秒）内完成周期（一个高低电平）性变化的次数</li>
</ul>
</li>
<li><strong>占空比（Duty Cycle）</strong>：<ul>
<li>占空比是指信号在一个周期内处于<strong>高电平的时间长度</strong>与<strong>总周期长度</strong>的比例。占空比的范围从0%到100%。</li>
<li>占空比 &#x3D; （高电平时间 &#x2F; 总周期时间）× 100%<ul>
<li>例如，占空比为50%的PWM信号意味着高电平和低电平各占一半时间；占空比为25%则表示信号只有四分之一的时间处于高电平。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMzhouqimaichong.png" alt="PWMzhouqimaichong"></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H 系列的单片机内部集成了8 通道 16 位高级 PWM 定时器，分成两周期可不同的 PWM，分别命名为 PWMA 和PWMB ，可分别单独设置。</p>
<p>第一组 PWMA 可配置成 4 组互补 &#x2F; 对称 &#x2F; 死区控制 的PWM 或捕捉外部信号。</p>
<p>第二组 PWMB 可配置成 4 路PWM 输出或捕捉外部信号。</p>
<p>两组 PWM 的时钟频率可分别独立设置。</p>
<h3 id="输出占空比"><a href="#输出占空比" class="headerlink" title="输出占空比"></a>输出占空比</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>串口实现 PWM 启停 0x01启动，0x00停止</p>
<p>拷贝所需库文件（其他必备库请自行准备）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8H_PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PWM 周期时间设置为 1ms 24000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIOD (MAIN_Fosc/1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记位，是否更新PWM</span></span><br><span class="line"><span class="type">int</span> is_update_PWM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置马达 IO 引脚</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">    <span class="comment">// 摄制工作模式为 推挽输出</span></span><br><span class="line">    GPIO_Init.Mode = GPIO_OUT_PP;		</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_1;	    </span><br><span class="line">    GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 UART IO 引脚</span></span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    PWMx_InitDefine PWM_Init;</span><br><span class="line">    <span class="comment">// PWM 工作模式</span></span><br><span class="line">    PWM_Init.PWM_Mode = CCMRn_PWM_MODE1;</span><br><span class="line">    <span class="comment">// 设置周期时间 1ms</span></span><br><span class="line">    PWM_Init.PWM_Period = PERIOD - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置占空比</span></span><br><span class="line">    PWM_Init.PWM_Duty = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置死区时间</span></span><br><span class="line">    PWM_Init.PWM_DeadTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出通道选择</span></span><br><span class="line">    PWM_Init.PWM_EnoSelect = ENO6P;</span><br><span class="line">    <span class="comment">// 使能计数器，开启输入捕获/比较输出</span></span><br><span class="line">    PWM_Init.PWM_CEN_Enable = ENABLE;</span><br><span class="line">    <span class="comment">// 主使能输出</span></span><br><span class="line">    PWM_Init.PWM_MainOutEnable = ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 既要配置小组，也要配置大组</span></span><br><span class="line">    PWM_Configuration(PWM6, &amp;init);<span class="comment">// 初始化 PWM4 口</span></span><br><span class="line">    PWM_Configuration(PWMB, &amp;init);<span class="comment">// 初始化PWM通用寄存器,  PWMA,PWMB</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要开启中断使能</span></span><br><span class="line">    <span class="comment">// PWM 不涉及中断，但是可以使用中断，如不使用可以不配置</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 切换引脚</span></span><br><span class="line">    PWM6_SW(PWM6_SW_P01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx; <span class="comment">//模式,UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1; <span class="comment">//使用波特率, BRT_Timer1,BRT_Timer2,BRT_Timer3,BRT_Timer4</span></span><br><span class="line">    UART_Init.UART_BaudRate = <span class="number">115200ul</span>; <span class="comment">//波特率, 	   一般 110 ~ 115200</span></span><br><span class="line">    UART_Init.Morecommunicate = DISABLE;	<span class="comment">//多机通讯允许, ENABLE,DISABLE</span></span><br><span class="line">    UART_Init.UART_RxEnable = ENABLE; <span class="comment">//允许接收,   ENABLE,DISABLE</span></span><br><span class="line">    UART_Init.BaudRateDouble = ENABLE; <span class="comment">//波特率加倍, ENABLE,DISABLE</span></span><br><span class="line"></span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开串口中断使能</span></span><br><span class="line">    NVIC_UART1_Init(ENABLE, Priority_1);</span><br><span class="line">    <span class="comment">// 切换引脚</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> direction = <span class="number">1</span>; <span class="comment">//控制占空比的变化 1 / -1</span></span><br><span class="line"><span class="type">int</span> percent = <span class="number">0</span>; <span class="comment">// 占空比值    </span></span><br><span class="line">PWMx_Duty duty; <span class="comment">// 占空比设置结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动PWM马达</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_motor</span><span class="params">()</span> &#123;</span><br><span class="line">    PWM_Config();</span><br><span class="line">    <span class="comment">//让pwm从0开始</span></span><br><span class="line">    percent = <span class="number">0</span>;</span><br><span class="line">    direction = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止PWM马达</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop_motor</span><span class="params">()</span> &#123;</span><br><span class="line">    PWMx_InitDefine PWM_Init;</span><br><span class="line">    <span class="comment">// PWM 工作模式</span></span><br><span class="line">    PWM_Init.PWM_Mode = CCMRn_FORCE_INVALID;</span><br><span class="line">    PWM_Configuration(PWM6, &amp;init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 由于PWM的配置相关特殊功能寄存器位于扩展RAM区域，</span></span><br><span class="line">    <span class="comment">// 访问这些寄存器,需先将P_SW2的BIT7设置为1,才可正常读写。</span></span><br><span class="line">    EAXSFR(); <span class="comment">//  扩展寄存器访问使能   </span></span><br><span class="line">    GPIO_Config();</span><br><span class="line">    PWM_Config();    </span><br><span class="line">    UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据表示位判断是否跟新占空比</span></span><br><span class="line">        <span class="keyword">if</span>(is_update_PWM) &#123;</span><br><span class="line">            <span class="comment">// 占空比 0~100 循环</span></span><br><span class="line">            percent += direction;</span><br><span class="line">            <span class="keyword">if</span>(percent &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                direction = <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(percent &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                direction = <span class="number">1</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">            <span class="comment">// 设置占空比</span></span><br><span class="line">            duty.PWM6_Duty = PERIOD * percent / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 更新占空比</span></span><br><span class="line">            UpdatePwm(PWM6, &amp;duty);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 获取串口指令</span></span><br><span class="line">        <span class="keyword">if</span>(COM1.RX_Cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(RX1_Buffer[<span class="number">0</span>] == <span class="number">0x01</span>) &#123;</span><br><span class="line">                is_update_PWM = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 启动PWM</span></span><br><span class="line">                start_motor();               </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RX1_Buffer[<span class="number">0</span>] == <span class="number">0x00</span>) &#123;</span><br><span class="line">                is_update_PWM = <span class="number">0</span>;</span><br><span class="line">                stop_motor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        COM1.RX_Cnt = <span class="number">0</span>;   </span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">20</span>); </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>选择工作模式</strong></p>
<p>常用的有 模式1、模式2</p>
<p>一般来说，PWM 模式 2 是“下降模式”，即在计数器从最大值向下计数时输出高电平，而从0计数向上时输出低电平，反之亦然。这种模式决定了PWM信号的工作方式和输出形态。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMmoshi.png" alt="PWMmoshi.png"></p>
<p><strong>设置PWM的占空比</strong></p>
<p>占空比：<strong>占空比是指信号为高电平的时间与一个周期内总时间的比值</strong>（也可以理解为在一个 PWM 周期内高电平所占的比值）。占空比为0意味着信号始终为低电平，而占空比为100%意味着信号始终为高电平。</p>
<p><strong>选择PWM输出的通道</strong></p>
<p>正相&#x2F;反相输出：正相（P）输出即正常的PWM波形，而反相（N）输出是正相波形的反相信号。在某些场合，如电机控制，需要同时输出正反相信号。</p>
<blockquote>
<p>配置好后，直接通过物理引脚输出即可，为什么还要选择或者说设置一个”PWM输出的通道”?</p>
<p>不同的微控制器（MCU）通常内部有多个PWM生成模块。每个PWM模块内部可以生成多个不同的PWM信号，称为<strong>通道</strong>。</p>
<p>假设你使用一个MCU有一个定时器，可以生成4个PWM通道。如果你需要输出两个不同频率和占空比的 PWM 信号到两个引脚上，就可以配置通道 1 和通道 2，分别对应这两个 PWM 信号，并将它们分别映射到不同的物理引脚。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMtongdaoyinjiaotu.png" alt="PWMtongdaoyinjiaotu"></p>
<p><strong>设置PWM的周期</strong></p>
<p>PWM 周期指的是一个完整的 PWM 波形从开始到结束的时间长度，通常以时间单位（如毫秒或微秒）表示。在一个周期内，PWM 信号会从高电平变化到低电平，然后再回到高电平，形成一个完整的波形。</p>
<p>频率 &#x3D; 1&#x2F;周期：频率它描述了PWM信号中脉冲（或周期）出现的快慢。具体来说，频率是单位时间内脉冲重复出现的次数，通常用赫兹（Hz）作为单位来表示。例如，如果一个PWM信号的周期是1毫秒（ms），那么它的频率就是1毫秒的倒数，即1000次&#x2F;秒，或者说1千赫兹（kHz）。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/PWMzhouqitu.png" alt="PWMzhouqitu"></p>
<p>周期的长短决定了PWM信号的频率。周期越短，频率越高；周期越长，频率越低。具体的单位取决于定时器的配置和时钟频率。</p>
<blockquote>
<p>STC8H 的时钟频率为 24 000 000，也就是 1 秒内有 24 000 000 个周期变化</p>
<p>我们这里将 PWM 周期设置为 1 ms 也就是 24 000 000 &#x2F; 1000 &#x3D; 24 000个周期变化</p>
<p>我们没法通过赋值 1，2这样来设置周期，只能通过上述的方式来进行计算；</p>
</blockquote>
<p><strong>设置死区时间</strong></p>
<p>死区时间：在一些应用中，尤其是控制 H 桥电路或电机驱动时，正相和反相信号之间可能需要一个短暂的时间间隔，称为<strong>死区时间</strong>。这个间隔可以防止在两个 MOSFET 或者 IGBT 同时导通时造成短路。如果你不需要这种保护，就可以将死区时间设置为0。</p>
<p><strong>启用PWM主输出</strong></p>
<p>主输出：这是一个全局开关，控制所有已配置的PWM输出通道是否真正输出信号。如果设置为DISABLE，则即便其他配置已经完成，信号仍不会输出。</p>
<p><strong>启用定时器计数</strong></p>
<p>这通常是 PWM 定时器的使能控制位。当启用时，定时器开始计数并生成PWM波形。如果设置为DISABLE，定时器停止计数，PWM信号也停止输出。</p>
<blockquote>
<p><strong>PWM（脉宽调制）</strong> 一般需要配合<strong>计数器（定时器）</strong>一起使用。PWM信号的生成过程依赖于计数器的工作机制，定时器用于控制PWM信号的频率和占空比。定时器通过不断计数和重置，来实现PWM信号的周期性变化。</p>
</blockquote>
<p><strong>选择输出引脚</strong></p>
<p>这一步将具体的 PWM 通道与物理引脚进行绑定。PWM4 的正相和反相信号将分别从使用的引脚输出。</p>
<h3 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>为什么周期计算要 -1</strong></p>
<p>假设我们希望 PWM 信号的周期时间是 100 个时钟周期。</p>
<p>定时器会从 <code>0</code> 开始计数，到达 <code>99</code> 后重置回 <code>0</code>。(从 0 数到 99 一共 99 次，然后在加一 就变成 0 了 也就是 数了 100 次)</p>
<p>从 <code>0</code> 计到 <code>99</code>，共计 100 次。</p>
<p>因此，我们设定的周期值应当是 <code>100 - 1 = 99</code>。</p>
<p>二、<strong>PWM 要用到计数器，那么为什么没有配置，或者说配置的内容在哪</strong></p>
<p>三、<strong>特殊功能寄存器</strong></p>
<p>由于 PWM 的配置相关特殊功能寄存器位于扩展 RAM 区域，访问这些寄存器,需先将P_SW2 的 BIT7 设置为 1,才可正常读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EAXSFR();		<span class="comment">/* 扩展寄存器访问使能 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将 EAXFR 置1</span></span><br><span class="line"><span class="comment">STC8H.h</span></span><br><span class="line"><span class="comment">#define	EAXSFR()		P_SW2 |= 0x80 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/teshugongnengyjiaojicunqi.png" alt="teshugongnengyjiaojicunqi"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/teshujicunqishuom.png" alt="teshujicunqishuom"></p>
<blockquote>
<p>详细可参见STC8手册：</p>
<ul>
<li>3.1.2 《外设端口切换控制寄存器 2（P_SW2）》</li>
<li>9.2.8 《扩展 SFR 使能寄存器 EAXFR 的使用说明》</li>
</ul>
</blockquote>
<p>四、<strong>没有指定为高电平（1）为什么马达也可以震动？</strong></p>
<p>当你配置完占空比并指定引脚后，PWM 模块已经在你所指定的引脚上开始工作，产生脉冲信号。在 PWM 模式下，即便你没有手动拉高马达引脚，PWM 模块会自动根据配置产生高低电平信号。这种信号的变化（方波）会驱动马达振动。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC时钟</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/RTC%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<p>在嵌入式开发中，<strong>RTC（Real-Time Clock，实时时钟）</strong>是一个重要的<strong>硬件</strong>模块，用来跟踪当前的时间和日期。与一般的系统时钟不同，RTC 具有独立的电源（通常为电池），即使系统断电或进入低功耗模式，RTC 仍然能够保持运行。</p>
<blockquote>
<p>这个当前时间与日期，指的是我的 RTC 中设置的时间和日期，一般不是 PC 的当前时间和日期；</p>
</blockquote>
<p><strong>RTC的基本特性</strong></p>
<ul>
<li><p><strong>独立性</strong>：RTC 时钟是<strong>独立于系统主处理器运行的</strong>，即使系统进入低功耗模式或关机，RTC 仍然能正常计时。这通常是通过一块<strong>备用电池</strong>（如纽扣电池）来供电实现的，如果没有电池，系统断电后 RTC 会停止工作，导致时间信息丢失。</p>
</li>
<li><p><strong>低功耗</strong>：RTC 的设计非常节能，因为它需要在设备断电或处于待机状态下保持时间。典型的 RTC 功耗极低，使得它能够在备用电池的支持下持续工作多年。</p>
</li>
<li><p><strong>精度</strong>：RTC 时钟的频率通常由一个外部的 <strong>32.768kHz晶振</strong> 提供，这种频率的晶振能够精确跟踪时间变化。之所以选择这个频率，是因为它可以通过二进制的除法很方便地分频为1秒。</p>
<p>32.768kHz 可以是默认，也可以是可设置的</p>
</li>
<li><p><strong>计时功能</strong>：除了记录当前时间，RTC 通常还能提供<strong>闹钟、定时</strong>等功能。例如，可以设定某个时间触发闹钟中断，唤醒处理器执行特定任务。</p>
</li>
</ul>
<p><strong>RTC时钟的组成部分</strong></p>
<ul>
<li><p><strong>晶振（Oscillator）</strong>：通常，RTC 时钟使用一个 <strong>32.768kHz</strong> 的石英晶体振荡器来提供计时参考。这种晶振因为频率较低，功耗小，且稳定性高，适合长时间精确计时。</p>
</li>
<li><p><strong>备用电池</strong>：为了确保系统断电后，RTC 仍能继续保持正确的时间，通常会有一个小型纽扣电池为其供电。即使系统关闭或断电，RTC 依然可以正常工作。</p>
</li>
<li><p><strong>寄存器</strong>：RTC 中包含用于存储当前时间、日期、以及闹钟设定的寄存器。操作系统或嵌入式程序可以通过访问这些寄存器来获取或设置时间信息。</p>
</li>
</ul>
<p><strong>RTC 与系统时钟的区别</strong></p>
<ul>
<li><p><strong>RTC（实时时钟）</strong>：RTC的主要任务是记录“实际时间”，即年、月、日、时、分、秒等。它不依赖系统的运行状态，即使在设备断电的情况下，它仍能通过备用电池继续运行。</p>
</li>
<li><p><strong>系统时钟</strong>：系统时钟（或CPU时钟）是提供处理器和系统运行时基的时钟信号。它的频率通常较高（以MHz或GHz为单位），主要用于协调系统中各个组件的工作。</p>
</li>
</ul>
<p><strong>RTC 中时间和日期的存储</strong></p>
<p>RTC 负责跟踪当前的时间和日期，这些信息通常以寄存器的形式存储在 <strong>RTC 芯片</strong>中。不同 RTC 芯片的实现略有不同，但一般来说，RTC 会将时间和日期以<strong>二进制编码的十进制（BCD）格式</strong>或直接的<strong>二进制格式</strong>存储。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>以 PCF8563 为例</strong></p>
<p>PCF8563：PCF8563 是一款低功耗的 I2C RTC 时钟芯片，能够以 <strong>BCD</strong> 格式存储时间和日期信息，并具有时钟报警、时钟输出等功能。它具有低功耗、集成度高、工作稳定等特点，适用于需要长时间运行且功耗要求较低的应用场景。</p>
<p>PCF8563 通过<strong>I2C总线</strong>与主控芯片（如微控制器）进行通信。</p>
<p><strong>存储格式</strong></p>
<blockquote>
<p>PCF8563 芯片使用 BCD 格式进行存储</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/Decimal2BCD.jpg" alt="Decimal2BCD"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/shijiyinjiao.jpg" alt="shijiyinjiao"></p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCshizhongyuanlitu.png" alt="RTCshizhongyuanlitu"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/I2Cyuanlitu.png" alt="I2Cyuanlitu"></p>
<p>引脚说明：</p>
<ol>
<li>#INT： 中断引脚。当触发到定时任务时，会触发引脚高低电平变化。</li>
<li>SCL和SDA：为I2C通讯的两个引脚。用来保证MCU和RTC时钟芯片间进行通讯的。</li>
<li>OSCI：振荡器输入</li>
<li>OSCO：振荡器输出</li>
<li>Vss：地</li>
<li>SDA：串行数据 I&#x2F;O</li>
<li>SCL：串行时钟输入</li>
<li>CLKOUT：时钟输出（开漏）</li>
<li>VDD：正电源</li>
</ol>
<h3 id="实现时间的设置与读取"><a href="#实现时间的设置与读取" class="headerlink" title="实现时间的设置与读取"></a>实现时间的设置与读取</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;STC8G_H_I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> 	<span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UART_GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef UART_GPIO_init;</span><br><span class="line">	<span class="comment">//IO模式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">    UART_GPIO_init.Mode = GPIO_PullUp;		</span><br><span class="line">    UART_GPIO_init.Pin = GPIO_Pin_0 | GPIO_Pin_1; <span class="comment">//要设置的端口</span></span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;UART_GPIO_init);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 UART</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    COMx_InitDefine UART_Init;   </span><br><span class="line">    <span class="comment">//模式,UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    <span class="comment">//使用波特率,   BRT_Timer1,BRT_Timer2,BRT_Timer3,BRT_Timer4</span></span><br><span class="line">    <span class="comment">//查看手册 UART 与 Timer 要对应起来</span></span><br><span class="line">	UART_Init.UART_BRT_Use = BRT_Timer1;		</span><br><span class="line">    <span class="comment">//波特率,一般 110 ~ 115200</span></span><br><span class="line">	UART_Init.UART_BaudRate = <span class="number">115200</span>;	</span><br><span class="line">    <span class="comment">//多机通讯允许, ENABLE,DISABLE</span></span><br><span class="line">	UART_Init.Morecommunicate = DISABLE;	</span><br><span class="line">    <span class="comment">//允许接收,ENABLE,DISABLE</span></span><br><span class="line">	UART_Init.UART_RxEnable = DISABLE;		</span><br><span class="line">    <span class="comment">//波特率加倍, ENABLE,DISABLE</span></span><br><span class="line">	UART_Init.BaudRateDouble = DISABLE;	</span><br><span class="line">    </span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init);</span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化一个显示函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RTC_Time</span> <span class="title">time</span> =</span> &#123;</span><br><span class="line">        <span class="comment">// 按照结构体定义顺序，年月日，时分秒，周</span></span><br><span class="line">        <span class="number">2024</span>,</span><br><span class="line">        <span class="number">9</span>,</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">        <span class="number">24</span>,</span><br><span class="line">        <span class="number">3</span>        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">// 打开全局中断使能 UART 要用</span></span><br><span class="line">    </span><br><span class="line">    UART_Config();</span><br><span class="line">    RTC_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向 RTC 写入初始时间</span></span><br><span class="line">    RTC_WriteTime(&amp;time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读出 RTC 时间并 UART 打印</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取 RTC 时间</span></span><br><span class="line">        RTC_ReadTime(&amp;time);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d %d:%d:%d \n&quot;</span>,time.year, (<span class="type">int</span>)time.month, (<span class="type">int</span>)time.day, (<span class="type">int</span>)time.hour, (<span class="type">int</span>)time.minute, (<span class="type">int</span>)time.second);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;week=%d\n&quot;</span>, (<span class="type">int</span>)time.week);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1s间隔读一次时间</span></span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================================================================</span><br><span class="line"><span class="comment">// RTC.c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 零时存储时间的数组</span></span><br><span class="line">u8 timeDate[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转 BCD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Decimal2BCD(time) ((time / 10) &lt;&lt; 4 + (time %10) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BCD 转十进制</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DCB2Decima(i, b) (((timeDate[i] &amp; b) &gt;&gt; 4) * 10) + (timeDate[i] &amp; 0x0F)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_ADDR 0xA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEN_ADDR 0x02</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef RTC_GPIO_init;</span><br><span class="line">	<span class="comment">//IO模式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">    RTC_GPIO_init.Mode = GPIO_OUT_OD;		</span><br><span class="line">    RTC_GPIO_init.Pin = GPIO_Pin_2 | GPIO_Pin_3; <span class="comment">//要设置的端口</span></span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;RTC_GPIO_init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_I2C_Config</span><span class="params">()</span> &#123;</span><br><span class="line">    I2C_InitTypeDef I2C_Init;</span><br><span class="line">    <span class="comment">//总线速度=Fosc/2/(Speed*2+4),0~63</span></span><br><span class="line">    <span class="comment">// 注意不要超过 PCF8563 的最大传输速度</span></span><br><span class="line">    I2C_Init.I2C_Speed = <span class="number">13</span>;				</span><br><span class="line">    <span class="comment">//I2C功能使能,ENABLE, DISABLE</span></span><br><span class="line">	I2C_Init.I2C_Enable = ENABLE;				</span><br><span class="line">    <span class="comment">//主从模式选择,  I2C_Mode_Master,I2C_Mode_Slave</span></span><br><span class="line">	I2C_Init.I2C_Mode = I2C_Mode_Master;		</span><br><span class="line">    <span class="comment">//主机使能自动发送,  ENABLE, DISABLE</span></span><br><span class="line">	I2C_Init.I2C_MS_WDTA = DISABLE;				</span><br><span class="line">	</span><br><span class="line">    I2C_Init(&amp;I2C_Init);</span><br><span class="line">	<span class="comment">//u8	I2C_SL_ADR; //从机设备地址,  0~127</span></span><br><span class="line">	<span class="comment">//u8	I2C_SL_MA; //从机设备地址比较使能,  ENABLE, DISABL</span></span><br><span class="line">    </span><br><span class="line">    I2C_SW(I2C_P33_P32);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    EAXSFR(); <span class="comment">// 开启特殊寄存器使能</span></span><br><span class="line">    </span><br><span class="line">    RTC_GPIO_Config();</span><br><span class="line">    RTC_I2C_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入 RTC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WriteTime</span><span class="params">(RTC_Time* time)</span> &#123;</span><br><span class="line">    <span class="comment">// 1,将时间存入数组，注意要转换为 BCD 码</span></span><br><span class="line">    <span class="comment">// 注意：在写入时，库函数是将数组按顺序存入 RTC 寄存器中的，</span></span><br><span class="line">    <span class="comment">// 所以此时要将数组的参数与 RTC 寄存器中时间的存储顺序对应</span></span><br><span class="line">    <span class="comment">// RTC 中存储的寄存器顺序为：</span></span><br><span class="line">    <span class="comment">// 秒、分钟、小时、日、星期、月/世纪、年</span></span><br><span class="line">    timeDate[<span class="number">0</span>] = Decima2BCD(time-&gt;RTC_Sec);</span><br><span class="line">    timeDate[<span class="number">1</span>] = Decima2BCD(time-&gt;RTC_Min);</span><br><span class="line">    timeDate[<span class="number">2</span>] = Decima2BCD(time-&gt;RTC_Hour);</span><br><span class="line">    timeDate[<span class="number">3</span>] = Decima2BCD(time-&gt;RTC_Day);</span><br><span class="line">    timeDate[<span class="number">4</span>] = (time-&gt;RTC_Week);</span><br><span class="line">    timeDate[<span class="number">5</span>] = Decima2BCD(time-&gt;RTC_Month);</span><br><span class="line">    timeDate[<span class="number">6</span>] = (((time-&gt;RTC_Year) % <span class="number">100</span> / <span class="number">10</span>) &lt;&lt; <span class="number">4</span>) + ((time-&gt;RTC_Year) % <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//世纪处理：</span></span><br><span class="line">    <span class="keyword">if</span>(time-&gt;RTC_Year &gt; <span class="number">2100</span>) &#123;</span><br><span class="line">        timeDate[<span class="number">5</span>] |= <span class="number">0x80</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        timeDate[<span class="number">5</span>] &amp;= <span class="number">0x80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入时间</span></span><br><span class="line">    <span class="comment">//从设备地址、从设备寄存器地址、写入的数据、要写入数据多少</span></span><br><span class="line">    I2C_WriteNbyte(DEV_ADDR, MEN_ADDR, timeDate, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 RTC 中读取</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ReadTime</span><span class="params">(RTC_Time* time)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    I2C_ReadNbyte(DEV_ADDR, MEN_ADDR, timeDate, <span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将读取的 BCD 转为十进制并存入结构体</span></span><br><span class="line">    <span class="comment">// 因为读取和写入都是按照顺序进行的，这里存放也要对应</span></span><br><span class="line">    <span class="comment">// 秒、分钟、小时、日、星期、月/世纪、年</span></span><br><span class="line">    time-&gt;RTC_Sec = DCB2Decima(<span class="number">0</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Min = DCB2Decima(<span class="number">1</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Hour = DCB2Decima(<span class="number">2</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Day = DCB2Decima(<span class="number">3</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Week = timeDate[<span class="number">4</span>];</span><br><span class="line">    time-&gt;RTC_Month = DCB2Decima(<span class="number">5</span>, <span class="number">0x70</span>);</span><br><span class="line">    time-&gt;RTC_Year = DCB2Decima(<span class="number">6</span>, <span class="number">0x70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeDate[<span class="number">5</span>] * <span class="number">0x80</span>) &#123;</span><br><span class="line">        time-&gt;RTC_Year += <span class="number">2100</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        time-&gt;RTC_Year += <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================================================================</span><br><span class="line"><span class="comment">//RTC.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RTC_H</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;type_def.h&quot;</span></span></span><br><span class="line"><span class="comment">// RTC 时间结构体    </span></span><br><span class="line">type <span class="keyword">struct</span> &#123;</span><br><span class="line">    u16	RTC_Year;  <span class="comment">//RTC 年, </span></span><br><span class="line">	u8	RTC_Month; <span class="comment">//RTC 月, 01~12</span></span><br><span class="line">	u8	RTC_Day;   <span class="comment">//RTC 日, 01~31</span></span><br><span class="line">	u8	RTC_Hour;  <span class="comment">//RTC 时, 00~23</span></span><br><span class="line">	u8	RTC_Min;   <span class="comment">//RTC 分, 00~59</span></span><br><span class="line">	u8	RTC_Sec;   <span class="comment">//RTC 秒</span></span><br><span class="line">    u8  RTC_Week;  <span class="comment">//RTC 周</span></span><br><span class="line">&#125;RTC_Time;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化RTC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">RTC_WriteTime(RTC_Time* time);</span><br><span class="line">RTC_ReadTime(RTC_Time* time);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="实现闹钟"><a href="#实现闹钟" class="headerlink" title="实现闹钟"></a>实现闹钟</h3><ul>
<li><p>闹钟是基于 RTC 提供的实际时间设置的。你需要指定一个绝对的触发时间，包括小时、分钟、甚至日期等。</p>
</li>
<li><p>一旦时间到达设定的时刻，闹钟触发一次。</p>
</li>
<li><p>闹钟不具备自动重设功能，需要手动重新设定。</p>
</li>
</ul>
<p>这里为了实现闹钟和定时器先介绍两个寄存器：</p>
<p><strong>控制 &#x2F; 状态寄存器</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCkongzhijicuncunqi.png" alt="RTCkongzhijicuncunqi"></p>
<blockquote>
<p>这里我们要关注下AF、TF、AIE、TIE</p>
<p>AF：报警标志位，当报警事件发生时，AF 标志位会被置为 1。需要我们手动软件置零。</p>
<p>TF：定时器标志位，当定时器事件触发时，TF 标志位会被置为 1。需要我们手动软件置零。</p>
<p>AIE：报警中断使能位，AIE 控制的是闹钟的中断使能。如果 AIE 置位为 1，AF 置位时将触发中断。</p>
<p>TIE：定时器中断使能位，TIE 控制的是定时器的中断使能。如果 TIE 置位为 1，TF 置位时将触发中断。</p>
</blockquote>
<p><strong>报警寄存器</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCnaozhongjicunqi.png" alt="RTCnaozhongjicunqi"></p>
<blockquote>
<p>这里可以看到我们想要设置某个闹钟时间，只需要将他的最高位置 0，余下的 7 位设置为具体的时间即可。</p>
</blockquote>
<p>这里要理解所谓的实现闹钟的功能，并不是说我们设定一个时间后，这个 RTC 到达指定时间后自己会发声，而是指他在达到我们设置顶的事件后他的中断输出引脚会产生一个低电平（或者是高电平），我们要去捕捉这个中断，然后通过蜂鸣器去实现这个闹钟的功能，定时器也是同理。 </p>
<p><strong>实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所谓的闹钟就是设定的时间到了，#INT 引脚会发出中断（也就是一个高电平或者低电平）</span></span><br><span class="line"><span class="comment">// 我们需要在这个中断中去进行闹钟功能的触发</span></span><br><span class="line"><span class="comment">// 1.将这个引脚初始化</span></span><br><span class="line"><span class="comment">// RTC.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EXTI_Config</span><span class="params">()</span>&#123;</span><br><span class="line">	EXTI_InitTypeDef init;</span><br><span class="line">	<span class="comment">//中断模式,EXT_MODE_RiseFall 0 上升沿/下降沿中断</span></span><br><span class="line">    <span class="comment">// 		  EXT_MODE_Fall 1 下降沿中断</span></span><br><span class="line">	init.EXTI_Mode = EXT_MODE_RiseFall;			</span><br><span class="line">	</span><br><span class="line">	Ext_Inilize(EXT_INT3,&amp;init);</span><br><span class="line">	</span><br><span class="line">	NVIC_INT3_Init(ENABLE , Priority_0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.设置闹钟寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StartAlarm</span><span class="params">(RTC_Alarm * alarm)</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//一开始就设置了4个最高位都是1的数据</span></span><br><span class="line">    	<span class="comment">// 4 个 AE 默认 1 不可用</span></span><br><span class="line">    	<span class="comment">// 按寄存器的顺序分别是分钟、小时、天、星期</span></span><br><span class="line">		u8 arr[<span class="number">4</span>] = &#123;<span class="number">0x80</span> , <span class="number">0x80</span> , <span class="number">0x80</span> , <span class="number">0x80</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 配置闹钟开关 :: 允许启用闹钟</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">//1.1 先把控制寄存器的数据读取出来</span></span><br><span class="line">		I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//1.2 修改第1位【AIE = 1】 --- 允许闹钟中断</span></span><br><span class="line">    	<span class="comment">// 闹钟中断使能位</span></span><br><span class="line">		rtc_dat |= <span class="number">0x02</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1.3 修改第3位【AF = 0】 ---- 表示闹钟还没有响过，</span></span><br><span class="line">        <span class="comment">// 将报警标志位置 0 表示没有闹钟发声</span></span><br><span class="line">		rtc_dat &amp;= ~<span class="number">0x08</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.4 再把修改好的数据写回去</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//再度一次，看看我的配置有没有写进去？</span></span><br><span class="line">		I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//2. 到底配的是几点? 什么时间响闹钟?</span></span><br><span class="line">    	<span class="comment">// 配置闹钟多少点响，也就是什么时候触发中断	</span></span><br><span class="line">		<span class="comment">//判断分钟  0 ~ 59</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;minute != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的分</span></span><br><span class="line">            <span class="comment">// 因为是以 BCD 存储的所以要转为 BCD</span></span><br><span class="line">			arr[<span class="number">0</span>] = Decimal2BCD(alarm-&gt;minute );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">0</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断小时 0 ~ 23</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;hour != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的小时</span></span><br><span class="line">			arr[<span class="number">1</span>] = Decimal2BCD(alarm-&gt;hour );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">1</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断日期 1 ~ 31</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;day != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的小时</span></span><br><span class="line">			arr[<span class="number">2</span>] = Decimal2BCD(alarm-&gt;day );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">2</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断星期 0 ~ 6</span></span><br><span class="line">		<span class="keyword">if</span>(alarm-&gt;week != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//2.1 指定闹钟的小时</span></span><br><span class="line">			arr[<span class="number">3</span>] = Decimal2BCD(alarm-&gt;week );		</span><br><span class="line">			<span class="comment">//2.2. 启用闹钟</span></span><br><span class="line">			arr[<span class="number">3</span>] &amp;= ~<span class="number">0x80</span> ; <span class="comment">// 0111 1111</span></span><br><span class="line">		&#125;			</span><br><span class="line">		<span class="comment">// 回写到寄存器</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, ALA_ADD, arr, <span class="number">4</span>);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是闹钟中断还是定时器中断</span></span><br><span class="line">u8 <span class="title function_">RTC_ISAlarmINT</span><span class="params">()</span> &#123;</span><br><span class="line">	u8 dat;</span><br><span class="line">	I2C_ReadNbyte(<span class="number">0xA2</span>, <span class="number">0x01</span>, &amp;dat, <span class="number">1</span>);	</span><br><span class="line">	<span class="comment">//判断第3位 AF 是否是1，如果是1，即表示是闹钟引发的中断，否则就是其他引发的中断</span></span><br><span class="line">	<span class="keyword">return</span> dat &amp; <span class="number">0x08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.接下来就是中断的配置，</span></span><br><span class="line"><span class="comment">// 当 RTC 的 #INT 引脚触发了高电平（低电平），我们需要指定 #INT 引脚所对应的中断发声</span></span><br><span class="line"><span class="comment">// 从 GPIO 配置中可以看到我们用的 EXIT3 也就是外部中3</span></span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">// Exti_lsr.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> handle_tit3_interrupte();    </span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: INT3_ISR_Handler</span></span><br><span class="line"><span class="comment">// 描述: INT3中断函数.</span></span><br><span class="line"><span class="comment">// 参数: none.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-23</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INT3_ISR_Handler</span> <span class="params">(<span class="type">void</span>)</span> interrupt INT3_VECTOR		<span class="comment">//进中断时已经清除标志</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加用户代码</span></span><br><span class="line"><span class="comment">//	P03 = ~P03;</span></span><br><span class="line">	WakeUpSource = <span class="number">4</span>;</span><br><span class="line">	handle_tit3_interrupte(); <span class="comment">// 这就是我们自订的处理函数</span></span><br><span class="line">&#125;  </span><br><span class="line">=============================================================================</span><br><span class="line"><span class="comment">// 4.定义我们处理的逻辑，也就是我们要做的事情（发声）</span></span><br><span class="line"><span class="comment">// 这里又要思考一点事情</span></span><br><span class="line"><span class="comment">// 4.1 前面寄存器介绍中所过 AF / TF 要软件置 0</span></span><br><span class="line"><span class="comment">// 4.2 我们只有一个 #INT 口，却有两个可以触发中断的方法闹钟和定时器</span></span><br><span class="line"><span class="comment">//     这里需要判断下是闹钟还是定时器触发的中断</span></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">void</span> handle_tit3_interrupte() &#123;</span><br><span class="line">    <span class="keyword">if</span>(RTC_ISAlarmINT()) &#123;</span><br><span class="line">        os_create_task(TASK_BUZZER); <span class="comment">// 是闹钟就发声</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        os_create_task(TASK_LED); <span class="comment">// 不是闹钟就肯定是定时器，就做其他的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对应的闹钟中断标志位置 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearAlarmFlag</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清除闹钟控制寄存器配置。</span></span><br><span class="line">    <span class="comment">// 把AF置 0 【响过闹钟之后，这个AF会 置1 ，要手动清0，否则下一次闹钟到了之后，不会响了！】</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);	</span><br><span class="line">	<span class="comment">// 把第3位 置 0</span></span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x08</span>;	</span><br><span class="line">	<span class="comment">//再写回去</span></span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止（关闭）闹钟的逻辑，将闹钟的中断使能位置 0</span></span><br><span class="line"><span class="comment">// 如果不关闭，假设我设置 30min 时候发声，他会到每一个 30min 发声</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StopAlarm</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 设置控制寄存器里面的AIE = 0 ， 表示闹钟中断无效！</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x02</span>;</span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现定时器"><a href="#实现定时器" class="headerlink" title="实现定时器"></a>实现定时器</h3><ul>
<li><p>PCF8563 定时器是基于倒计时的，可以设定为倒计时模式。当倒计时时间到达 0 时，定时器触发一个事件，并可以选择重新倒计时或者停止。</p>
</li>
<li><p>定时器的时间间隔可以设定为秒、分钟等。</p>
</li>
<li><p>定时器一般是循环计时，可以周期性地执行任务，时间结束后重新开始计时。</p>
</li>
</ul>
<p><strong>倒计时定时器寄存器</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/RTCdaojisjishijicunqi.png" alt="RTCdaojisjishijicunqi"></p>
<blockquote>
<p>大致与上面闹钟同理：区别在于两个参数：<br>TD1、TD0：用于设置定时器的时钟频率，</p>
<p>定时器倒计数数值寄存器位描述：具体倒计时要数的数，通过这两个可以设置倒计数的时长</p>
<p>以 64 Hz 为例，那么 设置寄存器值位 64 就是 1s</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RTC.c</span></span><br><span class="line"><span class="comment">// 1.中断引脚配置（引脚的配置和上面闹钟是一致的可以共用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置定时器配置寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StartTimer</span><span class="params">(RTC_Hz hz , u8 count)</span>&#123;</span><br><span class="line">		<span class="comment">//2.1 配置定时器开关.. </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.1 先把控制寄存器读取出来</span></span><br><span class="line">		I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.2 把TIE 【第0位】置1</span></span><br><span class="line">		rtc_dat |= <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.3 把TF【第2位】 置0</span></span><br><span class="line">		rtc_dat &amp;= ~<span class="number">0x04</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.1.4 把配置再写回去！</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">						</span><br><span class="line">		<span class="comment">//2.2 配置定的是什么时间 【需要有两个寄存器来协同完成】...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.2.1 先配置定时器时钟频率，以及启用这种频率 00: 4096，01: 64，10:  1，11: 1/60</span></span><br><span class="line">		rtc_dat = <span class="number">0x80</span> | hz;</span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, TIM1_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.2.2 再配置定时器的时钟周期</span></span><br><span class="line">		rtc_dat = count; <span class="comment">// 结合上面看，就是1s钟触发一次定时操作！</span></span><br><span class="line">		I2C_WriteNbyte(DEV_ADD, TIM2_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_StopTimer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 设置控制寄存器里面的TIE 【第0位】 = 0 ， 表示定时器中断无效！</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x01</span>;</span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearTimerFlag</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器来过之后，TF位就会置1，我们要手动置0，否则下一次定时器不来了</span></span><br><span class="line">	I2C_ReadNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把第2位置0</span></span><br><span class="line">	rtc_dat &amp;= ~<span class="number">0x04</span>;</span><br><span class="line"></span><br><span class="line">	I2C_WriteNbyte(DEV_ADD, CON_ADD, &amp;rtc_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在 PCF8563芯片中，晶振频率为32.768kHz，但我们为什么可以选择 32.768kHz、1024kHz、32Hz、1Hz，他不是只有个 32.768kHz 的晶振么</strong></p>
<p>在 <strong>PCF8563</strong> 实时时钟（RTC）芯片中，虽然它使用了<strong>32.768kHz</strong>的晶振作为基准频率，但通过内部的<strong>分频电路</strong>，可以将该基准频率分频为其他不同的频率输出，如<strong>1024Hz</strong>、<strong>32Hz</strong>、和<strong>1Hz</strong>。这意味着尽管晶振频率固定为32.768kHz，但通过硬件电路的分频机制，PCF8563芯片可以输出不同的时钟频率。</p>
<p>二、<strong>I2C 的总线到底如何配置</strong></p>
<p>I2C（Inter-Integrated Circuit）总线的速度是指主设备和从设备之间数据传输的速率。</p>
<p>公式为：总线速度 &#x3D; <strong>Fosc&#x2F;2&#x2F;(Speed*2+4),0~63</strong></p>
<p><strong>FOSC</strong>：这是系统的主时钟频率（通常是微控制器的晶振频率）。</p>
<p><strong>MSSPEED</strong>：用于控制 I2C 速度的一个寄存器值或配置参数。</p>
<p><strong>2 和 4</strong>：这是 I2C 控制器内部的<strong>定值</strong>，用于分频公式中的基准值。</p>
<blockquote>
<p>MSSPEED 是一个控制分频的参数，用于将主时钟（FOSC）分频成较低的频率，从而得到 I2C 总线所需的时钟频率（SCL）。</p>
<p>通常情况下，I2C 的速度取决于具体应用的要求、设备能力和电路布局。如果连接的设备需要高速传输，则可以选择快速模式或更高的模式；而在低功耗应用中，标准模式的 100 kbit&#x2F;s 速度可能就足够了。</p>
</blockquote>
<p>三、<strong>在开发文档中 MSSPEED 所对应的值为时钟数，那么这个是时钟数是什么？</strong></p>
<p>在开发文档中提到的 “时钟数” 是指 <strong>I2C 总线传输一个数据位所需的时钟周期数</strong>。具体来说，它是 I2C 通信中每发送或接收一位数据时，SCL（串行时钟线）所需要的时钟周期数。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>STC8H</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/STC8H/</url>
    <content><![CDATA[<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>Keil C51程序自动加载了一个名为”STARTUP.A51”的文件，在这个文件里面进行了一系列的初始化操作后进入用户编写的C语言程序入口main函数中，main函数执行完毕后，STARTUP.A51文件后有一句跳转到程序入口main函数的语句，所以会再次进入C语言主程序main函数中执行相关内容。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI_OLED显示</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/SPI_OLED%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>SPI（串行外设接口）是一种广泛应用的<strong>全双工同步串行通信协议</strong>，通常用于微控制器与外部设备之间的高速数据传输。它采用<strong>主从架构</strong>，通过<strong>主设备生成时钟信号</strong>并控制数据流动，通过四条主要信号线<strong>（MOSI、MISO、SCLK和SS）</strong>实现<strong>全双工通信</strong>。数据传输通过时钟的<strong>上升或下降沿</strong>进行，且支持可配置的时钟极性（CPOL）和相位（CPHA），以适应不同设备的要求。尽管SPI的传输速度较高，且实现相对简单，但其缺点在于需要较多的引脚和短距离传输的限制，适合用于传感器、存储器、显示屏及其他外设的接口。整体来说，SPI因其速度和灵活性在嵌入式系统中得到了广泛应用。</p>
<p><strong>全双工：</strong>全双工指的是通信的双方可以同时进行数据的发送和接收，彼此互不干扰。(也就是说需要至少两条线进行通信)</p>
<p><strong>同步：</strong>指数据的传输是通过一个共同的时钟信号进行协调的。所有参与通信的设备都依赖于同一时钟信号来发送和接收数据。</p>
<p><strong>串行通信：</strong> 数据通过一条数据线依次<strong>一位一位</strong>的发送。</p>
<p>发送设备和接收设备在<strong>同一时刻</strong>依据<strong>同一个时钟信号</strong>进行数据的采样和传输。</p>
<p><strong>SPI 协议通信过程</strong></p>
<ol>
<li><p><strong>主设备选择从设备</strong>：通过将对应从设备的 <strong>SS</strong> 线拉低，选中某个从设备进行通信。</p>
</li>
<li><p><strong>时钟同步</strong>：主设备生成 <strong>SCLK</strong>，并在时钟上升沿或下降沿驱动数据。</p>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li><p>在时钟脉冲的作用下，主设备通过 <strong>MOSI</strong> 线发送数据，同时从设备通过 <strong>MISO</strong> 线发送数据。</p>
</li>
<li><p>数据在时钟的上升沿或下降沿采样，具体依赖于时钟极性和相位设置。</p>
</li>
</ul>
</li>
<li><p><strong>完成通信</strong>：数据传输结束后，主设备将 <strong>SS</strong> 线拉高，终止对从设备的选择。</p>
</li>
</ol>
<p><strong>通信过程图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPItongxinliucheng.jpg" alt="SPItongxinliucheng"></p>
<blockquote>
<p>MOSI: 主设备输出，从设备输入（接收）</p>
<p>MISO: 主设备输入（接收），从设备输出</p>
<p>SCLK: 主设备生成的时钟信号</p>
<p>SS(NSS): 选择从设备的的信号（当每次传输完成后，主设备拉高 SS 信号，结束通信）</p>
</blockquote>
<h2 id="OLED显示屏"><a href="#OLED显示屏" class="headerlink" title="OLED显示屏"></a>OLED显示屏</h2><p>本次示例屏采用的是中景园的 0.96 寸 OLED 显示屏  SSD1306 驱动带字库</p>
<p><strong>如图所示</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIOLED.png" alt="SPIOLED"></p>
<blockquote>
<p>右图中左侧六个引脚的为字库芯片</p>
<p>右图中右侧三个引脚的为线性稳压器</p>
</blockquote>
<p><strong>引脚说明</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIyinjiaoshuom.png" alt="SPIyinjiaoshuom"></p>
<blockquote>
<p><strong>GND</strong>：逻辑电路的接地端。必须连接到地。</p>
<p><strong>VCC</strong>：OLED 的电源输入端。必须连接到电源。</p>
<p><strong>CLK &#x2F; SCL</strong>：串行时钟输入端。</p>
<p><strong>MOSI &#x2F; SDA</strong>：串行数据输入端。</p>
<p><strong>DC</strong>：数据&#x2F;命令控制引脚。当引脚拉高时，SDA输入作为显示数据处理；当引脚拉低时，SDA输入传递到命令寄存器。</p>
<p><strong>CS1</strong>：OLED 芯片选择引脚；低电平使能，高电平禁止。</p>
<p><strong>FSO</strong>：字库芯片的数据输出引脚。</p>
<p><strong>CS2</strong>：字库芯片选择引脚；低电平使能，高电平禁止。</p>
</blockquote>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIyuanlitu.png" alt="SPIyuanlitu"></p>
<blockquote>
<p>X096-2864KSWAG01：OLED 模块</p>
<p>8 * 2.54 ：8个引脚，引脚间距为 2.54</p>
<p>GT20L16S1Y：字库 IC</p>
<p>ME6206a33XG：线性稳压器</p>
</blockquote>
<p><strong>函数先根据你要展示的内容，去字库芯片中查找他的位置，然从指定位置中读出这些字，然后展示在 OLED 上</strong></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPISTC8Hyinjiaotu.png" alt="SPISTC8Hyinjiaotu"></p>
<p><strong>字库 IC 中地址计算方法，以 GB2313为例</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/SPIICziku.png" alt="SPIICziku"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例里的函数讲解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.以写入 GB2313 字符集的汉字为例</span></span><br><span class="line"><span class="comment">// 以左上角为原点，显示：12864，带中文字库</span></span><br><span class="line">OLED_Display_GB2312_string(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;12864，带中文字库&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.根据字库IC提供的计算方法算出该字符点阵在字库IC中的位置</span></span><br><span class="line">u32 fontaddr=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_GB2312_string</span><span class="params">(u8 x,u8 y,u8 *text)</span> &#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u8 addrHigh,addrMid,addrLow; </span><br><span class="line">	u8 fontbuf[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">while</span>(text[i]&gt;<span class="number">0x00</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((text[i]&gt;=<span class="number">0xb0</span>)&amp;&amp;(text[i]&lt;=<span class="number">0xf7</span>)&amp;&amp;(text[i+<span class="number">1</span>]&gt;=<span class="number">0xa1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//¹ú±ê¼òÌå£¨GB2312£©ºº×ÖÔÚ¾§ÁªÑ¶×Ö¿âICÖÐµÄµØÖ·ÓÉÒÔÏÂ¹«Ê½À´¼ÆËã£º</span></span><br><span class="line">			<span class="comment">//Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*32+ BaseAdd;BaseAdd=0</span></span><br><span class="line">			<span class="comment">//ÓÉÓÚµ£ÐÄ8Î»µ¥Æ¬»úÓÐ³Ë·¨Òç³öÎÊÌâ£¬ËùÒÔ·ÖÈý²¿È¡µØÖ·</span></span><br><span class="line">			fontaddr=(text[i]<span class="number">-0xb0</span>)*<span class="number">94</span>;</span><br><span class="line">			fontaddr+=(text[i+<span class="number">1</span>]<span class="number">-0xa1</span>)+<span class="number">846</span>;</span><br><span class="line">			fontaddr=fontaddr*<span class="number">32</span>;</span><br><span class="line">			</span><br><span class="line">			addrHigh=(fontaddr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>;   <span class="comment">//µØÖ·µÄ¸ß8Î»,¹²24Î»</span></span><br><span class="line">			addrMid=(fontaddr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;       <span class="comment">//µØÖ·µÄÖÐ8Î»,¹²24Î»</span></span><br><span class="line">			addrLow=(fontaddr&amp;<span class="number">0xff</span>);            <span class="comment">//µØÖ·µÄµÍ8Î»,¹²24Î»</span></span><br><span class="line">			</span><br><span class="line">			OLED_get_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,<span class="number">32</span>);</span><br><span class="line">			<span class="comment">//È¡32¸ö×Ö½ÚµÄÊý¾Ý£¬´æµ½&quot;fontbuf[32]&quot;</span></span><br><span class="line">			OLED_Display_16x16(x,y,fontbuf);</span><br><span class="line">			<span class="comment">//ÏÔÊ¾ºº×Öµ½LCDÉÏ£¬yÎªÒ³µØÖ·£¬xÎªÁÐµØÖ·£¬fontbuf[]ÎªÊý¾Ý</span></span><br><span class="line">			x+=<span class="number">16</span>;</span><br><span class="line">			i+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((text[i]&gt;=<span class="number">0xa1</span>)&amp;&amp;(text[i]&lt;=<span class="number">0xa3</span>)&amp;&amp;(text[i+<span class="number">1</span>]&gt;=<span class="number">0xa1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			fontaddr=(text[i]<span class="number">-0xa1</span>)*<span class="number">94</span>;</span><br><span class="line">			fontaddr+=(text[i+<span class="number">1</span>]<span class="number">-0xa1</span>);</span><br><span class="line">			fontaddr=fontaddr*<span class="number">32</span>;</span><br><span class="line">			</span><br><span class="line">			addrHigh=(fontaddr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>;</span><br><span class="line">			addrMid=(fontaddr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;</span><br><span class="line">			addrLow=(fontaddr&amp;<span class="number">0xff</span>);</span><br><span class="line">			</span><br><span class="line">			OLED_get_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,<span class="number">32</span>);</span><br><span class="line">			OLED_Display_16x16(x,y,fontbuf);</span><br><span class="line">			x+=<span class="number">16</span>;</span><br><span class="line">			i+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((text[i]&gt;=<span class="number">0x20</span>)&amp;&amp;(text[i]&lt;=<span class="number">0x7e</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">char</span> fontbuf[<span class="number">16</span>];</span><br><span class="line">			fontaddr=(text[i]<span class="number">-0x20</span>);</span><br><span class="line">			fontaddr=(<span class="type">unsigned</span> <span class="type">long</span>)(fontaddr*<span class="number">16</span>);</span><br><span class="line">			fontaddr=(<span class="type">unsigned</span> <span class="type">long</span>)(fontaddr+<span class="number">0x3cf80</span>);</span><br><span class="line">			</span><br><span class="line">			addrHigh=(fontaddr&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>;</span><br><span class="line">			addrMid=(fontaddr&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;</span><br><span class="line">			addrLow=fontaddr&amp;<span class="number">0xff</span>;</span><br><span class="line">			</span><br><span class="line">			OLED_get_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,<span class="number">16</span>);</span><br><span class="line">			OLED_Display_8x16(x,y,fontbuf);</span><br><span class="line">			x+=<span class="number">8</span>;</span><br><span class="line">			i+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向SSD1306写入一个字节。</span></span><br><span class="line"><span class="comment">//mode:数据/命令标志 0,表示命令;1,表示数据;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(u8 dat,u8 cmd)</span> &#123;	</span><br><span class="line">	u8 i;	</span><br><span class="line">    <span class="comment">// 判断是命令（0）还是数据（1），将 DC 置 0/1</span></span><br><span class="line">	<span class="keyword">if</span>(cmd) &#123; </span><br><span class="line">	  OLED_DC_Set(); <span class="comment">// DC: 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	  OLED_DC_Clr(); <span class="comment">// DC: 0	</span></span><br><span class="line">	&#125;	  </span><br><span class="line">    <span class="comment">// CS1 置 0，选择 OLED 芯片（SSD1306）</span></span><br><span class="line">    <span class="comment">// 表示要向 SSD1306 中写数据了</span></span><br><span class="line">	OLED_CS_Clr(); </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123; <span class="comment">// 写一个字节	8 位		  </span></span><br><span class="line">		OLED_SCL_Clr(); <span class="comment">// 将 SCL(时钟) 置 0</span></span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>) &#123; <span class="comment">// 从高位开始，依次判断 0 / 1</span></span><br><span class="line">		   OLED_SDA_Set(); <span class="comment">// 1 就将 SDA  置 1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		   OLED_SDA_Clr(); <span class="comment">// 0 就将 SDA 置 0</span></span><br><span class="line">		&#125;</span><br><span class="line">		OLED_SCL_Set(); <span class="comment">// 将 SCL 值 1，也就是上升沿</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">	&#125;				 		  </span><br><span class="line">	OLED_CS_Set(); <span class="comment">// 将 CS 置 1（不选择 OLED）</span></span><br><span class="line">	OLED_DC_Set(); <span class="comment">// 拉高作为数据  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从相关地址中：(计算出汉字在字库中的地址，然后将地址写入，然后从写入的地址中读出数据)</span></span><br><span class="line"><span class="comment">//（addrHigh：地址高字节,addrMid：地址中字节,addrLow：地址低字节）</span></span><br><span class="line"><span class="comment">// 中连续读出 DataLen 个字节的数据到 pbuff 的地址</span></span><br><span class="line"><span class="comment">// 连续读取</span></span><br><span class="line"><span class="comment">// 由于担心8位单片机有乘法溢出问题，所以分三部取地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_get_data_from_ROM</span><span class="params">(u8 addrHigh,u8 addrMid,u8 addrLow,u8 *pbuff,u8 DataLen)</span> &#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	OLED_ROM_CS_Clr();</span><br><span class="line">    <span class="comment">// 0x03 通常是“读取数据”的命令</span></span><br><span class="line">    <span class="comment">// 表示准备从指定的地址开始读取数据。</span></span><br><span class="line">	Send_Command_to_ROM(<span class="number">0x03</span>);</span><br><span class="line">    <span class="comment">//送指令到晶联讯字库IC</span></span><br><span class="line">	Send_Command_to_ROM(addrHigh);</span><br><span class="line">	Send_Command_to_ROM(addrMid);</span><br><span class="line">	Send_Command_to_ROM(addrLow);</span><br><span class="line">    <span class="comment">// 从字库 IC 中读取出来 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;DataLen;i++) &#123;</span><br><span class="line">		*(pbuff+i)=Get_data_from_ROM();</span><br><span class="line">  &#125;</span><br><span class="line">	OLED_ROM_CS_Set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从晶联讯字库IC中取汉字或字符数据（1个字节）</span></span><br><span class="line">u8 <span class="title function_">Get_data_from_ROM</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u8 i,read=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">		OLED_SCL_Clr();</span><br><span class="line">		read&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// OLED_READ_FS0: 字库芯片的数据输出引脚。</span></span><br><span class="line">		<span class="keyword">if</span>(OLED_READ_FS0) &#123; </span><br><span class="line">			read++;</span><br><span class="line">    &#125;</span><br><span class="line">		OLED_SCL_Set();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数先根据你要展示的内容，去字库芯片中查找他的位置，然从指定位置中读出这些字，然后展示在 OLED 上</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>SPI 和 UART 的区别</strong></p>
<p>二、<strong>write 的代码也就是在控制数据点的高低，也没有显示的写入 OLED 的代码呀，为什么 OLED 可以保存并显示内容呢</strong></p>
<p>在 <code>OLED_WR_Byte()</code> 函数中，虽然没有显式写入 SSD1306 内存的代码，但实际的数据传输是通过 <strong>SPI 或 I2C</strong> 接口的硬件控制实现的。</p>
<p><strong>具体的写入过程</strong></p>
<ol>
<li><p><strong>数据传输过程</strong>：<br>每个字节通过 SDA 引脚按位传输。<code>OLED_SDA_Set()</code> 和 <code>OLED_SDA_Clr()</code> 控制数据线的电平状态（高或低），代表传输的每一位。每次时钟 <code>OLED_SCL_Set()</code> 上升沿时，SSD1306 会读取数据引脚上的电平，形成一个位数据。</p>
</li>
<li><p><strong>命令或数据的区分</strong>：<br><code>OLED_DC_Set()</code> 和 <code>OLED_DC_Clr()</code> 用于区分当前传输的是<strong>数据</strong>还是<strong>命令</strong>。高电平表示数据，低电平表示命令。这决定了 SSD1306 如何处理接收到的信息。</p>
</li>
<li><p>**芯片选择 (CS)**：<br><code>OLED_CS_Clr()</code> 拉低 CS 信号，告诉 SSD1306 开始通信。传输完成后，<code>OLED_CS_Set()</code> 结束通信。SSD1306 会根据传输的内容将数据存储到相应的显存地址中，并在下一个刷新周期内更新显示内容。</p>
</li>
</ol>
<p>三、<strong>时钟极性*CKP&#x2F;Clock Polarity）</strong></p>
<p>四、<strong>时钟相位</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/290620901">SPI协议详解（图文并茂+超详细） - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p><strong>中断</strong>（Interrupt）是一种机制，允许<strong>外部</strong>或<strong>内部</strong>事件在发生时<strong>打断</strong>处理器正在执行的任务，使处理器暂时转移去处理这些事件。</p>
<p>在嵌入式系统中，中断可以是由<strong>硬件外设产生的信号</strong>，也可以是<strong>处理器内部条件触发的事件</strong>。处理器在响应中断时，会暂停当前执行的程序，保存上下文，执行特定的中断服务程序（ISR，Interrupt Service Routine），并在处理完中断后恢复并继续执行原来的任务。</p>
<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><p><strong>中断源</strong> 是引发中断事件的硬件或软件模块。常见的中断源包括以下几类：</p>
<ul>
<li><strong>外部中断</strong>：来自外部设备的信号。例如，外部按键、定时器溢出、串口数据接收完成等。</li>
<li><strong>内部中断</strong>：由处理器内部的模块或条件触发的中断。例如，除法错误、非法指令等。</li>
<li><strong>软件中断</strong>：通过软件指令触发的中断（例如，系统调用）。</li>
</ul>
<p><strong>常见的硬件中断源：</strong></p>
<ol>
<li><strong>外部设备</strong>：如键盘、鼠标、按键等，通过物理事件引发中断。</li>
<li><strong>定时器</strong>：定时器溢出（或达到预定计数值）后触发中断，用于定时操作或延时。</li>
<li><strong>串口</strong>：如 UART 接收到数据后触发中断，以通知 MCU 读取数据。</li>
<li><strong>ADC</strong>（模数转换器）：当转换完成时，触发中断通知处理器读取转换结果。</li>
<li><strong>GPIO</strong>（通用输入&#x2F;输出）：输入引脚电平变化（上升沿&#x2F;下降沿）时触发中断。</li>
</ol>
<h3 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h3><p><strong>中断寄存器</strong> 是用于控制、管理和响应中断的寄存器。通过配置这些寄存器，开发者可以启用或屏蔽特定的中断、设置中断的优先级、读取中断标志等。每种处理器架构通常都有不同的中断控制寄存器，以下是常见的中断寄存器类型：</p>
<ol>
<li><strong>中断屏蔽寄存器（Interrupt Mask Register，IMR）</strong>：<ul>
<li>用于启用或禁用特定中断。当某个中断被屏蔽时，即使触发该中断源，也不会导致中断的产生。</li>
<li>通过设置相应的位，可以允许某个中断或屏蔽某个中断。</li>
</ul>
</li>
<li><strong>中断优先级寄存器（Interrupt Priority Register，IPR）</strong>：<ul>
<li>设置不同中断的优先级。通常一个处理器可以处理多个中断，如果多个中断同时触发，处理器会优先响应优先级更高的中断。</li>
</ul>
</li>
<li><strong>中断标志寄存器（Interrupt Flag Register，IFR）</strong>：<ul>
<li>当某个中断源产生中断时，会在中断标志寄存器中置位，用于标识中断的发生。中断服务程序需要清除这个标志位，以避免中断重复触发。</li>
</ul>
</li>
<li><strong>中断控制寄存器（Interrupt Control Register，ICR）</strong>：<ul>
<li>管理中断的使能、模式、边沿检测等功能。通过配置该寄存器，开发者可以控制中断触发的条件，如上升沿、下降沿或电平触发。</li>
</ul>
</li>
</ol>
<h3 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h3><p><strong>中断函数</strong> 或 <strong>中断服务程序</strong>（ISR，Interrupt Service Routine）是响应中断时执行的代码。当中断发生时，处理器暂停当前执行的任务，跳转到 ISR 处理函数，处理完成后再返回继续执行原来的任务。</p>
<p>中断服务函数通常简洁高效，因为在处理中断的过程中，主程序是暂停的，所以 ISR 的执行时间应尽可能短。</p>
<p><strong>中断函数的特点：</strong></p>
<ul>
<li><strong>无需被显式调用</strong>：中断服务函数由硬件触发，不需要手动调用。</li>
<li><strong>执行时自动保存上下文</strong>：处理器进入中断函数时会自动保存当前上下文（寄存器、程序计数器等），退出时恢复。</li>
<li><strong>需要清除中断标志位</strong>：在某些平台上，中断服务函数需要<strong>手动清除中断标志位</strong>，否则该中断会一直重复触发。</li>
</ul>
<p>中断使系统可以及时响应外部或内部的变化，而不必通过轮询或定时检查的方式，提高了处理效率和系统的实时性。</p>
<h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><p><strong>内部中断</strong> 是由微控制器或<strong>处理器内部</strong>的事件触发的中断，通常与<strong>内部的硬件模块或处理器状态有关</strong>。这类中断<strong>不</strong>会依赖于外部输入信号，而是依靠 MCU 内部的条件或外设的运行情况来触发。</p>
<p><strong>内部中断的触发方式：</strong></p>
<ul>
<li><strong>定时器溢出</strong>：当定时器达到预设值（如定时器计数溢出），会触发定时器中断。</li>
<li><strong>模数转换完成</strong>：在 ADC（模数转换器）完成数据采集并准备好转换结果时，触发中断通知处理器读取数据。</li>
<li><strong>看门狗定时器超时</strong>：看门狗定时器用于检测系统是否正常运行，如果看门狗定时器超时，系统会触发中断或复位。</li>
<li><strong>串口通信完成</strong>：当串口（UART、SPI、I2C）传输或接收数据完成时，触发中断来读取数据或处理错误。</li>
<li><strong>软件触发</strong>：处理器可以通过执行特定指令（如 ARM 架构中的 <code>SWI</code> 指令）来触发一个软件中断。</li>
</ul>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p><strong>外部中断</strong> 是一种<strong>硬件中断机制</strong>，用于处理外部设备或信号源的异步事件。由微控制器&#x2F;处理器<strong>外部</strong>的物理事件或信号触发的中断，通常由外部设备或电路的输入信号变化导致。</p>
<p><strong>外部中断的触发方式：</strong></p>
<ul>
<li><strong>引脚电平变化</strong>：外部设备通过微控制器的 <strong>GPIO</strong> 引脚发送信号。当某个输入引脚的电平发生变化（上升沿、下降沿、或高低电平），触发外部中断。例如，按钮按下或释放会改变引脚的电平状态，触发中断。</li>
<li><strong>外部传感器信号</strong>：一些外部传感器（如红外传感器、加速度计）在检测到环境变化时会向 MCU 发送信号，触发中断。</li>
<li><strong>外部计数器</strong>：某些外部设备会产生计数信号，MCU 可以通过外部中断捕获这些计数值进行处理。</li>
</ul>
<h3 id="STC8H-实现外部中断"><a href="#STC8H-实现外部中断" class="headerlink" title="STC8H 实现外部中断"></a>STC8H 实现外部中断</h3><p>查看数据手册了解中断的触发方式是什么(上升沿、下降沿、或高低电平)</p>
<p><strong>STC8H外部中断表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/STC8Hwaibzhongduanbiao.png" alt="STC8Hwaibzhongduanbiao"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Exti.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** INT配置 ********************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Exti_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    EXTI_InitTypeDef Exti_Init; <span class="comment">//结构定义</span></span><br><span class="line"></span><br><span class="line">    Exti_Init.EXTI_Mode = EXT_MODE_RiseFall;<span class="comment">//中断模式,   EXT_MODE_RiseFall,EXT_MODE_Fall</span></span><br><span class="line">    Ext_Inilize(EXT_INT0,&amp;Exti_Init); <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">    NVIC_INT0_Init(ENABLE,Priority_0); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ext_int0_call</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 当中断触发时的实现逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================================================================================</span><br><span class="line"><span class="comment">// Exit_lsr.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> ext_int0_call();</span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="comment">// 函数: INT0_ISR_Handler</span></span><br><span class="line"><span class="comment">// 描述: INT0中断函数.</span></span><br><span class="line"><span class="comment">// 参数: none.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-23</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INT0_ISR_Handler</span> <span class="params">(<span class="type">void</span>)</span> interrupt INT0_VECTOR <span class="comment">//进中断时已经清除标志</span></span><br><span class="line">&#123;</span><br><span class="line">	ext_int0_call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>串口通信</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="什么是串口"><a href="#什么是串口" class="headerlink" title="什么是串口"></a>什么是串口</h2><p>串口是一个广义的概念，指的是用于<strong>串行通信的接口</strong>。在计算机和嵌入式设备上，串口通信是指<strong>数据一位一位地按顺序传输</strong>，而不是像并行接口那样同时传输多个位。串口通信是许多嵌入式系统和外部设备（如传感器、模块、其他计算机等）之间进行通信的常用方式之一。</p>
<blockquote>
<p>通过物理连接，将串口（如UART串行接口）的引脚与设备的USB端口或其他通信接口相连，以实现设备之间的数据传输或通信。</p>
</blockquote>
<h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h3><p><strong>UART</strong> (通用异步收发传输器 Universal Asynchronous Receiver&#x2F;Transmitter)，是一种具体实现<strong>全双工异步串行通信</strong>的<strong>硬件或电路</strong>（它本身也定义了一套简单的<strong>串口通信协议</strong>）。</p>
<p><strong>全双工:</strong> 全双工指的是通信的双方可以同时进行数据的发送和接收，彼此互不干扰。(也就是说需要至少两条线进行通信)</p>
<p><strong>异步:</strong> 数据的发送方和接收方<strong>不需要共享一个全局的时钟信号</strong>。发送方可以在任意时间发送数据，接收方通过特殊的<strong>起始位</strong>和<strong>停止位</strong>来判断数据的开始和结束。（不需要专门的时钟信号线）</p>
<p><strong>串行通信:</strong> 数据通过一条数据线<strong>依次一位一位</strong>的发送。</p>
<p>UART 通过定义起始位、数据位、校验位和停止位等传输格式，来实现数据的串行发送和接收；具有数据传输速度稳定、可靠性高、适用范围广等优点。在嵌入式系统中，串口常用于与外部设备进行通讯，如传感器、液晶显示屏、WiFi 模块、蓝牙模块等。</p>
<h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><strong>引脚连接</strong></p>
<p>UART 通道有两条数据线。每个设备上都有一个 RX 引脚和一个 TX 引脚（RX 用于接收，TX 用于发送）。每个设备的 RX 引脚都连接到另一个设备的 TX 引脚。请注意，没有共享时钟线！这是通用异步接收方发送方的“异步”方面。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTyingjianlianjie.png" alt="UARTyingjianlianjie"></p>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p><strong>UART 通信的组成</strong></p>
<p>在 UART中，传输模式为数据包（字符）形式。数据包由起始位、数据帧、奇偶校验位和停止位组成。 </p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTtongxinxieyi.png" alt="UARTtongxinxieyi"></p>
<p><strong>数据的收发过程</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTshujushoufaguocheng.png" alt="UARTshujushoufaguocheng"></p>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p><strong>TTL</strong>（Transistor-Transistor Logic）是一种使用双极型晶体管（BJT）来实现逻辑电路的<strong>逻辑电平标准</strong>。其广泛应用于单片机通信中，特别是在串行通信接口（如UART、SPI、I2C）等场景下。</p>
<p>严格来说，TTL不是一种通信协议，而是逻辑电平的定义标准，描述的是<strong>电气属性</strong>。</p>
<p>TTL的电平标准定义了“高”电平和“低”电平的电压范围，通常与电源电压（Vcc）有关。传统 TTL 逻辑电平以 5V 电源供电，常见的电平范围如下：</p>
<ul>
<li><strong>逻辑 1</strong>（高电平）：约为 2.0V 到 5V</li>
<li><strong>逻辑 0</strong>（低电平）：约为 0V 到 0.8V</li>
</ul>
<p>在串口通讯中 TTL 电平用于定义信号的电压范围：TX（发送引脚）、RX（接收引脚）</p>
<p><strong>TX</strong>（Transmit）：发送端通过 TX 引脚发送数据。当发送一个逻辑高电平（1）时，TX引脚输出一个接近 5V 的电压；当发送一个逻辑低电平（0）时，TX 引脚输出接近 0V 的电压。</p>
<p><strong>RX</strong>（Receive）：在接收端，RX 引脚检测输入电压是否在TTL电平的范围内。如果接收到的电压在高电平范围（通常是 2V 以上），则解码为逻辑 1；如果电压在低电平范围（通常是 0.8V 以下），则解码为逻辑 0。</p>
<h3 id="UART-与-TTL"><a href="#UART-与-TTL" class="headerlink" title="UART 与 TTL"></a>UART 与 TTL</h3><p><strong>既然已经有了 UART 或者 TTL 中的一个协议，为什么还需要另外一个？</strong></p>
<p>UART 负责<strong>数据的传输方式</strong>，即如何按位发送和接收数据。而 TTL 则规定了实际传输中<strong>电信号的高低</strong>电平。</p>
<p>它们的关系类似于计算机网络中的 <strong>TCP&#x2F;IP 协议和以太网物理层</strong>的关系。UART 是负责<strong>逻辑层面的数据传输协议</strong>，而 TTL 则是负责<strong>电信号层面的物理传输标准</strong>。没有 UART 协议，TTL 电平的信号就没有办法以串行数据的方式组织和传输。没有 TTL 电平或其他类似的物理层标准，UART 定义的信号则没有适当的电压来表示和传输。</p>
<h3 id="CH340N"><a href="#CH340N" class="headerlink" title="CH340N"></a>CH340N</h3><p><strong>CH340N</strong> 是一款常用的 USB 转 UART（串口）的桥接芯片，用于将 UART 串口数据转换为 USB 接口数据，进而实现串口设备与 USB 设备之间的通信。</p>
<p>CH340N 芯片主要用于将串行 UART 接口转换为 USB 接口，并且在系统中<strong>可以虚拟为标准的串口设备</strong>（COM 口）。这种功能使得我们可以在计算机没有串口的情况下，通过 USB 进行串行通信，方便调试、数据传输等应用。</p>
<p><strong>串口转换芯片的转换电路图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/chuankouzuanUSB.png" alt="chuankouzuanUSB"></p>
<p><strong>引脚图：</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/chuankouzuanUSByuanlitu.png" alt="chuankouzuanUSByuanlitu"></p>
<ul>
<li>D+ D-对应的 USB 口，和 PC 主机连接</li>
<li>P3.1 P3.0 对应的芯片引脚</li>
<li>采用 CH340 将串口和 USB 之间进行转换</li>
</ul>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>以下是 STC8H 的芯片引脚介绍图</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/STC8H8K64Uyinjiaotu.png" alt="STC8H8K64Uyinjiaotu"></p>
<p>其中有 4 组 Uart 通讯口:</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/UARTtongxinkou.png" alt="UARTtongxinkou"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过串口接受收据并原样返回</p>
<ol>
<li><p>新建项目。新建<code>main.c</code>文件</p>
</li>
<li><p>导入函数库。拷贝以下函数库文件到项目目录：</p>
</li>
<li><p><code>Config.h</code> <code>Type_def.h</code></p>
</li>
<li><p><code>GPIO.h``GPIO.c</code></p>
</li>
<li><p><code>Delay.h``Delay.c</code></p>
</li>
<li><p><code>UART.h``UART.c``UART_Isr.c</code></p>
</li>
<li><p><code>NVIC.c</code> <code>NVIC.h</code></p>
</li>
<li><p><code>Switch.h</code></p>
</li>
</ol>
<h4 id="配置代码"><a href="#配置代码" class="headerlink" title="配置代码"></a>配置代码</h4><h5 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************* IO配置函数 *******************/</span></span><br><span class="line"><span class="type">void</span>	<span class="title function_">GPIO_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_Init; <span class="comment">//结构定义  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定IO的工作模式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    <span class="comment">//指定要初始化的IO引脚, Px0, Px1</span></span><br><span class="line">    GPIO_Init.Pin  = GPIO_Pin_0 | GPIO_Pin_1; </span><br><span class="line">       </span><br><span class="line">    GPIO_Inilize(GPIO_P3,&amp;GPIO_Init);	<span class="comment">//初始P3端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UART-1"><a href="#UART-1" class="headerlink" title="UART"></a>UART</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UART_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    COMx_InitDefine UART_Init; <span class="comment">//结构定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工作模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    <span class="comment">// SCON = (SCON &amp; 0x3f) | COMx-&gt;UART_Mode; SCON 串口 1 的控制寄存器 </span></span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;	</span><br><span class="line">    <span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1;			</span><br><span class="line">    UART_Init.UART_BaudRate  = <span class="number">115200ul</span>; <span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    <span class="comment">// 能够通过 UART 的 RX 引脚接收从其他设备发送过来的数据。</span></span><br><span class="line">    UART_Init.UART_RxEnable  = ENABLE; <span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    UART_Init.BaudRateDouble = DISABLE; <span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化串口: UART1,UART2,UART3,UART4</span></span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init); </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//UART1 中断初始化</span></span><br><span class="line">    <span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定为UART1通信的TX（发送）和RX（接收）引脚到底是那一对</span></span><br><span class="line">    <span class="comment">//UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在单片机开发中，配置了UART（UART1_SW(UART1_SW_P30_P31);）后，通常还需要配置GPIO（GPIO_Pin_0 | GPIO_Pin_1）。这是因为UART本身只是一种通信协议和硬件外设模块，而 GPIO 管脚的配置则决定了UART功能的实际物理引脚映射和特性。</p>
</blockquote>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">on_uart1_recv</span><span class="params">()</span> &#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="comment">// RX_Cnt收到的数据个数（字节u8 - unsigned char）</span></span><br><span class="line">    <span class="comment">// 将收到的数据, 按字节逐个循环</span></span><br><span class="line">    <span class="comment">// u8 RX1_Buffer[120]</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;COM1.RX_Cnt; i++) &#123;</span><br><span class="line">        u8 dat = RX1_Buffer[i]; <span class="comment">//  1 1 1 1  0 0 0 0 -&gt; 0xF0</span></span><br><span class="line">        TX1_write2buff(dat);	<span class="comment">//收到的数据原样返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">开启串口调试，接收数据，把收到的数据原样返回</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化GPIO、UART</span></span><br><span class="line">    GPIO_config();</span><br><span class="line">    UART_config();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启中断（全局）必须要写！</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个字节</span></span><br><span class="line">    TX1_write2buff(<span class="number">0x23</span>);</span><br><span class="line">	<span class="comment">// 通过PrintString1输出字符串</span></span><br><span class="line">    PrintString1(<span class="string">&quot;STC8H8K64U UART1 Test Programme!\r\n&quot;</span>);	<span class="comment">//UART1发送一个字符串</span></span><br><span class="line">    <span class="comment">// 通过printf输出字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STC8H8K64U UART1 Test Programme!\r\n&quot;</span>);	<span class="comment">//UART1发送一个字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 超时计数</span></span><br><span class="line">        <span class="comment">// 一旦收到了一个字节数据，RX_TimeOut会初始化一个值（例如：5）</span></span><br><span class="line">        <span class="keyword">if</span>((COM1.RX_TimeOut &gt; <span class="number">0</span>) &amp;&amp; (COM1.RX_TimeOut == <span class="number">0</span>)) &#123;            </span><br><span class="line">            <span class="keyword">if</span>(COM1.RX_Cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 收到数据了，on_uart1_recv();</span></span><br><span class="line">                on_uart1_recv();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完数据，将数据个数清零</span></span><br><span class="line">            COM1.RX_Cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 注意这里delay代码的位置，属于while</span></span><br><span class="line">        delay_ms(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>UART_Init.UART_BRT_Use = BRT_Timer1;</code> 这一句的作用是<strong>指定用哪个定时器来生成波特率</strong>，即通过哪个定时器为串口通信提供时钟信号。</p>
<p>在单片机中，多个定时器通常可以执行不同的任务，比如控制 PWM 信号、生成定时中断或产生串口波特率。如果某个定时器被用于其他任务，就需要选择另一个定时器来生成波特率。</p>
</blockquote>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>查看数据手册 UART 通信涉及中断，所以需要配置中断(开启中断)；</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>使用 STC-ISP 调试工具进行调试。切换好串口助手，选择正确的串口，设置和代码中相同的波特率。</p>
<p>通过发送区进行数据发送，通过接收区观察接收内容。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>为什么配置或者说使用 UART 时要指定定时器或者波特率发生器？</strong></p>
<p>在使用 <strong>UART</strong>（通用异步收发器）进行串行通信时，<strong>定时器</strong>或者<strong>波特率发生器</strong>的配置是必不可少的，因为串行通信是<strong>异步通信</strong>，没有时钟信号来同步发送端和接收端的数据传输。因此，波特率发生器和定时器的作用是保证双方能够在相同的时间窗口内正确地发送和接收数据。</p>
<blockquote>
<p><strong>异步通信</strong>（Asynchronous Communication）是一种数据传输方式，其中<strong>发送端和接收端之间没有共享的时钟信号</strong>，即没有全局时钟来同步数据的发送和接收。这种方式允许设备在不同的时间开始传输数据，但仍然能够通过某种机制正确解码接收到的数据。</p>
</blockquote>
<p>二、<strong>为什么要指定波特率?</strong></p>
<p>UART通信是异步的，这意味着通信双方没有共享的时钟信号。<strong>在没有时钟同步的情况下，双方必须依靠波特率来控制数据传输的速率</strong>。如果发送端和接收端的波特率不一致，数据将无法正确解码，导致通信错误。因此，指定波特率为了<strong>确保数据能够在预期的速率下传输和接收</strong>。</p>
<p>三、<strong>URAT 中使用了 定时器，但我们却没有配置定时器却能使用为什么？</strong></p>
<p>因为他内部自己配置了对于定时器的一系列操作；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(COMx-&gt;UART_BRT_Use == BRT_Timer1) &#123;       </span><br><span class="line">	TR1 = <span class="number">0</span>;</span><br><span class="line">	AUXR &amp;= ~<span class="number">0x01</span>;		<span class="comment">//S1 BRT Use Timer1;</span></span><br><span class="line">	TMOD &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);	<span class="comment">//Timer1 set As Timer</span></span><br><span class="line">	TMOD &amp;= ~<span class="number">0x30</span>;		<span class="comment">//Timer1_16bitAutoReload;</span></span><br><span class="line">	AUXR |=  (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);	<span class="comment">//Timer1 set as 1T mode</span></span><br><span class="line">	TH1 = (u8)(j&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	TL1 = (u8)j;</span><br><span class="line">	ET1 = <span class="number">0</span>;			<span class="comment">//禁止中断</span></span><br><span class="line">	TMOD &amp;= ~<span class="number">0x40</span>;		<span class="comment">//定时</span></span><br><span class="line">	INTCLKO &amp;= ~<span class="number">0x02</span>;	<span class="comment">//不输出时钟</span></span><br><span class="line">	TR1  = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、<strong>多机通信指的是什么？</strong></p>
<p>UART（Universal Asynchronous  Receiver&#x2F;Transmitter，通用异步收发器）串口通信中的多机通信，指的是一个 UART 设备（通常称为主设备或主机）同时与多个其他 UART 设备（称为从设备或从机）进行通信的模式。这种通信模式在需要集中控制多个设备或进行数据广播的场景中非常有用。</p>
<p>五、<strong>波特率发生器怎么选：</strong></p>
<p>看数据手册：比如 UART4 可以选择定时器 2、定时器 4，UART4 只能使用定时器 2 等。</p>
<p>这里的波特率发生器就是定时器，但我们只需选择不需要配置，因为它默认会给我们进行配置 ；</p>
<p>六、<strong>为什么 MCU 可以发送汉字而不可以接收汉字</strong></p>
<p>如果 PC 端读取到一个字节的高位在有效范围，接下来的字节会被解释为同一字符的一部分，而不是独立的字节。相反，如果接收到的字节在 ASCII 范围内（0x00 到 0x7F），接收方将其视为普通字符。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>定时器（Timer）是一种嵌入式系统中常见的<strong>外设</strong>（是<strong>集成在芯片内部</strong>的一组功能模块），通常由一个晶体<strong>振荡器</strong>提供时钟信号，可以计时一定的时间后执行相应的操作；它是基于<strong>硬件计数器</strong>的一种机制，通常集成在微控制器（MCU）或处理器中；定时器的基本功能是<strong>精确测量时间间隔</strong>，或者<strong>根据时间周期触发特定任务</strong>。</p>
<blockquote>
<p>在嵌入式系统中，被称为<strong>外设</strong>（Peripheral）是因为它相对于<strong>中央处理器（CPU）的核心执行逻辑来说，是一种辅助功能模块</strong>。</p>
</blockquote>
<h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><ul>
<li><strong>时钟源</strong>：定时器依赖于外部时钟或内部时钟源（通常是微控制器的主时钟或分频时钟）来进行计时。</li>
<li><strong>计数器</strong>：定时器内部有一个计数器，它根据时钟源的频率进行递增或递减。计数器的大小可以是 8 位、16 位、32 位或其他大小，决定了它的计数范围。</li>
<li><strong>中断机制</strong>：定时器通常具有中断功能，当计数器达到设定的值或溢出时，定时器可以触发中断，通知处理器执行特定任务。</li>
</ul>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>嵌入式定时器一般有几种常见的工作模式：</p>
<ol>
<li><strong>计时&#x2F;定时模式（Timer Mode）</strong>：<ul>
<li>定时器以固定的频率计数，计数器的值随时间递增。当计数器<strong>达到预设值（或溢出）</strong>时，产生一个定时中断。这种模式用于周期性任务，例如定时任务、PWM 信号的产生、或周期性事件的触发。</li>
</ul>
</li>
<li><strong>计数模式（Counter Mode）</strong>：<ul>
<li>定时器可以用作事件计数器，它在某个外部信号（如 GPIO 脉冲输入）发生时进行计数。每检测到一个外部脉冲信号，计数器递增一次。这种模式适合<strong>对外部事件进行计数</strong>，比如脉冲信号的测量、转速计数等。</li>
</ul>
</li>
<li><strong>捕获模式（Capture Mode）</strong>：<ul>
<li>定时器在捕获模式下可以记录某个输入信号的变化时刻。比如，当一个外部信号到达时，定时器将当前的计数器值保存起来，从而记录信号发生时的精确时间。捕获模式常用于脉宽测量、外部信号的精确计时等。</li>
</ul>
</li>
<li><strong>比较模式（Compare Mode）</strong>：<ul>
<li>定时器在比较模式下，当计数器的值与预设的比较值相等时，定时器可以产生中断或者输出一个信号。该模式常用于生成 PWM（脉宽调制）信号或周期性输出信号。</li>
</ul>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>定时器启动后，根据配置的模式和速率进行计数。在定时模式下，定时器对内部系统时钟进行计数；在计数模式下，定时器对外部引脚输入的脉冲进行计数。</p>
<p>当定时器的计数值达到其容量上限（如16位定时器的上限为65535）时，会发生溢出。此时，定时器的溢出标志位（如TF0、TF1等）会被硬件置位，并向CPU发出中断请求（如果中断被允许）。</p>
<p>如果CPU允许中断，并且没有其他更高优先级的中断正在处理，那么CPU会响应定时器的中断请求，并跳转到对应的中断服务程序执行。</p>
<blockquote>
<p>单片机复位后，程序计数器(PC)从 0000H 单元开始执行程序。另外中断服务程序的入口地址(又称中断向量)也位于程序存储器单元。在程序存储器中，每个中断都有一个固定的入口地址，当中断发生并得到响应后，单片机就会自动跳转到相应的中断入口地址去执行程序。外部中断 0(INTO) 的中断服务程序的入口地址是 0003H，定时器&#x2F;计数器 0(TIMERO) 中断服务程序的入口地址是 000BH，外部中断 1(INT1) 的中断服务程序的入口地址是 0013H，定时器&#x2F;计数器 1(TIMER1) 的中断服务程序的入口地址是 001BH 等。</p>
<p>在 51 系列单片机中这些地址由 keil 编译器进行维护；</p>
</blockquote>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断被激活时，硬件会尝试跳转到我们提供的中断处理函数。而硬件怎么找到我们的中断处理函数呢？每种架构的 CPU 都会有一个固定的中断向量表，中断向量表按照中断号顺序存储中断处理函数的函数地址，当发生中断时，硬件会顺序查找对应的函数地址并跳转。</p>
<p>当程序被编译时，编译器会识别出中断服务函数的声明，并根据中断号在生成的代码中将中断服务函数的入口地址放置在中断向量表中对应的位置。中断向量表是一个特殊的存储区域，它记录了所有中断服务函数的入口地址，以便在中断发生时能够快速找到并跳转到相应的中断服务函数执行。</p>
<p>那么咱们写代码时在函数后加 interrupt n；Keil 编译后会将此函数首地址放入对应的寄存器中(<strong>中断向量</strong>)，请问这个中断号与中断向量的对应表在keil 中什么地方配置的呢，或者是在代码中如何实现的呢？这是由 keil 编译器所维护的一组对应关系表，写interrupt n，keil 会自动在中断向量处插入跳转到该函数入口点的 LJMP 单片机中断被允许且发生中断请求事件，CPU由硬件向PC写入中断向量实现中断跳转</p>
<blockquote>
<p>LJMP是一种远跳转指令，用于在保护模式或实地址模式下跳转到不同的代码段执行程序。</p>
<p>中断向量不是寄存器，是 FLASH 中的 code 区域靠前的一部分</p>
</blockquote>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>STC8H内置了5个16位定时器：T0，T1，T2，T3，T4；</p>
<p><strong>中断向量表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/STC8Hzhongduanxiangliangbiao.png" alt="STC8Hzhongduanxiangliangbiao"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>使用定时器，控制板载LED高低电平输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	GPIO_InitTypeDef GPIO_Init; <span class="comment">//结构定义</span></span><br><span class="line">	GPIO_Init.Pin = GPIO_Pin_3; <span class="comment">//指定要初始化的IO,</span></span><br><span class="line">    <span class="comment">//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Init.Mode = GPIO_PullUp;	</span><br><span class="line">    </span><br><span class="line">	GPIO_Inilize(GPIO_P5, &amp;GPIO_InitStructure);	<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	TIM_InitTypeDef Timer_Init <span class="comment">//结构定义</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//定时器0做16位自动重装, 中断频率为100000HZ，中断函数从P6.7取反输出50KHZ方波信号.</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">//指定工作模式,TIM_16BitAutoReload, TIM_16Bit, TIM_8BitAutoReload, TIM_16BitAutoReloadNoMask        </span></span><br><span class="line">	Timer_Init.TIM_Mode = TIM_16BitAutoReload;	</span><br><span class="line">    <span class="comment">//指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext</span></span><br><span class="line">	Timer_Init.TIM_ClkSource = TIM_CLOCK_1T;	</span><br><span class="line">    <span class="comment">//是否输出高速脉冲, ENABLE或DISABLE，如果配置ENABLE，则P3.5端口会同步输出时钟脉冲</span></span><br><span class="line">	Timer_Init.TIM_ClkOut = DISABLE;		</span><br><span class="line">    <span class="comment">//初值,指定Timer频率 1000hz (每秒执行1000次，每次1ms（周期））</span></span><br><span class="line">    <span class="comment">//不要小于367hz (2.7ms周期)</span></span><br><span class="line">	<span class="comment">//不要大于1 000 000hz 一百万 （1us周期)</span></span><br><span class="line">	Timer_Init.TIM_Value     = <span class="number">65536UL</span> - (MAIN_Fosc / <span class="number">1000UL</span>);	</span><br><span class="line">	<span class="comment">//是否初始化后启动定时器, ENABLE或DISABLE																	</span></span><br><span class="line">	Timer_Init.TIM_Run       = ENABLE;	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化Timer0 Timer0,Timer1,Timer2,Timer3,Timer4</span></span><br><span class="line">	Timer_Inilize(Timer0,&amp;TIM_InitStructure);	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">	NVIC_Timer0_Init(ENABLE,Priority_0);			</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	GPIO_config();</span><br><span class="line">	TIMER_config();</span><br><span class="line">	<span class="comment">// 开启全局中断</span></span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	P53 = <span class="number">0</span>;		<span class="comment">// 熄灯</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================================================= </span><br><span class="line"><span class="comment">// Timer_lsr.c</span></span><br><span class="line"><span class="comment">// 函数: Timer0_ISR_Handler</span></span><br><span class="line"><span class="comment">// 描述: Timer0中断函数.</span></span><br><span class="line"><span class="comment">// 参数: none.</span></span><br><span class="line"><span class="comment">// 返回: none.</span></span><br><span class="line"><span class="comment">// 版本: V1.0, 2020-09-23</span></span><br><span class="line"><span class="comment">//========================================================================</span></span><br><span class="line"><span class="type">void</span> Timer0_ISR_Handler (<span class="type">void</span>) interrupt TMR0_VECTOR <span class="comment">//进中断时已经清除标志</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加用户代码</span></span><br><span class="line">   P53 = ~P53;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>工作模式</strong></p>
<p>工作模式指的是计数方式，timer的计数是在主频计数的基础上，来进行数数的。timer有16位的计数器，通过计数器来计数来确定定时器运行的时长，在关键位置触发定时中断。</p>
<ul>
<li><strong>16位自动重装载模式：</strong>可以被设置成定时或者计数两种模式，每当定时器溢出时就会触发中断或者输出信号。</li>
<li>16位不可重装载模式：计数值达到设定值后，定时器就会停止计数，需要重新初始化才能继续计数。</li>
<li>8位自动重装载模式：8位计数器溢出时触发中断或输出信号。</li>
<li>不可屏蔽中断的16位自动重装载模式：16位计数器溢出时触发中断或输出信号，并且可以通过软件或硬件方式清除定时器计数器的值。</li>
</ul>
<p>通常使用<strong>16位自动重装载模式.</strong></p>
<p><strong>时钟源</strong></p>
<p>可配置的是重要有两个：说白了就是如何去数数</p>
<ul>
<li>1T: 跟随主频：每个时钟频率加一，速度是传统 8051 单片机的 12 倍</li>
<li>12T: 进行12分频：每 12 个时钟频率加一，与传统 8051 单片机相同</li>
</ul>
<p><strong>初值</strong></p>
<p>从初值开始数数，数多久触发一次中断；</p>
<p><strong>中断使能</strong></p>
<p>中断配置是为了打开中断开关的，从而可以触发中断回调的，如果不配置，将无法触发中断回调。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在定时器计算中为什么是 65536ul 减一，而不是 16 位的最大值 65535 减一</strong></p>
<p><strong>定时器的溢出原理</strong>：定时器计数器的工作原理是从一个预设的初始值开始，递增至最大计数值后发生溢出，随即重新开始从 0 计数。对于一个 16 位定时器，其最大计数范围是 0 到 65535，共有 65536 个可能的计数值。</p>
<p>在设置定时器预加载值时，选择 65536 作为基准是基于以下原因：</p>
<ul>
<li><strong>从 0 计数</strong>：定时器从 0 开始计数，<strong>达到预设值后回到 0</strong>。如果定时器从预设值开始计数，并且计数到 65535 之后发生溢出回到 0，则整个周期实际上包含了 65536 个计数步骤。</li>
<li><strong>完整周期</strong>：使用 65536 作为基数，允许定时器完整地经历从预设值到 65535 的所有计数状态，确保溢出时计数周期的完整性。</li>
</ul>
<blockquote>
<p>从 0 开始计数到达 16 位计数器的最大值 65535 之后发生溢出回到 0 ，然后在开始重新计数；也就是说加到 65535 之后还要再加一，才是一个完整的周期，也就是 65536 个数；</p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>指纹识别_AS608</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB_AS608/</url>
    <content><![CDATA[<p>AS608 是一款常用的指纹识别模块，广泛应用于各种身份验证和安全系统中。AS608 使用<strong>光学传感器</strong>捕捉指纹图像，具有较高的灵敏度和分辨率，能够清晰识别指纹的细节。每个指纹可以转换为<strong>模板</strong>，存储在模块内。模板通常包含特征点的信息，以提高识别的准确性。</p>
<blockquote>
<p>模板指的是经过处理后提取出的指纹特征信息。具体来说，模板是一个数字化的表示，包含指纹的独特特征点及其相互关系，而不是原始的指纹图像。</p>
</blockquote>
<p>AS608 指纹识别模块主要是指采用了杭州晟元芯片技术有限公司（Synochip）的 <strong>AS608 指纹识别芯片</strong>而做成的指纹模块，模块厂商只是基于该芯片设计外围电路，集成一个可供 2 次开发的指纹模块；<strong>所以，只要是基于 AS608 芯片的指纹模块，其控制电路及控制协议几乎是一样的，只是厂家和性能不同而已。</strong></p>
<h2 id="ATK-AS608"><a href="#ATK-AS608" class="headerlink" title="ATK-AS608"></a>ATK-AS608</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608img.png" alt="ATKAS608img"></p>
<h3 id="引脚描述"><a href="#引脚描述" class="headerlink" title="引脚描述"></a>引脚描述</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608yinjiao.png" alt="ATKAS608yinjiao"></p>
<blockquote>
<p>WAK：当手指放在传感器上时，WAK 会被拉高到高电平。初始化时，WAK 引脚的默认状态通常是低电平，MCU 通过轮询 WAK 状态来判断手指是否按下。在正常工作时，WAK 会在有手指时变为高电平，而没有手指时保持低电平。你无需将其初始化为高电平。</p>
</blockquote>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p><strong>模块指令格式</strong></p>
<p>模块指令格式分为三种：命令包格式、数据包格式、结束包格式。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608tongxinxieyi.png" alt="ATKAS608tongxinxieyi"></p>
<ul>
<li><p>包标识 &#x3D; 01 命令包</p>
</li>
<li><p>包标识 &#x3D;02 数据包，且有后续包 </p>
</li>
<li><p>包标识 &#x3D;08 最后一个数据包，即结束包 </p>
</li>
<li><p>所有的数据包都要加包头：0xEF01 </p>
</li>
<li><p><strong>发送</strong>给模块和<strong>接收</strong>模块的数据包格式相同。</p>
</li>
<li><p>数据包不能单独进入执行流程，必须跟在指令包或应答包后面。 </p>
</li>
<li><p>包长度 &#x3D; 包长度至校验和（指令、参数或数据）的总字节数，包含校验和，但不包含包长度本身的字节数。 </p>
</li>
<li><p>校验和是从包标识至校验和之间所有字节之和，超出 2 字节的进位忽略。 </p>
</li>
<li><p>芯片地址在没有生成之前为缺省的 0xFFFFFFFF，一旦上位机通过指令生成了芯片 地址，则所有的数据包都必须按照生成的地址收发。芯片将拒绝地址错误的数据 包。 </p>
</li>
<li><p>对于多字节的高字节在前低字节在后 （如 2bytes 的 00 06 表示 0006，而不是 0600）。</p>
</li>
<li><p>具体的指令码需要查看数据手册；</p>
</li>
</ul>
<p><strong>模块应答格式</strong></p>
<p>应答是将有关命令执行情况与结果上报给上位机，应答包含有参数，并可跟后续数据包。 上位机只有在收到模块的应答包后才能确认模块收包情况与指令执行情况。模块应答包中包 含一个参数：确认码。确认码表示执行指令完毕的情况。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608yindaxieyi.png" alt="ATKAS608yindaxieyi"></p>
<ul>
<li>返回的确认码含义需要去查看数据手册</li>
</ul>
<p><strong>指令只能由上位机下给模块，模块向上位机应答。</strong> </p>
<p><strong>不同的指令所返回的应答模块的确认码是不同的，我们只需要判断他所返回的几个状态就可以了；</strong></p>
<blockquote>
<p>系统上电复位后将首先检查默认的设备握手口令是否被修改，若未被修改，则系统 认为上位机没有验证口令的需求，SOC 直接进入正常工作状态；若已被修改，则必须首先验证设备握手口令，口令通过后 SOC 才进入正常工作状态。</p>
</blockquote>
<h3 id="口令和地址"><a href="#口令和地址" class="headerlink" title="口令和地址"></a>口令和地址</h3><p>系统默认口令为 0，可通过指令修改。若默认口令未被修改，则系统不要求验证口令， 上位机和 MCU 与芯片通讯；若口令被修改，则上位机与芯片通讯的第一个指令必须是验证 口令，只有口令验证通过后，芯片才接收其它指令。注：不建议修改口令！</p>
<p> 芯片的默认地址为 0Xffffffff,可通过指令修改，数据包的地址域必须与该地址相配，命令包&#x2F;数据包才被系统接收。 </p>
<h3 id="缓冲区与指纹库"><a href="#缓冲区与指纹库" class="headerlink" title="缓冲区与指纹库"></a>缓冲区与指纹库</h3><p>系统内设有一个 72K 字节的图像缓冲区与二个 512bytes 大小的特征文件缓冲区，名字 分别称为：ImageBuffer,CharBuffer1 和 CharBuffer2。用户可以通过指令读写任意一个缓冲区。 CharBuffer1 或 CharBuffer2 既可以用于存放普通特征文件也可以用于存放模板特征文件。通过 UART 口上传或下载图像时为了加快速度，只用到像素字节的高 4 位，即将两个像素合 成一个字节传送。通过 USB 口则是整 8 位像素。 </p>
<p>指纹库容量根据挂接的 FLASH 容量不同而改变，系统会自动判别。指纹模板按照<strong>序号</strong>存放，序号定义为：0—（N-1）（N 为指纹库容量）。用户只能根据序号访问指纹库内容。</p>
<h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608yuanlitu.png" alt="ATKAS608yuanlitu"></p>
<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UAER 初始化</span></span><br><span class="line"></span><br><span class="line">sbit WAK = P3^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我如何去触发（使用）这个指纹识别的功能</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(WAK == <span class="number">1</span>) &#123;</span><br><span class="line">        shuazhiwen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shuazhiwen</span><span class="params">()</span> &#123; </span><br><span class="line">    uchar IDs1,IDs2,IDs3;	 </span><br><span class="line">	SFG_identify();		 <span class="comment">//发送检测指纹命令</span></span><br><span class="line">	<span class="keyword">while</span>(querenma == <span class="number">1</span>)	<span class="comment">// 指纹错误</span></span><br><span class="line">		SFG_identify();  <span class="comment">//发送检测指纹命令</span></span><br><span class="line">	<span class="keyword">if</span>(querenma == <span class="number">0</span>) &#123;   </span><br><span class="line">		LcmClearTXT();</span><br><span class="line">		PutStr(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;门已打开&quot;</span>); </span><br><span class="line">		IDs1=PageID/<span class="number">100</span>;</span><br><span class="line">		IDs2=PageID/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">		IDs3=PageID%<span class="number">10</span>;</span><br><span class="line">		PutStr(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;编号为:&quot;</span>);</span><br><span class="line">		WriteCommand(<span class="number">0x8D</span>);		<span class="comment">//指定第三行显示位置</span></span><br><span class="line">		WriteData(<span class="number">0x30</span> + IDs1);</span><br><span class="line">		WriteData(<span class="number">0x30</span> + IDs2);</span><br><span class="line">		WriteData(<span class="number">0x30</span> + IDs3);</span><br><span class="line">		jidianqi = <span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">2500</span>); </span><br><span class="line">		jidianqi = <span class="number">1</span>;	</span><br><span class="line">		delay(<span class="number">1000</span>);</span><br><span class="line">		PutStr(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;    欢迎使用    &quot;</span>);</span><br><span class="line">		PutStr(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;  多功能门禁锁  &quot;</span>);</span><br><span class="line">		PutStr(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;  请输入密码：  &quot;</span>);</span><br><span class="line">		sc = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span>(querenma == <span class="number">9</span>) &#123; <span class="comment">// 没有指纹</span></span><br><span class="line">		LcmClearTXT();</span><br><span class="line">		PutStr(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;没搜索到指纹&quot;</span>);</span><br><span class="line">		PutStr(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;请重新按手指&quot;</span>);</span><br><span class="line">		beep = <span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">300</span>);</span><br><span class="line">		beep = <span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1000</span>);</span><br><span class="line">		PutStr(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;    欢迎使用    &quot;</span>);</span><br><span class="line">		PutStr(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;  多功能门禁锁  &quot;</span>);</span><br><span class="line">		PutStr(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;  请输入密码：  &quot;</span>);</span><br><span class="line">		sc++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SFG_identify</span><span class="params">()</span> &#123; <span class="comment">//自动验证指纹     录图像+生成特征+搜索   </span></span><br><span class="line">    uchar i,ID1,ID2; </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		0xEF01 0xFFFFFFFF 0x01 0x0003(03) 0x11 0x15（校验位）验证指纹</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">    SBUF = <span class="number">0xef</span>;    <span class="comment">// 触发中断写数据  </span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>); <span class="comment">// SCON寄存器 串口发送结束时一件自动置1 等着发送完</span></span><br><span class="line">    TI = <span class="number">0</span>;		 <span class="comment">// 需手动置0</span></span><br><span class="line">    SBUF = <span class="number">0X01</span>;    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    SBUF = <span class="number">0XFF</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">    SBUF = <span class="number">0XFF</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">    SBUF = <span class="number">0XFF</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">    SBUF = <span class="number">0XFF</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    SBUF=<span class="number">0X01</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    SBUF = <span class="number">0X00</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">    SBUF = <span class="number">0X03</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    SBUF = <span class="number">0X11</span>;   <span class="comment">// 表示验证指针</span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">    SBUF = <span class="number">0X00</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line">    summaf = <span class="number">0x15</span>;</span><br><span class="line">    SBUF = summaf;	   <span class="comment">//校验和</span></span><br><span class="line">    <span class="keyword">while</span>(TI == <span class="number">0</span>);</span><br><span class="line">    TI = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;       </span><br><span class="line">    	<span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    	RI = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI = <span class="number">0</span>;</span><br><span class="line">    querenma = SBUF;</span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI = <span class="number">0</span>;</span><br><span class="line">    ID1 = SBUF;</span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI = <span class="number">0</span>;</span><br><span class="line">    ID2 = SBUF;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI = <span class="number">0</span>;			  <span class="comment">//得分</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI  =<span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">1</span>] = SBUF;</span><br><span class="line">    <span class="keyword">while</span>(RI == <span class="number">0</span>);</span><br><span class="line">    RI=<span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">0</span>] = SBUF;</span><br><span class="line">    summas = (sum[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + sum[<span class="number">0</span>];									 </span><br><span class="line">    <span class="comment">//PageID=ID1;</span></span><br><span class="line">    PageID=(ID1 &lt;&lt; <span class="number">8</span>) + ID2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键扫描程序 P1.0--P1.3为行线 P1.4--P1.7为列线</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Keycan</span><span class="params">(<span class="type">void</span>)</span> &#123;   </span><br><span class="line">  	<span class="type">unsigned</span> <span class="type">char</span> rcode, ccode;</span><br><span class="line">  	P1 = <span class="number">0xF0</span>;     		</span><br><span class="line">  	<span class="keyword">if</span>((P1&amp;<span class="number">0xF0</span>) != <span class="number">0xF0</span>) &#123;</span><br><span class="line">    	delay(<span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">if</span>((P1&amp;<span class="number">0xF0</span>) != <span class="number">0xF0</span>) &#123;  </span><br><span class="line">        	rcode = <span class="number">0xFE</span>;	<span class="comment">// 1111 1110</span></span><br><span class="line">    		<span class="keyword">while</span>((rcode&amp;<span class="number">0x10</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">       			P1 = rcode;      <span class="comment">// 1011 1110</span></span><br><span class="line">      			<span class="keyword">if</span>((P1&amp;<span class="number">0xF0</span>) != <span class="number">0xF0</span>) &#123;</span><br><span class="line">       				ccode = (P1&amp;<span class="number">0xF0</span>)|<span class="number">0x0F</span>; <span class="comment">// 1011 0000 ==&gt; 1011 1111</span></span><br><span class="line">       				<span class="comment">//do&#123;;&#125;</span></span><br><span class="line">	   				<span class="keyword">while</span>((P1&amp;<span class="number">0xF0</span>) != <span class="number">0xF0</span>);</span><br><span class="line">       				<span class="keyword">return</span> ((~rcode) + (~ccode)); <span class="number">0000</span> <span class="number">0001</span> + <span class="number">0100</span> <span class="number">0000</span> =&gt; <span class="number">0100</span> <span class="number">0001</span></span><br><span class="line">      			&#125;<span class="keyword">else</span></span><br><span class="line">    				rcode = (rcode&lt;&lt;<span class="number">1</span>)|<span class="number">0x01</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="推挽输出"><a href="#推挽输出" class="headerlink" title="推挽输出"></a>推挽输出</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608tuiwan.png" alt="ATKAS608tuiwan"></p>
<blockquote>
<p>推挽模式不支持线与，因为可能会导致 mos 管烧掉</p>
</blockquote>
<h2 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ATKAS608kailou.png" alt="ATKAS608kailou"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>数码管</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E6%95%B0%E7%A0%81%E7%AE%A1/</url>
    <content><![CDATA[<p>数码管是一种常用于嵌入式开发中的<strong>显示设备</strong>，能够显示数字或特定字符。它以多个 LED 段组成的形式显示信息，广泛应用于电子设备的数字显示，如电子钟、温度计、计数器等。</p>
<p>数码管通常由 <strong>7 段（七段显示器）</strong> 或 <strong>8 段（包括小数点）</strong> 的 LED 组成，每个段对应一个 LED。当相应段被点亮时，会形成数字0-9的形状。</p>
<p><strong>共阴与共阳</strong></p>
<p>数码管的驱动方式主要有两种：共阳极和共阴极。</p>
<ul>
<li><strong>共阳极</strong>：所有LED段的阳极（正极）连接在一起，通过控制各个LED段的阴极（负极）来控制其亮灭。</li>
<li><strong>共阴极</strong>：所有LED段的阴极（负极）连接在一起，通过控制各个LED段的阳极（正极）来控制其亮灭。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/gongyingongyangtu.png" alt="gongyingongyangtu"></p>
<blockquote>
<p>举例：</p>
<p>对于一个共阴数码管，要点亮某一段，比如“a段”，需要将“a段”的阳极引脚置高（电压为正），而阴极已经连接到地，所以电流会通过LED流向阴极，从而点亮LED。</p>
<p>对于一个共阳数码管，要点亮某一段，比如“a段”，需要将“a段”的阴极引脚置低（接地），而阳极已经连接到正电压（<code>+5V</code>），这样电流就会从阳极流向阴极，通过LED，从而点亮LED。</p>
</blockquote>
<p><strong>四位数码管原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/siweishumaguanyuanlitu.png" alt="siweishumaguanyuanlitu"></p>
<h2 id="74HC595位移寄存器"><a href="#74HC595位移寄存器" class="headerlink" title="74HC595位移寄存器"></a>74HC595位移寄存器</h2><p>为了解决数码管端口复用的问题引入了 74HC595 位移寄存器</p>
<p>74HC595 是一个 <strong>8 位移位寄存器</strong>，具备 <strong>串行数据输入</strong>（逐位输入）和 <strong>并行数据输出</strong>（一次输出 8 位）的功能。它可以通过控制输入的时钟脉冲将串行输入的数据位依次移入寄存器中，然后一次性输出 8 位数据。</p>
<blockquote>
<p>也是一个将二进制数据转换为高低电平的一个工具。</p>
</blockquote>
<p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595yinjiaotu.png" alt="74HC595yinjiaotu"></p>
<p>74HC595 引脚：</p>
<ol>
<li>LATCH_CLOCK:  锁存时钟</li>
<li>SHIFT_CLOCK: 移位时钟</li>
<li>A:  数据输入信号管脚</li>
<li>QA~QH: 将二进制数据信号转化为高低电平输出给数码管</li>
<li>SQH: 串行数据输出管脚</li>
</ol>
<p><strong>管脚功能定义</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595guanjiaodingyi.png" alt="74HC595guanjiaodingyi"></p>
<p><strong>真值表</strong>（“↑”表示上升沿；“↓”表示下降沿）</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595zhenzhibiao.png" alt="74HC595zhenzhibiao"></p>
<p>真值表解释：</p>
<ol>
<li><strong>X</strong>：表示该引脚的状态无关，处于任意状态（高电平或低电平都无影响）。</li>
<li><strong>↑</strong>：表示上升沿，即时钟从低电平变为高电平的瞬间。</li>
<li><strong>SER</strong>：串行数据输入</li>
<li><strong>SRCLK</strong>：移位寄存器时钟</li>
<li><strong>SRCLR</strong>：移位寄存器清零</li>
<li><strong>RCLK</strong>：存储寄存器时钟信号</li>
<li><strong>OE</strong>：输出使能信号</li>
</ol>
<p>根据表中的不同情况，移位寄存器的行为如下：</p>
<ul>
<li><strong>X X X X H</strong>：当 <code>OE</code> 为高电平时，QA 到 QH 输出被禁用（输出处于高阻态）。</li>
<li><strong>X X X X L</strong>：当 <code>OE</code> 为低电平时，QA 到 QH 输出被启用，输出寄存器的数据可以通过并行输出引脚输出。</li>
<li><strong>X X L X X</strong>：当 <code>SRCLR</code> 为低电平时，移位寄存器的数据被清零，所有数据位变为 0。</li>
<li><strong>L ↑ H X X</strong>：当 <code>SER</code> 为低电平且 <code>SRCLK</code> 时钟上升沿到来时，移位寄存器的第一级存储数据变为 0，其它级别的数据顺序右移。</li>
<li><strong>H ↑ H X X</strong>：当 <code>SER</code> 为高电平且 <code>SRCLK</code> 时钟上升沿到来时，移位寄存器的第一级存储数据变为 1，其它级别的数据顺序右移。</li>
<li><strong>X X X ↑ X</strong>：当 <code>RCLK</code> 时钟上升沿到来时，移位寄存器中的数据存储到输出寄存器，并更新输出。</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>74HC595 原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595yuanlitu.png" alt="74HC595yuanlitu"></p>
<p><strong>数据输入与移位过程</strong></p>
<ul>
<li><strong>A（数据输入）</strong>：通过该引脚，74HC595 可以接收<strong>一个串行数据</strong>流。</li>
<li><strong>SHIFT_CLOCK（移位时钟）</strong>：每个时钟上升沿时，串行数据通过 A 进入移位寄存器，寄存器中已有的数据则向高位位移。</li>
<li><strong>LATCH_CLOCK（存储时钟&#x2F;锁存时钟）</strong>：该信号用于控制何时将移位寄存器中的内容输出到并行引脚 <code>QA</code> 到 <code>QH</code>。通常移位完成后，上升沿时触发锁存操作，将寄存器中的数据输出到 Qx 引脚(Qx 泛指 QA~QH 中任意一个)。</li>
</ul>
<p><strong>清除与输出控制</strong></p>
<ul>
<li><strong>RESET（复位引脚）</strong>：当该引脚为低电平时，移位寄存器中的所有数据将被清零。</li>
<li><strong>OE（输出使能）</strong>：该引脚为低电平时，输出引脚 <code>QA</code> 到 <code>QH</code> 才有效；为高电平时，输出引脚为高阻态（等效于禁用输出）。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><strong>SQ<sub>H</sub>（串行数据输出端）</strong>：用于<strong>级联</strong>多个 74HC595 芯片，使得可以串联多个寄存器扩展更多的 IO 端口。第一个寄存器中的数据将通过这个引脚输出串行输入到下一个 74HC595 的串行数据输入端。</li>
</ul>
<p><strong>串联多个 74HC595</strong></p>
<p>如果要控制超过 8 个输出，可以将多个 74HC595 级联。级联时，第一个 74HC595 的 <code>SQH</code>（串行输出引脚）连接到下一个 74HC595 的 <code>A</code>（数据输入引脚），以此类推。这样可以通过同一个数据和时钟输入同时控制多个 74HC595，实现扩展更多的并行输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595cuanlian.png" alt="74HC595cuanlian"></p>
<p>当 U1 八个被填满后，在传入数据就会通过 SQH 引脚被挤到 U2 中的 QA 然后依次向高位位移。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>以 74HC595 为例</p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/74HC595STC8Hyuanlitu.png" alt="74HC595STC8Hyuanlitu"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>八个数码管分别亮7、7、、7、7、7、7、7</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NIXIE.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注意，此处要反着来，因为共阳时低电平导通，最低为代表 a 段数码管</span></span><br><span class="line">    u8 dat = <span class="number">0xF8</span>; <span class="comment">// 要显示的数字 7 1111 1000</span></span><br><span class="line">    u8 num = <span class="number">0xFB</span>; <span class="comment">// 要显示哪几个数码管 1111 1011  </span></span><br><span class="line">    </span><br><span class="line">    NIXIE_Init();</span><br><span class="line">    </span><br><span class="line">    NIXIE_shwo(dat, num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">====================================================================================</span><br><span class="line"><span class="comment">// NIXIE.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __NIXIE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NIXIE_H__</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIXIE_DI  P44  <span class="comment">// 数据输入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIXIE_SCK P42  <span class="comment">// 移位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIXIE_RCK P43  <span class="comment">// 锁存寄存器</span></span></span><br><span class="line"><span class="comment">// 获取 byte 的第 pso 位    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_BIT_VAL(byte, pos)	(byte &amp; (1 &lt;&lt; pos))    </span></span><br><span class="line"><span class="comment">// 空操作    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOP_TIME() NOP2()</span></span><br><span class="line"><span class="comment">// 锁存操作 上升沿有效</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCK_ACTION() 		\</span></span><br><span class="line"><span class="meta">		NIXIE_RCK = 0;		\</span></span><br><span class="line"><span class="meta">		NOP_TIME();			\</span></span><br><span class="line"><span class="meta">		NIXIE_RCK = 1;		\</span></span><br><span class="line"><span class="meta">		NOP_TIME();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> NIXIE_Init();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示操作</span></span><br><span class="line"><span class="comment">// dat 显示的数据，num 要显示那几个数码管</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIXIE_show</span><span class="params">(u8 dat, u8 num)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">======================================================================================</span><br><span class="line"><span class="comment">// NIXIE.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NIXIE.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> NIXIE_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    GPIO_InitTypeDef	GPIO_Init; <span class="comment">// 结构定义</span></span><br><span class="line">    <span class="comment">// 指定要初始化的IO,</span></span><br><span class="line">	GPIO_Init.Pin  = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4;	</span><br><span class="line">    <span class="comment">// 指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Init.Mode = GPIO_PullUp;	</span><br><span class="line">    </span><br><span class="line">	GPIO_Inilize(GPIO_P4, &amp;GPIO_Init);<span class="comment">//初始化</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIXIE_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NIXIE_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NIXIE_Write1Bit</span><span class="params">(u8 dat)</span> &#123;</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        NIXIE_DI = GET_BIT_VAL(dat, i);</span><br><span class="line">		<span class="comment">// 寄存器的移位操作</span></span><br><span class="line">		NIXIE_SCK = <span class="number">0</span>;</span><br><span class="line">		NOP_TIME(); <span class="comment">// 休眠一会儿</span></span><br><span class="line">		NIXIE_SCK = <span class="number">1</span>;</span><br><span class="line">		NOP_TIME(); <span class="comment">// 休眠一会儿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIXIE_show</span><span class="params">(u8 dat, u8 num)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示 7.</span></span><br><span class="line">	<span class="comment">// 0111 1000</span></span><br><span class="line">	<span class="comment">// 先发字母位 (控制显示的内容)	// 0点亮</span></span><br><span class="line">	<span class="comment">// 8bit，先发出去的会作为高位</span></span><br><span class="line">	NIXIE_out(dat);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 0,1,2,3....7</span></span><br><span class="line">	<span class="comment">// 再发数字位 （控制显示哪几个） // 只要不是0，就是高电平</span></span><br><span class="line">	<span class="comment">// 1111 1011</span></span><br><span class="line">	<span class="comment">// 7.7.空7. 7.7.7.7.  -------------------与二级制是反向</span></span><br><span class="line">	<span class="comment">// 8bit，先发出去的会作为高位</span></span><br><span class="line">	NIXIE_out(num);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 锁存操作</span></span><br><span class="line">	RCK_ACTION();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>温湿度传感器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<p>在嵌入式开发中，<strong>温湿度传感器</strong>是一类用于测量环境<strong>温度</strong>和<strong>湿度</strong>的<strong>设备</strong>，广泛应用于气候监测、家用电器、物联网（IoT）设备、工业自动化等领域。它们能够感知环境中的温度和湿度变化，并将这些信息以<strong>电信号</strong>（0 和 1）的形式传递给微控制器（MCU）或处理单元。</p>
<h3 id="温湿度传感器的工作原理"><a href="#温湿度传感器的工作原理" class="headerlink" title="温湿度传感器的工作原理"></a><strong>温湿度传感器的工作原理</strong></h3><p>温湿度传感器通常将温度和湿度这两个参数集成在一个<strong>传感器芯片</strong>上，它们的工作原理如下：</p>
<h4 id="温度传感器部分"><a href="#温度传感器部分" class="headerlink" title="温度传感器部分"></a>温度传感器部分</h4><ul>
<li>温度测量常使用热敏电阻、热电偶、或半导体温度传感器来感知温度。<ul>
<li><strong>热敏电阻</strong>：通过材料电阻值随温度变化而变化的特性来测量温度。</li>
<li><strong>半导体温度传感器</strong>：基于 PN 结的电压特性，随着温度变化产生可测量的电压变化。</li>
<li><strong>热电偶</strong>：由两种不同金属连接形成，当温度变化时产生电势差。</li>
</ul>
</li>
</ul>
<h4 id="湿度传感器部分"><a href="#湿度传感器部分" class="headerlink" title="湿度传感器部分"></a>湿度传感器部分</h4><ul>
<li>湿度测量一般通过电容式湿度传感器或电阻式湿度传感器来完成。<ul>
<li><strong>电容式湿度传感器</strong>：由一层吸湿性介质组成，介质吸收空气中的水分导致电容变化，从而测量湿度。</li>
<li><strong>电阻式湿度传感器</strong>：感湿材料的电阻随空气湿度变化而变化，电阻值的变化反映空气中的湿度。</li>
</ul>
</li>
</ul>
<h3 id="常见的温湿度传感器种类"><a href="#常见的温湿度传感器种类" class="headerlink" title="常见的温湿度传感器种类"></a><strong>常见的温湿度传感器种类</strong></h3><p>嵌入式开发中，使用最广泛的温湿度传感器主要有以下几类：</p>
<h4 id="DHT-系列传感器"><a href="#DHT-系列传感器" class="headerlink" title="DHT 系列传感器"></a><strong>DHT 系列传感器</strong></h4><ul>
<li>DHT11 和 DHT22 是常见的低成本温湿度传感器，具有数字输出，易于与微控制器连接。<ul>
<li><strong>DHT11</strong>：精度较低，温度测量范围为 0<del>50℃，湿度测量范围为 20%</del>90%RH（相对湿度）。</li>
<li><strong>DHT22</strong>：精度较高，温度测量范围为 -40<del>80℃，湿度测量范围为 0%</del>100%RH。</li>
<li><strong>通信方式</strong>：单总线协议，通常用一根数据线来传输温度和湿度数据，简单易用。</li>
</ul>
</li>
</ul>
<h4 id="SHT-系列传感器"><a href="#SHT-系列传感器" class="headerlink" title="SHT 系列传感器"></a><strong>SHT 系列传感器</strong></h4><ul>
<li>SHT3x、SHT4x 系列是 Sensirion 公司生产的高精度温湿度传感器，广泛用于工业和高精度应用。<ul>
<li><strong>精度</strong>：温度测量精度高达 ±0.1℃，湿度测量精度 ±1.5%RH。</li>
<li><strong>通信方式</strong>：采用 I2C 或 SPI 接口，数据传输速度快，适合对精度要求较高的应用。</li>
</ul>
</li>
</ul>
<h4 id="AM2302（DHT22-的改进版）"><a href="#AM2302（DHT22-的改进版）" class="headerlink" title="AM2302（DHT22 的改进版）"></a><strong>AM2302（DHT22 的改进版）</strong></h4><ul>
<li>与 DHT22 类似，AM2302 是精度更高的温湿度传感器。<ul>
<li><strong>温度测量范围</strong>：-40~80℃。</li>
<li><strong>湿度测量范围</strong>：0~100%RH。</li>
</ul>
</li>
</ul>
<h3 id="DHT11"><a href="#DHT11" class="headerlink" title="DHT11"></a>DHT11</h3><p><strong>DHT11</strong> 是一种常用的低成本<strong>温湿度传感器</strong>，广泛用于简单的环境监测应用。它可以<strong>同时测量环境的温度和湿度</strong>，并通过<strong>单线数字接口</strong>与微控制器通信，易于使用。</p>
<p><strong>温度测量：</strong>DHT11 使用一个 <strong>NTC 热敏电阻</strong>作为温度感应器，感知周围环境的温度变化。热敏电阻的电阻值会随着温度变化而变化，传感器内部将此电阻变化转换为温度数据。</p>
<p><strong>湿度测量：</strong>DHT11 使用<strong>电容式湿度传感器</strong>来检测湿度。传感器内有一个吸湿性聚合物层，这一层的电容会随着空气中水分含量（湿度）的变化而变化。传感器通过测量这一电容变化来计算空气湿度。</p>
<p><strong>通信协议</strong></p>
<p>DHT11 使用<strong>单线数字通信协议</strong>来与微控制器通信，这意味着它只需<strong>一个数据线即可传输温湿度数据</strong>。通信流程通常如下：</p>
<ol>
<li><p><strong>初始化</strong>：微控制器向传感器发送一个低电平启动信号（至少 18ms），然后释放数据线（至少 10us）。</p>
</li>
<li><p><strong>响应信号</strong>：DHT11 传感器发送一个响应信号（响应低高电平，低电平至少 78us，高电平至少 80us），告诉微控制器它已经准备好数据。</p>
</li>
<li><p><strong>数据传输</strong>：DHT11 以位（bit）的形式将温度和湿度数据（共 40 位）传给微控制器。数据传输分为两个部分：</p>
<ul>
<li><p><strong>湿度数据</strong>（16 位）：包含湿度的整数和小数部分。</p>
</li>
<li><p><strong>温度数据</strong>（16 位）：包含温度的整数和小数部分。</p>
</li>
</ul>
</li>
<li><p><strong>校验位</strong>：最后传感器发送一个 8 位的校验码，用于确认数据是否传输正确。</p>
</li>
</ol>
<p><strong>DHT11 温湿度传感器的通信时序参数</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11shixucanshu.png" alt="DHT11shixucanshu"></p>
<p><strong>数据时序图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11shjushixu.png" alt="DHT11shjushixu"></p>
<p><strong>信息格式说明</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11geshishuom.png" alt="DHT11geshishuom"></p>
<p><strong>接收到的 40 位数据示例</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11shili.png" alt="DHT11shili"></p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p>使用 DHT11 模块</p>
<p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/DHT11yinjiao.png" alt="DHT11yinjiao"></p>
<blockquote>
<p>NG 通常表示<strong>没有接地</strong>或<strong>没有连接</strong>。在具体电路中，建议结合设计者的注释或相关文档进一步确认它的确切含义。</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DHT11.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typedef</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> humidity;    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="type">float</span> temperature; <span class="comment">// 温度</span></span><br><span class="line">    u8 is_ok;		   <span class="comment">// 校验位：0 数据异常，1 数据正确</span></span><br><span class="line">    </span><br><span class="line">&#125;DHT11_TRH;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_GetTRH</span><span class="params">()</span>;</span><br><span class="line">===============================================================================</span><br><span class="line"><span class="comment">// DHT11.c    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DHT11.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11 P46 <span class="comment">// 温湿度传感器数据引脚    </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGH 1    <span class="comment">// 高电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOW 0    <span class="comment">// 低电平</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 计算从设备输出的高低电平是否正确 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> calc_time(level, min, max, ErrMsg); count = 0;								\</span></span><br><span class="line"><span class="meta">                                            do &#123;									\				</span></span><br><span class="line">                                                count++;							\</span><br><span class="line">                                                NOP16();<span class="comment">//(1us) 不同设备可能时间不同 	 \ </span></span><br><span class="line">                                            &#125; <span class="keyword">while</span>(DHT11 == level);				\</span><br><span class="line">                                            <span class="keyword">if</span>(count &lt; main || count &gt; max) &#123;		\</span><br><span class="line">                                                <span class="built_in">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>, ErrMsg, count);	\</span><br><span class="line">                                                <span class="keyword">return</span> trh;							\</span><br><span class="line">                                            &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay20ms</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">// @24.000MHz</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line">    </span><br><span class="line">    _nop_();</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    j = <span class="number">112</span>;</span><br><span class="line">    k = <span class="number">91</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(--k);</span><br><span class="line">        &#125; <span class="keyword">while</span>(--j);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span>(--i);  </span><br><span class="line">&#125;    </span><br><span class="line">      </span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DHT11_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_DHT11_Init;</span><br><span class="line">    GPIO_DHT11_Init.Mode = GPIO_PullUp; <span class="comment">//IO模式, GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_DHT11_Init.Pin = GPIO_Pin_6;   <span class="comment">//要设置的端口</span></span><br><span class="line">    </span><br><span class="line">    GPIO_Inilize(GPIO_P4, &amp;GPIO_DHT11_Init);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_DHT11_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DHT11_TRH <span class="title function_">DhT11_GetTRH</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    DHT11_TRH trh;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    u8 dat[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    trh.is_ok = <span class="number">0</span>; <span class="comment">// 默认数据不准确</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主机起始信号拉低时间</span></span><br><span class="line">    DHT11 = <span class="number">0</span>;</span><br><span class="line">    Delay20ms();</span><br><span class="line">    DHT11 = <span class="number">1</span>; <span class="comment">// 拉高后 10~35us 内温湿度传感觉会进行相应；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主机释放总线时间,高电平持续 10~35 us</span></span><br><span class="line">    calc_time(HIGH, <span class="number">10</span>, <span class="number">35</span>, <span class="string">&quot;主机释放时间有误&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应低电平时间，低电平持续时间 78~88 us</span></span><br><span class="line">    calc_time(LOW, <span class="number">78</span>, <span class="number">88</span>, <span class="string">&quot;响应低电平时间有误&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 响应高电平时间，高电平持续 80~92 us</span></span><br><span class="line">    calc_time(HIGH, <span class="number">80</span>, <span class="number">92</span>, <span class="string">&quot;响应高电平时间有无&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始接收数据并校验是否正确（40 位）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 五个字节</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">7</span>; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 每个字节八位</span></span><br><span class="line">            <span class="comment">// 判断低电平是否有误</span></span><br><span class="line">            calc_time(LOW, <span class="number">50</span>, <span class="number">58</span>, <span class="string">&quot;信号 0|1 低电平时间有误&quot;</span>);</span><br><span class="line">            <span class="comment">// 判断高电平是否有误</span></span><br><span class="line">            calc_time(LOW, <span class="number">23</span>, <span class="number">74</span>, <span class="string">&quot;信号 0|1 低电平时间有误&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">48</span>) &#123; <span class="comment">// 48 是 0|1 高电平的中间值</span></span><br><span class="line">                <span class="comment">// 数组默认为 0，所以这里只需要根据位置修改为 1 即可</span></span><br><span class="line">                dat[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 校验数据是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(dat[<span class="number">4</span>] == dat[<span class="number">0</span>] + dat[<span class="number">1</span>] + dat[<span class="number">2</span>] + dat[<span class="number">3</span>]) &#123;</span><br><span class="line">        trh.is_ok = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 组装温湿度</span></span><br><span class="line">       trh.humidity = dat[<span class="number">0</span>] + dat[<span class="number">1</span>] * <span class="number">0.1</span>;</span><br><span class="line">       <span class="comment">// 温度小数位的最高位为标志位不参与运算 </span></span><br><span class="line">       trh.humidity = dat[<span class="number">2</span>] + (dat[<span class="number">3</span>] &amp; <span class="number">0x7F</span>) * <span class="number">0.1</span>; </span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span>(dat[<span class="number">3</span>] &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">           trh.humidity = -trh.humidity;</span><br><span class="line">       &#125; </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> trh;</span><br><span class="line">&#125;                           </span><br><span class="line">===========================================================================</span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#inculude <span class="string">&quot;STC8G_H_Delay.h&quot;</span>   </span></span><br><span class="line"><span class="meta">#inculude <span class="string">&quot;STC8G_H_UART.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#inculude <span class="string">&quot;DHTll.h.h&quot;</span>   </span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    DHT11_TRH DHT11_trh;</span><br><span class="line">      </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    DHT11_Init();</span><br><span class="line">    UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        trh = DHT11_GetTRH();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(trh.is_ok) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;温度：%.2f\n&quot;</span>, trh.temperature);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;湿度：%.2f\n&quot;</span>, trh.humidity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;数据有误，请重新获取~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>热敏电阻</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB/</url>
    <content><![CDATA[<p>NTC（Negative Temperature Coefficient）即负温度系数，是一种描述材料或元器件<strong>电阻值随温度变化</strong>的特性。具体来说，NTC指的是那些电阻值随温度<strong>升高</strong>而<strong>降低</strong>的材料或元器件。</p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/remdianzuyuanlitu.png" alt="remdianzuyuanlitu"></p>
<blockquote>
<p>R6 上标注的 <strong>10kΩ</strong> 通常是指 <strong>NTC 热敏电阻在某个特定温度下（25℃）的标称电阻值</strong></p>
</blockquote>
<h2 id="计算热敏电阻位置的电压值"><a href="#计算热敏电阻位置的电压值" class="headerlink" title="计算热敏电阻位置的电压值"></a>计算热敏电阻位置的电压值</h2><p><strong>电容器两端的电压</strong>与谁并联，就跟谁电压相等。</p>
<p>以上图为例：</p>
<p>vcc 处电压为 3.3V，NTC 处的电压为 ntc_V，那么 R20 处的电压就是 (3.3 - ntc_v)V，那么流过 R20 的电流 I &#x3D;  (3.3 - ntc_v) &#x2F; 10</p>
<p>假设 ntc-v 为 1.3 则 2 &#x2F; 10 000 &#x3D; 0.0002 安，也就是说 经过 R20 的电流为 0.0002 安</p>
<p>同理，热敏电阻的电流 I &#x3D; (ntc_V - 0) &#x2F; 热敏电阻</p>
<p>又因为串联电路电流处处相等：(ntc_V  &#x2F; 热敏电阻) &#x3D;  (3.3 - ntc_v) &#x2F; 10</p>
<p>所以：热敏电阻(KΩ) &#x3D; ntc_V  * 10 &#x2F; （3.3 - ntc_V  ）</p>
<p><strong>电路中明明有一条路是电容的支路，但为什么还是按照串联计算呢</strong></p>
<p>电容器在上电瞬间的行为表现为短路，因为当电容器刚刚连接到电源时，两个板之间的电势差为零，而电势的变化速度非常快。由于电容器的特性，当电压为零时，根据欧姆定律，电流会变为无限大，因此形成了短路的表象。</p>
<p>然而，这种短路现象并不会持续很久，电容器内的电荷和电势会很快建立起来，电流会逐渐降低直至稳定。那么此时就会形成断路的情况，那么也就可以当作这条路不存在了。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NTC.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	__NTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__NTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数声明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 热敏电阻初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对应温度的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NTC_GetTemperature</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">=================================================================</span><br><span class="line"><span class="comment">// NTC.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NTC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ADC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 热敏电阻与温度对照表</span></span><br><span class="line">u16 code temp_table[]= &#123;</span><br><span class="line">	<span class="number">58354</span>, <span class="comment">// -55</span></span><br><span class="line">	<span class="number">55464</span>, <span class="comment">// -54</span></span><br><span class="line">	<span class="number">52698</span>, <span class="comment">// -53</span></span><br><span class="line">	<span class="number">50048</span>, <span class="comment">// -52</span></span><br><span class="line">	<span class="number">47515</span>, <span class="comment">// -51</span></span><br><span class="line">	<span class="number">45097</span>, <span class="comment">// -50</span></span><br><span class="line">	<span class="number">42789</span>, <span class="comment">// -49</span></span><br><span class="line">	<span class="number">40589</span>, <span class="comment">// -48</span></span><br><span class="line">	<span class="number">38492</span>, <span class="comment">// -47</span></span><br><span class="line">	<span class="number">36496</span>, <span class="comment">// -46</span></span><br><span class="line">	<span class="number">34597</span>, <span class="comment">// -45</span></span><br><span class="line">	<span class="number">32791</span>, <span class="comment">// -44</span></span><br><span class="line">	<span class="number">31075</span>, <span class="comment">// -43</span></span><br><span class="line">	<span class="number">29444</span>, <span class="comment">// -42</span></span><br><span class="line">	<span class="number">27896</span>, <span class="comment">// -41</span></span><br><span class="line">	<span class="number">26427</span>, <span class="comment">// -40</span></span><br><span class="line">	<span class="number">25034</span>, <span class="comment">// -39</span></span><br><span class="line">	<span class="number">23713</span>, <span class="comment">// -38</span></span><br><span class="line">	<span class="number">22460</span>, <span class="comment">// -37</span></span><br><span class="line">	<span class="number">21273</span>, <span class="comment">// -36</span></span><br><span class="line">	<span class="number">20148</span>, <span class="comment">// -35</span></span><br><span class="line">	<span class="number">19083</span>, <span class="comment">// -34</span></span><br><span class="line">	<span class="number">18075</span>, <span class="comment">// -33</span></span><br><span class="line">	<span class="number">17120</span>, <span class="comment">// -32</span></span><br><span class="line">	<span class="number">16216</span>, <span class="comment">// -31</span></span><br><span class="line">	<span class="number">15361</span>, <span class="comment">// -30</span></span><br><span class="line">	<span class="number">14551</span>, <span class="comment">// -29</span></span><br><span class="line">	<span class="number">13785</span>, <span class="comment">// -28</span></span><br><span class="line">	<span class="number">13061</span>, <span class="comment">// -27</span></span><br><span class="line">	<span class="number">12376</span>, <span class="comment">// -26</span></span><br><span class="line">	<span class="number">11728</span>, <span class="comment">// -25</span></span><br><span class="line">	<span class="number">11114</span>, <span class="comment">// -24</span></span><br><span class="line">	<span class="number">10535</span>, <span class="comment">// -23</span></span><br><span class="line">	<span class="number">9986</span>,  <span class="comment">// -22</span></span><br><span class="line">	<span class="number">9468</span>,  <span class="comment">// -21</span></span><br><span class="line">	<span class="number">8977</span>,  <span class="comment">// -20</span></span><br><span class="line">	<span class="number">8513</span>,  <span class="comment">// -19</span></span><br><span class="line">	<span class="number">8075</span>,  <span class="comment">// -18</span></span><br><span class="line">	<span class="number">7660</span>,  <span class="comment">// -17</span></span><br><span class="line">	<span class="number">7267</span>,  <span class="comment">// -16</span></span><br><span class="line">	<span class="number">6896</span>,  <span class="comment">// -15</span></span><br><span class="line">	<span class="number">6545</span>,  <span class="comment">// -14</span></span><br><span class="line">	<span class="number">6212</span>,  <span class="comment">// -13</span></span><br><span class="line">	<span class="number">5898</span>,  <span class="comment">// -12</span></span><br><span class="line">	<span class="number">5601</span>,  <span class="comment">// -11</span></span><br><span class="line">	<span class="number">5319</span>,  <span class="comment">// -10</span></span><br><span class="line">	<span class="number">5053</span>,  <span class="comment">// -9</span></span><br><span class="line">	<span class="number">4801</span>,  <span class="comment">// -8</span></span><br><span class="line">	<span class="number">4562</span>,  <span class="comment">// -7</span></span><br><span class="line">	<span class="number">4336</span>,  <span class="comment">// -6</span></span><br><span class="line">	<span class="number">4122</span>,  <span class="comment">// -5</span></span><br><span class="line">	<span class="number">3920</span>,  <span class="comment">// -4</span></span><br><span class="line">	<span class="number">3728</span>,  <span class="comment">// -3</span></span><br><span class="line">	<span class="number">3546</span>,  <span class="comment">// -2</span></span><br><span class="line">	<span class="number">3374</span>,  <span class="comment">// -1</span></span><br><span class="line">	<span class="number">3211</span>,  <span class="comment">// 0</span></span><br><span class="line">	<span class="number">3057</span>,  <span class="comment">// 1</span></span><br><span class="line">	<span class="number">2910</span>,  <span class="comment">// 2</span></span><br><span class="line">	<span class="number">2771</span>,  <span class="comment">// 3</span></span><br><span class="line">	<span class="number">2639</span>,  <span class="comment">// 4</span></span><br><span class="line">	<span class="number">2515</span>,  <span class="comment">// 5</span></span><br><span class="line">	<span class="number">2396</span>,  <span class="comment">// 6</span></span><br><span class="line">	<span class="number">2284</span>,  <span class="comment">// 7</span></span><br><span class="line">	<span class="number">2177</span>,  <span class="comment">// 8</span></span><br><span class="line">	<span class="number">2076</span>,  <span class="comment">// 9</span></span><br><span class="line">	<span class="number">1978</span>,  <span class="comment">// 10</span></span><br><span class="line">	<span class="number">1889</span>,  <span class="comment">// 11</span></span><br><span class="line">	<span class="number">1802</span>,  <span class="comment">// 12</span></span><br><span class="line">	<span class="number">1720</span>,  <span class="comment">// 13</span></span><br><span class="line">	<span class="number">1642</span>,  <span class="comment">// 14</span></span><br><span class="line">	<span class="number">1568</span>,  <span class="comment">// 15</span></span><br><span class="line">	<span class="number">1497</span>,  <span class="comment">// 16</span></span><br><span class="line">	<span class="number">1430</span>,  <span class="comment">// 17</span></span><br><span class="line">	<span class="number">1366</span>,  <span class="comment">// 18</span></span><br><span class="line">	<span class="number">1306</span>,  <span class="comment">// 19</span></span><br><span class="line">	<span class="number">1248</span>,  <span class="comment">// 20</span></span><br><span class="line">	<span class="number">1193</span>,  <span class="comment">// 21</span></span><br><span class="line">	<span class="number">1141</span>,  <span class="comment">// 22</span></span><br><span class="line">	<span class="number">1092</span>,  <span class="comment">// 23</span></span><br><span class="line">	<span class="number">1044</span>,  <span class="comment">// 24</span></span><br><span class="line">	<span class="number">1000</span>,  <span class="comment">// 25</span></span><br><span class="line">	<span class="number">957</span>,   <span class="comment">// 26</span></span><br><span class="line">	<span class="number">916</span>,   <span class="comment">// 27</span></span><br><span class="line">	<span class="number">877</span>,   <span class="comment">// 28</span></span><br><span class="line">	<span class="number">840</span>,   <span class="comment">// 29</span></span><br><span class="line">	<span class="number">805</span>,   <span class="comment">// 30</span></span><br><span class="line">	<span class="number">771</span>,   <span class="comment">// 31</span></span><br><span class="line">	<span class="number">739</span>,   <span class="comment">// 32</span></span><br><span class="line">	<span class="number">709</span>,   <span class="comment">// 33</span></span><br><span class="line">	<span class="number">679</span>,   <span class="comment">// 34</span></span><br><span class="line">	<span class="number">652</span>,   <span class="comment">// 35</span></span><br><span class="line">	<span class="number">625</span>,   <span class="comment">// 36</span></span><br><span class="line">	<span class="number">600</span>,   <span class="comment">// 37</span></span><br><span class="line">	<span class="number">576</span>,   <span class="comment">// 38</span></span><br><span class="line">	<span class="number">552</span>,   <span class="comment">// 39</span></span><br><span class="line">	<span class="number">530</span>,   <span class="comment">// 40</span></span><br><span class="line">	<span class="number">509</span>,   <span class="comment">// 41</span></span><br><span class="line">	<span class="number">489</span>,   <span class="comment">// 42</span></span><br><span class="line">	<span class="number">470</span>,   <span class="comment">// 43</span></span><br><span class="line">	<span class="number">452</span>,   <span class="comment">// 44</span></span><br><span class="line">	<span class="number">434</span>,   <span class="comment">// 45</span></span><br><span class="line">	<span class="number">417</span>,   <span class="comment">// 46</span></span><br><span class="line">	<span class="number">401</span>,   <span class="comment">// 47</span></span><br><span class="line">	<span class="number">386</span>,   <span class="comment">// 48</span></span><br><span class="line">	<span class="number">371</span>,   <span class="comment">// 49</span></span><br><span class="line">	<span class="number">358</span>,   <span class="comment">// 50</span></span><br><span class="line">	<span class="number">344</span>,   <span class="comment">// 51</span></span><br><span class="line">	<span class="number">331</span>,   <span class="comment">// 52</span></span><br><span class="line">	<span class="number">318</span>,   <span class="comment">// 53</span></span><br><span class="line">	<span class="number">306</span>,   <span class="comment">// 54</span></span><br><span class="line">	<span class="number">295</span>,   <span class="comment">// 55</span></span><br><span class="line">	<span class="number">284</span>,   <span class="comment">// 56</span></span><br><span class="line">	<span class="number">274</span>,   <span class="comment">// 57</span></span><br><span class="line">	<span class="number">264</span>,   <span class="comment">// 58</span></span><br><span class="line">	<span class="number">254</span>,   <span class="comment">// 59</span></span><br><span class="line">	<span class="number">245</span>,   <span class="comment">// 60</span></span><br><span class="line">	<span class="number">236</span>,   <span class="comment">// 61</span></span><br><span class="line">	<span class="number">228</span>,   <span class="comment">// 62</span></span><br><span class="line">	<span class="number">220</span>,   <span class="comment">// 63</span></span><br><span class="line">	<span class="number">212</span>,   <span class="comment">// 64</span></span><br><span class="line">	<span class="number">205</span>,   <span class="comment">// 65</span></span><br><span class="line">	<span class="number">198</span>,   <span class="comment">// 66</span></span><br><span class="line">	<span class="number">191</span>,   <span class="comment">// 67</span></span><br><span class="line">	<span class="number">184</span>,   <span class="comment">// 68</span></span><br><span class="line">	<span class="number">178</span>,   <span class="comment">// 69</span></span><br><span class="line">	<span class="number">172</span>,   <span class="comment">// 70</span></span><br><span class="line">	<span class="number">166</span>,   <span class="comment">// 71</span></span><br><span class="line">	<span class="number">160</span>,   <span class="comment">// 72</span></span><br><span class="line">	<span class="number">155</span>,   <span class="comment">// 73</span></span><br><span class="line">	<span class="number">150</span>,   <span class="comment">// 74</span></span><br><span class="line">	<span class="number">145</span>,   <span class="comment">// 75</span></span><br><span class="line">	<span class="number">140</span>,   <span class="comment">// 76</span></span><br><span class="line">	<span class="number">135</span>,   <span class="comment">// 77</span></span><br><span class="line">	<span class="number">131</span>,   <span class="comment">// 78</span></span><br><span class="line">	<span class="number">126</span>,   <span class="comment">// 79</span></span><br><span class="line">	<span class="number">122</span>,   <span class="comment">// 80</span></span><br><span class="line">	<span class="number">118</span>,   <span class="comment">// 81</span></span><br><span class="line">	<span class="number">115</span>,   <span class="comment">// 82</span></span><br><span class="line">	<span class="number">111</span>,   <span class="comment">// 83</span></span><br><span class="line">	<span class="number">107</span>,   <span class="comment">// 84</span></span><br><span class="line">	<span class="number">104</span>,   <span class="comment">// 85</span></span><br><span class="line">	<span class="number">101</span>,   <span class="comment">// 86</span></span><br><span class="line">	<span class="number">97</span>,    <span class="comment">// 87</span></span><br><span class="line">	<span class="number">94</span>,    <span class="comment">// 88</span></span><br><span class="line">	<span class="number">91</span>,    <span class="comment">// 89</span></span><br><span class="line">	<span class="number">89</span>,    <span class="comment">// 90</span></span><br><span class="line">	<span class="number">86</span>,    <span class="comment">// 91</span></span><br><span class="line">	<span class="number">83</span>,    <span class="comment">// 92</span></span><br><span class="line">	<span class="number">81</span>,    <span class="comment">// 93</span></span><br><span class="line">	<span class="number">78</span>,    <span class="comment">// 94</span></span><br><span class="line">	<span class="number">76</span>,    <span class="comment">// 95</span></span><br><span class="line">	<span class="number">74</span>,    <span class="comment">// 96</span></span><br><span class="line">	<span class="number">71</span>,    <span class="comment">// 97</span></span><br><span class="line">	<span class="number">69</span>,    <span class="comment">// 98</span></span><br><span class="line">	<span class="number">67</span>,    <span class="comment">// 99</span></span><br><span class="line">	<span class="number">65</span>,    <span class="comment">// 100</span></span><br><span class="line">	<span class="number">63</span>,    <span class="comment">// 101</span></span><br><span class="line">	<span class="number">61</span>,    <span class="comment">// 102</span></span><br><span class="line">	<span class="number">60</span>,    <span class="comment">// 103</span></span><br><span class="line">	<span class="number">58</span>,    <span class="comment">// 104</span></span><br><span class="line">	<span class="number">56</span>,    <span class="comment">// 105</span></span><br><span class="line">	<span class="number">55</span>,    <span class="comment">// 106</span></span><br><span class="line">	<span class="number">53</span>,    <span class="comment">// 107</span></span><br><span class="line">	<span class="number">52</span>,    <span class="comment">// 108</span></span><br><span class="line">	<span class="number">50</span>,    <span class="comment">// 109</span></span><br><span class="line">	<span class="number">49</span>,    <span class="comment">// 110</span></span><br><span class="line">	<span class="number">47</span>,    <span class="comment">// 111</span></span><br><span class="line">	<span class="number">46</span>,    <span class="comment">// 112</span></span><br><span class="line">	<span class="number">45</span>,    <span class="comment">// 113</span></span><br><span class="line">	<span class="number">43</span>,    <span class="comment">// 114</span></span><br><span class="line">	<span class="number">42</span>,    <span class="comment">// 115</span></span><br><span class="line">	<span class="number">41</span>,    <span class="comment">// 116</span></span><br><span class="line">	<span class="number">40</span>,    <span class="comment">// 117</span></span><br><span class="line">	<span class="number">39</span>,    <span class="comment">// 118</span></span><br><span class="line">	<span class="number">38</span>,    <span class="comment">// 119</span></span><br><span class="line">	<span class="number">37</span>,    <span class="comment">// 120</span></span><br><span class="line">	<span class="number">36</span>,    <span class="comment">// 121</span></span><br><span class="line">	<span class="number">35</span>,    <span class="comment">// 122</span></span><br><span class="line">	<span class="number">34</span>,    <span class="comment">// 123</span></span><br><span class="line">	<span class="number">33</span>,    <span class="comment">// 124</span></span><br><span class="line">	<span class="number">32</span>,    <span class="comment">// 125</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置热敏电阻要用到的引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIC_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef NIC_GPIO_Init; <span class="comment">//结构定义</span></span><br><span class="line">	NIC_GPIO_Init.Pin  = GPIO_Pin_4; <span class="comment">//指定要初始化的IO,</span></span><br><span class="line">    <span class="comment">// 指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	NIC_GPIO_Init.Mode = GPIO_HighZ;	</span><br><span class="line">    </span><br><span class="line">	GPIO_Inilize(GPIO_P0, &amp;NIC_GPIO_Init);<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC 转换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NIC_ADC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC_InitTypeDef NIC_ADC_init;</span><br><span class="line">	<span class="comment">// ADC 模拟信号采样时间控制, 0~31（注意： SMPDUTY 一定不能设置小于 10）</span></span><br><span class="line">	NIC_ADC_init.ADC_SMPduty = <span class="number">31</span>;	</span><br><span class="line">    <span class="comment">// 设置 ADC 工作时钟频率	ADC_SPEED_2X1T~ADC_SPEED_2X16T</span></span><br><span class="line">	NIC_ADC_init.ADC_Speed = ADC_SPEED_2X1T;	</span><br><span class="line">    <span class="comment">// ADC结果调整,	ADC_LEFT_JUSTIFIED,ADC_RIGHT_JUSTIFIED</span></span><br><span class="line">	NIC_ADC_init.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;	</span><br><span class="line">	NIC_ADC_init.ADC_CsSetup = <span class="number">0</span>; <span class="comment">//ADC 通道选择时间控制 0(默认),1</span></span><br><span class="line">	NIC_ADC_init.ADC_CsHold = <span class="number">1</span>; <span class="comment">//ADC 通道选择保持时间控制 0,1(默认),2,3</span></span><br><span class="line">	</span><br><span class="line">	ADC_Inilize(&amp;NIC_ADC_init);</span><br><span class="line">	</span><br><span class="line">	ADC_PowerControl(ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热敏电阻初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NTC_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NIC_GPIO_Config();</span><br><span class="line">    NIC_ADC_Config();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取温度值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NTC_GetTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> ntc_V; <span class="comment">// ADC 处的电压</span></span><br><span class="line">    <span class="type">float</span> ntc_R; <span class="comment">// ADC 处的电阻值</span></span><br><span class="line">    <span class="type">float</span> ntc_100R; <span class="comment">// 热敏电阻的电阻值 * 100</span></span><br><span class="line">    <span class="type">float</span> diff; <span class="comment">// 差值</span></span><br><span class="line">    <span class="type">float</span> min <span class="comment">// 最小差值</span></span><br><span class="line">    <span class="type">int</span> i, index;</span><br><span class="line">    <span class="comment">// 获取 ADC 采样数值</span></span><br><span class="line">    u16 adc_result = Get_ADCResult(ADC_CH12);	<span class="comment">//channel = 0~15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将采样的数值转换为电压值</span></span><br><span class="line">    ntc_V = adc_result * <span class="number">2.5</span> / <span class="number">4096</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据电压求出电阻 电阻 = 电压 / 电流</span></span><br><span class="line">    <span class="comment">// 串联电路电流处处相等下</span></span><br><span class="line">    ntc_R = ntc_V * <span class="number">10</span> / ( <span class="number">3.3</span> - ntc_V );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用热敏电阻处的电阻与对照表中的数据进行比对进而得出温度值</span></span><br><span class="line">    ntc_100R = <span class="number">100</span> * ntc_R;</span><br><span class="line">    <span class="comment">// 遍历数组，比较差值最小的，就是当前的温度</span></span><br><span class="line">    <span class="comment">// 默认第一个元素插值最小</span></span><br><span class="line">    index = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 数组中存放是是（阻值 x 100)</span></span><br><span class="line">    <span class="comment">// 默认数组中第一个元素的差值最小</span></span><br><span class="line">    min = temp_table[<span class="number">0</span>] - ntc_100R &gt; <span class="number">0</span>? temp_table[<span class="number">0</span>] - ntc_100R : -(temp_table[<span class="number">0</span>] - ntc_100R);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(temp_table) / <span class="keyword">sizeof</span>(u16); i++) &#123;</span><br><span class="line">        <span class="comment">// 得出当前阻值与对照表中阻止的差</span></span><br><span class="line">        diff = temp_table[i] - ntc_100R &gt; <span class="number">0</span>? temp_table[i] - ntc_100R: -(temp_table[i] - ntc_100R);</span><br><span class="line">        <span class="comment">// 获取差值最小的下标</span></span><br><span class="line">        <span class="keyword">if</span>(diff &lt; min) &#123;</span><br><span class="line">        	min = diff;</span><br><span class="line">            index = i;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_ADC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">	<span class="comment">// &amp;gt;&amp;gt;&amp;gt; 记得添加 NVIC.c, UART.c, UART_Isr.c &amp;lt;&amp;lt;&amp;lt;</span></span><br><span class="line">    COMx_InitDefine COMx_Init; <span class="comment">//结构定义</span></span><br><span class="line">    <span class="comment">//模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span></span><br><span class="line">    COMx_Init.UART_Mode = UART_8bit_BRTx;	</span><br><span class="line">    <span class="comment">//选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span></span><br><span class="line">    COMx_Init.UART_BRT_Use = BRT_Timer1;			</span><br><span class="line">    COMx_Init.UART_BaudRate = <span class="number">115200ul</span>; <span class="comment">//波特率, 一般 110 ~ 115200</span></span><br><span class="line">    COMx_Init.UART_RxEnable = ENABLE; <span class="comment">//接收允许,   ENABLE或DISABLE</span></span><br><span class="line">    COMx_Init.BaudRateDouble = DISABLE; <span class="comment">//波特率加倍, ENABLE或DISABLE</span></span><br><span class="line">    <span class="comment">//初始化串口1 UART1,UART2,UART3,UART4</span></span><br><span class="line">    UART_Configuration(UART1, &amp;amp;COMx_InitStructure);		</span><br><span class="line">	<span class="comment">//中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,Priority_2,Priority_3</span></span><br><span class="line">  	NVIC_UART1_Init(ENABLE,Priority_1);		</span><br><span class="line">    <span class="comment">// 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P43_P44</span></span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="comment">// 温度</span></span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    NTC_Init();</span><br><span class="line">    UART_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 得到温度值</span></span><br><span class="line">        t = NTC_GetTemperature();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;温度:%d\n&quot;</span>, t);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>NTC.h 中的头尾是什么作用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	__NTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__NTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>‌#ifndef 在 C 语言中是“if not defined”的简写，属于宏定义的一种，用于条件编译。</p>
<ol>
<li><code>#ifndef __NTC_H</code>：这是预处理指令 <code>#ifndef</code>（If Not Defined的缩写），用于检查宏 <code>__NTC_H</code> 是否尚未定义。如果 <code>__NTC_H</code> 没有被定义，那么编译器会执行 <code>#ifndef</code> 和紧接着的 <code>#endif</code> 之间的代码。这种机制用于确保头文件的内容只被包含一次。</li>
<li><code>#define __NTC_H</code>：这行代码定义了宏 <code>__NTC_H</code>。一旦这个宏被定义，后续的 <code>#ifndef __NTC_H</code> 检查就会失败，因为 <code>__NTC_H</code> 已经被定义了。这防止了头文件内容的重复包含。</li>
<li><code>#endif</code>：这表示 <code>#ifndef</code> 和 <code>#endif</code> 之间的代码块的结束。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>独立按键</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<p>查看原理图，看独立按键分别接的是那些引脚</p>
<h2 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h2><ol>
<li>软件延时法：在按键按下时，使用软件延时一段时间，例如10毫秒，然后再检测按键是否还处于按下状态，如果是，则认为按键有效。这种方法简单易行，但会浪费一定的处理器时间，同时需要根据实际情况调整延时时间。</li>
<li>硬件滤波法：在按键输入引脚上添加RC滤波电路，可以有效地去除按键信号上的瞬间噪声。这种方法对于高频噪声的去除效果较好，但需要一定的电路设计能力。</li>
<li>程序消抖法：在程序中记录按键前后两次的状态，如果两次状态不同，则认为按键有效。这种方法可以根据需要调整检测时间，消抖效果较好，但需要额外的程序设计。</li>
</ol>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>当用户按下，或者松开按键时，捕获到这个事件。将事件通过串口发出来</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立按键</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 P51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2 P52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3 P53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4 P54</span></span><br><span class="line"></span><br><span class="line">u8 state = <span class="number">0x0f</span>; <span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下/回弹  软件消抖</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UP(state, i) = ((a &amp; (1 <span class="string">&lt;&lt; i)) &gt;</span> 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOWM(state, i) = ((a &amp; (1 &lt;&lt; i)) &lt;= 0)</span></span><br><span class="line"><span class="comment">// 设置控制变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_UP(state, i) = state |= (1 &lt;&lt; i) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_DOWN(state, i) = state &amp;= ~(1 &lt;&lt; i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询四个按键 1~4</span></span><br><span class="line">u8 <span class="title function_">get_kay</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> KAY1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> KAY2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) <span class="keyword">return</span> KAY3;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="keyword">return</span> KAY4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Comfig</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4;</span><br><span class="line">    </span><br><span class="line">    GPIO_Inilize(GPIO_P5, &amp;GPIO_Init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UART 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">    UART_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">    UART_Init.UART_BaudRate = <span class="number">115200ul</span>;</span><br><span class="line">    UART_Init.Morecommunicate = DISABLE; <span class="comment">// 多机通讯</span></span><br><span class="line">    <span class="comment">// 是否允许接收来自发送端的数据</span></span><br><span class="line">    UART_Init.UART_RxEnable = ENABLE;</span><br><span class="line">    UART_Init.BaudRateDouble = DISABLE; <span class="comment">// 波特率加倍      </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">          </span><br><span class="line">   	<span class="type">int</span> i; <span class="comment">// 四个灯循环遍历</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 全局中断</span></span><br><span class="line">    EA = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    UART_Config();</span><br><span class="line">    GPIO_Comfig();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断四个按键是否按下抬起</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (get_kay() == <span class="number">0</span>) &amp;&amp; (IS_UP(state, i))) &#123;</span><br><span class="line">                <span class="comment">// 将用于消抖的控制位置 0</span></span><br><span class="line">                SET_DOWN(state, i)</span><br><span class="line">                PrintString1(<span class="string">&quot;按钮%d被按下了\n&quot;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((get_kay() == <span class="number">0</span>) &amp;&amp; (IS_DOWM(stat, i))) &#123;</span><br><span class="line">                <span class="comment">// 将用于消抖的控制位置 1</span></span><br><span class="line">                SET_UP(state, i)</span><br><span class="line">                PrintString1(<span class="string">&quot;按钮%d被松开了\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵键盘</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>矩阵键盘通常由<strong>行（Row）和列（Column）组成，按键排列在行和列的交叉点处。例如，一个 4x4 矩阵键盘</strong>有 4 行 4 列，共 16 个按键。每个按键位于行和列的交点处，按下按键时会将该行和该列连接在一起。</p>
<p><strong>工作原理</strong></p>
<p>矩阵键盘的工作原理是通过<strong>扫描行和列来检测哪个按键被按下</strong>。每按下一个按键，就会将对应的行和列连接，使微控制器能够识别按键的具体位置。为了实现这一点，矩阵键盘的检测通常分为两部分：</p>
<ul>
<li><strong>行扫描</strong>：微控制器将行设置为输出，逐行输出高或低电平信号。</li>
<li><strong>列检测</strong>：微控制器将列设置为输入，检查列引脚是否检测到电平的变化（即按键被按下）。</li>
</ul>
<p><strong>去抖处理</strong></p>
<p>按键按下和释放时，电路中可能会出现抖动现象，导致信号不稳定。在嵌入式系统中，通常需要进行<strong>按键去抖动处理</strong>。常见的去抖动方法包括：</p>
<ul>
<li><strong>软件去抖动</strong>：在检测到按键按下后，延时数毫秒后再次检测按键状态（或者通过额外的标志位，在检测到按下后立即置 0），以确保信号稳定。</li>
<li><strong>硬件去抖动</strong>：在按键电路中增加电容或使用专门的去抖动芯片来滤除噪声信号。</li>
</ul>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><p><strong>引脚图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/juzhenjpanyinjiaotu.png" alt="juzhenjpanyinjiaotu"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MatrixKey.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MATRIXKEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MATRIXKEY_H </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Scan</span><span class="params">(<span class="type">void</span>(*key_down) (u8, u8), <span class="type">void</span>(*key_up) (u8, u8))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// MatrixKey.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义行列</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL1 P03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL2 P06    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL3 P07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL4 P17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW1 P34    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW2 P35 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW3 P40    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW4 P41   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测按键上一个状态是否为弹起</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_up(status, row, col)   ((status &amp; (1 <span class="string">&lt;&lt; 4 * row + col)) &gt;</span> 0)</span></span><br><span class="line"><span class="comment">// 检测按键上一个状态是否为按下    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_down(status, row, col) ((status &amp; (1 &lt;&lt; 4 * row + col)) == 0)      </span></span><br><span class="line"><span class="comment">// 设置按键状态为弹起</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_up(status, row, col)   (status |= (1 &lt;&lt; 4 * row + col))</span></span><br><span class="line"><span class="comment">// 设置按键状态为按下  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_down(status, row, col) (status &amp;= (1 &lt;&lt; 4 * row + col))    </span></span><br><span class="line">    </span><br><span class="line">u16 status = <span class="number">0xFFFF</span>; <span class="comment">//默认 4x4 的按键状态都是弹起    </span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config_MatrixKey</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;    </span><br><span class="line">    GPIO_Init.Mode = GPIO_PullUp;</span><br><span class="line">    </span><br><span class="line">	GPIO_Init.Pin = GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;    </span><br><span class="line">    GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_7;</span><br><span class="line">    GPIO_Inilize(GPIO_P1, &amp;GPIO_Init);</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line">    GPIO_Inilize(GPIO_P3, &amp;GPIO_Init);</span><br><span class="line">    </span><br><span class="line">    GPIO_Init.Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">    GPIO_Inilize(GPIO_P4, &amp;GPIO_Init);</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_Config_MatrixKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_row</span><span class="params">(u8 row)</span> &#123;</span><br><span class="line">    ROW1 = row == <span class="number">0</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    ROW2 = row == <span class="number">1</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    ROW3 = row == <span class="number">2</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    ROW4 = row == <span class="number">3</span>? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">get_col</span><span class="params">(u8 col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(col == <span class="number">0</span>) <span class="keyword">return</span> COL1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">1</span>) <span class="keyword">return</span> COL2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">2</span>) <span class="keyword">return</span> COL3;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col == <span class="number">3</span>) <span class="keyword">return</span> COL4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="comment">// 扫描按键，如果需要感知按下或者弹起的状态，那么就传递进来按下和弹起的处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MK_Scan</span><span class="params">(<span class="type">void</span>(*key_down) (u8, u8), <span class="type">void</span>(*key_up) (u8, u8))</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 4行</span></span><br><span class="line">        set_row(i);			  <span class="comment">// 逐行扫描</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123; <span class="comment">// 逐列判定</span></span><br><span class="line">            <span class="comment">// 判断按键是否被按下，且按下之前的上一个状态时弹起（防抖）</span></span><br><span class="line">            <span class="keyword">if</span>(get_col(j) == <span class="number">0</span> &amp;&amp; is_up(status, i, j)) &#123;</span><br><span class="line">                set_down(status, i, j);</span><br><span class="line">                <span class="keyword">if</span> (key_down != null) key_down(i j);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(get_col(j) == <span class="number">1</span> &amp;&amp; is_down(status, i, j)) &#123;</span><br><span class="line">                set_up(status, i, j);</span><br><span class="line">                <span class="keyword">if</span> (key_up != null) key_down(i j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_NVIC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Switch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8G_H_Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MatrixKey.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> UART_Config(<span class="type">void</span>) &#123;</span><br><span class="line">    COMx_InitDefine UART_Init;</span><br><span class="line">    </span><br><span class="line">    UART_Init.UART_Mode = UART_8bit_BRTx;</span><br><span class="line">	UART_Init.UART_BRT_Use = BRT_Timer1;</span><br><span class="line">	UART_Init.UART_BaudRate = <span class="number">115200ul</span>;</span><br><span class="line">	UART_Init.Morecommunicate = DISABLE;</span><br><span class="line">	UART_Init.UART_RxEnable = ENABLE;</span><br><span class="line">	UART_Init.BaudRateDouble = DISABLE;</span><br><span class="line">    </span><br><span class="line">    UART_Configuration(UART1, &amp;UART_Init);</span><br><span class="line">    </span><br><span class="line">    NVIC_UART1_Init(ENABLE, Priority_1);</span><br><span class="line">    </span><br><span class="line">    UART1_SW(UART1_SW_P30_P31);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下：%d-%d\n&quot;</span>, (<span class="type">int</span>)row, (<span class="type">int</span>)col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(u8 row, u8 col)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹起：%d-%d\n&quot;</span>, (<span class="type">int</span>)row, (<span class="type">int</span>)col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    UART_Config();</span><br><span class="line">    MK_Init();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;        </span><br><span class="line">        MK_Scan(down, <span class="literal">NULL</span>);</span><br><span class="line">        delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>系统时钟</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<h2 id="主频"><a href="#主频" class="headerlink" title="主频"></a>主频</h2><p>主频指CPU内核工作时的<strong>时钟频率</strong>，它表示CPU内数字脉冲信号震荡的速度。主频的高低在很大程度上反映了CPU速度的快慢，但与CPU实际的运算能力并没有直接的线性关系。</p>
<p>主频的产生主要依赖于CPU内部的时钟发生器（也称为时钟振荡器）。时钟发生器通过不断振荡产生稳定的电信号，这些电信号以固定的频率传递给CPU内部的计数器。计数器每接收一个信号就表示一个时钟周期的发生，而CPU则在每个时钟周期内执行一条指令或进行一步操作。</p>
<p>11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz   2.80 GHz；</p>
<p>其中 2.80 GHz 就是主频，即 CPU 的时钟频率，它表示CPU内部的时钟振荡器每秒能够产生2.8亿个时钟周期，每个时钟周期 CPU可 以执行一条或多条指令（这取决于CPU的架构和指令集）。</p>
<h2 id="系统时钟-时钟频率"><a href="#系统时钟-时钟频率" class="headerlink" title="系统时钟 &#x2F; 时钟频率"></a>系统时钟 &#x2F; 时钟频率</h2><p>系统时钟频率是指同步电路中时钟的基础频率，即单位时间内（如1秒）时钟信号发生的次数。这个频率是由系统时钟振荡器产生的，它提供了一个稳定且精确的脉冲信号，用于控制计算机内部各个部件的同步工作。</p>
<blockquote>
<p>可以将系统时钟理解为主频，因为二者除了概念，在数值上是一致的；</p>
</blockquote>
<h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>时钟周期，也称为振荡周期或节拍周期，是<strong>时钟频率的倒数</strong>。它表示了CPU完成一个最基本动作所需的时间。时钟周期是计算机中最基本的、最小的时间单位。</p>
<p>振荡周期指任何振动（振荡）现象重复出现的时间间隔，也就是完成一次振动所需要的时间。</p>
<p>例如，STC8H的时钟频率为<code>24MHz</code>，那么每个时钟周期的时间就是<code>1/24MHz=41.67ns</code>。</p>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>指令周期是指<strong>计算机执行一条指令所需的全部时间。</strong>它包括了从取出指令、对指令进行译码、执行指令以及处理指令执行结果等一系列步骤。指令周期的长度取决于指令的复杂性和所需的操作数等因素。</p>
<p>指令周期包括了从指令的获取、译码、操作数寻址、执行到结果写回的整个过程。</p>
<p>指令周期可以被认为是计算机执行一条指令所经历的时钟周期数量。</p>
<h2 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h2><p><strong>机器周期则是实现指令周期的基本单位</strong>，一个指令周期通常包含若干个机器周期（比如加法操作）。换句话说，一条指令的执行过程（即指令周期）可能涉及多个机器周期，每个机器周期完成指令执行过程中的一个或多个基本操作。</p>
<blockquote>
<p>早期的 STC8H 单片机的机器周期为 12 个时钟周期。现在的 STC8H 可以有两种配置，一个是 1T，一个是 12 T。这分别是什么意思呢？</p>
<p> 1T 则说明是<strong>单时钟&#x2F;机器周期(1T)的单片机</strong>，指的是该单片机在执行指令时，每个机器周期仅需要一个时钟周期的时间。</p>
<p>标准的 8051 单片机是 12T 的，即一个机器周期包含 12 个时钟周期</p>
<p>传统的单片机（如8051）通常需要多个机器周期来完成一条指令的执行，但在 1T 单片机中，设计的目的是使每条指令在一个时钟周期内完成，因此<strong>指令周期和机器周期相等</strong>。</p>
</blockquote>
<ul>
<li>12T也就是早期的配置，假设当系统时钟为24MHz时，每个机器周期的时间就是<code>12 * 41.67ns = 500ns</code>。</li>
<li>1T是芯片架构升级后的，每个机器周期的时间为 <code>1 * 41.67ns = 41.67ns.</code>。</li>
</ul>
<h2 id="NOP-指令"><a href="#NOP-指令" class="headerlink" title="NOP 指令"></a>NOP 指令</h2><p>NOP指令是一种汇编指令，表示“no operation”（不执行任何操作）。它不会改变寄存器的值，也不会修改存储器中的数据，只消耗一个指令周期。在程序中插入NOP指令可以用于延时或调整代码的执行顺序。</p>
<p>NOP指令在某些情况下也被用于填充一些未使用的空间，使程序的大小达到特定的大小或对齐要求。在编写汇编代码时，程序员可以在代码中插入NOP指令来占用空间，使得代码和数据能够对齐在内存中的特定地址上，以提高程序的执行效率。</p>
<p>在STC8H单片机中，NOP指令被翻译成一条长度为1个字节的指令，不做任何操作。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙通信</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>蜂鸣器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E8%9C%82%E9%B8%A3%E5%99%A8/</url>
    <content><![CDATA[<p>蜂鸣器（Buzzer）是一种能够<strong>将电信号转化为声音信号的电子设备</strong>，常用于嵌入式系统中发出提示音或警报声。</p>
<p>蜂鸣器是一种利用直流电或交流电驱动，发出特定频率的声音的器件。它通常由外壳、振动膜片、电磁线圈或压电元件组成；根据工作原理的不同，可以分为电磁式和压电式两类；按驱动方式分类可分为有源蜂鸣器和无源蜂鸣器</p>
<p><strong>有源蜂鸣器</strong>：内部集成了振荡器，直接接通电源即可发声。使用方便，只需给定直流电压即可驱动。</p>
<p><strong>无源蜂鸣器</strong>：没有内置振荡器，需要通过外部信号（如PWM信号）驱动产生振荡。声音频率、节奏可以通过外部控制。</p>
<p><strong>原理图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/fengmingqiyuanlitu.png" alt="fengmingqiyuanlitu"></p>
<h2 id="赫兹与周期的换算"><a href="#赫兹与周期的换算" class="headerlink" title="赫兹与周期的换算"></a>赫兹与周期的换算</h2><p><strong>频率是指在单位时间内(1s)发生重复事件的次数,通常用赫兹(Hz)表示;周期时间则指完成一次所需时间</strong></p>
<p>频率和周期的关系为：f&#x3D;1&#x2F;T。即频率等于周期的倒数，二者成反比。假设频率为 f &#x3D; 2Hz，那么其周期 T &#x3D; 1 &#x2F; f &#x3D; 1 &#x2F; 2 &#x3D; 0.5 秒（高低电平各0.25）。那么就是定时器的计数时间就应该是：</p>
<p>65535 - （MAIN_Fosc &#x2F; (2 * 2));</p>
<p>那么 1047 的频率也就是一秒内要发生 1047 个重复的周期，也就是 1047 个高电平 + 1047 个低电平，那么也就是说在 1 秒内高低电平一共要被触发 1047 + 1047 &#x3D; 2097 次，也就是定时器在一秒内要被触发 2097 次，所以触发时间就是：</p>
<p>65536 - (MAIN_Fosc &#x2F; (2 * 1047));</p>
<p>再捋一下，此时 (MAIN_Fosc &#x2F; (2 * 1047)) 这个时间就是一次高电平或者低电平的时间，那么 60036 减去这个时间就表示，每次数这么长的时间就触发一次定时中断去改变他的高低电平，这样就达到了触发 1047 这个频率的目的；</p>
<p>再仔细说下为什么这里是主频除以后面的频率，给我一个确定的时间 1ms 我会算，但是给频率就反应不过来怎么办？</p>
<p>这里可以这么想，以上面的 2097 为例，一秒内要执行 2097 次高低电平的转换，那么每次的时间就是 1 &#x2F; 2097s；那么我们将这个 1 &#x2F; 2097 换成主频的时钟周期数，不就是 (主频 * 1&#x2F;2097)，即 MAIN_Fosc &#x2F; 2097 了么；2097 个这么长的时间就是 1ms(24MHz);</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>通过定时器控制播放哆来咪发唆拉西哆</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NVIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 蜂鸣器引脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUZZER P00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小字二组 哆来咪发唆拉西哆 对应的频率</span></span><br><span class="line"><span class="comment">//			      C`	D`     E`   F`	  G`	A`	  B`    C``</span></span><br><span class="line">u16 hz_note[] = &#123;<span class="number">1047</span>, <span class="number">1175</span>, <span class="number">1319</span>, <span class="number">1397</span>, <span class="number">1568</span>, <span class="number">1760</span>, <span class="number">1976</span>, <span class="number">2093</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引脚初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Init;</span><br><span class="line">	GPIO_Init.Pin  = GPIO_Pin_0;</span><br><span class="line">    <span class="comment">// 指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Init.Mode = GPIO_OUT_PP;</span><br><span class="line">	GPIO_Inilize(GPIO_P0, &amp;GPIO_Init);<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Config</span><span class="params">(u16 hz_buzzer)</span> &#123;</span><br><span class="line">    TIM_InitTypeDef Timer_init;</span><br><span class="line">    </span><br><span class="line">    Timer_init.TIM_Mode = TIM_16BitAutoReload;</span><br><span class="line">    <span class="comment">// 时钟源 TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext</span></span><br><span class="line">	Timer_init.TIM_ClkSource = TIM_CLOCK_1T;</span><br><span class="line">    <span class="comment">// 可编程时钟输出,如果配置ENABLE，则 P3.5 端口会同步输出时钟脉冲</span></span><br><span class="line">	Timer_init.TIM_ClkOut = DISABLE	;	</span><br><span class="line">    <span class="comment">// 装载初值</span></span><br><span class="line">    Timer_init.TIM_Value = <span class="number">65536</span> - (MAIN_Fosc / (<span class="number">2</span> * hz_buzzer));		</span><br><span class="line">    <span class="comment">// 是否运行 ENABLE,DISABLE</span></span><br><span class="line">	Timer_init.TIM_Run = ENABLE;		</span><br><span class="line">	<span class="comment">// 选择定时器，并且进行配置</span></span><br><span class="line">	Timer_Inilize(Timer0, &amp;Timer_init);</span><br><span class="line">    <span class="comment">//打开中断使能</span></span><br><span class="line">	NVIC_Timer0_Init(ENABLE, Priority_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器 0 中断函数中执行的代码</span></span><br><span class="line">handle_timer0_interrupt() &#123;</span><br><span class="line">    BUZZER = ~BUZZER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 中断总控制</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(hz_note) / siezeof(hz_note[<span class="number">0</span>]; i++))&#123;</span><br><span class="line">            Timer_Config(hz_note[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每播放一个轮次，就停三秒钟不要出声，再继续播放；</span></span><br><span class="line">        stop();</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        </span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);</span><br><span class="line">        delay_ms(<span class="number">250</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>定时器的效果是如何作用于蜂鸣器的</strong></p>
<p>定时器的效果作用于蜂鸣器，主要是通过控制蜂鸣器电源的开关状态（即高电平或低电平）来实现的；定时周期决定了蜂鸣器发声的频率，因为频率是单位时间内周期性事件的次数。</p>
<p>也就是说，在一秒内，以不同的频率给蜂鸣器发送高低电平就可以控制它发出不同的声音。</p>
<p>二、<strong>为什么高低电平各占一半呢，高低电平的占比不是和占空比有关么</strong></p>
<p>这样做可以简化控制逻辑，同时确保蜂鸣器发出的声音具有稳定的频率和音色。他可能并不是真的各占一半。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑分析仪</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA/</url>
    <content><![CDATA[<p><strong>逻辑分析仪</strong>（Logic Analyzer）是一种用于调试和分析<strong>数字电路</strong>信号的<strong>电子仪器</strong>。它能够捕获并显示数字电路中的多个信号（通常是并行信号），帮助工程师分析和理解电路的工作情况。与示波器不同，逻辑分析仪侧重于监<strong>测数字信号</strong>的时序和逻辑状态，而不是模拟信号的波形。</p>
<p>以<a href="https://www.saleae.com/zh-hans">Saleae 逻辑分析仪</a>为例</p>
<p>你使用那些个引脚，用杜邦线连接到那些引脚就好了，然后打开软件，选择频率就可以查看了。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>震动马达</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/STC8H/%E9%9C%87%E5%8A%A8%E9%A9%AC%E8%BE%BE/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过P0.1引脚控制马达震动。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOTOR P01</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	GPIO_InitTypeDef	GPIO_InitStructure;		<span class="comment">//结构定义</span></span><br><span class="line">	GPIO_InitStructure.Pin  = GPIO_Pin_1;		<span class="comment">//指定要初始化的IO,</span></span><br><span class="line">	GPIO_InitStructure.Mode = GPIO_OUT_PP;	<span class="comment">//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span></span><br><span class="line">	GPIO_Inilize(GPIO_P0, &amp;GPIO_InitStructure);<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	GPIO_config();</span><br><span class="line">	</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		MOTOR = <span class="number">1</span>;</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		MOTOR = <span class="number">0</span>;</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">		delay_ms(<span class="number">250</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STC8H</tag>
      </tags>
  </entry>
  <entry>
    <title>JL环境搭建</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/%E6%9D%B0%E7%90%86/JL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>SDK工程默认支持在 Windows 系统上，用 CodeBlocks 编译。</p>
<p>配置环境主要分为三步：</p>
<ol>
<li>下载并安装 CodeBlocks，下载链接： <a href="http://pkgman.jieliapp.com/s/codeblocks">http://pkgman.jieliapp.com/s/codeblocks</a></li>
<li>打开安装好的 CodeBlocks 后，关闭 CodeBlocks</li>
<li>下载并安装工具链，下载链接：<a href="http://pkgman.jieliapp.com/s/win-toolchain">http://pkgman.jieliapp.com/s/win-toolchain</a></li>
<li>下载并安装软件包管理器，下载链接：<a href="http://pkgman.jieliapp.com/s/pkgmanoffline">http://pkgman.jieliapp.com/s/pkgmanoffline</a></li>
</ol>
<p>到现在，你已经可以打开 CodeBlocks 工程进行编译开发了。</p>
<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://doc.zh-jieli.com/AC79/zh-cn/master/index.html">杰里官方文档地址</a></p>
<p>在官方文档中要选择我们对应的芯片型号与版本，比如：AC791，在选择版本时候建议不要选择最新的 master 选择 release_v 1.2.0 即可；</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>杰里官方推荐的集成开发工具为<a href="https://www.codeblocks.org/downloads/">CodeBlocks官方网站</a></p>
<h2 id="安装工具链"><a href="#安装工具链" class="headerlink" title="安装工具链"></a>安装工具链</h2><ul>
<li>在确保当前机器已经安装好 CodeBlocks 之后，就可以开始安装杰理工具链，点击<a href="http://pkgman.jieliapp.com/s/win-toolchain">链接</a>下载工具链（Windows版本）</li>
<li>下载好的杰理工具链安装包名称为 2.5.0.exe，双击后按提示进行安装即可。</li>
</ul>
<h2 id="更新工具链"><a href="#更新工具链" class="headerlink" title="更新工具链"></a>更新工具链</h2><p>在确保当前PC已经安装杰理的工具链后，当杰理发布新版本的工具链时，可以按如下步骤检查更新：点击“开始菜单“ ，选择”检查更新“ 。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/jcgx.png" alt="jcgx"></p>
<p>如果未更新到杰理工具链最新版本，则会提示下图。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/sjjc.png" alt="sjjc"></p>
<p>点击上图界面”确定”按钮后，进入如图所示下载界面。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/sjgz.png" alt="sjgz"></p>
<p>点击上图的”下载升级包”后，开始下载新版本工具链的安装包，下载完毕后，提示升级包文件下载成功界面。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/sjwc.png" alt="sjwc"></p>
<p>点击”打开升级包文件”后，开始安装下载好的安装包。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/dksjb.png" alt="dksjb"></p>
<p>更新到最新的版本后，再次”检查更新”就会提示如下信息。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/zxbb.png" alt="zxbb"></p>
<h2 id="安装杰理软件包管理器"><a href="#安装杰理软件包管理器" class="headerlink" title="安装杰理软件包管理器"></a>安装杰理软件包管理器</h2><ul>
<li>为了能正常使用 AC791N_配置工具 (AC791N_config_tool)，需要事先安装杰理软件包管理器，点击链接 <a href="http://pkgman.jieliapp.com/s/pkgmanoffline">http://pkgman.jieliapp.com/s/pkgmanoffline</a> 下载。</li>
<li>双击后按提示进行安装即可。</li>
</ul>
]]></content>
      <categories>
        <category>JL</category>
      </categories>
      <tags>
        <tag>杰里</tag>
      </tags>
  </entry>
  <entry>
    <title>编译与烧录</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/%E6%9D%B0%E7%90%86/%E7%BC%96%E8%AF%91%E4%B8%8E%E7%83%A7%E5%BD%95/</url>
    <content><![CDATA[<h2 id="下载模式"><a href="#下载模式" class="headerlink" title="下载模式"></a>下载模式</h2><ul>
<li>将开发板 USB 的接口端使用合适的 USB 数据线正确连接到 PC 主机。</li>
<li>通过长按开发板的顶板 update 键，同时（注意是同时, 并hold住）按 reset 键。</li>
<li>先松开 reset 键，再松开 update 键，即可进入下载模式。</li>
<li>进入下载模式后，电脑弹出如下红框所示的盘符，代表进入下载模式成功。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/xzms.png" alt="xzms"></p>
<p>此时，按下”win + x”组合键，选择”设备管理器”，在”磁盘驱动器”中，可以看到如下设备 WL82 UBOOT1.00 USB Device，即为成功进入了下载模式。</p>
<h2 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h2><ul>
<li>以 demo_DevKitBoard 工程为例，将准备好的 <a href="https://doc.zh-jieli.com/AC79/zh-cn/release_v1.2.0/getting_started/preparation/hardware.html#hardware">硬件环境</a> 上电， 然后使开发板进入 <a href="https://doc.zh-jieli.com/AC79/zh-cn/release_v1.2.0/getting_started/preparation/update.html#update">下载模式</a> 。</li>
<li>在 CodeBlocks 界面中点击 <code>build</code> 或者 <code>rebuild</code> 进行编译 。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>编译时报错，提示无法找到 @xxx.objs.txt 文件</strong></p>
<p>如：ld.exe cannot find @..........\cpu\wl82\tools\sdk.elf.objs.txt: No such file or directory|</p>
<p>这个 objs.txt 的文件，一般是在链接前通过 Code::Blocks 的脚本生成的文件。里面包含了所有需要链接的文件的路径。如果在一开始没有允许 Code::Blocks 执行生成文件的脚本，则会导致问题。可以通过下面方式来允许：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/wt1.png" alt="wt1"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/JL/AC791N/wt2.png" alt="wt2"></p>
<p>ld.exe cannot find obj&#x2F;Release&#x2F;apps&#x2F;common&#x2F;example&#x2F;third_party&#x2F;lvgl_v9&#x2F;examples&#x2F;widgets&#x2F;obj&#x2F;lv_example_obj_1.o: No such file or directory</p>
]]></content>
      <categories>
        <category>JL</category>
      </categories>
      <tags>
        <tag>杰里</tag>
      </tags>
  </entry>
  <entry>
    <title>J-Link烧录器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/%E7%83%A7%E5%BD%95%E5%99%A8/J-Link%E7%83%A7%E5%BD%95%E5%99%A8/</url>
    <content><![CDATA[<p>J-Link 是由 SEGGER 公司推出的一款高性能的<strong>调试</strong>和<strong>烧录</strong>工具，广泛用于嵌入式开发领域，支持多种微控制器（MCU）的调试和烧录功能。J-Link 烧录是通过该工具与目标硬件进行通信，将程序固件烧录到目标芯片的闪存中，通常与开发环境（如 IAR Embedded Workbench、Keil MDK、GCC 等）配合使用。下面我将从多个角度详细介绍 J-Link 烧录的过程和特点。</p>
<h3 id="J-Link-硬件概述"><a href="#J-Link-硬件概述" class="headerlink" title="J-Link 硬件概述"></a><strong>J-Link 硬件概述</strong></h3><p>J-Link 是一款 USB 接口的调试器，它通过 <strong>USB 连接到开发主机</strong>（通常是 PC），并通过 <strong>JTAG</strong> 或 <strong>SWD</strong> 接口<strong>与目标微控制器进行通信</strong>。J-Link 兼容多种微控制器架构，最常见的有 ARM Cortex-M 系列、Cortex-A 系列、RX、Renesas 等。</p>
<p>J-Link 的工作原理是通过在主机和目标硬件之间建立一个高效的通信通道，进行数据交换和控制。它不仅支持调试功能，还可以实现烧录、读取、擦除闪存等功能。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/%E7%83%A7%E5%BD%95%E5%99%A8/JLink/lxt.png" alt="lxt"></p>
<h3 id="J-Link-烧录流程"><a href="#J-Link-烧录流程" class="headerlink" title="J-Link 烧录流程"></a><strong>J-Link 烧录流程</strong></h3><h4 id="安装-J-Link-驱动"><a href="#安装-J-Link-驱动" class="headerlink" title="安装 J-Link 驱动"></a>安装 J-Link 驱动</h4><p>在 PC 上需要安装 J-Link 的驱动程序和相关软件工具包。可以通过 SEGGER 官方网站下载最新版本的 J-Link 软件和驱动程序。安装 J-Link 驱动并将 J-Link 连接到电脑后设备会被识别为一个调试器设备，通常在设备管理器中显示为“J-Link”或“J-Link Plus”。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/%E7%83%A7%E5%BD%95%E5%99%A8/JLink/sbtp.png" alt="sbtp"></p>
<blockquote>
<p>注意有些非正版的 J-Link 设备，可能由于被屏蔽等问题导致安装驱动后不显示“J-Link”或“J-Link Plus”只显示一个 USB Composite Device，那么这时候就需要去找厂家要硬件所支持的版本驱动；</p>
</blockquote>
<p><a href="https://www.segger.com/downloads/jlink/">J-Link官方下载链接</a></p>
<p><a href="https://www.segger.com/products/debug-probes/j-link/">查看J-Link支持的设备</a></p>
<h4 id="连接目标硬件"><a href="#连接目标硬件" class="headerlink" title="连接目标硬件"></a>连接目标硬件</h4><p>首先需要通过 J-Link 将目标开发板（如 STM32、NXP、TI 等 MCU 开发板）连接到 PC。<strong>连接时使用的是 JTAG 或 SWD 接口</strong>。这些接口是调试和烧录操作的通信通道。需要确保目标板正确连接并供电。</p>
<h4 id="启动烧录工具"><a href="#启动烧录工具" class="headerlink" title="启动烧录工具"></a>启动烧录工具</h4><p>J-Link 支持多种烧录方式，可以通过以下工具进行烧录：</p>
<ul>
<li><strong>J-Link Commander (JLinkExe)</strong>: 这是 SEGGER 提供的命令行工具，能够直接与 J-Link 通信，进行闪存的擦除、写入、读取等操作。</li>
<li><strong>J-Flash</strong>: 这是 SEGGER 提供的图形化烧录工具，可以选择烧录文件并进行相关配置。</li>
<li><strong>集成开发环境（IDE）</strong>: 许多嵌入式开发环境（如 IAR Embedded Workbench、Keil MDK）也内置了 J-Link 的支持，可以通过 IDE 中的烧录功能进行操作。</li>
</ul>
<h4 id="配置目标-MCU"><a href="#配置目标-MCU" class="headerlink" title="配置目标 MCU"></a>配置目标 MCU</h4><p>在烧录之前，需要在烧录工具中选择目标 MCU。目标设备的型号和烧录方式（例如：是否需要启用 Flash 编程选项）需要根据实际情况进行配置。J-Link 支持广泛的 MCU 型号，烧录工具会根据所选 MCU 自动加载相关的配置和驱动。</p>
<h4 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h4><p>选择好固件（通常是 HEX、BIN 或 ELF 文件）后，开始执行烧录操作。烧录过程通常包括以下几个步骤：</p>
<ul>
<li><strong>擦除闪存</strong>：有时需要擦除 MCU 中的闪存区域，以确保旧的固件被彻底清除。擦除过程通常由 J-Link 自动完成。</li>
<li><strong>写入固件</strong>：将编译后的固件文件（.bin 或 .hex）写入目标芯片的闪存。写入过程包括数据传输和验证，确保烧录的固件与源文件一致。</li>
<li><strong>验证固件</strong>：写入完成后，J-Link 会自动读取目标闪存中的数据并与源文件进行对比，确保烧录没有错误。如果有问题，烧录过程会失败，并反馈错误信息。</li>
</ul>
<h4 id="完成烧录并复位"><a href="#完成烧录并复位" class="headerlink" title="完成烧录并复位"></a>完成烧录并复位</h4><p>烧录完成后，通常需要复位 MCU 以启动新烧录的固件。J-Link 可以通过复位信号自动重启目标硬件。此时，新的固件就可以开始执行。</p>
<h3 id="J-Link-烧录的优势"><a href="#J-Link-烧录的优势" class="headerlink" title="J-Link 烧录的优势"></a><strong>J-Link 烧录的优势</strong></h3><ul>
<li><strong>高速性能</strong>：J-Link 采用高效的 USB 2.0 或 3.0 接口与目标硬件通信，具有较高的烧录速度，尤其是在大量数据需要烧录时，能显著减少开发周期。</li>
<li><strong>广泛支持</strong>：J-Link 支持多种架构和平台（如 ARM、Renesas、ST、NXP 等），为开发者提供了更大的灵活性。</li>
<li><strong>稳定性</strong>：J-Link 在烧录和调试过程中非常稳定，适合工业级的开发需求。</li>
<li><strong>强大的集成工具</strong>：与 IAR、Keil、Eclipse 等主流 IDE 配合，J-Link 提供了丰富的调试和烧录选项，使开发人员能方便地进行烧录和调试操作。</li>
<li><strong>批量烧录支持</strong>：对于大规模生产，J-Link 提供了批量烧录的功能，可以通过脚本或自动化工具进行快速烧录。</li>
</ul>
<h3 id="J-Link-烧录中的调试功能"><a href="#J-Link-烧录中的调试功能" class="headerlink" title="J-Link 烧录中的调试功能"></a><strong>J-Link 烧录中的调试功能</strong></h3><p>J-Link 不仅仅是一个烧录工具，它还提供了强大的调试功能。在烧录完成后，你可以使用 J-Link 进行实时调试，如单步执行、断点设置、变量监控、内存查看等功能。这些功能可以帮助开发者快速定位问题和优化代码。</p>
<h3 id="常见问题和解决办法"><a href="#常见问题和解决办法" class="headerlink" title="常见问题和解决办法"></a><strong>常见问题和解决办法</strong></h3><ul>
<li><strong>连接失败</strong>：检查 J-Link 与目标板之间的连接，确保 JTAG 或 SWD 接口正确连接，目标设备已经上电。</li>
<li><strong>烧录失败</strong>：检查固件文件是否完整，尝试擦除目标闪存后再烧录。确认目标 MCU 和 J-Link 的驱动是否正确安装。</li>
<li><strong>速度过慢</strong>：J-Link 提供多种调试和编程速度设置，可以通过调整这些设置来提高烧录速度。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>J-Link 烧录是一项高效、稳定的固件烧录工具，适用于多种嵌入式开发平台。它支持通过 JTAG 或 SWD 接口与目标硬件进行通信，并且能够实现高速度、可靠性的烧录和调试功能。对于嵌入式开发人员来说，熟悉 J-Link 的使用可以大大提高开发效率，减少调试时间。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>烧录器</tag>
      </tags>
  </entry>
  <entry>
    <title>串口烧录</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/%E7%83%A7%E5%BD%95%E5%99%A8/%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95/</url>
    <content><![CDATA[<p>串口烧录是指通过串行通信接口（UART）将程序代码从电脑下载到微控制器（MCU）的存储器（如Flash存储）中，使其能够运行新的固件。</p>
<p>串口烧录需要一个 <strong>USB转串口模块（如 CH340）</strong> ，它的作用是将计算机的 USB 接口信号转换为串口信号，使计算机能够通过串口与目标设备通信；还需要一个<strong>专门的烧录软件</strong>，用来将编译好的固件文件（通常是 .hex 或 .bin 文件）通过 CH340 写入到微控制器的存储中。</p>
<h2 id="CH340"><a href="#CH340" class="headerlink" title="CH340"></a>CH340</h2><p><strong>CH340</strong> 是由 <strong>江苏沁恒微电子股份有限公司</strong> 生产的一款 <strong>USB 转串口芯片</strong>。它的主要功能是将 USB 接口转换为串口（UART）、打印口或 IrDA 接口，常用于嵌入式开发中进行串口通信或代码烧录。</p>
<p>CH340 应用于嵌入式开发中的代码烧录环节，主要作用如下：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/%E7%83%A7%E5%BD%95%E5%99%A8/%E4%B8%B2%E5%8F%A3%E7%83%A7%E5%BD%95/ch340lj.png" alt="ch340lj"></p>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p><strong>硬件连接</strong>：</p>
<ul>
<li>CH340 芯片的 USB 端连接到电脑，串口端（TXD&#x2F;RXD）连接到 MCU 的 UART（通常是 UART0）。</li>
<li>如果烧录时需要复位，可以将 CH340 的 <strong>DTR&#x2F;RTS</strong> 引脚连接到 MCU 的 <strong>RESET</strong> 或 <strong>BOOT0</strong> 引脚。</li>
</ul>
<p><strong>安装驱动</strong>：</p>
<ul>
<li>在电脑上安装 CH340 的 USB 驱动程序。</li>
<li>Windows 上可以在设备管理器中查看串口号（如 COM3）。</li>
<li><a href="https://www.wch.cn/downloads/CH341SER_EXE.html">CH341SER.EXE - 南京沁恒微电子股份有限公司</a></li>
</ul>
<p><strong>软件配置</strong>：</p>
<ul>
<li>使用烧录工具（如 Arduino IDE、XLoader、esptool.py、STM32CubeProgrammer）选择对应的串口号。</li>
<li>设置波特率（通常为 9600 或 115200，具体取决于 MCU 和开发环境的配置）。</li>
<li>在 Keil 中设置生成 .hex 文件</li>
</ul>
<p><strong>开始烧录</strong>：</p>
<ul>
<li>将编译生成的 .hexi 文件通过串口发送到 MCU 的 Flash 存储中。</li>
<li>烧录完成后，MCU 复位，运行新代码。</li>
</ul>
<blockquote>
<p>驱动安装时如果提示“驱动预安装成功”，且卸载时显示“无驱动可卸载”，那么就需要重启电脑将 CH340 连接好后重新安装即可。</p>
</blockquote>
<h2 id="烧录工具"><a href="#烧录工具" class="headerlink" title="烧录工具"></a>烧录工具</h2><p>不同的 MCU 支持的烧录工具都不同，如果确定要使用串口烧录，可以找厂商提供下对用的工具</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>烧录器</tag>
      </tags>
  </entry>
  <entry>
    <title>RTOS介绍</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/FreeRTOS%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>FreeRTOS 是一个开源的轻量级<strong>实时操作系统</strong>（RTOS），专为嵌入式系统设计。由 Real Time Engineers Ltd. 开发，目前由亚马逊维护并以 MIT License 开源。它广泛应用于物联网（IoT）、工业自动化和其他对实时性要求较高的场景。</p>
<p>FreeRTOS 的任务调度本质上是<strong>并发（Concurrency）</strong>而非并行（Parallelism）。</p>
<p><a href="https://www.freertos.org/Documentation/00-Overview">FreeRTOS官方文档</a></p>
<blockquote>
<p>裸机（Bare-metal）是没有操作系统的编程方式，程序直接在硬件上运行，需要手动管理任务调度、硬件资源和中断处理，适用于简单或对实时性要求高的应用。</p>
<p>FreeRTOS 是一个实时操作系统，基于裸机提供了任务调度、内存管理和中断处理等功能，使得多任务管理和并发执行变得更简单，适用于更复杂的应用。FreeRTOS 可以看作是裸机的扩展，通过操作系统的抽象层来简化硬件管理和程序设计。</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>轻量化设计</strong></p>
<ul>
<li>代码量小，占用内存低，适合资源受限的嵌入式系统。</li>
<li>内核大小通常只有几 KB。</li>
</ul>
<p><strong>可移植性</strong></p>
<ul>
<li>支持多种架构（ARM Cortex-M、RISC-V、x86 等）。</li>
<li>可跨平台运行，容易适配不同硬件。</li>
</ul>
<p><strong>实时性</strong></p>
<ul>
<li>支持<strong>抢占式调度</strong>、时间片轮转调度和优先级调度。</li>
<li>延迟和抖动低。</li>
</ul>
<p><strong>模块化</strong></p>
<ul>
<li>可裁剪的内核，用户可以根据需求选用或裁剪功能模块。</li>
</ul>
<p><strong>丰富的功能</strong></p>
<ul>
<li>提供任务管理、信号量、队列、互斥锁、定时器等功能。</li>
</ul>
<p><strong>社区支持和生态</strong></p>
<ul>
<li>大量开发者和维护团队支持。</li>
<li>与 AWS IoT 集成，提供 IoT 应用的解决方案。</li>
</ul>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>RTOS 内核和演示应用程序源代码使用以下惯例:<a href="https://freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/06-Coding-guidelines/02-FreeRTOS-Coding-Standard-and-Style-Guide">FreeRTOS编码标准风格指南</a></p>
<ul>
<li><p>变量</p>
<ul>
<li><p><em>uint32_t</em> 类型变量以 <em>ul</em> 为前缀，其中“u”表示“unsigned” ，“l”表示“long”。</p>
</li>
<li><p><em>uint16_t</em> 类型变量以 <em>us</em> 为前缀，其中“u”表示“unsigned” ，“s”表示“short”。</p>
</li>
<li><p><em>uint8_t</em> 类型变量以 <em>uc</em> 为前缀，其中“u”表示“unsigned” ，“c”表示“char ”。</p>
</li>
<li><p>非 stdint 类型的变量（我们自定义的变量类型，非 uint32_t、uint16_t 等这些类型）以 <em>x</em> 为前缀。例如，BaseType_t 和 TickType_t， 二者分别是可移植层定义的定义类型，主要架构的自然类型或最有效类型， 以及用于保存 RTOS 滴答计数的类型。(类似这样：BaseType_t  xA;)</p>
</li>
<li><p>非 stdint 类型的未签名变量（Unsigned Type）存在附加前缀 <em>u</em>。例如， UBaseType_t（未签名 BaseType_t）类型变量以 <em>ux</em> 为前缀。</p>
</li>
<li><p><em>size_t</em> 类型变量也带有 <em>ux</em> 前缀。</p>
</li>
<li><p>枚举变量以 <em>e</em> 为前缀</p>
</li>
<li><p>指针以附加 <em>p</em> 为前缀，例如，指向 uint16_t 的指针将以 <em>pus</em> 为前缀。</p>
</li>
<li><p>根据 MISRA 指南，未限定标准 <em>char</em> 类型仅可包含 ASCII 字符， 并以 <em>c</em> 为前缀。</p>
</li>
<li><p>根据 MISRA 指南，char* 类型变量仅可包含指向 ASCII 字符串的指针， 并以 <em>pc</em> 为前缀。</p>
</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li>文件作用域静态（私有）函数以 <em>prv</em> 为前缀。</li>
<li>根据变量定义的相关规定，API 函数以其返回类型为前缀， 并为 <em>void</em> 添加前缀 <em>v</em>。</li>
<li>API 函数名称以定义 API 函数文件的名称开头。例如，在 tasks.c 中定义 vTaskDelete， 并且具有 void 返回类型。</li>
</ul>
</li>
<li><p>宏</p>
<ul>
<li>宏以定义宏的文件为前缀。前缀为小写。例如， configUSE_PREEMPTION 在 FreeRTOSConfig.h 中定义。</li>
<li>除前缀外，所有宏均使用大写字母书写，并使用下划线来分隔单词。</li>
</ul>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>仅使用 stdint.h 类型和 RTOS 自带的 typedef，但以下情况除外：</p>
<ul>
<li><p>char</p>
<p>根据 MISRA 指南，仅在未限定字符类型包含 ASCII 字符方可使用未限定字符类型。</p>
</li>
<li><p>char *</p>
<p>根据 MISRA 指南，仅在未限定字符指针指向 ASCII 字符串时方可使用未限定字符指针 。使用需要 char * 参数的标准库函数时， 无需抑制良性编译器警告，此举尤其考虑到将一些编译器默认为未限定 char 类型是签名的， 而其他编译器默认未限定 char 类型是未签名的。</p>
</li>
</ul>
<p>针对每个移植定义四种类型。即：</p>
<ul>
<li><p>TickType_t</p>
<ul>
<li>如果 configUSE_16_BIT_TICKS 设置为非零 (true) ，则将 TickType_t 定义为未签名的 16 位类型。</li>
<li>如果 configUSE_16_BIT_TICKS 设置为零 (false)，则将 TickType_t 定义为未签名的 32 位类型。</li>
</ul>
<p>请参阅 API 文档的<a href="https://freertos.org/Documentation/02-Kernel/03-Supported-devices/02-Customization/">自定义</a>章节 获取完整信息。</p>
<p>32 位架构应始终将 configUSE_16_BIT_TICKS 设置为 0。</p>
</li>
<li><p>BaseType_t</p>
<p>架构中最有效、最自然的类型。例如，在 32 位架构上， BaseType_t 会被定义为 32 位类型。在 16 位架构上，BaseType_t 会被定义为 16 位类型 。如果将 BaseType_t 定义为 char， 则须特别注意确保将签名字符用于可能为负的函数返回值来指示错误。</p>
</li>
<li><p>UBaseType_t</p>
<p>未签名的 BaseType_t。</p>
</li>
<li><p>StackType_t</p>
<p>意指架构用于存储堆栈项目的类型。通常是 16 位架构上的 16 位类型 和 32 位架构上的 32 位类型，但也有例外情况。供 FreeRTOS 内部使用。</p>
</li>
</ul>
<blockquote>
<p>pd 是 <strong>Portable Data</strong>（可移植数据）的缩写，用于表示布尔值、错误状态或状态码等。它通常出现在宏定义和返回值中，提供了一种统一的、平台无关的表示方式。</p>
</blockquote>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="任务（Task）"><a href="#任务（Task）" class="headerlink" title="任务（Task）"></a><strong>任务（Task）</strong></h3><ul>
<li>FreeRTOS 的基本单元，每个任务相当于一个独立的线程。</li>
<li>每个任务有优先级，调度时优先级高的任务先执行。</li>
<li>任务的状态：<ul>
<li>就绪态（Ready）</li>
<li>运行态（Running）</li>
<li>阻塞态（Blocked）</li>
<li>挂起态（Suspended）</li>
</ul>
</li>
</ul>
<h3 id="调度器（Scheduler）"><a href="#调度器（Scheduler）" class="headerlink" title="调度器（Scheduler）"></a><strong>调度器（Scheduler）</strong></h3><ul>
<li><strong>抢占式调度</strong>：优先级高的任务可以抢占低优先级任务。</li>
<li><strong>时间片轮转</strong>：相同优先级的任务按时间片轮流执行。</li>
<li><strong>静态优先级调度</strong>：优先级固定，调度简单高效。</li>
</ul>
<h3 id="中断服务（Interrupt-Handling）"><a href="#中断服务（Interrupt-Handling）" class="headerlink" title="中断服务（Interrupt Handling）"></a><strong>中断服务（Interrupt Handling）</strong></h3><ul>
<li>支持中断嵌套。</li>
<li>提供中断安全 API，如 xQueueSendFromISR。</li>
</ul>
<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a><strong>信号量（Semaphore）</strong></h3><ul>
<li><strong>二值信号量</strong>：任务间简单同步。</li>
<li><strong>计数信号量</strong>：用于计数资源访问次数。</li>
</ul>
<h3 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a><strong>互斥锁（Mutex）</strong></h3><ul>
<li>防止多个任务同时访问共享资源。</li>
<li>提供优先级继承机制，防止优先级反转。</li>
</ul>
<h3 id="消息队列（Queue）"><a href="#消息队列（Queue）" class="headerlink" title="消息队列（Queue）"></a><strong>消息队列（Queue）</strong></h3><ul>
<li>用于任务间通信或中断与任务间通信。</li>
<li>支持任意类型数据的传递。</li>
</ul>
<h3 id="定时器（Timer）"><a href="#定时器（Timer）" class="headerlink" title="定时器（Timer）"></a><strong>定时器（Timer）</strong></h3><ul>
<li>软件定时器，用于定时执行任务。</li>
<li>提供单次触发和周期触发两种模式。</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><p>提供多种动态内存分配策略：</p>
<ul>
<li>heap_1：固定大小分配，不支持释放。</li>
<li>heap_2：简单合并算法，支持释放。</li>
<li>heap_4：最常用，内存碎片少。</li>
<li>heap_5：支持多内存区域。</li>
</ul>
<h2 id="时间片调度"><a href="#时间片调度" class="headerlink" title="时间片调度"></a>时间片调度</h2><p>同等优先级任务轮流地享有相同的 CPù 时间(可设置)，叫时间片；在FreeRTOS中，一个时间片就等于 SysTick 中断周期。</p>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>临界区</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E4%B8%B4%E7%95%8C%E5%8C%BA/</url>
    <content><![CDATA[<p>在 <strong>RTOS</strong>（实时操作系统）中，<strong>临界区</strong>（Critical Section）是指一段需要以原子性方式执行的代码。这意味着在执行临界区代码时，不允许其他任务或中断干扰，以确保数据一致性和操作的正确性。</p>
<h2 id="临界区的必要性"><a href="#临界区的必要性" class="headerlink" title="临界区的必要性"></a>临界区的必要性</h2><p>在 RTOS 中，任务是并发运行的，尤其是在多任务环境中，可能会发生以下情况：</p>
<ol>
<li><strong>任务切换（上下文切换）</strong>：在访问共享资源时，另一个任务可能会抢占当前任务。</li>
<li><strong>中断触发</strong>：中断服务程序可能会在任务执行时访问共享资源。</li>
<li><strong>数据竞争问题</strong>：多个任务或中断同时访问同一资源时，可能会引发数据损坏或错误操作。</li>
</ol>
<p><strong>临界区的作用</strong>就是防止以上问题，通过保护共享资源或关键代码段，确保并发环境下的正确性。</p>
<h2 id="定义临界区"><a href="#定义临界区" class="headerlink" title="定义临界区"></a>定义临界区</h2><p><strong>临界区</strong>通常是指一段需要访问共享资源（如全局变量、硬件寄存器、内存等）的代码。以下是一些典型的例子：</p>
<ul>
<li>修改全局变量。</li>
<li>操作队列、信号量、互斥锁等共享资源。</li>
<li>访问外部硬件设备寄存器。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update_shared_resource</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区开始</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    shared_resource++;  <span class="comment">// 对共享资源的修改</span></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line">    <span class="comment">// 临界区结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何实现临界区"><a href="#如何实现临界区" class="headerlink" title="如何实现临界区"></a>如何实现临界区</h2><p>在 RTOS 中，实现临界区主要在两个方面：</p>
<h3 id="禁止任务间切换"><a href="#禁止任务间切换" class="headerlink" title="禁止任务间切换"></a>禁止任务间切换</h3><p>在临界区代码执行期间，暂停任务调度，防止任务之间的切换。这种方法适用于不涉及中断的代码。</p>
<ul>
<li>在 FreeRTOS 中使用：<ul>
<li>taskENTER_CRITICAL() 和 taskEXIT_CRITICAL()： 禁止调度器，防止任务切换，保护临界区代码。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">taskENTER_CRITICAL();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果所使用的 FreeRTOS 移植未使用 configMAX_SYSCALL_INTERRUPT_PRIORITY 内核配置常量 （也称为 configMAX_API_CALL_INTERRUPT_PRIORITY），则调用 taskENTER_CRITICAL() 会全局禁用中断。如果所使用的 FreeRTOS 移植使用了 configMAX_SYSCALL_INTERRUPT_PRIORITY 内核配置常量，则调用 taskENTER_CRITICAL() 会禁用优先级等于或低于 configMAX_SYSCALL_INTERRUPT_PRIORITY 设置的优先级的中断， 并启用所有高于此优先级的中断。</p>
</blockquote>
<h3 id="禁止中断"><a href="#禁止中断" class="headerlink" title="禁止中断"></a>禁止中断</h3><p>在临界区代码执行期间，关闭中断，防止中断访问共享资源。</p>
<ul>
<li>在 FreeRTOS 中使用：<ul>
<li>taskENTER_CRITICAL_FROM_ISR() 和 taskEXIT_CRITICAL_FROM_ISR()： 完全禁用中断，这种方法适合保护非常短的关键代码段，但会导致系统延迟处理其他中断。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br></pre></td></tr></table></figure>

<p>临界区必须尽量简短，否则会对本来可以嵌套的 高优先级中断的响应时间产生不利影响。 每次调用 taskENTER_CRITICAL_FROM_ISR() 时， 都必须有对应的 taskEXIT_CRITICAL_FROM_ISR() 调用。</p>
<p>不得从临界区调用 FreeRTOS API 函数。</p>
<blockquote>
<p>如果使用的 FreeRTOS 移植支持中断嵌套，则调用 taskENTER_CRITICAL_FROM_ISR() 将禁用优先级等于或低于由configMAX_SYSCALL_INTERRUPT_PRIORITY（或 configMAX_API_CALL_INTERRUPT_PRIORITY）内核配置常量设置的优先级的中断， 同时启用所有其他高于此优先级的中断。 如果使用的 FreeRTOS 移植不支持中断嵌套，则 taskENTER_CRITICAL_FROM_ISR() 和 taskEXIT_CRITICAL_FROM_ISR() 将不起作用。</p>
</blockquote>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>任务管理</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>FreeRTOS 的任务管理是其核心功能之一，它负责在嵌入式系统中调度和管理多个任务（时间片轮询的方式），以便高效地利用处理器资源。任务管理的目标是确保各个任务按预期运行，执行时能及时响应事件或中断，并在不同任务间进行切换。</p>
<h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><p>FreeRTOS 通过任务状态来<strong>管理任务的执行、调度和同步</strong>，确保任务能够根据不同的条件高效地执行或等待。</p>
<p>任务可以存在于以下四种状态：</p>
<ul>
<li><p><strong>运行</strong></p>
<p>当任务实际执行时，它被称为处于运行状态。任务当前正在使用处理器。 如果运行 RTOS 的处理器只有一个内核， 那么在任何给定时间内都只能有一个任务处于运行状态。</p>
</li>
<li><p><strong>准备就绪</strong></p>
<p>准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态），但目前没有执行的任务， 因为同等或更高优先级的不同任务已经处于运行状态。</p>
</li>
<li><p><strong>阻塞</strong></p>
<p>如果任务当前正在等待时间或外部事件，则该任务被认为处于阻塞状态。 例如，如果一个任务调用 vTaskDelay()，它将被阻塞（被置于阻塞状态），直到延迟结束——一个时间事件。 任务也可以通过阻塞来等待队列、信号量、事件组、通知或信号量 事件。处于阻塞状态的任务通常有一个”超时”期， 超时后任务将被超时，并被解除阻塞， 即使该任务所等待的事件没有发生。“阻塞”状态下的任务不使用任何处理时间，不能 被选择进入运行状态。</p>
</li>
<li><p><strong>挂起</strong></p>
<p>与“阻塞”状态下的任务一样， “挂起”状态下的任务不能被选择进入运行状态，但处于挂起状态的任务没有超时。相反，任务只有在分别通过 vTaskSuspend() 和 xTaskResume() API 调用明确命令时才会进入或退出挂起状态。</p>
</li>
</ul>
<blockquote>
<p>阻塞：任务在阻塞状态时不会消耗 CPU 时间。调度器会选择其他处于就绪状态的任务来执行，直到阻塞条件解除，任务才会重新进入就绪状态。</p>
<p>挂起：任务进入挂起状态后，它不会消耗 CPU 时间，不会再参与调度。调度器不会选择挂起的任务执行，任务处于完全暂停的状态，直到再次显式恢复。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/rwzt.png" alt="rwzt"></p>
<blockquote>
<p>这四种状态中，除了运行态，其他三种任务状态的任务都有其对应的任务状态列表。</p>
<p>就绪列表：pxReadyTasksLists[x]，其中 x 代表任务优先级数值；pxReadyTasksLists[x] 代表的是一个数组，每个元素保存对应优先级的就绪任务列表。这里的 x 表示任务的优先级数值（硬件数值范围：0 ~ 31）。</p>
<p>阻塞列表：pxDelayedTaskList</p>
<p>挂起列表：xSuspendedTaskList</p>
<p>以 pxReadyTasksLists[x] 为例，调度器通过检查 pxReadyTasksLists[x] 数组来选择要执行的任务。每个 pxReadyTasksLists[x] 列表存储了优先级为 x 的所有就绪任务。调度器从最高优先级开始，逐个检查各个优先级的任务队列，找到第一个非空的队列，并选择该队列中的任务执行。这样 FreeRTOS 保证了优先级高的任务会优先执行，实现了抢占式调度。</p>
</blockquote>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p><strong>任务的优先级</strong>在 <strong>FreeRTOS</strong> 中起着至关重要的作用，它决定了任务在多个任务并发执行时的调度顺序。</p>
<p>每个任务均被分配了从 0 到 (configMAX_PRIORITIES - 1) 的优先级，configMAX_PRIORITIES 通常定义在 FreeRTOSConfig.h。</p>
<blockquote>
<p>如果正在使用的移植使用了“前导零计数”类指令的移植优化任务选择机制 （针对单一指令中的任务选择）而且configUSE_PORT_OPTIMISED_TASK_SELECTION 在 FreeRTOSConfig.h 中设置为 1，则 configMAX_PRIORITIES 无法高于 32。在其他所有情况下， configMAX_PRIORITIES 可以取任何合理数值——但为了保证 RAM 的使用效率，应取实际需要的最小值。</p>
<p>处于相同优先级的任务数量不限。如果 configUSE_TIME_SLICING 未经定义，或者如果 configUSE_TIME_SLICING 设置为 1，则具有<strong>相同优先级的若干就绪状态任务将通过时间切片轮询调度方案共享可用的处理时间</strong>。</p>
</blockquote>
<p>优先级数字小表示任务优先级低。<strong>空闲任务</strong>的优先级为零 (tskIDLE_PRIORITY)。</p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>在 FreeRTOS 中有三种不同的处理器架构和任务调度模式，主要与<strong>多核处理器</strong> 相关；分别是<strong>单核（Single-Core）</strong>、<strong>AMP（Asymmetric Multi-Processing）</strong> 和 <strong>SMP（Symmetric Multi-Processing）</strong></p>
<h3 id="单核"><a href="#单核" class="headerlink" title="单核"></a>单核</h3><p>FreeRTOS 默认使用固定优先级的<strong>抢占式调度策略</strong>，对同等优先级的任务执行时间切片轮询调度：</p>
<ul>
<li>“固定优先级”是指调度器不会永久更改任务的优先级， 但可能会因优先级继承而暂时提高任务的优先级。</li>
<li>“抢占式”是指调度器始终运行优先级最高且可运行的 RTOS 任务， 无论任务何时能够运行。例如， 如果中断服务程序 (ISR) 更改了优先级最高且可运行的任务， 调度器会停止当前正在运行的低优先级任务 并启动高优先级任务——即使这发生在同一个时间片内 。这种情况下可以说高优先级任务 “抢占”了低优先级任务。</li>
<li>“轮询调度”是指具有相同优先级的任务轮流进入运行状态。</li>
<li>“时间切片”是指调度器会在每个 tick 中断上在同等优先级任务之间进行切换， tick 中断之间的时间构成一个时间切片。（tick 中断是 RTOS 用来衡量时间的周期性中断。）</li>
</ul>
<p><strong>使用优先排序的抢占式调度器，避免任务饥饿</strong></p>
<p>始终运行优先级最高且可运行的任务的一个后果是从未进入<a href="https://freertos.org/Documentation/02-Kernel/02-Kernel-features/01-Tasks-and-co-routines/02-Task-states">阻塞或挂起</a>状态的高优先级任务将永久性剥夺所有更低优先级任务的任何执行时间。这就是通常最好创建事件驱动型任务的原因之一 。例如，如果一个高优先级任务正在等待一个事件，那么它就不应处于该事件的循环（轮询）中，因为如果处于轮询中，它会一直运行，永远不进入“阻塞”或 “挂起”状态。相反，该任务应进入“阻塞”状态等待这一事件。该事件可以 通过某个<a href="https://freertos.org/Why-FreeRTOS/highlighted-features">FreeRTOS任务间通信和同步原语</a>发送至任务。 收到事件后，优先级更高的任务会自动解除“阻塞”状态。这样低优先级 任务会运行，而高优先级任务会处于“阻塞”状态。</p>
<p><strong>优先级继承</strong></p>
<p>假设：</p>
<ul>
<li>任务 A（高优先级）需要一个资源（例如互斥锁）。</li>
<li>任务 B（低优先级）已经持有该资源，并且任务 A 被阻塞。</li>
<li>任务 C（中优先级）开始执行并抢占任务 B。</li>
</ul>
<p>没有优先级继承的情况：</p>
<ul>
<li>任务 C 会抢占任务 B 的执行，任务 B 不能及时释放资源，任务 A 会被长时间阻塞，导致优先级反转。</li>
</ul>
<p>启用优先级继承的情况：</p>
<ul>
<li>当任务 A 因为资源被任务 B 占用而阻塞时，FreeRTOS 会自动<strong>提升任务 B 的优先级</strong>，将其临时提升到任务 A 的优先级水平。</li>
<li>任务 B 现在有了和任务 A 相同的优先级，它会继续执行并尽快释放资源。</li>
<li>任务 B 释放资源后，它的优先级会恢复到原来的值，任务 A 也会重新获得执行权。</li>
</ul>
<h3 id="AMP"><a href="#AMP" class="headerlink" title="AMP"></a>AMP</h3><p>使用 FreeRTOS 的非对称多处理 (AMP) 是指多核设备的每个核心都单独运行自己的 FreeRTOS 实例。这些 核心并不都需要具有相同架构， 但如果 FreeRTOS 实例之间需要进行通信，则需要共享一些内存。</p>
<p>每个核心都会运行自己的 FreeRTOS 实例， 因此任何给定核心上的调度算法与上文的单核系统调度算法完全相同 。您可以使用<a href="https://freertos.org/Documentation/02-Kernel/02-Kernel-features/04-Stream-and-message-buffers/03-Message-buffer-example">流缓冲区或消息缓冲区</a>作为核间通信原语， 这样一来，一个核心上的任务可以进入“阻塞”状态， 以等待另一个核心发来的数据或事件。</p>
<h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><p>使用 FreeRTOS 的对称多处理 (SMP) 指的是 <a href="https://freertos.org/Documentation/02-Kernel/02-Kernel-features/13-Symmetric-multiprocessing-introduction/">一个 FreeRTOS 实例可以跨多个处理器核心调度 RTOS 任务</a>。 由于只有一个 FreeRTOS 实例在运行，一次只能使用 FreeRTOS 的一个移植， 因此每个核心必须具有相同的处理器架构并共用相同的内存空间。</p>
<h2 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h2><p>RTOS 调度器启动时，自动创建空闲任务，以确保始终<strong>存在一个能够运行的任务</strong>。它以最低优先级创建， 以确保如果有更高的优先级应用程序任务处于准备就绪状态，则不使用任何 CPU 时间（并不参与实际的应用逻辑）。</p>
<p>空闲任务负责释放 RTOS 分配给<strong>已删除任务的内存</strong>。因此，在使用 vTaskDelete() 函数来确保空闲任务不会匮乏处理时间的应用程序中（ 空闲任务占用系统的过多处理时间）， 这很重要。 空闲任务没有其他激活函数，因此可以在所有其他条件下合理地缺乏微控制器时间 。</p>
<p>应用程序任务可以共享空闲任务优先级 (tskIDLE_PRIORITY)。 请参阅 configIDLE_SHOULD_YIELD <a href="https://freertos.org/Documentation/02-Kernel/03-Supported-devices/02-Customization">配置参数</a>， 了解如何配置该行为。</p>
<h2 id="TaskHandle"><a href="#TaskHandle" class="headerlink" title="TaskHandle"></a>TaskHandle</h2><p>任务引用的类型(任务句柄)。例如，调用 xTaskCreate（通过指针参数） 返回 TaskHandle_t 变量，然后可以将该变量用作 vTaskDelete 的参数来删除任务。</p>
<p><strong>任务创建时</strong>，FreeRTOS 会为每个任务分配一个任务控制块（TCB），并通过任务句柄提供访问该控制块的指针。任务控制块保存了任务的所有信息，包括任务的状态、优先级、堆栈指针等。</p>
<p><strong>任务句柄的存储</strong>：通常，任务句柄是一个 TaskHandle_t 类型的变量，这个变量实际上是一个指向任务控制块的指针。你可以通过传递任务句柄来操作任务。例如，调用 vTaskDelete() 函数时需要传入一个任务句柄来指定删除哪个任务。</p>
<h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><h3 id="xTaskCreate"><a href="#xTaskCreate" class="headerlink" title="xTaskCreate"></a>xTaskCreate</h3><p>创建一项新任务并将其添加到准备运行的任务列表中;</p>
<p>注意：configSUPPORT_DYNAMIC_ALLOCATION(是否支持动态内存分配) 必须在 FreeRTOSConfig.h 中设置为 1，或处于未定义状态（默认为 1）才可使用此 RTOS API 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果未定义则创建一个，但是默认启用动态内存管理，所以可以不管他</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configSUPPORT_DYNAMIC_ALLOCATION</span></span><br><span class="line">    <span class="comment">/* Defaults to 1 for backward compatibility. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法 </span></span><br><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pvTaskCode,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> configSTACK_DEPTH_TYPE uxStackDepth,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> *pvParameters,</span></span><br><span class="line"><span class="params">                         UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                         TaskHandle_t *pxCreatedTask</span></span><br><span class="line"><span class="params">                       )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>pvTaskCode</em></p>
<p>指向任务入口函数的指针（即实现任务的函数名称）。</p>
</li>
</ul>
<blockquote>
<p> 任务通常以无限循环的形式实现；实现任务的函数绝不能尝试返回或退出。但是任务可通过 vTaskDelete 删除。</p>
</blockquote>
<ul>
<li><p><em>pcName</em></p>
<p>任务的描述性名称。此参数主要用于方便调试，但也可用于获取任务句柄（通过 xTaskGetHandle 函数）。任务名称的最大长度由 FreeRTOSConfig.h 中的 configMAX_TASK_NAME_LEN 定义。</p>
</li>
<li><p><em>uxStackDepth</em></p>
<p>分配用作任务堆栈的 wrod（不是字节数！）。</p>
<p>例如，如果堆栈宽度为 16 位，uxStackDepth 为 100，则将分配 200  字节用作任务堆栈。如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈。堆栈深度与堆栈宽度的乘积不得超过 size_t 类型变量所能包含的最大值。</p>
<p>对于<strong>对于 32 位处理器</strong>（如 ARM Cortex-M 系列）wrod 通常为 4 字节</p>
</li>
<li><p><em>pvParameters</em></p>
<p>作为参数传递给所创建任务的值。如果 pvParameters 设置为某变量的地址，则在创建的任务执行时，该变量必须仍然存在， 因此，不能传递堆栈变量的地址。</p>
</li>
<li><p><em>uxPriority</em></p>
<p>指定优先级。</p>
<p>支持 MPU 的系统 可以通过在 uxPriority 中设置 portPRIVILEGE_BIT 位来选择以特权（系统）模式创建任务。 例如，要创建优先级为 2 的特权任务，请将 uxPriority 设置为 ( 2 | portPRIVILEGE_BIT )。应断言优先级低于 configMAX_PRIORITIES。如果 configASSERT 未定义，则优先级默认上限为 (configMAX_PRIORITIES - 1)。</p>
<blockquote>
<p><strong>MPU</strong>（Memory Protection Unit）是一种硬件单元，用于提供内存保护功能，防止不恰当的内存访问，增加系统的安全性和稳定性。</p>
</blockquote>
</li>
<li><p><em>pxCreatedTask</em></p>
<p>用于将句柄传递至由 xTaskCreate() 函数创建的任务。pxCreatedTask 是可选参数， 可设置为 NULL。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果任务创建成功，则返回 pdPASS，</li>
<li>否则返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskCode</span><span class="params">(<span class="type">void</span>* pvParameters)</span> &#123;</span><br><span class="line">    configASSERT( ( ( <span class="type">uint32_t</span> ) pvParameters ) == <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span>( ;; ) &#123;</span><br><span class="line">        <span class="comment">/* Task code goes here. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaseType_t xReturned;</span><br><span class="line">TaskHandle_t xHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">xReturned = xTaskCreate(vTaskCode, <span class="string">&quot;NAME&quot;</span>, STACK_SIZE, ( <span class="type">void</span> * ) <span class="number">1</span>, tskIDLE_PRIORITY, &amp;xHandle );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xReturned == pdPASS ) &#123;</span><br><span class="line">    vTaskDelete( xHandle );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xTaskCreateStatic"><a href="#xTaskCreateStatic" class="headerlink" title="xTaskCreateStatic"></a>xTaskCreateStatic</h3><p>创建一项新任务 并将其添加到准备运行的任务列表中。</p>
<p>configSUPPORT_STATIC_ALLOCATION 必须在 FreeRTOSConfig.h 中设置为 1，才可使用此 RTOS API 函数。</p>
<p>如果 使用 xTaskCreateStatic 创建任务，则 RAM 由应用程序编写者提供，这会产生更多的参数，但这样能够在编译时静态分配 RAM。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">( TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                             UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                             StackType_t * <span class="type">const</span> puxStackBuffer,</span></span><br><span class="line"><span class="params">                             StaticTask_t * <span class="type">const</span> pxTaskBuffer )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>pxTaskCode</em></p>
<p>指向任务入口函数的指针（即实现任务的函数名称， 请参阅如下示例）。</p>
<p>任务通常以无限循环的形式实现；实现任务的函数绝不能尝试返回或退出。但是任务可通过 vTaskDelete 删除。</p>
</li>
<li><p><em>pcName</em></p>
<p>任务的描述性名称。此参数主要用于方便调试，但也可用于获取任务句柄（通过 xTaskGetHandle 函数）。</p>
<p>任务名称的最大长度由 FreeRTOSConfig.h中的 configMAX_TASK_NAME_LEN 定义。 |</p>
</li>
<li><p><em>ulStackDepth</em></p>
<p>puxStackBuffer 参数用于将 StackType_t 变量的数组传递至 xTaskCreateStatic。</p>
<p>ulStackDepth 必须设置为数组中的索引数。</p>
</li>
<li><p><em>pvParameters</em></p>
<p>作为参数传递给所创建任务的值。</p>
<p>如果 pvParameters 设置为某变量的地址，则在创建的任务执行时，该变量必须仍然存在，因此，不能传递堆栈变量的地址。 |</p>
</li>
<li><p><em>uxPriority</em></p>
<p>指定任务优先级。</p>
<p>支持 MPU 的系统 可以通过在 uxPriority 中设置 portPRIVILEGE_BIT 位来选择以特权（系统）模式创建任务。例如要创建优先级为 2 的特权任务，请将 uxPriority 设置为 ( 2 | portPRIVILEGE_BIT）。</p>
<p>应断言优先级低于 configMAX_PRIORITIES。如果 configASSERT 未定义，则优先级默认上限为 (configMAX_PRIORITIES - 1)。</p>
</li>
<li><p><em>puxStackBuffer</em></p>
<p>必须指向至少包含 ulStackDepth 个索引的 StackType_t 数组（见上述 ulStackDepth参数）。</p>
<p> 该数组将用作任务堆栈，因此必须持久存在 （不能在函数的堆栈上声明）。 |</p>
</li>
<li><p><em>pxTaskBuffer</em></p>
<p>必须指向 StaticTask_t 类型的变量（指向自定义分配内存的一个句柄）。该变量将用于保存新任务的数据结构体 (TCB)，因此必须持久存在（不能在函数的堆栈上声明）。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果 puxStackBuffer 和 pxTaskBuffer 均不为 NULL，则创建任务， 并返回任务的句柄。</p>
<p>如果 puxStackBuffer 或 pxTaskBuffer 为 NULL，则不会创建任务， 并返回 NULL。</p>
<h3 id="估算栈的大小"><a href="#估算栈的大小" class="headerlink" title="估算栈的大小"></a>估算栈的大小</h3><p>在FreeRTOS中，任务栈的大小通常是根据任务的需求和系统资源来进行估算的。栈的大小需要足够大，以便存储任务的局部变量、函数调用的返回地址、保存寄存器等数据。</p>
<p>ARM 架构理论上最多需要保存 9 个寄存器，我们用函数调用的深度 * 9 ，再加上函数中定义的局部变量的大小 就可以得出一个足够大小的栈。256 一般就足够了。</p>
<h3 id="vTaskDelete"><a href="#vTaskDelete" class="headerlink" title="vTaskDelete"></a>vTaskDelete</h3><p>从 RTOS 内核管理中移除任务。要删除的任务将从所有就绪、 阻塞、挂起和事件列表中移除。</p>
<p>INCLUDE_vTaskDelete 必须定义为 1，才可使用此函数。</p>
<p>注意：空闲任务负责释放由 RTOS 内核分配给<strong>已删除任务的内存</strong>。因此，如果应用程序调用了 vTaskDelete()，请务必确保空闲任务获得足够的微控制器处理时间。</p>
<p>任务代码分配的内存（通过 malloc() 或其他内存分配函数分配的内存）不会自动释放， 应在任务删除之前手动释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>xTask</em></p>
<p>要删除的任务的句柄。如果传递 NULL，会删除调用任务。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vOtherFunction</span><span class="params">( <span class="type">void</span> )</span> &#123;</span><br><span class="line">    TaskHandle_t xHandle = <span class="literal">NULL</span>;</span><br><span class="line">    xTaskCreate( vTaskCode, <span class="string">&quot;NAME&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, tskIDLE_PRIORITY, &amp;xHandle );</span><br><span class="line">    <span class="keyword">if</span>( xHandle != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        vTaskDelete( xHandle );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h2><p>按给定的滴答数延迟任务。任务保持阻塞的实际时间取决于滴答频率 。</p>
<p>INCLUDE_vTaskDelay 必须定义为 1，才可使用此函数。</p>
<p>常量 portTICK_PERIOD_MS 可用于根据滴答频率计算实际时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )</span></span><br></pre></td></tr></table></figure>

<p>configTICK_RATE_HZ 是 <strong>每秒钟发生的滴答次数</strong>，也就是系统时钟的频率，单位是赫兹（Hz）。它定义了在每秒钟内系统时钟产生多少次滴答（tick）。</p>
<p>那么每个滴答时钟的时间不就是 1s &#x2F; configTICK_RATE_HZ &#x3D;&#x3D;&gt; 1000ms &#x2F; configTICK_RATE_HZ 毫秒了么</p>
<p><strong>参数：</strong></p>
<ul>
<li><p><em>xTicksToDelay</em></p>
<p>调用任务应阻塞的 tick 周期数。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span> &#123;</span><br><span class="line">    <span class="comment">/* Block for 500ms. */</span></span><br><span class="line">    <span class="type">const</span> TickType_t xDelay = <span class="number">500</span> / portTICK_PERIOD_MS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; ) &#123;</span><br><span class="line">        <span class="comment">/* Simply toggle the LED every 500ms, blocking between each toggle. */</span></span><br><span class="line">        vToggleLED();</span><br><span class="line">        vTaskDelay(xDelay);</span><br><span class="line">        <span class="comment">/*        </span></span><br><span class="line"><span class="comment">        vTaskDelay(pdMS_TO_TICKS(500))</span></span><br><span class="line"><span class="comment">        pdMS_TO_TICKS() 宏用于将给定的数字转换成对应的滴答数量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vTaskDelay 函数的调用和任务的执行时间，可能会受到其他任务、系统中断以及代码路径的影响，从而导致任务实际延迟的时间与期望的延迟时间有所偏差。</p>
<h3 id="vTaskDelay"><a href="#vTaskDelay" class="headerlink" title="vTaskDelay"></a>vTaskDelay</h3><p>按给定的滴答数延迟任务。任务保持阻塞的实际时间取决于滴答频率 。</p>
<p>INCLUDE_vTaskDelay 必须定义为 1，才可使用此函数。</p>
<p>常量 portTICK_PERIOD_MS 可用于根据滴答频率计算实际时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portTICK_PERIOD_MS (( TickType_t ) 1000 / configTICK_RATE_HZ)</span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p><em>xTicksToDelay</em></p>
<p>调用任务应阻塞的 tick 周期数。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> TickType_t xDelay = <span class="number">500</span> / portTICK_PERIOD_MS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( ;; ) &#123;</span><br><span class="line">        vToggleLED();</span><br><span class="line">        vTaskDelay(xDelay);</span><br><span class="line">        <span class="comment">/* 还可以用下面这个宏      </span></span><br><span class="line"><span class="comment">        vTaskDelay(pdMS_TO_TICKS(500))</span></span><br><span class="line"><span class="comment">        pdMS_TO_TICKS() //宏用于将给定的数字转换成对应的滴答数量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>会恢复中断 并进行任务调度？</p>
<h3 id="vTaskDelayUntil"><a href="#vTaskDelayUntil" class="headerlink" title="vTaskDelayUntil"></a>vTaskDelayUntil</h3><h3 id="xTaskDelayUntil"><a href="#xTaskDelayUntil" class="headerlink" title="xTaskDelayUntil"></a>xTaskDelayUntil</h3><h3 id="uxTaskPriorityGet"><a href="#uxTaskPriorityGet" class="headerlink" title="uxTaskPriorityGet"></a>uxTaskPriorityGet</h3><h3 id="uxTaskPriorityGetFromISR"><a href="#uxTaskPriorityGetFromISR" class="headerlink" title="uxTaskPriorityGetFromISR"></a>uxTaskPriorityGetFromISR</h3><h3 id="uxTaskBasePriorityGet"><a href="#uxTaskBasePriorityGet" class="headerlink" title="uxTaskBasePriorityGet"></a>uxTaskBasePriorityGet</h3><h3 id="uxTaskBasePriorityGetFromISR"><a href="#uxTaskBasePriorityGetFromISR" class="headerlink" title="uxTaskBasePriorityGetFromISR"></a>uxTaskBasePriorityGetFromISR</h3><h3 id="vTaskPrioritySet"><a href="#vTaskPrioritySet" class="headerlink" title="vTaskPrioritySet"></a>vTaskPrioritySet</h3><h3 id="vTaskSuspend"><a href="#vTaskSuspend" class="headerlink" title="vTaskSuspend"></a>vTaskSuspend</h3><h3 id="vTaskResume"><a href="#vTaskResume" class="headerlink" title="vTaskResume"></a>vTaskResume</h3><h3 id="xTaskResumeFromISR"><a href="#xTaskResumeFromISR" class="headerlink" title="xTaskResumeFromISR"></a>xTaskResumeFromISR</h3><h3 id="xTaskAbortDelay"><a href="#xTaskAbortDelay" class="headerlink" title="xTaskAbortDelay"></a>xTaskAbortDelay</h3><h2 id="RTOS-内核控制"><a href="#RTOS-内核控制" class="headerlink" title="RTOS 内核控制"></a>RTOS 内核控制</h2><h3 id="vTaskStartScheduler"><a href="#vTaskStartScheduler" class="headerlink" title="vTaskStartScheduler"></a>vTaskStartScheduler</h3><p>启动 RTOS 调度器。调用后，RTOS 内核可以控制在何时执行哪些任务。</p>
<p>空闲任务和定时器守护进程任务]（可选）会在 RTOS 调度器启动时自动创建。</p>
<p>vTaskStartScheduler 仅在以下情况下返回：没有足够的 RTOS 堆可用来创建空闲或定时器守护进程任务。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAFunction</span><span class="params">( <span class="type">void</span> )</span>&#123;</span><br><span class="line">    xTaskCreate( vTaskCode, <span class="string">&quot;NAME&quot;</span>, STACK_SIZE, <span class="literal">NULL</span>, tskIDLE_PRIORITY, <span class="literal">NULL</span> );</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xTaskResumeAll"><a href="#xTaskResumeAll" class="headerlink" title="xTaskResumeAll"></a>xTaskResumeAll</h3><p>恢复通过调用 vTaskSuspendAll() 挂起的调度器。</p>
<p>xTaskResumeAll() 仅恢复调度器，不会恢复之前通过调用 vTaskSuspend() 而挂起的任务。</p>
<p>但是注意，在该任务中，如果他检测到</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>堆栈应该多大？</strong></p>
<p> 确定使用 RTOS 时需要多少堆栈与确定编写裸机应用程序（不使用操作系统的应用程序）时需要多少堆栈并无多大区别 。</p>
<p>所需的堆栈大小取决于以下应用程序特定的参数：</p>
<ul>
<li>函数调用嵌套深度</li>
<li>函数作用域变量声明的数量和大小</li>
<li>函数参数的数量</li>
<li>处理器架构</li>
<li>编译器</li>
<li>编译器优化级别</li>
<li>中断服务程序的堆栈要求——对于许多 RTOS 移植来说是零，因为 RTOS 在进入中断服务程序时会切换为使用专用中断堆栈。</li>
</ul>
<p>尽管难以确定要为任务分配多少堆栈，但 RTOS 会提供功能，以便采用务实的试错方法来调整任务的堆栈大小； <a href="https://freertos.org/Documentation/02-Kernel/04-API-references/03-Task-utilities/04-uxTaskGetStackHighWaterMark">uxTaskGetStackHighWaterMark()</a> API 函数可以用于查看实际的堆栈使用量，允许在分配的堆栈超出必要大小时减少堆栈大小， 而<a href="https://freertos.org/Documentation/02-Kernel/02-Kernel-features/09-Memory-management/02-Stack-usage-and-stack-overflow-checking">堆栈溢出检测</a> 功能可以用于确定堆栈是否太小。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
<p>二、<strong>如何使用我们自己定义的 delay_ms 函数</strong></p>
<p>当我们定义的延时函数依赖于 SysTick 定时器时，由于 FreeRTOS 接管了 SysTick 的控制权，该定时器只有在 <code>vTaskStartScheduler</code> 函数执行后才会启用。因此，如果延时函数 delay_ms() 被调用时 vTaskStartScheduler() 尚未运行，SysTick 尚未工作，可能导致延时函数进入死循环，阻塞程序运行。</p>
<p>三、<strong>就绪队列如何保证优先执行先执行高优先级的任务</strong></p>
<p>在 FreeRTOS 中，<strong>就绪队列</strong>中的任务是通过多个链表来管理的，每个链表对应一个不同的优先级级别。虽然这些队列使用链表来存储任务，但 FreeRTOS 保证高优先级任务优先执行的机制是通过<strong>优先级队列</strong>（优先级数组）和调度策略来实现的。</p>
<p><strong>就绪状态的优先级队列</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES ( 5 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span>&#123;</span></span><br><span class="line">    listFIRST_LIST_INTEGRITY_CHECK_VALUE </span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxNumberOfItems;</span><br><span class="line">    ListItem_t * configLIST_VOLATILE pxIndex;</span><br><span class="line">    MiniListItem_t xListEnd;                 </span><br><span class="line">    listSECOND_LIST_INTEGRITY_CHECK_VALUE</span><br><span class="line">&#125; List_t;</span><br><span class="line"></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br></pre></td></tr></table></figure>

<p>当调度器决定从就绪队列中选择一个任务来执行时，它会按照优先级从 <strong>高到低</strong> 的顺序检查优先级队列。由于每个优先级都有一个独立的链表，调度器总是首先检查 <strong>优先级最高的队列</strong>（即数组 pxReadyTasksLists[0] 对应的队列）。</p>
<ul>
<li><strong>高优先级任务</strong>：如果某个任务的优先级较高（数字较小），它会出现在 pxReadyTasksLists[0] 中，调度器会优先选择该队列中的任务来执行。</li>
<li><strong>低优先级任务</strong>：如果最高优先级队列为空，调度器会选择下一个优先级的队列，以此类推。</li>
</ul>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>事件组</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E4%BA%8B%E4%BB%B6%E7%BB%84/</url>
    <content><![CDATA[<p>在 <strong>FreeRTOS</strong> 中，<strong>队列（Queue）、信号量（Semaphore）、任务通知（Task Notification）等同步机制，每次只能处理一个任务</strong>。换句话说，这些机制都是<strong>点对点</strong>的，一次只能满足一个任务的同步需求。</p>
<p>但在实际应用中，我们往往<strong>需要多个任务同时等待一个或多个事件</strong>的发生，比如多个外设的状态变化、多个任务等待某个初始化完成等。这时候，<strong>事件组（Event Groups）</strong>就派上了用场！</p>
<p>事件组（Event Groups）是一种用于任务间通信的机制，主要用于多任务之间的同步。事件组允许任务通过设置和清除标志位来彼此协作，完成类似于“事件通知”的功能。事件组适合用于当多个任务需要等待某些条件或事件时，它们之间进行同步。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/sjzys.png" alt="sjzys"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在 FreeRTOS 中，事件组的本质是一个结构体，包含一个用于存储事件位状态的整数，通常是一个 <strong>32 位的无符号整数</strong>。其中，<strong>高 8 位</strong>用来存储<strong>事件组</strong>的控制信息，而<strong>低 24 位</strong>用来存储<strong>事件标志位</strong>（最多 24 个事件标志）。因此，一个事件组最多可以存储 24 个事件标志，而具体这些标志表示什么事件则由<strong>应用程序</strong>来决定。此外事件组还包含一个<strong>等待链表</strong>，链表中存放了一个个等待该事件组的任务。当任务等待事件组的标志位时，它们会被添加到该链表中，直到满足条件，事件组才会唤醒相应的任务。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/sjz32w.png" alt="sjz32w"></p>
<blockquote>
<p>高 8 位通常存储的是与<strong>事件组本身</strong>的管理和状态相关的信息，诸如：是否有任务等待、事件组是否需要清除标志位、同步操作模式（AND&#x2F;OR），等等。</p>
<p>这些控制信息是<strong>事件组级别的管理</strong>，而不是单个任务的状态控制。</p>
</blockquote>
<h2 id="事件组和事件位数据类型"><a href="#事件组和事件位数据类型" class="headerlink" title="事件组和事件位数据类型"></a>事件组和事件位数据类型</h2><p>事件组由 EventGroupHandle_t 类型的变量引用。</p>
<p>如果 configUSE_16_BIT_TICKS 设为 1，则事件组中存储的位（或标志）数为 8； 如果 configUSE_16_BIT_TICKS 设为 0，则为 24。 configUSE_16_BIT_TICKS 的值取决于 任务内部实现中用于线程本地存储的数据类型。</p>
<p>事件组中的所有事件位都存储在 EventBits_t 类型的单个无符号整数变量中。事件位 0 存储在位 0 中， 事件位 1 存储在位1 中，依此类推。</p>
<p>包含 24 个事件位的事件组，其中包含了 3 个事件，在图片中仅设置了事件位 2</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/eventgroupshili.gif" alt="eventgroupshili"></p>
<h2 id="事件组相关函数"><a href="#事件组相关函数" class="headerlink" title="事件组相关函数"></a>事件组相关函数</h2><p>提供的事件组 API 函数允许任务在事件组中设置一个或多个事件位， 清除事件组中的一个或多个事件位，并挂起（进入阻塞状态， 因此任务不会消耗任何处理时间）以等待事件组中一个或多个事件位固定下来。</p>
<p>事件组也可用于同步任务，创建通常称为“集合”的任务。任务同步点是应用程序代码中的一个位置，在该位置任务将在阻塞状态（不消耗任何 CPU 时间）下等待，直到参与同步的所有其他任务也到达其同步点。</p>
<h2 id="实现事件组时-RTOS-必须克服的挑战"><a href="#实现事件组时-RTOS-必须克服的挑战" class="headerlink" title="实现事件组时 RTOS 必须克服的挑战"></a>实现事件组时 RTOS 必须克服的挑战</h2><p>在实现事件组时，RTOS 必须克服以下两项主要挑战：</p>
<ol>
<li><p>避免在用户的应用程序中创建争用条件：<br>如果出现以下情况，事件组实现将在应用程序中创建争用条件：</p>
<ul>
<li>不清楚各个位（或标志）由谁清除。</li>
<li>不清楚何时清除位。</li>
<li>不清楚在任务退出测试位值的 API 函数时是否设置或清除了位（可能是 另一个任务或中断已更改该位的状态）。</li>
</ul>
<p>FreeRTOS 事件组的实现通过内置智能来确保位的设置、测试和清除具有原子性， 从而消除了争用条件的可能性。线程本地存储和谨慎使用 API 函数返回值使之成为可能。</p>
</li>
<li><p>避免不确定性：</p>
<p>事件组概念意味着非确定性行为，因为 不知道在一个事件组上有多少任务被阻塞，因此 不清楚在设置事件位时 需要测试多少条件或解除多少阻塞任务。</p>
<p>根据 FreeRTOS 质量标准，<strong>无法</strong>在禁用中断时 或在中断服务程序中 执行非确定性操作。为确保在设置事件位时 不违反这些严格的质量标准，需要以下两点：</p>
<ul>
<li>RTOS 调度器的锁定机制用于确保 在 RTOS 任务中设置事件位时中断仍处于启用状态。</li>
<li>尝试在中断服务程序中设置事件位时， 集中延迟中断机制用于 将设置位的动作延迟到任务。</li>
</ul>
</li>
</ol>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="xEventGroupCreate"><a href="#xEventGroupCreate" class="headerlink" title="xEventGroupCreate"></a>xEventGroupCreate</h3><p>创建一个新的 RTOS 事件组，并返回可以引用新创建的事件组的句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event_groups.h</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>要使此 RTOS API 函数可用：</p>
<ol>
<li>configSUPPORT_DYNAMIC_ALLOCATION 必须在 FreeRTOSConfig.h 中设置为 1，或保留未定义状态（此时 默认为 1）。</li>
<li>必须将 RTOS 源文件 FreeRTOS&#x2F;source&#x2F;event_groups.c 包含在构建中。</li>
</ol>
<p>每个事件组都需要（非常）少量的 RAM 来保存 事件组的状态。如果使用 xEventGroupCreate() 创建事件组， 则所需的 RAM 将从 FreeRTOS 堆自动分配。 如果使用 xEventGroupCreateStatic() 创建事件组 则 RAM 由应用程序编写器提供，这需要用到一个附加参数， 但允许在编译时静态分配 RAM 。</p>
<p>事件组存储在 EventBits_t 类型的变量中。如果 configUSE_16_BIT_TICKS 设置为 1，则事件组内实现的位数（或标志数）为 8； 如果 configUSE_16_BIT_TICKS 设置为 0，则事件组内实现的位数（或标志数）为 24。 对 configUSE_16_BIT_TICKS 的依赖 取决于 RTOS 任务内部实现中用于线程本地存储的数据类型。</p>
<p><strong>参数：</strong></p>
<p><em>无</em></p>
<p><strong>返回：</strong></p>
<ul>
<li>如果创建了事件组，则返回事件组的句柄。</li>
<li>如果没有足够的 FreeRTOS 堆来创建事件组，则返回 NULL。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EventGroupHandle_t xCreatedEventGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xCreatedEventGroup == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xEventGroupSetBits"><a href="#xEventGroupSetBits" class="headerlink" title="xEventGroupSetBits"></a>xEventGroupSetBits</h3><p>在 RTOS 事件组中设置位（标志）。该函数不能从中断中调用。xEventGroupSetBitsFromISR() 是可从中断调用的版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup, <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br></pre></td></tr></table></figure>

<p>在事件组中设置位时，所有等待该位的任务将自动解除阻塞。</p>
<p>必须将 RTOS 源文件 FreeRTOS&#x2F;source&#x2F;event_groups.c 包含在构建中，xEventGroupSetBits() 函数才可用。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xEventGroup</p>
<p>要设置位的事件组。必须事先通过调用 xEventGroupCreate() 创建事件组。</p>
</li>
<li><p>uxBitsToSet</p>
<p>指定要在事件组中设置的一个或多个位的按位值。例如，将 uxBitsToSet 设置为 0x08，则只设置第 3 位。将 uxBitsToSet 设置为 0x09，即可设置第 3 位和第 0 位。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>返回的是事件组当前的值，即在调用该函数之后，事件组中所有位的最新状态。</p>
<p>调用 xEventGroupSetBits() 后，返回的事件组值可能会受到以下两种情况的影响：</p>
<ol>
<li>如果设置某个事件位使得等待该位的任务从阻塞状态中解除，该位可能会被自动清除（具体取决于 xClearBitOnExit 参数的设置，参考 xEventGroupWaitBits() 函数）。</li>
<li>如果在调用 xEventGroupSetBits() 之后，有优先级更高的任务变为就绪状态并执行，它们可能会在返回之前修改事件组的值。</li>
</ol>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">uxBits = xEventGroupSetBits(xEventGroup, BIT_0 | BIT_4 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((uxBits &amp; ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )&#123;</span><br><span class="line">    <span class="comment">// 当前函数返回后 0、4 位报纸不变s</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((uxBits &amp; BIT_0) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当函数返回时，位0保持不变，但位4被清除。可能是由于等待位4的任务从阻塞状态中移除，位4被自动清除。</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((uxBits &amp; BIT_4) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当函数返回时，位4保持不变，但位0被清除。可能是由于等待位0的任务从阻塞状态中移除，位0被自动清除。.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 位0和位4未被设置。可能有一个任务正在等待这两个位被设置，当任务离开“阻塞”状态时，这些位被清除。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xEventGroupWaitBits"><a href="#xEventGroupWaitBits" class="headerlink" title="xEventGroupWaitBits"></a>xEventGroupWaitBits</h3><p>读取 RTOS 事件组中的位，选择性地进入“阻塞”状态（已设置 超时值）以等待设置单个位或一组位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event_groups.h</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                      TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>无法从中断调用此函数。</p>
<p>必须将 RTOS 源文件 FreeRTOS&#x2F;source&#x2F;event_groups.c 包含在构建中，xEventGroupWaitBits() 函数才可用。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xEventGroup</p>
<p>事件组的句柄，表示你想要操作的事件组。必须事先通过调用 xEventGroupCreate() 创建事件组。</p>
</li>
<li><p>uxBitsToWaitFor</p>
<p>指定你希望等待的位。它是一个位掩码，每一位对应一个特定的事件标志。</p>
<p>例如，要等待 第 0 位和&#x2F;或第 2 位，将 uxBitsToWaitFor 设置为 0x05 即可。要等待第 0 位和&#x2F;或第 1 位和&#x2F;或第 2 位， 将 uxBitsToWaitFor 设置为 0x07 即可。uxBitsToWaitFor <strong>不得</strong> 设置为 0。</p>
</li>
<li><p>xClearOnExit</p>
<p>如果 xClearOnExit 设置为 pdTRUE，那么在发生以下情况之前，作为 uxBitsToWaitFor 参数传递的值中设置的任何位都将在 xEventGroupWaitBits() 返回之前在事件组中清除；xEventGroupWaitBits() 因超时以外的任何原因返回。超时值由 xTicksToWait 参数设置。（只要不是超时返回都将清除标志位）</p>
<p>如果 xClearOnExit 设置为 pdFALSE，那么当调用 xEventGroupWaitBits() 返回时，事件组中设置的位不会改变。</p>
</li>
<li><p>xWaitForAllBits</p>
<p>xWaitForAllBits 用于创建逻辑 AND（必须设置所有位） 或逻辑 OR（必须设置一个或多个位）：</p>
<p>如果 xWaitForAllBits 设置为 pdTRUE（逻辑 &amp;&amp;），那么 xEventGroupWaitBits() 在以下条件下将返回：</p>
<ul>
<li>作为 uxBitsToWaitFor 参数传递的值中的所有位在事件组中被设置（置 1）或指定的阻塞时间到期。</li>
</ul>
<p>如果 xWaitForAllBits 设置为 pdFALSE（逻辑 ||），那么 xEventGroupWaitBits() 在以下条件下将返回：</p>
<ul>
<li>作为 uxBitsToWaitFor 参数传递的值中的任何位在事件组中被设置（置 1）或指定的阻塞时间到期。</li>
</ul>
</li>
<li><p>xTicksToWait</p>
<p>等待以下情况发生的最长时间（以“滴答”为单位，取决于 xWaitForAllBits 值）：</p>
<ul>
<li>uxBitsToWaitFor 指定的一个&#x2F;所有位被设置。</li>
</ul>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li><p>事件位等待完成设置或阻塞时间过期时的事件组值。在以下情况下，事件组中事件位的当前值将与返回值不同： 高优先级任务或中断在调用任务解除“阻塞”状态和退出 xEventGroupWaitBits() 函数之间更改了事件位的值 。</p>
<p>测试返回值以确定哪些位已完成设置。如果 xEventGroupWaitBits() 因为超时过期而返回， 则并非在等待的所有位都会进行设置。如果 xEventGroupWaitBits() 返回因为其等待的位被设置而返回， 则返回值是由于任何位因为 xClearOnExit 参数被设置为 pdTRUE </p>
<p>而自动清除之前的事件组值。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_0	( 1 &lt;&lt; 0 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_4	( 1 &lt;&lt; 4 )</span></span><br><span class="line"></span><br><span class="line">uxBits = xEventGroupWaitBits(</span><br><span class="line">               xEventGroup,   </span><br><span class="line">               BIT_0 | BIT_4,</span><br><span class="line">               pdTRUE,</span><br><span class="line">               pdFALSE, </span><br><span class="line">               xTicksToWait );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((uxBits &amp; ( BIT_0 | BIT_4)) == (BIT_0 | BIT_4)) &#123;</span><br><span class="line">    <span class="comment">// 两个位都是 1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((uxBits &amp; BIT_0) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 只设置了 bit 0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(( uxBits &amp; BIT_4) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 只设置了 bit 4</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 二者都没有修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xEventGroupSync"><a href="#xEventGroupSync" class="headerlink" title="xEventGroupSync"></a>xEventGroupSync</h3><p>以原子方式设置 RTOS 事件组中的位（标志），然后等待在同一事件组中设置位的组合。此功能通常<strong>用于同步多个任务</strong>（通常称为任务集合），其中每个 任务必须等待其他任务到达同步点后才能继续。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">event_groups.h</span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSync</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>不能从中断使用此函数。</p>
<p>如果设置了 uxBitsToWait 参数指定的位，或者在该时间内设置了这些位，则该函数将在其阻塞时间到期之前返回。这种情况下，uxBitsToWait 指定的所有位将在 函数返回之前自动清除。</p>
<p>必须将 RTOS 源文件 FreeRTOS&#x2F;source&#x2F;event_groups.c 包含在构建中，xEventGroupSync() 函数才可用。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xEventGroup</p>
<p>事件组的句柄，表示你想要操作的事件组。必须事先通过调用 xEventGroupCreate() 创建事件组。</p>
</li>
<li><p>uxBitsToSet</p>
<p>在确定 uxBitsToWait 参数指定的所有位是否都已设置（可能还要等待）之前，要在事件组中设置的一个或多个位。</p>
<p>例如，将 uxBitsToSet 设置为 0x04， 即可设置事件组内的第 2 位。</p>
</li>
<li><p>uxBitsToWaitFor</p>
<p>表示任务希望等待哪些位被设置为 1。只有当这些位中的所有位都被设置时，任务才会解除阻塞并继续执行。</p>
<p>例如，将 uxBitsToWaitFor 设置为 0x05，即可等待第 0 位和第 2 位。将 uxBitsToWaitFor 设置为 0x07，即可等待第 0 位、第 1 位和第 2 位等。</p>
</li>
<li><p>xTicksToWait</p>
<p>等待 uxBitsToWaitFor 参数值指定的所有位被设置的最长时间（以滴答为单位） 。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li><p>等待置位时或阻塞到期时事件组的值。测表示事件组中所有位的当前状态。</p>
<p>如果 xEventGroupSync() 因为超时过期而返回， 则并非在等待的所有位都会进行设置（有部分状态位没有被设置）。它会返回事件组的当前状态。</p>
<p>如果 xEventGroupSync() 因其所等待的所有位都被设置而返回， 那么返回值是自动清除任何位<strong>之前</strong>的事件组值。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 0 标志位，等待 ALL_SYNC_BITS 对应的标志位被置位</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )</span></span><br><span class="line"></span><br><span class="line">uxReturn = xEventGroupSync( xEventBits,</span><br><span class="line">                                    TASK_0_BIT,</span><br><span class="line">                                    ALL_SYNC_BITS,</span><br><span class="line">                                    xTicksToWait );</span><br><span class="line"><span class="keyword">if</span>((uxReturn &amp; ALL_SYNC_BITS) == ALL_SYNC_BITS) &#123;</span><br><span class="line">    <span class="comment">// 当三个任务同步时的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>按键被按下时，通过事件组触发三个任务依次执行，打印不同的消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EVENT_BIT(N)		(1 &lt;&lt; N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_0			EVENT_BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_1			EVENT_BIT(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_2			EVENT_BIT(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_3			EVENT_BIT(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_4			EVENT_BIT(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_5			EVENT_BIT(5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_6			EVENT_BIT(6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_7			EVENT_BIT(7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_8			EVENT_BIT(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_9			EVENT_BIT(9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_10		EVENT_BIT(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_11		EVENT_BIT(11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_12		EVENT_BIT(12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_13		EVENT_BIT(13)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_14		EVENT_BIT(14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_15		EVENT_BIT(15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_16		EVENT_BIT(16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_17		EVENT_BIT(17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_18		EVENT_BIT(18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_19		EVENT_BIT(19)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_20		EVENT_BIT(20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_21		EVENT_BIT(21)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_22		EVENT_BIT(22)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_23		EVENT_BIT(23)</span></span><br><span class="line"></span><br><span class="line">TaskHandle_t            task_handler;</span><br><span class="line">TaskHandle_t            task_key_handler;</span><br><span class="line">TaskHandle_t            task1_handler;</span><br><span class="line">TaskHandle_t            task2_handler;</span><br><span class="line">TaskHandle_t            task3_handler;</span><br><span class="line">EventGroupHandle_t			event_group;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    EventBits_t bits;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bits = xEventGroupWaitBits(event_group, EVENT_BIT_0, pdTRUE, pdFALSE, portMAX_DELAY);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task1: %d\r\n&quot;</span>, bits);</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    EventBits_t bits;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bits = xEventGroupWaitBits(event_group, EVENT_BIT_0, pdTRUE, pdTRUE, portMAX_DELAY);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task2: %d\r\n&quot;</span>, bits);</span><br><span class="line">        vTaskDelay(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    EventBits_t bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bits = xEventGroupWaitBits(event_group, EVENT_BIT_0, pdTRUE, pdTRUE, portMAX_DELAY);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task3: %d\r\n&quot;</span>, bits);</span><br><span class="line">        vTaskDelay(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_key</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    FlagStatus pre_state = RESET;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FlagStatus state = gpio_input_bit_get(GPIOA, GPIO_PIN_0);</span><br><span class="line">        <span class="keyword">if</span>(SET == state &amp;&amp; pre_state == RESET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,按下</span></span><br><span class="line">            pre_state = state;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;set bit \r\n&quot;</span>);</span><br><span class="line">            xEventGroupSetBits(event_group, EVENT_BIT_0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(RESET == state &amp;&amp; pre_state == SET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,抬起</span></span><br><span class="line">            pre_state = state;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    GPIO_config();</span><br><span class="line">    Usart0_init();</span><br><span class="line"></span><br><span class="line">    event_group = xEventGroupCreate();</span><br><span class="line">    <span class="keyword">if</span>(event_group != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;group success\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line">    xTaskCreate(task_key, <span class="string">&quot;task_key&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;task_key_handler);</span><br><span class="line">    xTaskCreate(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">4</span>, &amp;task1_handler);</span><br><span class="line">    xTaskCreate(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">3</span>, &amp;task2_handler);</span><br><span class="line">    xTaskCreate(task3, <span class="string">&quot;task3&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task3_handler);</span><br><span class="line">    vTaskDelete(task_handler);</span><br><span class="line"></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart0_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;recv: %s\n&quot;, data);</span></span><br><span class="line">    xEventGroupSetBitsFromISR(event_group, EVENT_BIT_0, <span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 时钟初始化</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">    <span class="comment">// 配置GPIO模式</span></span><br><span class="line">    gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    nvic_priority_group_set(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line">    xTaskCreate(start_task, <span class="string">&quot;start_task&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是任务间通信的主要形式。它们可以用于在任务之间 以及中断和任务之间发送消息。在大多数情况下，队列用作线程安全的 FIFO（先进先出）缓冲区， 新数据被发送到队列的后面，但也可以发送到前面。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/queueyuanli.gif" alt="queueyuanli"></p>
<p>向队列中写入和从队列中读取。此示例中创建队列来保存 5 个项目，并且队列永远不会满。</p>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>FreeRTOS 队列使用模型既简单又灵活， 这两者通常是不可兼得的。消息通过队列以副本的方式发送， 这意味着<strong>数据（可以是更大的缓冲区的指针）本身被复制到队列中， 而不是队列始终只存储对数据的引用。</strong></p>
<ul>
<li><p>已经包含在 C 语言变量（整数、 小结构体等）中的小消息可以直接送入队列。没有 必要为消息分配一个缓冲区， 然后将变量复制到分配的缓冲区中。同样，可以直接从队列中将消息读取到 C 变量中 。</p>
<p>此外，以这种方式向队列发送消息， 允许发送任务立即覆盖发送到队列的变量或缓冲区（直接覆盖队列中的数据）， 即使发送的消息仍在队列中。</p>
<p>由于变量中包含的数据已复制到队列中， 变量本身可以重复使用。不要求发送消息的任务和接收消息的任务约定哪个任务拥有该消息，以及哪个任务负责在不需要该消息时 将其清空。</p>
</li>
<li><p>使用通过复制传递数据的队列不会导致无法将队列用于通过引用传递数据。当消息的大小达到一定程度， 将整条消息逐字节复制到队列中是不现实的， 此时可将消息定义为保存若干指针并复制消息的 一个指针至队列。</p>
</li>
<li><p>内核独自负责分配用于队列存储区的内存 。</p>
</li>
<li><p>可变大小的消息可以通过定义队列来保存结构体， 其中包含一个指向队列消息的成员， 以及另一个保存队列消息大小的成员。</p>
</li>
<li><p>单个队列可用于接收不同的消息类型， 以及来自多个地点的消息， 方法是将队列定义为保存一个结构体，该结构的一个成员持有消息类型， 另一个成员保存消息数据（或消息数据的一个指针）。如何解释数据 取决于消息类型。</p>
<p>正是使用这种方式，管理 FreeRTOS-Plus-TCP IP 堆栈的任务才能使用一个队列来接收 ARP 定时器事件、 从以太网硬件接收的数据包、 从应用程序接收的数据包、网络故障事件等的通知。</p>
</li>
<li><p>该实现适用于在内存保护环境中使用 。一个被限制在受保护的内存区域的任务可以将数据传递给一个被限制在不同的受保护内存区域的任务， 因为通过调用队列发送函数 来调用 RTOS 将提高微控制器的权限等级 。队列存储区 仅可由 RTOS 访问（具有完整权限）。</p>
</li>
<li><p>提供一个单独的 API 用于中断内部。将 RTOS 任务中使用的 API 与中断服务程序中使用的 API 分开， 意味着 RTOS API 函数的实现 不承担每次执行时检查其调用上下文的开销。 使用单独的中断 API 也意味着，在大多数情况下，创建 RTOS 感知的中断服务程序对终端用户而言更简单—— 与其他 RTOS 产品相比。</p>
</li>
<li><p>从任何意义上来说，API 都更加简单。</p>
</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>队列 API 函数允许指定阻塞时间。</p>
<p>当一个任务试图从一个空队列中读取时，该队列将进入阻塞状态（因此它不会消耗任何 CPU 时间，且其他任务可以运行）直到队列中的数据变得可用，或者阻塞时间过期。</p>
<p>当一个任务试图写入到一个满队列时，该队列将进入阻塞状态（因此它不会消耗任何 CPU 时间，且其他任务可以运行）直到队列中出现可用空间，或者阻塞时间过期。</p>
<p>如果同一个队列上有多个处于阻塞状态的任务， 那么具有最高优先级的任务将最先解除阻塞。</p>
<p>请注意，中断只能使用以 “FromISR” 结尾的 API 函数。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="xQueueCreate"><a href="#xQueueCreate" class="headerlink" title="xQueueCreate"></a>xQueueCreate</h3><p>创建新队列并返回一个可以引用该队列的 句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">(UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>

<p>configSUPPORT_DYNAMIC_ALLOCATION 必须在 FreeRTOSConfig.h 中设置为 1，或保留为未定义状态（默认为 1）， 才可使用此 RTOS API 函数。</p>
<p>每个队列都需要 RAM 来保存队列状态 以及队列中包含的项目（队列存储区）。 如果使用 xQueueCreate() 创建队列，则所需的 RAM 会自动 从 FreeRTOS 堆中分配。 如果 使用 xQueueCreateStatic() 创建队列， 则 RAM 由应用程序编写者提供，这会产生更多的参数， 但这样能够在编译时静态分配 RAM 。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>uxQueueLength</p>
<p>队列一次可存储的最大项目数。</p>
</li>
<li><p>uxItemSize</p>
<p>存储队列中每个项目所需的大小（以字节为单位）。</p>
<p>项目通过复制而非引用的方式入队，因此该参数值是每个入队项目将复制的 字节数。队列中的每个项目必须具有相同的大小。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果队列创建成功，则返回所创建队列的句柄。如果创建队列所需的内存 无法分配，则返回 NULL。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xQueue1 = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>( <span class="type">unsigned</span> <span class="type">long</span> ));</span><br><span class="line"><span class="keyword">if</span>(xQueue1 == <span class="literal">NULL</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xQueue2 = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> AMessage *));</span><br><span class="line"><span class="keyword">if</span>( xQueue2 == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="xQueueSend"><a href="#xQueueSend" class="headerlink" title="xQueueSend"></a>xQueueSend</h3><p>此宏用于调用 xQueueGenericSend() 函数。之所以包含此宏，是为了 向后兼容那些未提供 xQueueSendToFront() 和 xQueueSendToBack()  宏的 FreeRTOS 版本。其功能 等同于 xQueueSendToBack()。</p>
<p>从队列尾部入队一个数据项。数据项通过复制而非引用入队。不得从中断服务程序 。不得从中断服务程序中调用 此函数。</p>
<p>xQueueSendFromISR()，这是一个可在 ISR 中使用的替代函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(QueueHandle_t xQueue, <span class="type">const</span> <span class="type">void</span> * pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xQueue</p>
<p>要向其中发布项目的<strong>队列的句柄</strong>。</p>
</li>
<li><p>pvItemToQueue</p>
<p>指向要放入队列中的<strong>项目的指针</strong>。队列能够存储的项目的大小在创建队列时即已定义，因此 pvItemToQueue 中的这些字节将复制到 队列存储区中。</p>
</li>
<li><p>xTicksToWait</p>
<p>队列已满的情况下，任务处于阻塞状态且愿意等待队列中出现可用空间的 最长时间。</p>
<p>如果队列已满且 xTicksToWait 设置为 0， 则调用将立即返回。时间以滴答周期为单位定义，如果需要转换为实际时间，可以使用 portTICK_PERIOD_MS 常量 。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果成功发布项目，返回 pdTRUE，</li>
<li>否则返回 errQUEUE_FULL。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xQueue1 = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulVar = <span class="number">10UL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xQueueSend(xQueue1, (<span class="type">void</span>*) &amp;ulVar, (TickType_t )<span class="number">10</span>) != pdPASS) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="xQueueReceive"><a href="#xQueueReceive" class="headerlink" title="xQueueReceive"></a>xQueueReceive</h3><p>从队列中接收项目。该项目通过复制接收，因此必须提供足够大小的缓冲区。创建队列时定义了复制到缓冲区中的字节数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">(QueueHandle_t xQueue, <span class="type">void</span>* pvBuffer, TickType_t xTicksToWait)</span></span><br></pre></td></tr></table></figure>

<p>这是用于调用 xQueueGenericReceive() 函数的宏。</p>
<p>中断服务程序中不得使用此函数。请参阅 xQueueReceiveFromISR 了解可以选择的替代方案。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p><em>xQueue</em></p>
<p>要从中接收项目的队列的句柄。</p>
</li>
<li><p><em>pvBuffer</em></p>
<p>指向要将所接收项目复制到缓冲区的指针。</p>
</li>
<li><p><em>xTicksToWait</em></p>
<p>如果在调用时队列为空， 则任务应阻塞等待项目接收的最长时间。</p>
<p>如果队列为空，将 xTicksToWait 设置为 0 将导致函数立即返回 。时间是以滴答周期为单位定义的，因此如果需要，应使用常量 portTICK_PERIOD_MS 转换为实时。如果 INCLUDE_vTaskSuspend 设置为 “1”， 则将阻塞时间指定为 portMAX_DELAY 会导致任务无限期地阻塞 （没有超时）。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果从队列中成功接收项目，则返回 pdTRUE；</li>
<li>否则返回 pdFALSE。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span> <span class="title">xRxedStructure</span>, *<span class="title">pxRxedPointer</span>;</span></span><br><span class="line"></span><br><span class="line">xStructQueue = xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xQueueReceive(xStructQueue, &amp;(xRxedStructure), (TickType_t)<span class="number">10</span>) == pdPASS) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>信号量</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<p>FreeRTOS 中的信号量是一种重要的同步机制，用于实现任务之间或任务与中断之间的<strong>通信</strong>和<strong>资源共享管理</strong>。信号量最初是为解决并发编程中<strong>互斥访问共享资源</strong>的问题而设计的，但在 FreeRTOS 中还可以用于任务间的同步。</p>
<p>FreeRTOS 提供了三种主要类型的信号量：</p>
<ol>
<li><strong>二值信号量（Binary Semaphore）</strong><ul>
<li>只有两个状态：空（0） 和 满（1）。</li>
<li>常用于<strong>任务间同步</strong>和<strong>中断与任务的同步</strong>。</li>
<li>在创建时，二值信号量可以通过 xSemaphoreCreateBinary() 或 xSemaphoreCreateBinaryStatic() 创建。</li>
</ul>
</li>
<li><strong>计数信号量（Counting Semaphore）</strong><ul>
<li>允许多个任务或中断访问资源，类似于一个计数器。</li>
<li>计数信号量的计数值可以大于 1，表示同一时间允许多个任务获取信号量。</li>
<li>常用于<strong>管理多个等价资源</strong>或<strong>实现事件计数</strong>。</li>
<li>在创建时，可以通过 xSemaphoreCreateCounting() 或 xSemaphoreCreateCountingStatic() 创建。</li>
</ul>
</li>
<li><strong>互斥量（Mutex）</strong><ul>
<li>专门用于保护共享资源，实现任务间的互斥访问。</li>
<li>互斥量具有<strong>优先级继承机制</strong>，用于防止<strong>优先级反转</strong>问题。</li>
<li>互斥量始终处于<strong>二值信号量的状态</strong>，但为互斥访问场景进行了特殊优化。</li>
<li>在创建时，可以通过 xSemaphoreCreateMutex() 或 xSemaphoreCreateMutexStatic() 创建。</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：在许多使用场景中，使用直达任务通知要比使用信号量的速度更快，内存效率更高。</p>
</blockquote>
<h2 id="二进制信号量"><a href="#二进制信号量" class="headerlink" title="二进制信号量"></a>二进制信号量</h2><p>二进制信号量用于互斥和同步目的。</p>
<p>二进制信号量和互斥锁极为相似，但存在一些细微差别：互斥锁包括优先继承机制， 而二进制信号量则不然。因此，<strong>二进制信号量是实现同步的更好选择</strong>（任务之间或任务与中断之间）， 而<strong>互斥锁是实现简单互斥的更好选择</strong>。</p>
<p>信号量相关函数允许指定阻塞时间。阻塞时间表示在尝试“获取”信号量时， 如果信号量不是立即可用， 任务应进入阻塞状态的最大“滴答”数。如果多个任务在同一信号量上阻塞， 则具有最高优先级的任务将成为下次信号量可用时解除阻塞的任务。</p>
<p>可将二进制信号量视为仅能容纳一个项目的队列。因此，队列只能为空或满 （因此称为二进制）。</p>
<p><strong>使用信号量同步任务与中断。中断仅“提供” 信号量，而任务仅“获取”信号量。</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/freertosbinSemaphore.gif" alt="freertosbinSemaphore"></p>
<p> xSemaphoreGiveFromISR 用于释放信号量</p>
<p>xSemaphoreTake 用于获取信号量的<em>宏</em>。</p>
<p><strong>信号量的“给出”和“获取”机制</strong>：</p>
<ul>
<li>二进制信号量的计数值最多只能为 1（表示信号量可用）。</li>
<li>当一个任务成功调用 xSemaphoreTake 时，信号量的计数值立即变为 <code>0</code>，表示信号量被“占用”。</li>
<li>在信号量变为 0 后，其他试图获取信号量的任务都会进入阻塞状态，直到信号量被重新“给出”并变为 1。</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="xSemaphoreCreateBinary"><a href="#xSemaphoreCreateBinary" class="headerlink" title="xSemaphoreCreateBinary"></a>xSemaphoreCreateBinary</h4><p>创建一个二进制信号量，并返回一个可以引用该信号量的句柄。</p>
<p>每个二进制信号量需要少量 RAM，用于保存信号量状态。如果 使用 xSemaphoreCreateBinary() 创建了二进制信号量，那么所需的 RAM 将自动从 FreeRTOS 堆中分配。如果二进制信号量 是使用 xSemaphoreCreateBinaryStatic() 创建的，则 RAM 由应用程序写入器提供，这需要一个附加参数，但允许 RAM 在编译时进行静态分配 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>信号量是在“空”状态下创建的，这意味着必须先用 xSemaphoreGive() API 函数给出信号量， 然后才能使用 xSemaphoreTake() 函数来获取（获得）该信号量。</p>
<p>二值信号量并不需要在得到后立即释放， 因此，任务同步可以通过一个任务&#x2F;中断持续释放信号量 而另外一个持续获得信号量来实现。</p>
<p>与互斥锁不同， 二进制信号量可用于中断服务程序。</p>
<p><strong>返回值：</strong></p>
<ul>
<li><p><em>NULL</em></p>
<p>因为可用 FreeRTOS 堆不足，所以无法创建信号量。</p>
</li>
<li><p><em>其他任何值</em></p>
<p>信号量已成功创建。返回值是一个句柄， 通过该句柄可以引用信号量。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphore = xSemaphoreCreateBinary();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xSemaphore == <span class="literal">NULL</span> )&#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xSemaphoreTake"><a href="#xSemaphoreTake" class="headerlink" title="xSemaphoreTake"></a>xSemaphoreTake</h4><p>用于获取信号量的。</p>
<p>不得从 ISR 调用此宏。如果需要，xQueueReceiveFromISR() 可用来从中断中获取一个信号量， 尽管这不是正常操作。信号量使用队列作为 其底层机制，因此函数在某种程度上可互操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphoreTake(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait);</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xSemaphore</p>
<p>正在获取的信号量的句柄——在创建信号量时获得。</p>
</li>
<li><p>xTicksToWait</p>
<p>等待信号量变为可用的时间（以滴答为单位）。</p>
<p>如果 INCLUDE_vTaskSuspend 设置为 1，则将阻塞时间指定为 portMAX_DELAY 会导致任务无限期地阻塞（没有超时限制）。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果获得信号量，则返回 <em>pdTRUE</em>。</li>
<li>如果 xTicksToWait 过期，信号量不可用，则返回 <em>pdFALSE</em>。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( xSemaphoreTake(xSemaphore, ( TickType_t )<span class="number">10</span>) == pdTRUE ) &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xSemaphoreGive"><a href="#xSemaphoreGive" class="headerlink" title="xSemaphoreGive"></a>xSemaphoreGive</h4><p>用于释放信号量的。释放前信号量必须已经创建</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xSemaphore</p>
<p>要释放的信号量的句柄。这是创建信号量时返回的句柄。 |</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果信号量被释放，则返回 <em>pdTRUE</em>。</li>
<li>如果发生错误，则返回 <em>pdFALSE</em>。信号量是使用队列实现的。发布消息时，如果队列上没有空间， 那么可能会发生错误，这表明最初未能正确获取信号量。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( xSemaphoreGive( xSemaphore ) != pdTRUE ) &#123;</span><br><span class="line">    <span class="comment">// 释放失败的处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xSemaphoreTake( xSemaphore, ( TickType_t ) <span class="number">0</span> ) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取信号量后就可以访问共享资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 操作玩抽释放信号量</span></span><br><span class="line">    <span class="keyword">if</span>( xSemaphoreGive( xSemaphore ) != pdTRUE ) &#123;</span><br><span class="line">        <span class="comment">// 释放失败的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xSemaphoreTakeFromISR"><a href="#xSemaphoreTakeFromISR" class="headerlink" title="xSemaphoreTakeFromISR"></a>xSemaphoreTakeFromISR</h4><p>可从 ISR 调用的 xSemaphoreTake() 版本。与 xSemaphoreTake() 不同，xSemaphoreTakeFromISR() 不允许指定阻塞时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphoreTakeFromISR(SemaphoreHandle_t xSemaphore, <span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken)</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xSemaphore</p>
<p>信号量被“获取”。信号量由 SemaphoreHandle_t 类型的变量引用， 必须在使用之前显式创建。</p>
</li>
<li><p>pxHigherPriorityTaskWoken</p>
<p>信号量由于其类型可能阻塞一个或多个任务，等待给出信号量。调用 xSemaphoreTakeFromISR() 会尝试获取信号量，如果成功获取信号量，则会唤醒一个正在等待该信号量的任务，使其离开阻塞状态。</p>
<p>如果调用函数导致任务离开阻塞状态， 且未阻塞任务的优先级等于或高于当前正在执行的任务（被中断的任务），那么 API 函数将从内部把 *pxHigherPriorityTaskWoken 设置为 pdTRUE。 </p>
<p>如果 xSemaphoreTakeFromISR() 将 pxHigherPriorityTaskWoken 设置为 pdTRUE，则应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务（返回优先级最高的任务，而不是被中断的任务） 。该机制与 xQueueReceiveFromISR() 函数中使用的机制相同， pxHigherPriorityTaskWoken 是一个可选参数，可设置为 NULL。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果成功获取信号量，则返回 pdTRUE。如果因为信号量不可用而未成功获取信号量， 则返回 pdFALSE。</p>
<h4 id="xSemaphoreGiveFromISR"><a href="#xSemaphoreGiveFromISR" class="headerlink" title="xSemaphoreGiveFromISR"></a>xSemaphoreGiveFromISR</h4><p>用于释放信号量的<em>宏</em>。释放前信号量必须已经 通过调用 xSemaphoreCreateBinary() 或 xSemaphoreCreateCounting() 创建。</p>
<p>互斥锁型信号量（那些调用 xSemaphoreCreateMutex() 创建的信号量） 不得与此宏一起使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore, <span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken)</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xSemaphore</p>
<p>要释放的信号量的句柄。这是创建信号量时返回的句柄。</p>
</li>
<li><p>pxHigherPriorityTaskWoken</p>
<p>如果给出信号量会导致任务解除阻塞，并且解除阻塞的任务的优先级高于当前正在运行的任务， 则 xSemaphoreGiveFromISR() 会将 *pxHigherPriorityTaskWoken 设置为 pdTRUE。 </p>
<p>如果 xSemaphoreGiveFromISR() 将此值设置为 pdTRUE，则应在退出中断之前请求上下文切换。</p>
<p> 从 FreeRTOS V7.3.0 开始，pxHigherPriorityTaskWoken 为可选参数， 可设置为 NULL。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果成功给出信号量，则返回 pdTRUE，否则 errQUEUE_FULL。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>开启两个任务，分别去等待信号。</p>
<p>开启按键扫描任务，当点击按键时，发送信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;semphr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskHandle_t            task_handler;</span><br><span class="line">TaskHandle_t            task_key_handler;</span><br><span class="line">TaskHandle_t            task1_handler;</span><br><span class="line">TaskHandle_t            task2_handler;</span><br><span class="line">SemaphoreHandle_t 			sema_handler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    BaseType_t result;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        result = xSemaphoreTake(sema_handler, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(result == pdTRUE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task1\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task1 Error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    BaseType_t result;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        result = xSemaphoreTake(sema_handler, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(result == pdTRUE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task2\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task2 Error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_key</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    FlagStatus pre_state = RESET;</span><br><span class="line">    BaseType_t result;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FlagStatus state = gpio_input_bit_get(GPIOA, GPIO_PIN_0);</span><br><span class="line">        <span class="keyword">if</span>(SET == state &amp;&amp; pre_state == RESET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,按下</span></span><br><span class="line">            pre_state = state;</span><br><span class="line"></span><br><span class="line">            result = xSemaphoreGive(sema_handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(RESET == state &amp;&amp; pre_state == SET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,抬起</span></span><br><span class="line">            pre_state = state;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart0_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 时钟初始化</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">    <span class="comment">// 配置GPIO模式</span></span><br><span class="line">    gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    GPIO_config();</span><br><span class="line">    Usart0_init();</span><br><span class="line"></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line">    xTaskCreate(task_key, <span class="string">&quot;task_key&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_key_handler);</span><br><span class="line">    xTaskCreate(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">3</span>, &amp;task1_handler);</span><br><span class="line">    xTaskCreate(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task2_handler);</span><br><span class="line">    vTaskDelete(task_handler);</span><br><span class="line"></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NVIC_SetPriorityGrouping(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line">    sema_handler = xSemaphoreCreateBinary();</span><br><span class="line">    xTaskCreate(start_task, <span class="string">&quot;start_task&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p>正如二进制信号量可以被认为是长度为 1 的队列那样， 计数信号量也可以被认为是长度大于 1 的队列。同样，信号量的使用者对存储在队列中的数据并不感兴趣， 他们只关心队列是否为空。</p>
<p>计数信号量通常用于两种情况：</p>
<ol>
<li><p>盘点事件。</p>
<p>在此使用场景中，事件处理程序将在每次事件发生时“提供”信号量（递增信号量计数值）， 而处理程序任务将在每次处理事件时“获取”信号量 （递减信号量计数值）。因此，计数值是已发生的事件数与已处理的事件数之间的差值。在这种情况下， 创建信号量时希望计数值为零。</p>
</li>
<li><p>资源管理。</p>
<p>在此使用情景中，计数值表示可用资源的数量。为了获得对资源的控制，任务必须首先获得信号量——递减信号量计数值。当计数值达到零时， 表示没有空闲资源可用。当任务结束使用资源时， 它会“返还”一个信号量——同时递增信号量计数值。在这种情况下， 创建信号量时希望计数值等于最大计数值。</p>
</li>
</ol>
<p><strong>计数信号量的“给出”和“获取”机制</strong></p>
<p><strong>给出机制：</strong></p>
<p>“给出”信号量表示资源或事件的增加，可以理解为将信号量的计数值递增。</p>
<ul>
<li><p>当调用 xSemaphoreGive() 或 xSemaphoreGiveFromISR() 时：</p>
<p>如果当前信号量的计数值小于最大允许值，则计数值增加 1。</p>
<p>如果计数值已达到最大值（通常在创建信号量时定义），进一步的“给出”操作不会改变计数值，函数返回 <code>pdFAIL</code>。</p>
<p>如果有任务正在等待此信号量且任务的优先级足够高，则调度器会将该任务从阻塞状态移到就绪状态。</p>
</li>
</ul>
<p><strong>获取机制：</strong></p>
<p>“获取”信号量表示使用资源或响应事件，可以理解为将信号量的计数值递减。</p>
<ul>
<li><p>当调用 xSemaphoreTake() 或 xSemaphoreTakeFromISR() 时：</p>
<p>如果当前信号量的计数值大于零，则计数值减少 1，函数返回 pdPASS。</p>
<p>如果计数值等于零：</p>
<ul>
<li>如果指定了阻塞时间（xTicksToWait），任务进入阻塞状态，等待计数值变为大于零。</li>
<li>如果阻塞时间为 0，函数立即返回 pdFAIL，表示获取失败。</li>
</ul>
</li>
</ul>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="xSemaphoreCreateCounting"><a href="#xSemaphoreCreateCounting" class="headerlink" title="xSemaphoreCreateCounting"></a>xSemaphoreCreateCounting</h4><p>创建一个计数信号量， 并返回一个可以引用该新建信号量的句柄。</p>
<p>configSUPPORT_DYNAMIC_ALLOCATION 必须在 FreeRTOSConfig.h 中设置为 1，或处于未定义状态（在这种情况下，默认为 1），该 RTOS API 函数 才可用。</p>
<p>每个计数信号量需要少量 RAM ，用于保存信号量的状态。如果使用 xSemaphoreCreateCounting() 创建计数信号量则所需的 RAM 将从 FreeRTOS 堆自动分配。 如果使用 xSemaphoreCreateCountingStatic() 创建计数信号量， 则 RAM会由应用程序编写器提供，这需要其他的 但允许在编译时静态分配 RAM 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>uxMaxCount</p>
<p>可以达到的最大计数值。当信号量达到此值时，它不能再被“给定”。</p>
</li>
<li><p>uxInitialCount</p>
<p>创建信号量时分配给信号量的计数值。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果已成功创建信号量，则将返回该信号量的句柄 。</li>
<li>如果因为保留信号量所需的 RAM 无法分配而无法创建信号量， 则会返回 NULL。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphore = xSemaphoreCreateCounting( <span class="number">10</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xSemaphore != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uxSemaphoreGetCount"><a href="#uxSemaphoreGetCount" class="headerlink" title="uxSemaphoreGetCount"></a>uxSemaphoreGetCount</h4><p>获取信号量的计数值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxSemaphoreGetCount</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xSemaphore</p>
<p>正在查询的信号量的句柄。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果信号量是计数信号量，则返回信号量的当前计数值 。如果信号量是二进制信号量， 则当信号量可用时，返回 1，当信号量不可用时， 返回 0。</p>
<h4 id="xSemaphoreTake-1"><a href="#xSemaphoreTake-1" class="headerlink" title="xSemaphoreTake"></a>xSemaphoreTake</h4><p>同上</p>
<h4 id="xSemaphoreGive-1"><a href="#xSemaphoreGive-1" class="headerlink" title="xSemaphoreGive"></a>xSemaphoreGive</h4><p>同上</p>
<h4 id="xSemaphoreTakeFromISR-1"><a href="#xSemaphoreTakeFromISR-1" class="headerlink" title="xSemaphoreTakeFromISR"></a>xSemaphoreTakeFromISR</h4><p>同上</p>
<h4 id="xSemaphoreGiveFromISR-1"><a href="#xSemaphoreGiveFromISR-1" class="headerlink" title="xSemaphoreGiveFromISR"></a>xSemaphoreGiveFromISR</h4><p>同上</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol>
<li>开启两个任务，等待信号，接收到信号后，处理耗时操作</li>
<li>开启按键扫描，点击按键时发送信号</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;semphr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskHandle_t            task_handler;</span><br><span class="line">TaskHandle_t            task_key_handler;</span><br><span class="line">TaskHandle_t            task1_handler;</span><br><span class="line">TaskHandle_t            task2_handler;</span><br><span class="line">SemaphoreHandle_t 		sema_handler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    BaseType_t result;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        result = xSemaphoreTake(sema_handler, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(result == pdTRUE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task1 %ld\n&quot;</span>, uxSemaphoreGetCount(sema_handler));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task1 Error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(<span class="number">2500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    BaseType_t result;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        result = xSemaphoreTake(sema_handler, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(result == pdTRUE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task2 %ld\n&quot;</span>, uxSemaphoreGetCount(sema_handler));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task2 Error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(<span class="number">2500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_key</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    FlagStatus pre_state = RESET;</span><br><span class="line">    BaseType_t result;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FlagStatus state = gpio_input_bit_get(GPIOA, GPIO_PIN_0);</span><br><span class="line">        <span class="keyword">if</span>(SET == state &amp;&amp; pre_state == RESET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,按下</span></span><br><span class="line">            pre_state = state;</span><br><span class="line">            result = xSemaphoreGive(sema_handler);</span><br><span class="line"><span class="comment">//			if(result == pdTRUE) &#123;</span></span><br><span class="line"><span class="comment">//				printf(&quot;semaphore give success\n&quot;);</span></span><br><span class="line"><span class="comment">//			&#125; else &#123;</span></span><br><span class="line"><span class="comment">//				printf(&quot;semaphore give error\n&quot;);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(RESET == state &amp;&amp; pre_state == SET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,抬起</span></span><br><span class="line">            pre_state = state;</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart0_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 时钟初始化</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">    <span class="comment">// 配置GPIO模式</span></span><br><span class="line">    gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    GPIO_config();</span><br><span class="line">    Usart0_init();</span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line">    xTaskCreate(task_key, <span class="string">&quot;task_key&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_key_handler);</span><br><span class="line">    xTaskCreate(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">3</span>, &amp;task1_handler);</span><br><span class="line">    xTaskCreate(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task2_handler);</span><br><span class="line">    vTaskDelete(task_handler);</span><br><span class="line"></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    NVIC_SetPriorityGrouping(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line"></span><br><span class="line">    sema_handler = xSemaphoreCreateCounting(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    xTaskCreate(start_task, <span class="string">&quot;start_task&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;task_handler);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是包含优先级继承机制的二进制信号量。鉴于二进制信号量是实现同步（任务之间或任务与中断之间） 的更好方式，因此互斥锁更适合实现简单的 相互排斥（即互斥）。</p>
<p>用于互斥时，互斥锁就像用于保护资源的令牌。当一个 任务希望访问资源时，必须首先获得（“获取”）该令牌。使用完资源后， 任务必须“返还”令牌，以便其他任务有机会访问 相同的资源。</p>
<p><strong>优先级继承机制</strong></p>
<p>互斥锁使用相同的信号量访问 API 函数，因此也能指定阻塞时间。该 阻塞时间表示一个任务试图“获取”互斥锁，而互斥锁无法立即使用时， 任务应进入阻塞状态的最大“滴答”数。然而，与二进制信号量不同， 互斥锁采用优先级继承机制。这意味着<strong>如果高优先级任务进入阻塞状态，同时尝试获取当前由低优先级任务持有的互斥锁（令牌）， 则持有令牌的任务的优先级会暂时提高到阻塞任务的优先级。</strong>这项机制 旨在确保较高优先级的任务保持阻塞状态的时间尽可能短， 从而最大限度减少已经发生的“优先级反转”现象。</p>
<blockquote>
<p>优先级继承无法解决优先级反转！只是在某些情况下将影响降至最低。应用程序的设计应从一开始就避免发生优先级反转。</p>
</blockquote>
<p><strong>不能从中断中使用互斥锁</strong></p>
<ul>
<li>互斥锁使用的优先级继承机制要求从任务中（而不是从中断中）拿走和放入互斥锁。</li>
<li>中断无法保持阻塞来等待一个被互斥锁保护的资源变为可用。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/mutexes.gif" alt="mutexes"></p>
<p><strong>互斥锁的“给出”和“获取”机制</strong></p>
<p>任务请求使用共享资源时，需要通过“获取”互斥锁来确保独占访问权。</p>
<ul>
<li><p>调用 xSemaphoreTake() 或 xSemaphoreTakeRecursive() 时：</p>
<p><strong>锁可用</strong>：如果互斥锁当前未被其他任务占用，则获取成功，并将锁的“拥有者”设置为当前任务，函数返回 pdPASS。</p>
<p><strong>锁不可用：</strong>如果互斥锁已被其他任务占用，则任务进入阻塞状态，直到：</p>
<ul>
<li>锁被释放。</li>
<li>超过了指定的阻塞时间（xTicksToWait）。</li>
</ul>
<p><strong>递归支持（Recursive Mutex）</strong>：如果当前任务已获取了互斥锁，递归获取是允许的，计数会递增（只适用于递归互斥锁）。</p>
</li>
</ul>
<p>当任务完成资源的使用后，必须通过“给出”互斥锁将其释放，允许其他任务继续使用。</p>
<ul>
<li><p>调用 <strong>xSemaphoreGive()</strong> 或 <strong>xSemaphoreGiveRecursive()</strong> 时：</p>
<p><strong>当前任务为锁的拥有者</strong>：互斥锁被释放，允许其他等待的任务获取锁。</p>
<p><strong>当前任务不是锁的拥有者</strong>：释放操作无效（仅在调试模式下可能触发断言错误）。</p>
<p><strong>递归支持（Recursive Mutex）</strong>：如果任务递归获取了多次互斥锁，则每次“给出”都会使计数递减，直到完全释放为止。</p>
</li>
</ul>
<h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><h4 id="xSemaphoreCreateMutex"><a href="#xSemaphoreCreateMutex" class="headerlink" title="xSemaphoreCreateMutex"></a>xSemaphoreCreateMutex</h4><p>创建互斥锁，并返回 一个该互斥锁可以引用的句柄。中断服务例程中， 不能使用互斥锁。</p>
<p>configSUPPORT_DYNAMIC_ALLOCATION 和 configUSE_MUTEXES 必须同时在 FreeRTOSConfig.h 中设置为 1，xSemaphoreCreateMutex() 才可用。（configSUPPORT_DYNAMIC_ALLOCATION 也可以不定义， 在这种情况下，它将默认为 1。）</p>
<p>每个互斥锁需要少量 RAM ， 以此来保持互斥锁的状态。如果互斥锁是使用 xSemaphoreCreateMutex() 创建的， 则所需的 RAM 将从 FreeRTOS 堆自动分配。 如果互斥锁是使用 xSemaphoreCreateMutexStatic() 创建的， 那么应由应用程序写入器提供 RAM， 但允许在编译时静态分配 RAM 。</p>
<p>使用 xSemaphoreTake() 获取互斥锁， 并使用 xSemaphoreGive() 给出互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure>

<p><strong>返回：</strong></p>
<ul>
<li>如果已成功创建互斥锁型信号量，则返回创建的互斥锁的句柄。</li>
<li>如果由于<a href="https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/09-Memory-management/01-Memory-management">无法分配</a>保存互斥锁所需的内存而未创建互斥锁，则返回 NULL。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xSemaphore != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xSemaphoreTake-2"><a href="#xSemaphoreTake-2" class="headerlink" title="xSemaphoreTake"></a>xSemaphoreTake</h4><p>同上</p>
<h4 id="xSemaphoreGive-2"><a href="#xSemaphoreGive-2" class="headerlink" title="xSemaphoreGive"></a>xSemaphoreGive</h4><p>同上</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>开启两个任务，同时等待和发送信号，观察任务调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;USART0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;semphr.h&quot;</span></span></span><br><span class="line"><span class="comment">/******</span></span><br><span class="line"><span class="comment">需求：创建3个任务</span></span><br><span class="line"><span class="comment">1. task1：等待Take信号</span></span><br><span class="line"><span class="comment">2. task2：每隔1秒执行一次任务</span></span><br><span class="line"><span class="comment">3. task3：等待Take信号</span></span><br><span class="line"><span class="comment">优先级逐个增加</span></span><br><span class="line"><span class="comment">------------------------------- 信号量</span></span><br><span class="line"><span class="comment">a. 创建互斥信号量</span></span><br><span class="line"><span class="comment">b. 默认发送了一个信号</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line">TaskHandle_t            xStartTask_Handler;</span><br><span class="line"><span class="comment">//TaskHandle_t            xTaskKey_Handler;</span></span><br><span class="line">TaskHandle_t            xTask1_Handler;</span><br><span class="line">TaskHandle_t            xTask2_Handler;</span><br><span class="line">TaskHandle_t            xTask3_Handler;</span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t xSemaphore = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART0_on_recv</span><span class="params">(<span class="type">uint8_t</span>* data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;recv[%d]: %s\n&quot;</span>, len, data);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同学：优先级低</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task_Low run!\n&quot;</span>);</span><br><span class="line">	<span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">// 无限阻塞在此函数，直到获取到信号</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_Low try take\n&quot;</span>);</span><br><span class="line">		xSemaphoreTake(xSemaphore, portMAX_DELAY);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_Low running!\n&quot;</span>);		</span><br><span class="line">		delay_1ms(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作	</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_Low give!\n&quot;</span>);</span><br><span class="line">		xSemaphoreGive(xSemaphore);</span><br><span class="line">		vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坏同学：优先级中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task_Middle run!\n&quot;</span>);</span><br><span class="line">	<span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_Middle! %d\n&quot;</span>, cnt++);</span><br><span class="line">		vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老师：优先级高</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task_High run!\n&quot;</span>);</span><br><span class="line">	<span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	BaseType_t xReturn; <span class="comment">// pdTRUE, pdFALSE</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">// 无限阻塞在此函数，直到获取到信号</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_High try take\n&quot;</span>);</span><br><span class="line">		xSemaphoreTake(xSemaphore, portMAX_DELAY);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_High running!\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		delay_1ms(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;task_High give!\n&quot;</span>);</span><br><span class="line">		xSemaphoreGive(xSemaphore);</span><br><span class="line">		vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// GPIO input PA0</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	<span class="comment">// input</span></span><br><span class="line">	gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_init</span><span class="params">()</span> &#123;</span><br><span class="line">	GPIO_config();</span><br><span class="line">	USART0_init();	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 在start任务中初始化所有外设</span></span><br><span class="line">	sys_init();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start!\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// FreeRTOS 创建互斥信号量, 默认会放一个信号</span></span><br><span class="line">	xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(xSemaphore != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;xSemaphore create successful!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 其他任务，进入临界区，等所有任务都创建完，再退出，一起运行</span></span><br><span class="line">  taskENTER_CRITICAL();</span><br><span class="line">	</span><br><span class="line">  xTaskCreate((TaskFunction_t)task1,              	<span class="comment">// 指向任务函数的指针</span></span><br><span class="line">              (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;task1&quot;</span>,            	<span class="comment">// 任务名称</span></span><br><span class="line">              <span class="number">64</span>,                                 	<span class="comment">// 任务栈大小</span></span><br><span class="line">              <span class="literal">NULL</span>,                               	<span class="comment">// 任务函数的参数</span></span><br><span class="line">              <span class="number">3</span>,                                  	<span class="comment">// 任务优先级, 数值越大，优先级越高</span></span><br><span class="line">              (TaskHandle_t*  )&amp;xTask1_Handler);  	<span class="comment">// 任务句柄</span></span><br><span class="line">							</span><br><span class="line">  xTaskCreate((TaskFunction_t)task2,              	<span class="comment">// 指向任务函数的指针</span></span><br><span class="line">              (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;task2&quot;</span>,            	<span class="comment">// 任务名称</span></span><br><span class="line">              <span class="number">64</span>,                                 	<span class="comment">// 任务栈大小</span></span><br><span class="line">              <span class="literal">NULL</span>,                               	<span class="comment">// 任务函数的参数</span></span><br><span class="line">              <span class="number">4</span>,                                  	<span class="comment">// 任务优先级, 数值越大，优先级越高</span></span><br><span class="line">              (TaskHandle_t*  )&amp;xTask2_Handler);  	<span class="comment">// 任务句柄</span></span><br><span class="line">								</span><br><span class="line">  xTaskCreate((TaskFunction_t)task3,              	<span class="comment">// 指向任务函数的指针</span></span><br><span class="line">              (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;task3&quot;</span>,            	<span class="comment">// 任务名称</span></span><br><span class="line">              <span class="number">64</span>,                                 	<span class="comment">// 任务栈大小</span></span><br><span class="line">              <span class="literal">NULL</span>,                               	<span class="comment">// 任务函数的参数</span></span><br><span class="line">              <span class="number">5</span>,                                  	<span class="comment">// 任务优先级, 数值越大，优先级越高</span></span><br><span class="line">              (TaskHandle_t*  )&amp;xTask3_Handler);  	<span class="comment">// 任务句柄						</span></span><br><span class="line">	<span class="comment">// Exti退出临界区</span></span><br><span class="line">  taskEXIT_CRITICAL();							</span><br><span class="line">	<span class="comment">// 3. 删除自己</span></span><br><span class="line">  vTaskDelete(xStartTask_Handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line">  systick_config();</span><br><span class="line">	<span class="comment">// 开始第一个任务</span></span><br><span class="line">  xTaskCreate((TaskFunction_t)start_task,            <span class="comment">// 任务的函数指针，函数名</span></span><br><span class="line">              (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;start_task&quot;</span>,          <span class="comment">// 任务名称，最大长度configMAX_TASK_NAME_LEN</span></span><br><span class="line">              (<span class="type">uint16_t</span>			 )<span class="number">128</span>,                   <span class="comment">// 任务栈大小，单位: 字Word / Half Word 128 x 4</span></span><br><span class="line">              (<span class="type">void</span>*		     )<span class="literal">NULL</span>,                  <span class="comment">// 任务函数的参数，通常用NULL</span></span><br><span class="line">              (UBaseType_t   )<span class="number">1</span>,                     <span class="comment">// 任务优先级，数值越大，优先级越高</span></span><br><span class="line">              (TaskHandle_t* )&amp;xStartTask_Handler);  <span class="comment">// 任务句柄				</span></span><br><span class="line">  <span class="comment">// 开启任务调度</span></span><br><span class="line">  vTaskStartScheduler();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归互斥锁"><a href="#递归互斥锁" class="headerlink" title="递归互斥锁"></a>递归互斥锁</h2><p>用户可对一把递归互斥锁重复加锁。只有用户为每成功的 xSemaphoreTakeRecursive() 请求调用 xSemaphoreGiveRecursive() 后，互斥锁才会重新变为可用。</p>
<p>例如，如果一个任务成功“加锁”相同的互斥锁 5 次， 那么任何其他任务都无法使用此互斥锁，直到任务也把这个互斥锁“解锁”5 次。</p>
<p>这种类型的信号量使用优先级继承机制，因此“加锁”一个信号量的任务必须在不需要此信号量时， 立即将信号量“解锁”。</p>
<p>不能从中断服务程序中使用类型是互斥锁的信号量。</p>
<p>不能从中断中使用互斥锁的原因是：</p>
<ul>
<li>互斥锁使用的优先级继承机制要求 从任务中（而不是从中断中）拿走和放入互斥锁。</li>
<li>中断无法保持阻塞来等待一个被互斥锁保护的资源 变得可用。</li>
</ul>
<p><strong>递归互斥锁的“给出”和“获取”机制</strong></p>
<p>递归互斥锁的基本思想是，每当一个任务成功获取锁时，锁的计数值会增加；当任务释放锁时，锁的计数值会减少。当计数值为零时，锁才会被真正释放，并允许其他任务获取该锁。</p>
<p>获取锁（Take）机制</p>
<ul>
<li>当一个任务首次请求获取递归互斥锁时，如果锁当前没有被占用，任务会立即获得锁，并将锁的计数器设为 1。</li>
<li>如果该任务再次请求获取该锁，它会成功获取锁（锁的计数器加 1），并继续执行嵌套的代码段。</li>
<li>锁的计数器会随着任务的每次获取递增，这样任务就可以在嵌套的调用中多次获取该锁，而不会发生死锁。</li>
</ul>
<p>释放锁（Give）机制</p>
<ul>
<li>当任务释放锁时，锁的计数器会减少。如果计数器的值大于 1，表示任务还有其他嵌套的调用持有锁，释放锁只是减少计数器的值，锁仍然被当前任务持有。</li>
<li>当任务释放锁时，如果计数器的值减至 0，表示当前任务已经没有</li>
</ul>
<h3 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h3><h4 id="xSemaphoreCreateRecursiveMutex"><a href="#xSemaphoreCreateRecursiveMutex" class="headerlink" title="xSemaphoreCreateRecursiveMutex"></a>xSemaphoreCreateRecursiveMutex</h4><p>创建一个递归互斥锁，并返回一个可以引用该互斥锁的句柄 。不能在中断服务程序中使用递归互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateRecursiveMutex</span><span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure>

<p>configSUPPORT_DYNAMIC_ALLOCATION 和 configUSE_RECURSIVE_MUTEXES 必须在 FreeRTOSConfig.h 中设置为 1，xSemaphoreCreateRecursiveMutex() 才可用（configSUPPORT_DYNAMIC_ALLOCATION 也可以不定义，这种情况下 默认为 1）。</p>
<p>每个递归互斥锁都需要少量 RAM，用于保存递归互斥锁的状态。 如果互斥锁是使用 xSemaphoreCreateRecursiveMutex() 创建的， 则所需的 RAM 将从 FreeRTOS 堆自动分配。 如果一个递归互斥锁是使用 xSemaphoreCreateRecursiveMutexStatic() 创建的， 那么RAM 由应用程序写入器提供，这需要用到一个附加参数， 但允许在编译时静态分配 RAM 。</p>
<p>递归互斥锁分别使用 xSemaphoreTakeRecursive() 和 xSemaphoreGiveRecursive() API 函数“获取”和“释放”。 不得使用 xSemaphoreTake() 和 xSemaphoreGive()。</p>
<p>xSemaphoreCreateMutex()和 xSemaphoreCreateMutexStatic()用于创建非递归互斥锁。非递归互斥锁只能被一个任务获取一次（在释放前），如果同一个任务想再次获取则会失败， 因为当任务第一次释放互斥锁时，互斥锁就一直处于释放状态。</p>
<p>与非递归互斥锁相反，递归互斥锁可以被同一个任务获取很多次， 获取多少次就需要释放多少次， 此时才会返回递归互斥锁。</p>
<p><strong>返回：</strong></p>
<p>如果已成功创建递归互斥锁，则返回创建的互斥锁的句柄。</p>
<p>如果由于无法分配保递归互斥锁所需的内存而未创建递归互斥锁，则返回 NULL。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xMutex = xSemaphoreCreateRecursiveMutex();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( xMutex != <span class="literal">NULL</span> )&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xSemaphoreTakeRecursive"><a href="#xSemaphoreTakeRecursive" class="headerlink" title="xSemaphoreTakeRecursive"></a>xSemaphoreTakeRecursive</h4><p>递归的“获取”一个互斥锁型信号量。 此互斥锁必须已经事先通过调用 xSemaphoreCreateRecursiveMutex() 完成创建；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphoreTakeRecursive(SemaphoreHandle_t xMutex, TickType_t xTicksToWait );</span><br></pre></td></tr></table></figure>

<p>必须在 FreeRTOSConfig.h 中将 configUSE_RECURSIVE_MUTEXES 设置为 1， 此宏才可用。</p>
<p>不得在使用 xSemaphoreCreateMutex() 创建的互斥锁上使用此宏。</p>
<p>所有者可以反复“获取”递归使用的互斥锁。在所有者 为每个成功的“获取”请求调用 xSemaphoreGiveRecursive() 之前，该互斥锁不会再次变得可用。例如， 如果一个任务成功地“获取”了同一个互斥锁 5 次， 那么任何其他任务都无法使用此互斥锁， 直到任务也把这个互斥锁“解锁”5 次。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xMutex</p>
<p>正在获得的互斥锁的句柄。这是由 xSemaphoreCreateRecursiveMutex() 返回的句柄。</p>
</li>
<li><p>xTicksToWait</p>
<p>等待信号量变为可用的时间（以滴答为单位）。可以使用 portTICK_PERIOD_MS 宏 将其转换为实际时间。可以用一个为零的阻塞时间来轮询信号量。如果 任务已有信号量，则无论 xTicksToWait 的值是多少， xSemaphoreTakeRecursive() 都将立即返回。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果获得信号量，则返回 pdTRUE；如果 xTicksToWait 过期，信号量不可用，则返回 pdFALSE。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) <span class="number">10</span> ) == pdTRUE ) &#123;</span><br><span class="line"></span><br><span class="line">    xSemaphoreTakeRecursive( xMutex, ( TickType_t ) <span class="number">10</span> );</span><br><span class="line">    xSemaphoreTakeRecursive( xMutex, ( TickType_t ) <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">    xSemaphoreGiveRecursive( xMutex );</span><br><span class="line">    xSemaphoreGiveRecursive( xMutex );</span><br><span class="line">    xSemaphoreGiveRecursive( xMutex );</span><br><span class="line">    <span class="comment">// 这时候其他任务可以获取这个锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xSemaphoreGiveRecursive"><a href="#xSemaphoreGiveRecursive" class="headerlink" title="xSemaphoreGiveRecursive"></a>xSemaphoreGiveRecursive</h4><p>递归地释放或“给出”一个互斥锁型信号量的<em>宏</em>。 此互斥锁必须已经事先通过调用 xSemaphoreCreateRecursiveMutex() 完成创建；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</span><br></pre></td></tr></table></figure>

<p>必须在 FreeRTOSConfig.h 中将 configUSE_RECURSIVE_MUTEXES 设置为 1， 此宏才可用。</p>
<p>不得在使用 xSemaphoreCreateMutex() 创建的互斥锁上使用此宏。</p>
<p>所有者可以反复“获取”递归互斥锁。在所有者为每个成功的“获取”请求调用 xSemaphoreGiveRecursive() 之前，该互斥锁不会再次变得可用。</p>
<p>例如， 如果一个任务成功地“获取”了同一个互斥锁 5 次， 那么任何其他任务都无法使用此互斥锁， 直到任务也把这个互斥锁“解锁”5 次。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xMutex</p>
<p>正在释放或“给出”的互斥锁的句柄。这是由 xSemaphoreCreateRecursiveMutex() 返回的句柄。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果成功给出信号量，则返回 pdTRUE。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;semphr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;USART0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskHandle_t            task_Handler;</span><br><span class="line">TaskHandle_t            task1_Handler;</span><br><span class="line">TaskHandle_t            task2_Handler;</span><br><span class="line">SemaphoreHandle_t 		sema_handler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">  BaseType_t result;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task1	take 0\n&quot;</span>);</span><br><span class="line">    xSemaphoreTakeRecursive(sema_handler, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task1	take 1\n&quot;</span>);</span><br><span class="line">    xSemaphoreTakeRecursive(sema_handler, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task1	give\n&quot;</span>);</span><br><span class="line">    xSemaphoreGiveRecursive(sema_handler);</span><br><span class="line">		</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task1	give\n&quot;</span>);</span><br><span class="line">    xSemaphoreGiveRecursive(sema_handler);</span><br><span class="line">    vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">  BaseType_t result;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task2	take 0\n&quot;</span>);</span><br><span class="line">    xSemaphoreTakeRecursive(sema_handler, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task2	take 1\n&quot;</span>);</span><br><span class="line">    xSemaphoreTakeRecursive(sema_handler, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task2	give\n&quot;</span>);</span><br><span class="line">    xSemaphoreGiveRecursive(sema_handler);</span><br><span class="line">		</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task2	give\n&quot;</span>);</span><br><span class="line">    xSemaphoreGiveRecursive(sema_handler);</span><br><span class="line"></span><br><span class="line">    vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 时钟初始化</span></span><br><span class="line">  rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">  <span class="comment">// 配置GPIO模式</span></span><br><span class="line">  gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">  GPIO_config();</span><br><span class="line">  USART0_init();</span><br><span class="line">	</span><br><span class="line">  sema_handler = xSemaphoreCreateRecursiveMutex();</span><br><span class="line">  <span class="keyword">if</span>(sema_handler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create error\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line">  xTaskCreate(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">3</span>, &amp;task1_Handler);</span><br><span class="line">  xTaskCreate(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task2_Handler);</span><br><span class="line">  vTaskDelete(task_Handler);</span><br><span class="line"></span><br><span class="line">  taskEXIT_CRITICAL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART0_on_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NVIC_SetPriorityGrouping(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line">  xTaskCreate(start_task, <span class="string">&quot;start_task&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;task_Handler);</span><br><span class="line">  vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h2><p>FreeRTOS 实现了基本的优先级继承机制，旨在优化 空间和执行周期。完全的优先级继承机制需要多得多的数据和处理器 周期来确定任何时刻的继承优先级，特别是在任务同时占用超过一个互斥锁时 。</p>
<p>请牢记优先级继承机制的这些特定行为：</p>
<ul>
<li>如果一个任务在占用一个互斥锁时没有先释放它已占用的互斥锁， 则可以进一步提升其继承优先级。</li>
<li>任务在释放其占有的所有互斥锁之前，一直保持最高继承优先级。 这与释放互斥锁的顺序无关。</li>
<li>如果多个互斥锁被占用，无论在任何一个被占用的互斥锁上等待的任务是否完成等待（超时）， 则任务将保持最高继承优先级 。</li>
</ul>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>直达任务通知</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E7%9B%B4%E8%BE%BE%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p>在 FreeRTOS 中，任务的调度是通过优先级来决定的，而<strong>直达任务</strong>（direct-to-task notification）是 FreeRTOS 提供的一种高效的任务间通信机制，它允许中断或其他任务直接向某个任务发送通知。这种通知与信号量、消息队列等其他任务间通信方式相比，具有更低的开销和更高的效率。</p>
<h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><p>每个 RTOS 任务都有一个任务通知数组（简称通知）。每个任务_都有“挂起”或“非挂起”的<strong>通知状态</strong>和一个 32 位的<strong>通知值</strong>。</p>
<p>常量 configTASK_NOTIFICATION_ARRAY_ENTRIES 设置任务通知数组中的索引数量。在 FreeRTOS V10.4.0 版本前，任务只有单条任务通知， 而无通知数组。</p>
<p>直达任务通知是直接发送到任务的事件，而不是通过中间对象 （如队列、事件组或信号量）间接发送至任务的事件。<strong>向任务发送“直达任务通知” 会将目标任务通知设为“挂起”状态。</strong>正如任务可以阻塞中间对象 （如等待信号量可用的信号量），任务也可以阻塞任务通知， 以等待通知状态变为“挂起”。</p>
<p>向任务发送“直达任务通知”也可以 使用下列任一方法更新目标通知的值（可选）：</p>
<ul>
<li>覆盖原值，无论接收任务是否读取被覆盖的值。</li>
<li>覆盖原值，但前提是接收任务已读取被覆盖的值。</li>
<li>在值中设置一个或多个位。</li>
<li>对值进行增量（添加 1）。</li>
</ul>
<p>调用 xTaskNotifyWait() &#x2F; xTaskNotifyWaitIndexed() 读取通知值会将该通知的状态清除为“非挂起”。此外，也可以通过调用xTaskNotifyStateClear()&#x2F;xTaskNotifyStateClearIndexed() 将通知状态明确设置为“未挂起”。</p>
<p><strong>注意：</strong>数组中的每条通知均独立运行 ——任务一次只能阻塞数组中的一个通知，并且不会被发送到任何其他数组索引的通知解除阻塞。</p>
<ul>
<li>在任务通知数组中，任务只能<strong>阻塞在某个特定通知值上</strong>，并且只会等待该通知索引的通知。</li>
<li>当任务处于阻塞状态时，<strong>其他通知索引的通知变化</strong>不会影响当前任务的阻塞状态，只有当前任务等待的通知发生变化，才会解除阻塞。</li>
</ul>
<p>默认情况下，RTOS 任务通知功能处于启用状态，并且可以 通过将 <a href="https://www.freertos.org/Documentation/02-Kernel/03-Supported-devices/02-Customization/#configuse_task_notifications">configUSE_TASK_NOTIFICATIONS</a> 在 <a href="https://www.freertos.org/Documentation/02-Kernel/03-Supported-devices/02-Customization">FreeRTOSConfig.h</a> 中设置为 0 从构建中排除（每个任务每个数组索引节省 8 个字节）。</p>
<p><strong>重要提示：</strong>FreeRTOS 流和消息缓冲区在数值索引为 0 时使用任务通知。 如需在调用流或消息缓冲区 API 函数时保持任务通知的状态， 请使用数组索引大于 0 的任务通知。</p>
<h2 id="性能优势和使用限制"><a href="#性能优势和使用限制" class="headerlink" title="性能优势和使用限制"></a>性能优势和使用限制</h2><p>任务通知具有高度灵活性，使得它们可以在必须要创建单独队列、二进制信号量、计数信号量或事件组的情况下进行使用。与通过诸如二进制信号量等中间对象来解除任务阻塞状态相比，通过直接通知解除 RTOS 任务阻塞状态的速度快 <strong>45%<strong>，</strong>使用的 RAM</strong> 也更少。不过这些性能优势也有一些意料之内的使用限制：</p>
<ol>
<li>RTOS 任务通知仅可在只有一个任务可以接收事件时使用。不过，这个条件在大多数真实世界情况下是满足的。比如，中断解除了一个任务的阻塞状态，该任务将处理由中断接收的数据。</li>
<li>仅可在使用 RTOS 任务通知代替队列的情况下：当某个接收任务可在阻塞状态下等待通知 （因而不花费任何 CPU 时间）时，发送任务不能 在阻塞状态下等待发送完成（在发送不能立刻完成的情况下）。</li>
</ol>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="xTaskNotifyGive"><a href="#xTaskNotifyGive" class="headerlink" title="xTaskNotifyGive"></a>xTaskNotifyGive</h3><p>每项任务都有一个“任务通知”数组，每条通知都包含一个状态和一个 32 位的值。直达任务通知是直接发送给任务的事件，可以解除接收任务的阻塞状态，还可以通过多种不同的方式更新接收任务的某个通知值。 </p>
<p>例如，任务通知数组可覆盖接收任务的某个通知值，或仅设置接收任务某个通知值中的一个或多个位。</p>
<p>xTaskNotifyGive() 宏可在 将任务通知用作速度更快的轻量级二进制或计数信号量的替代方案时使用。 </p>
<p><strong>FreeRTOS 信号量通过 xSemaphoreGive() API 函数释放，而 xTaskNotifyGive() 与其等效，使用接收 RTOS 任务的某个通知值代替信号量。</strong></p>
<blockquote>
<p>xSemaphoreGive() 主要用于释放一个信号量，可以解除另一个正在等待任务的阻塞</p>
<p>xTaskNotifyGive() 用于向某个任务发送一个通知，它是通过修改任务的 “通知值” 来通知目标任务某个事件的发生。</p>
</blockquote>
<p>xTaskNotifyGive() 与 xTaskNotifyGiveIndexed() 是等效宏，唯一区别在于 xTaskNotifyGiveIndexed() 可以操作数组中的任何任务通知，而 xTaskNotifyGive() 总是操作数组中索引为 0 的任务通知。</p>
<p>当任务通知值用作二进制或计数信号量的等效物时， 接收通知的任务应该使用 ulTaskNotifyTake() API 函数来等待通知， 而不是使用 xTaskNotifyWait() API 函数。</p>
<p><strong>注意：</strong>数组中的所有通知均独立操作，即一项任务在同一时间只能在数组中的一条通知上处于阻塞状态，并且不会被发送到其他数组索引的通知解除阻塞状态。</p>
<p>xTaskNotifyGive() 不能在中断服务程序中调用。 请使用 vTaskNotifyGiveFromISR() 代替。</p>
<p>必须在 FreeRTOSConfig.h 中将 configUSE_TASK_NOTIFICATIONS 设置为 1 （或保留为未定义状态），才可使用这些宏。常量 configTASK_NOTIFICATION_ARRAY_ENTRIES 决定了 每项任务的任务通知数组中的索引数。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xTaskToNotify</p>
<p>接收通知的 RTOS 任务的句柄，通知值会递增。可通过以下方法获取任务句柄： 使用 xTaskCreate() 创建任务，并通过 pxCreatedTask 参数获取句柄； 使用 xTaskCreateStatic() 创建任务，并存储返回值作为句柄； 调用 xTaskGetHandle()，通过任务名称获取句柄。当前正在执行的 RTOS 任务的句柄由 xTaskGetCurrentTaskHandle() API 函数返回。</p>
</li>
<li><p>uxIndexToNotify</p>
<p>目标任务的通知值数组中要向其发送通知的索引。 uxIndexToNotify 必须小于 configTASK_NOTIFICATION_ARRAY_ENTRIES。 xTaskNotifyGive() 没有此参数，并且总是将通知发送到索引 0。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>xTaskNotifyGiveIndexed() 是一个宏，调用 xTaskNotifyIndexed()， 并将 eAction 参数设置为 eIncrement，因此所有调用都返回 pdPASS。</p>
<h3 id="ulTaskNotifyTake"><a href="#ulTaskNotifyTake" class="headerlink" title="ulTaskNotifyTake"></a>ulTaskNotifyTake</h3><p>ulTaskNotifyTake() 是一个宏， 用于将任务通知作为一种速度更快、重量更轻的二进制或计数信号量替代品。</p>
<p>ulTaskNotifyTake() 是用来接收任务通知并在接收到通知时继续执行的。它通常用于替代信号量或消息队列的一种机制，特别适合任务间的简单同步。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)</span>;</span><br><span class="line">   </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTakeIndexed</span><span class="params">(UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, </span></span><br><span class="line"><span class="params">                                  TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>

<p>ulTaskNotifyTake() 和 ulTaskNotifyTakeIndexed() 是等效的宏 - 唯一的区别 是 ulTaskNotifyTakeIndexed() 可以在数组内的任何任务通知上运行， 而 ulTaskNotifyTake() 始终在数组索引 0 处的任务通知上运行。</p>
<p>当任务使用通知值作为二进制或计数信号量时，其他任务和中断应使用 xTaskNotifyGive() 宏或 xTaskNotify() 函数将数据发给任务，其中函数的 eAction 参数设置为 eIncrement （这两者是等效的）。</p>
<p><strong>ulTaskNotifyTake() 可以在退出时清除任务的通知值为 0，在这种情况下， 通知值起到二进制信号量的作用；或在退出时递减任务的通知值，在这种情况下， 通知值更像是计数信号量。</strong></p>
<p>RTOS 任务可以使用 ulTaskNotifyTake() [可选]进入阻塞状态以等待任务通知指。 任务处于“阻塞”状态时不会占用任何 CPU 时间。</p>
<p>当通知被挂起时，xTaskNotifyWait() 将返回，ulTaskNotifyTake() 将在任务的通知值不为零时返回，并在返回之前递减任务通知值 。</p>
<p>必须在 FreeRTOSConfig.h 中将 configUSE_TASK_NOTIFICATIONS 设置为 1（或 保留为未定义) ，这些宏才能可用。常量 configTASK_NOTIFICATION_ARRAY_ENTRIES 设置每个任务的任务通知数组中的索引数。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>uxIndexToWaitOn</p>
<p>调用任务的<strong>通知值数组中的索引</strong>， 调用任务将在该索引上等待非零通知。</p>
<p>uxIndexToWaitOn 必须小于 configTASK_NOTIFICATION_ARRAY_ENTRIES。</p>
<p>xTaskNotifyTake() 没有此参数，总是在索引 0 处等待通知。</p>
</li>
<li><p>xClearCountOnExit</p>
<p>如果收到 RTOS 任务通知，且 xClearCountOnExit 设置为 pdFALSE，那么 RTOS 任务的通知值将在 ulTaskNotifyTake() 退出前递减。这相当于 成功调用 xSemaphoreTake() 后，计数信号量的值被递减。</p>
<p>如果收到 RTOS 任务通知且 xClearCountOnExit 设置为 pdTRUE，则 RTOS 任务的通知值将在 ulTaskNotifyTake() 退出前重置为 0。这等同于 在成功调用 xSemaphoreTake() 后，将二进制信号量的值保留为 0（或空，或“不可用”）。</p>
</li>
<li><p>xTicksToWait</p>
<p>表示如果调用 ulTaskNotifyTake() 时尚未收到通知，在阻塞状态下等待收到通知的最长时间。</p>
<p>处于阻塞状态的 RTOS 任务不会消耗任何 CPU 时间。时间以 RTOS 滴答周期为单位。pdMS_TO_TICKS() 宏可用于 将以毫秒为单位的时间转换为以滴答为单位的时间。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>被递减或清楚之前的任务通知值的值 （请参阅 xClearCountOnExit 的说明）。</li>
</ul>
<h3 id="xTaskNotify"><a href="#xTaskNotify" class="headerlink" title="xTaskNotify"></a>xTaskNotify</h3><p>xTaskNotify() 用于直接向 RTOS 任务发送事件，并且可能解除该任务的阻塞状态，同时还可以按照以下任一方式更新接收任务的某个通知值：</p>
<ul>
<li>将一个 32 位数字写入通知值</li>
<li>将通知值加一（递增）</li>
<li>设置通知值中的一个或多个位</li>
<li>保持通知值不变</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(TaskHandle_t xTaskToNotify, <span class="type">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyIndexed</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                               UBaseType_t uxIndexToNotify,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                               eNotifyAction eAction)</span>;</span><br></pre></td></tr></table></figure>

<p>xTaskNotify() 和 xTaskNotifyIndexed() 是等效函数，唯一区别在于 xTaskNotifyIndexed() 可以操作数组中的任何任务通知，而 xTaskNotify() 总是操作 数组中索引为 0 的任务通知。</p>
<p>不得从中断服务程序 (ISR) 调用此函数。 请使用 xTaskNotifyFromISR() 代替。</p>
<p>必须在 FreeRTOSConfig.h 中将 configUSE_TASK_NOTIFICATIONS 设置为 1 （或保留为未定义状态），才可使用这些函数。常量 configTASK_NOTIFICATION_ARRAY_ENTRIES 决定了 每项任务的任务通知数组中的索引数。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p>xTaskToNotify</p>
<p>接收通知的 RTOS 任务（即目标任务）的句柄。可通过以下方法获取任务句柄： 使用 <a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/01-Task-creation/01-xTaskCreate">xTaskCreate()</a> 创建任务，并通过 pxCreatedTask 参数获取句柄； 使用 <a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/01-Task-creation/02-xTaskCreateStatic">xTaskCreateStatic()</a> 创建任务，并存储返回值作为句柄； 调用 <a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/03-Task-utilities/00-Task-utilities/#xtaskgethandle">xTaskGetHandle()</a>，通过任务名称获取句柄。当前正在执行的 RTOS 任务的句柄 由 <a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/03-Task-utilities/00-Task-utilities/#xtaskgetcurrenttaskhandle">xTaskGetCurrentTaskHandle()</a> API 函数返回。</p>
</li>
<li><p>uxIndexToNotify</p>
<p>目标任务的通知值数组中要向其发送通知的索引。uxIndexToNotify 必须小于 configTASK_NOTIFICATION_ARRAY_ENTRIES。xTaskNotify() 没有此参数， 并且总是将通知发送到索引 0。</p>
</li>
<li><p>ulValue</p>
<p>用于更新目标任务的通知值。请参阅下文 eAction 参数的说明。</p>
</li>
<li><p>eAction</p>
<p>一种枚举类型，可以取下列任一值，以执行相关操作。</p>
<ul>
<li><p>eNoAction</p>
<p>目标任务接收事件，但其通知值不会更新。在这种情况下， 不会使用 ulValue。</p>
</li>
<li><p>eSetBits</p>
<p>目标任务的通知值将与 ulValue 进行按位“或”操作。例如，如果 ulValue 设置为 0x01，则目标任务通知值中的第 0 位将被设置。同样，如果 ulValue 设置为 0x04，则目标任务通知值中的第 2 位将被设置。通过这种方式，RTOS 任务 通知机制可以作为 事件组的轻量级替代方案。</p>
</li>
<li><p>eIncrement</p>
<p>目标任务的通知值将增加 1，这样调用 xTaskNotify() 相当于调用 xTaskNotifyGive()。在这种情况下，不会使用 ulValue。</p>
</li>
<li><p>eSetValueWithOverwrite</p>
<p>目标任务的通知值无条件设置为 ulValue。通过这种方式，RTOS 任务 通知机制可以作为 xQueueOverwrite() 的轻量级替代方案。</p>
</li>
<li><p>eSetValueWithoutOrwrite</p>
<p>如果目标任务当前没有挂起的通知，则其通知值将设置为 ulValue。</p>
<p>如果目标任务已有挂起的通知，则其通知值不会更新， 以免之前的值在使用前被覆盖。在这种情况下，调用 xTaskNotify() 会失败， 返回 pdFALSE。</p>
<p>通过这种方式，RTOS 任务通知机制可以 在长度为 1 的队列上作为 xQueueSend() 的轻量级替代方案。</p>
</li>
</ul>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>除了 eAction 设置为 eSetValueWithoutOverwrite 且目标任务的通知值无法更新（因为目标任务已有挂起的通知）时， 其他情况下均返回 pdPASS。</p>
<h3 id="xTaskNotifyAndQuery"><a href="#xTaskNotifyAndQuery" class="headerlink" title="xTaskNotifyAndQuery"></a>xTaskNotifyAndQuery</h3><p>xTaskNotifyAndQueryIndexed() 执行的操作与 xTaskNotifyIndexed() 相同， 另外还可通过额外的 pulPreviousNotifyValue 参数返回目标任务之前的通知值 （函数被调用时的通知值，而不是函数返回时的通知值） 。</p>
<p>xTaskNotifyAndQuery() 执行的操作与 xTaskNotify() 相同， 另外还可通过额外的 pulPreviousNotifyValue 参数返回目标任务之前的通知值 （函数被调用时的通知值，而不是函数返回时的通知值） 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQuery</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                                eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> *pulPreviousNotifyValue)</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryIndexed</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                       UBaseType_t uxIndexToNotify,</span></span><br><span class="line"><span class="params">                                       <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                                       eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                       <span class="type">uint32_t</span> *pulPreviousNotifyValue)</span>;</span><br></pre></td></tr></table></figure>

<p>不得从中断服务程序 (ISR) 调用此函数。 请使用 xTaskNotifyAndQueryFromISR() 代替。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p><em>xTaskToNotify</em></p>
<p>接收通知的 RTOS 任务（即<em>目标</em>任务）的句柄。可通过以下方法获取任务句柄： </p>
<ul>
<li>使用 xTaskCreate() 创建任务，并通过 pxCreatedTask 参数获取句柄； </li>
<li>使用 xTaskCreateStatic() 创建任务，并存储返回值作为句柄； </li>
<li>调用 xTaskGetHandle()，并通过任务名称获取句柄。</li>
<li>当前正在执行的 RTOS 任务的句柄由 xTaskGetCurrentTaskHandle() API 函数返回。</li>
</ul>
</li>
<li><p>uxIndexToNotify</p>
<p>目标任务的通知值数组中要向其发送通知的索引。uxIndexToNotify 必须小于 configTASK_NOTIFICATION_ARRAY_ENTRIES。</p>
</li>
<li><p>ulValue 用于更新目标任务的通知值。请参阅下文 eAction 参数的说明。</p>
</li>
<li><p>eAction</p>
<p>一种枚举类型，可以取下列任一值，以执行相关操作。</p>
</li>
<li><p><em>pulPreviousNotifyValue</em></p>
<p>可用于在 xTaskNotifyAndQuery() 修改任何位之前传出目标任务的通知值。 pulPreviousNotifyValue 是可选参数，如果不需要，可设置为 NULL。如果不使用 pulPreviousNotifyValue， 可以考虑使用 xTaskNotify() 替代 xTaskNotifyAndQuery()。</p>
</li>
</ul>
<p><strong>eAction 值和相关操作</strong></p>
<ul>
<li><p>eNoAction</p>
<p>目标任务接收事件，但其通知值不会更新。在这种情况下， 不会使用 ulValue。</p>
</li>
<li><p>eSetBits</p>
<p>目标任务的通知值将与 ulValue 进行按位“或”操作。例如，如果 ulValue 设置为 0x01，则目标任务通知值中的第 0 位将被设置。同样，如果 ulValue 设置为 0x04，则目标任务通知值中的第 2 位将被设置。通过这种方式，RTOS 任务 通知机制可以作为事件组的轻量级替代方案。</p>
</li>
<li><p>eIncrement</p>
<p>目标任务的通知值将增加 1，这样调用 xTaskNotify() 相当于调用 xTaskNotifyGive()。在这种情况下，不会使用 ulValue。</p>
</li>
<li><p>eSetValueWithOverwrite</p>
<p>目标任务的通知值无条件设置为 ulValue。通过这种方式，RTOS 任务 通知机制可以作为 xQueueOverwrite() 的轻量级替代方案。</p>
</li>
<li><p>eSetValueWithoutOrwrite</p>
<p>如果目标任务当前没有挂起的通知，则其通知值 将设置为 ulValue。如果目标任务已有挂起的通知，则其通知值 不会更新，以免之前的值在使用前被覆盖。在这种情况下, 调用 xTaskNotify() 会失败，返回 pdFALSE。通过这种方式，RTOS 任务通知机制可以 在长度为 1 的队列上作为 xQueueSend() 的轻量级替代方案。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>除了 eAction 设置为 eSetValueWithoutOverwrite 且目标任务的通知值无法更新（因为目标任务已有挂起的通知）时， 其他情况下 均返回 pdPASS。</p>
<h3 id="xTaskNotifyWait"><a href="#xTaskNotifyWait" class="headerlink" title="xTaskNotifyWait"></a>xTaskNotifyWait</h3><p>xTaskNotifyWait() 用于使调用任务等待接收通知，可以为其设置一个可选的超时时间。如果接收 RTOS 任务在等待通知时已经处于阻塞状态，则在等待的通知到达时， 接收 RTOS 任务将解除阻塞状态，通知也将清除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(<span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWaitIndexed</span><span class="params">(UBaseType_t uxIndexToWaitOn,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                                   TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>数组中的所有通知均独立操作，即一项任务在同一时间只能在数组中的一条通知上处于阻塞状态， 并且不会被发送到其他数组索引的通知解除阻塞状态。</p>
<p>xTaskNotifyWait() 和 xTaskNotifyWaitIndexed() 是等效宏，唯一区别在于 xTaskNotifyWaitIndexed() 可以操作数组中的任何任务通知， 而 xTaskNotifyWait() 总是操作数组中索引为 0 的任务通知。</p>
<p>xTaskNotifyGive() 不能在中断服务程序中调用。 请使用 vTaskNotifyGiveFromISR() 代替。</p>
<p>必须在 FreeRTOSConfig.h 中将 configUSE_TASK_NOTIFICATIONS 设置为 1 （或保留为未定义状态），才可使用这些宏。常量 configTASK_NOTIFICATION_ARRAY_ENTRIES 决定了每项任务的任务通知数组中的索引数。</p>
<p><strong>参数：</strong></p>
<ul>
<li><p><em>uxIndexToWaitOn</em></p>
<p>调用任务的通知值数组中用于等待接收通知的索引。 uxIndexToWaitOn 必须小于 configTASK_NOTIFICATION_ARRAY_ENTRIES。xTaskNotifyWait() 没有此参数， 总是在索引 0 的位置等待通知。</p>
</li>
<li><p><em>ulBitsToClearOnEntry</em></p>
<p>调用 xTaskNotifyWait() 时，如果通知已挂起，则在进入 xTaskNotifyWait() 函数（即任务等待新通知之前）时，ulBitsToClearOnEntry 中设置的任何位都会在调用 RTOS 任务的通知值中 被清除 。例如，如果 ulBitsToClearOnEntry 设为 0x01， 则任务通知值中的第 0 位将在进入函数时被清除。 如果 ulBitsToClearOnEntry 设为 0xffffffff (ULONG_MAX) 则将清除任务通知值中的所有位，相当于将值清零。</p>
</li>
<li><p><em>ulBitsToClearOnExit</em></p>
<p>如果在调用 xTaskNotifyWait() 函数时收到了通知，则在 xTaskNotifyWait() 函数退出之前，ulBitsToClearOnExit 中设置的任何位都会在调用 RTOS 任务的通知值中 被清除。RTOS 任务的通知值保存到 *pulNotificationValue（见下文对 pulNotificationValue 的介绍）之后， 这些位即被清除。例如，如果 ulBitsToClearOnExit 设为 0x03， 则在函数退出之前，任务通知值中的第 0 位和第 1 位将被清除。如果 ulBitsToClearOnExit 设为 0xffffffff（ULONG_MAX），则将清除任务通知值中的所有位， 相当于将值清零。</p>
</li>
<li><p><em>pulNotificationValue</em></p>
<p>用于传出 RTOS 任务的通知值。复制到 *pulNotificationValue 的值是 RTOS 任务的通知值，该值是在应用 ulBitsToClearOnExit 设置清除任何位 之前的值。如果无需通知值，可以将 pulNotificationValue 设置为 NULL。</p>
</li>
<li><p><em>xTicksToWait</em></p>
<p>调用 xTaskNotifyWait() 时没有挂起通知的情况下， 在阻塞状态下等待接收通知的最长时间。RTOS 任务在阻塞状态下 不会消耗 CPU 时间。时间以 RTOS 滴答周期为单位。可以使用 pdMS_TO_TICKS() 宏 将以毫秒为单位的时间转换为以滴答为单位的时间。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果收到了通知，或者在调用 xTaskNotifyWait() 时通知已挂起， 则返回 pdTRUE。</p>
<p>如果调用 xTaskNotifyWait() 超时且在超时前没有收到通知， 则返回 pdFALSE。</p>
<h3 id="xTaskNotifyStateClear"><a href="#xTaskNotifyStateClear" class="headerlink" title="xTaskNotifyStateClear"></a>xTaskNotifyStateClear</h3><h3 id="ulTaskNotifyValueClear"><a href="#ulTaskNotifyValueClear" class="headerlink" title="ulTaskNotifyValueClear"></a>ulTaskNotifyValueClear</h3><h2 id="作为二进制信号量"><a href="#作为二进制信号量" class="headerlink" title="作为二进制信号量"></a>作为二进制信号量</h2><p>与通过二进制信号量解除任务阻塞状态不同，通过直接通知解除 RTOS 任务阻塞状态的速度<strong>提高 45%<strong>， 而且</strong>使用的 RAM 减少</strong>。</p>
<p>二进制信号量是一种最大计数为 1 的信号量，因此称为“二进制”。 只有在信号量可用的情况下，任务才能“获取”信号量， 而只有在其计数为 1 的情况下，信号量才可用。</p>
<p>当使用任务通知代替二进制信号量时，接收任务的通知值（32位）会用于替代二进制信号量的计数值， 而且 ulTaskNotifyTake()（或 ulTaskNotifyTakeIndexed()）API 函数 会用于代替信号量的 xSemaphoreTake() API 函数。ulTaskNotifyTake() 函数的 xClearOnExit 参数设置为 pdTRUE，这样每次获取通知时计数值均归零 ——模拟二进制信号量。</p>
<p>同样，xTaskNotifyGive()（或 xTaskNotifyGiveIndexed()） 或者 vTaskNotifyGiveFromISR()（或 vTaskNotifyGiveIndexedFromISR()）函数用于代替信号量的 xSemaphoreGive() 和 xSemaphoreGiveFromISR() 函数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RTOS任务调用传输函数，然后在阻塞状态下等待（因此不使用CPU时间），直到收到传输完成的通知。</span></span><br><span class="line"><span class="comment">// 传输由DMA执行，DMA结束中断用于通知任务。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储传输完成时将通知的任务句柄</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t xTaskToNotify = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标任务的任务通知数组中要使用的索引</span></span><br><span class="line"><span class="type">const</span> UBaseType_t xArrayIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外围驱动器的传输功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTransmission</span><span class="params">( <span class="type">uint8_t</span> *pcData, <span class="type">size_t</span> xDataLength )</span> &#123;    </span><br><span class="line">    <span class="comment">// 此时xTaskToNotify应为NULL，因为没有正在进行的传输。</span></span><br><span class="line">	<span class="comment">// 如有必要，可以使用互斥体来保护对外围设备的访问。</span></span><br><span class="line">    configASSERT( xTaskToNotify == <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">// 存储调用任务的句柄。当前正在执行的 RTOS 任务的句柄</span></span><br><span class="line">    xTaskToNotify = xTaskGetCurrentTaskHandle();</span><br><span class="line">    <span class="comment">// 启动传输-传输完成时会产生中断。</span></span><br><span class="line">    vStartTransmit( pcData, xDatalength );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输完成时的中断。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTransmitEndISR</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时，xTaskToNotify不应为NULL，因为传输正在进行中。</span></span><br><span class="line">    configASSERT( xTaskToNotify != <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知任务传输已完成。</span></span><br><span class="line">    vTaskNotifyGiveIndexedFromISR( xTaskToNotify,</span><br><span class="line">                                   xArrayIndex,</span><br><span class="line">                                   &amp;xHigherPriorityTaskWoken );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有正在进行的传输，因此没有要通知的任务。</span></span><br><span class="line">    xTaskToNotify = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果xHigherPriorityTaskWoken现在设置为pdTRUE，则应执行切换以确保中断直接返回到最高优先级的任务。</span></span><br><span class="line">	<span class="comment">// 用于此目的的宏取决于使用的端口，可能是调用portEND_SWITCHING_IRS（）。</span></span><br><span class="line">    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动传输的任务随后进入阻塞状态（因此不消耗任何CPU时间）等待其完成。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vAFunctionCalledFromATask</span><span class="params">(<span class="type">uint8_t</span> ucDataToTransmit, <span class="type">size_t</span> xDataLength)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> ulNotificationValue;</span><br><span class="line">	<span class="type">const</span> TickType_t xMaxBlockTime = pdMS_TO_TICKS(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用上述函数启动传输</span></span><br><span class="line">    StartTransmission( ucDataToTransmit, xDataLength );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待传输完成的通知。</span></span><br><span class="line">	<span class="comment">// 请注意，第一个参数是pdTRUE，它的作用是将任务的通知值清除回0，</span></span><br><span class="line">    <span class="comment">// 使通知值表现得像二进制（而不是计数）信号量</span></span><br><span class="line">    ulNotificationValue = ulTaskNotifyTakeIndexed( xArrayIndex, pdTRUE, xMaxBlockTime );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ulNotificationValue == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 传输按预期结束</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        对ulTaskNotifyTake() 的调用超时。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作为计数信号量"><a href="#作为计数信号量" class="headerlink" title="作为计数信号量"></a>作为计数信号量</h2><h2 id="作为事件组"><a href="#作为事件组" class="headerlink" title="作为事件组"></a>作为事件组</h2><h2 id="作为邮箱"><a href="#作为邮箱" class="headerlink" title="作为邮箱"></a>作为邮箱</h2><h2 id="任务间通信"><a href="#任务间通信" class="headerlink" title="任务间通信"></a>任务间通信</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/freertosrwzdyxj.png" alt="freertosrwzdyxj"></p>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>中断管理</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>中断是一种由硬件或软件触发的机制，用于打断当前程序的执行流程，转而去处理更高优先级的任务。</p>
<h2 id="中断执行流程"><a href="#中断执行流程" class="headerlink" title="中断执行流程"></a>中断执行流程</h2><p>以下是一个典型的中断处理流程，通常以硬件中断为例：</p>
<ol>
<li><strong>触发中断</strong></li>
</ol>
<ul>
<li>硬件设备产生中断信号，通知处理器有事件需要处理。</li>
<li>处理器检测到中断信号后，当前程序暂停，进入中断响应阶段。</li>
</ul>
<ol start="2">
<li><strong>中断优先级判断</strong></li>
</ol>
<ul>
<li>如果有多个中断信号，处理器根据中断优先级选择需要响应的中断。</li>
<li>如果当前有更高优先级的任务正在运行，则可能推迟低优先级中断的响应。</li>
</ul>
<ol start="3">
<li><strong>保存上下文</strong></li>
</ol>
<ul>
<li>处理器保存当前的执行上下文（包括程序计数器 PC、通用寄存器、状态寄存器等），以便中断处理完成后可以恢复。</li>
<li>在某些处理器中，这由硬件自动完成，或者需要软件显式完成。</li>
</ul>
<ol start="4">
<li><strong>跳转到中断向量表</strong></li>
</ol>
<ul>
<li>处理器根据中断号查找中断向量表（Interrupt Vector Table, IVT），获取对应中断服务例程（ISR）的入口地址。</li>
<li>中断向量表是一个存储各中断服务例程地址的数组。</li>
</ul>
<ol start="5">
<li><strong>执行中断服务例程（ISR）</strong></li>
</ol>
<ul>
<li>处理器跳转到中断服务例程的入口地址，执行中断处理代码。</li>
<li>中断服务例程是用户定义的程序，用于处理特定的中断事件。</li>
</ul>
<ol start="6">
<li><strong>中断结束与恢复</strong></li>
</ol>
<ul>
<li>中断服务例程执行完成后，调用 <code>IRET</code>（中断返回）或类似指令，恢复保存的上下文。</li>
<li>处理器返回到被中断的程序，继续执行。</li>
</ul>
<h2 id="ARM-中的中断优先级"><a href="#ARM-中的中断优先级" class="headerlink" title="ARM 中的中断优先级"></a>ARM 中的中断优先级</h2><p>ARM Cortex-M 架构自身允许最多 256 个不同的优先级（最多有 8 个 优先级位，因此从 0 到 0xff 的优先级都是可能的），但绝大多数使用 ARM Cortex-M 核心的微控制器仅允许使用其中一部分；</p>
<p>ARM Cortex-M4F 使用 4（低四位） 位优先级寄存器来配置中断的优先等级，共分为两个部分：抢占优先级和子优先级。分配给每个部分的位数是可配置的。抢占优先级定义了一个中断是否可以抢占另一个正在执行的中断。当两个抢占优先级相同的中断同时发生时，子优先级决定首先执行哪个中断。</p>
<p>在 ARM Cortex-M 核心中，优先级的数值越小， 则中断的逻辑优先级越高。</p>
<table>
<thead>
<tr>
<th align="center">分组</th>
<th align="center">抢占优先级</th>
<th align="center">响应优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分组0</td>
<td align="center">0（可取值为0）</td>
<td align="center">4（可取值为0到15）</td>
</tr>
<tr>
<td align="center">分组1</td>
<td align="center">1（可取值为0到1）</td>
<td align="center">3（可取值为0到7）</td>
</tr>
<tr>
<td align="center">分组2</td>
<td align="center">2（可取值为0到3）</td>
<td align="center">2（可取值为0到3）</td>
</tr>
<tr>
<td align="center">分组3</td>
<td align="center">3（可取值为0到7）</td>
<td align="center">1（可取值为0到1）</td>
</tr>
<tr>
<td align="center">分组4</td>
<td align="center">4（可取值为0到15）</td>
<td align="center">0（可取值为0）</td>
</tr>
</tbody></table>
<blockquote>
<p>在使用 FreeRTOS 时，建议将所有优先级位都指定为抢占优先级位， 不保留任何优先级位作为子优先级位。</p>
<p>任何其他配置都会使 configMAX_SYSCALL_interrupt_PRIORITY 设置与分配给各个外设中断之间的直接关系复杂化。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nvic_priority_group_set(NVIC_PRIGROUP_PRE4_SUB0);</span><br></pre></td></tr></table></figure>

<h2 id="FreeRTOS-中的中断优先级"><a href="#FreeRTOS-中的中断优先级" class="headerlink" title="FreeRTOS 中的中断优先级"></a>FreeRTOS 中的中断优先级</h2><p>FreeRTOS 的中断嵌套方案将可用的中断优先级分为两组：一组将被 RTOS 临界区屏蔽，另一组 永远不会被 RTOS 临界区屏蔽，因此始终处于启用状态。两个组之间的边界由 FreeRTOSConfig.h 中的 configMAX_SYSCALL_INTERRUPT_PRIORITY 设置定义。此设置的最佳值将取决于微控制器中实现的优先级位数量。</p>
<blockquote>
<p>临界区是指一段代码，它在执行过程中需要独占访问某些共享资源（如全局变量、外设寄存器等），以防止并发访问导致的数据不一致问题。中断中的临界区通过禁用某些中断来实现，这样可以保证这段代码不被中断打断，从而避免资源访问冲突。</p>
</blockquote>
<p>简单来说 FreeRTOS 中的中断分为以下两类：</p>
<ol>
<li><strong>非 FreeRTOS 管理的中断</strong>（中断优先级高于 configMAX_SYSCALL_INTERRUPT_PRIORITY）：<ul>
<li>这些中断<strong>不能调用 FreeRTOS 提供的 API 函数</strong>。</li>
<li>适用于对实时性要求非常高的事件。</li>
<li>它们的优先级设置必须高于 configMAX_SYSCALL_INTERRUPT_PRIORITY（即优先级数值小于）。</li>
</ul>
</li>
<li><strong>FreeRTOS 管理的中断</strong>（中断优先级低于等于 configMAX_SYSCALL_INTERRUPT_PRIORITY）：<ul>
<li><strong>可以调用 FreeRTOS 提供的中断安全 API</strong>。</li>
<li>中断优先级必须低于或等于 configMAX_SYSCALL_INTERRUPT_PRIORITY（即优先级数值大于或等于），否则可能导致系统行为异常。</li>
</ul>
</li>
</ol>
<p><strong>数值优先级与逻辑优先级设置之间的反转关系</strong></p>
<p>在 ARM Cortex-M 核心中，优先级的<strong>数值越小</strong>， 则中断的<strong>逻辑优先级越高</strong></p>
<p>在 FreeRTOS 中以 “FromISR” 结尾的 FreeRTOS 函数是中断安全的，但前提是调用这些函数的中断的<strong>逻辑优先级</strong>不高于 configMAX_SYSCALL_INTERRUPT_PRIORITY 定义的优先级；</p>
<p>因此，对于任何使用一个 RTOS API 函数的中断服务程序，必须为其手动设置为一个<strong>数值优先级</strong>， 这个值必须等于或<strong>大于</strong> configMAX_SYSCALL_INTERRUPT_PRIORITY 设定的值。这确保了中断的逻辑优先级等于或小于 configMAX_SYSCALL_INTRUPT_PRIORITY 设置。</p>
<p>FreeRTOS 规定，调用 “FromISR” 函数的中断必须满足：</p>
<ul>
<li>逻辑优先级 ≤ configMAX_SYSCALL_INTERRUPT_PRIORITY</li>
<li>数值优先级 ≥ configMAX_SYSCALL_INTERRUPT_PRIORITY</li>
</ul>
<blockquote>
<p>由于不同的 Cortex-M 微控制器使用的优先级位数可能有所不同（通常少于 8 位），为了统一处理这些差异，FreeRTOS 将硬件原生的优先级值映射到一个统一的 8 位优先级范围。这种映射机制确保了在不同 Cortex-M 微控制器上实现一致的中断优先级管理。<strong>configKERNEL_INTERRUPT_PRIORITY 和 configMAX_SYSCALL_INTERRUPT_PRIORITY</strong>；</p>
</blockquote>
<p><strong>对于仅实现 configKERNEL_INTERRUPT_PRIORITY 的移植：</strong></p>
<p>configKERNEL_INTERRUPT_PRIORITY 设置 RTOS 内核自身使用的中断优先级。（SysTick 也需要一个中断优先级）</p>
<p>调用 API 函数的中断也必须在此优先级下执行。不调用 API 函数的中断可以在更高的优先级下执行，因此其执行不会因 RTOS 内核活动而延迟 （在硬件本身的限制范围内）。</p>
<blockquote>
<p>如果微处理器本身与 FreeRTOS 一致，则可以不需要使用 configMAX_SYSCALL_INTERRUPT_PRIORITY 抽象一层； </p>
</blockquote>
<p><strong>对于同时实现 configKERNEL_INTERRUPT_PRIORITY 和  configMAX_SYSCALL_INTERRUPT_PRIORITY 的移植：</strong></p>
<p>configKERNEL_INTERRUPT_PRIORITY 设置 RTOS 内核自身使用的中断优先级。</p>
<p>configMAX_SYSCALL_INTERRUPT_PRIORITY 设置可以调用中断安全 FreeRTOS API 函数的最高中断优先级。</p>
<h3 id="宏介绍"><a href="#宏介绍" class="headerlink" title="宏介绍"></a>宏介绍</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 MCU 最多支持几位优先级 Cortex-M 是 4 位,0~15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configPRIO_BITS 4</span></span><br><span class="line"><span class="comment">// 定义最低优先级的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY 0xf</span></span><br><span class="line"><span class="comment">// 定义可以被 FreeRTOS 管理的最高优先级中断，</span></span><br><span class="line"><span class="comment">// 这里定义为5，也就是说优先级高于5的中断FreeRTOS是不可管理的，低于5的才可管理。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5</span></span><br><span class="line"><span class="comment">// 设置 RTOS 内核使用的中断优先级(最低)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))</span></span><br><span class="line"><span class="comment">// 设置可以调用中断安全 FreeRTOS API 函数的中断的最高逻辑优先级（数值最小，逻辑优先级最高）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>RTOS 内核的核心功能依赖于硬件的 SysTick 和其他可能需要的中断服务（例如上下文切换）。</p>
</blockquote>
<h2 id="中断优先级与任务优先级"><a href="#中断优先级与任务优先级" class="headerlink" title="中断优先级与任务优先级"></a>中断优先级与任务优先级</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/freertosrwzdyxj.png" alt="freertosrwzdyxj"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>FreeRTOS 主要用于帮我们管理中断的关闭与开启</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 屏蔽中断</span></span><br><span class="line">portENABLE_INTERRUPTS();</span><br><span class="line"><span class="comment">// 恢复中断</span></span><br><span class="line">portDISABLE_INTERRUPTS();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FreeRTOS 的中断屏蔽与恢复是通过设置 BASEPRI 寄存器的值来实现的（写 0 屏蔽，写 1 恢复）</p>
<p>BASEPRI 是 ARM Cortex-M 处理器架构中的一个 8 位寄存器，逻辑为：</p>
<ul>
<li>当 BASEPRI 设置为 0 时，所有中断都可以响应（没有屏蔽）。</li>
<li>当 BASEPRI 设置为某个非零值时，优先级低于该值的中断将被屏蔽。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskHandle_t start_handler;</span><br><span class="line">TaskHandle_t task_key_handler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_key</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flag = <span class="number">0</span>;</span><br><span class="line">    FlagStatus pre_state = RESET;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FlagStatus state = gpio_input_bit_get(GPIOA, GPIO_PIN_0);</span><br><span class="line">        <span class="keyword">if</span>(SET == state &amp;&amp; pre_state == RESET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,按下</span></span><br><span class="line">            pre_state = state;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;disable \r\n&quot;</span>);</span><br><span class="line">                <span class="comment">// 关闭中断</span></span><br><span class="line">                portDISABLE_INTERRUPTS();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 开启中断</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;enable \r\n&quot;</span>);</span><br><span class="line">                portENABLE_INTERRUPTS();</span><br><span class="line">            &#125;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="keyword">if</span>(flag &gt; <span class="number">1</span>) flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(RESET == state &amp;&amp; pre_state == SET) &#123;</span><br><span class="line">            <span class="comment">// 当前高电平, 上一次为低电平,抬起</span></span><br><span class="line">            pre_state = state;</span><br><span class="line">        &#125;</span><br><span class="line">        delay_1ms(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart0_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\r\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 时钟初始化</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">    <span class="comment">// 配置GPIO模式</span></span><br><span class="line">    gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRESCALER	10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREQ	    1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TIMER_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 时钟配置</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_TIMER5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位定时器</span></span><br><span class="line">    timer_deinit(TIMER5);</span><br><span class="line"></span><br><span class="line">    rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL4);</span><br><span class="line">    timer_parameter_struct tps;</span><br><span class="line">    timer_struct_para_init(&amp;tps);</span><br><span class="line">    tps.prescaler = PRESCALER - <span class="number">1</span>; <span class="comment">// 分频系数  240 000 000</span></span><br><span class="line">    tps.period = SystemCoreClock / PRESCALER / FREQ - <span class="number">1</span>; <span class="comment">// 周期计数值 1Hz</span></span><br><span class="line"></span><br><span class="line">    timer_init(TIMER5, &amp;tps);</span><br><span class="line">    nvic_irq_enable(TIMER5_DAC_IRQn, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    timer_interrupt_enable(TIMER5, TIMER_INT_UP);</span><br><span class="line">    timer_enable(TIMER5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER5_DAC_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(SET == timer_interrupt_flag_get(TIMER5, TIMER_INT_UP)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;timer\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除中断标志位</span></span><br><span class="line">    timer_interrupt_flag_clear(TIMER5,TIMER_INT_FLAG_UP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    GPIO_config();</span><br><span class="line">    usart0_init();</span><br><span class="line">    TIMER_config();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start\r\n&quot;</span>);</span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line">    xTaskCreate(task_key, <span class="string">&quot;task_key&quot;</span>, <span class="number">64</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;task_key_handler);</span><br><span class="line">    <span class="comment">// 这里不是是 NULL 如果删除的是 start_task 会导致 task_key 也被删除</span></span><br><span class="line">    vTaskDelete(start_handler);</span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置抢占优先级</span></span><br><span class="line">    nvic_priority_group_set(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    xTaskCreate(start_task, <span class="string">&quot;start_task&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;start_handler);</span><br><span class="line">    <span class="comment">// 开启滴答时钟的</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>vTaskDelay 函数为什么会恢复中断</strong></p>
<p>vTaskDelay 函数会调用 xTaskResumeAll 函数，在 xTaskResumeAll 这个函数中，他会执行 taskENTER_CRITICAL 和 taskEXIT_CRITICAL 函数，这两个函数分别起到了控制中断屏蔽的作用。</p>
<ul>
<li><p><strong>taskENTER_CRITICAL</strong>：这个宏会调用 portDISABLE_INTERRUPTS，通常是通过设置 BASEPRI 寄存器来屏蔽中断。</p>
</li>
<li><p><strong>taskEXIT_CRITICAL</strong>：这个宏会恢复 BASEPRI 寄存器的值，解除屏蔽低优先级的中断。</p>
</li>
</ul>
<p>二、<strong>如果在中断中执行while(1)会怎么样</strong></p>
<p><strong>中断无法结束</strong>：中断服务例程的目标是快速处理必要的操作并尽早返回，使得系统可以继续响应其他任务和中断。如果在 ISR 中执行 while(1)，中断服务例程会永远处于活动状态，不会退出，这会阻塞中断的返回，系统无法恢复到正常的执行流。</p>
<p>如果系统<strong>允许中断嵌套</strong>（即优先级较高的中断可以中断较低优先级的中断），那么当 <code>while(1)</code> 导致当前中断服务例程无法退出时，其他待处理的中断会被挂起，直到当前 ISR 完成。这意味着新的中断不会得到及时处理，可能会丢失重要的数据或事件。</p>
<p>如果系统<strong>禁用了中断嵌套</strong>（通过设置更高的优先级屏蔽），则新的中断在 ISR 执行时将被禁止，导致该中断甚至不会被触发，直到当前 ISR 执行完毕。</p>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RTX51系统</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51%E7%B3%BB%E7%BB%9F%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>RTX51 是 KEIL 公司开发的针对 8051 系列单片机的多任务实时操作系统（RTOS）。它提供了<strong>多任务处理</strong>能力，允许程序以<strong>并行</strong>方式执行，适用于对时间要求严格的嵌入式应用。RTX51 具有简单的 API 和任务调度机制，使开发者能够更方便地管理任务和资源，确保系统的响应性和稳定性。RTX51 系统提供了任务管理、任务调度、任务通讯、定时器、信号量、邮箱等实时操作系统的基本功能，并与 Keil 公司的 C51 编译器紧密集成，从而方便开发人员进行开发和调试。</p>
<blockquote>
<p>RTX51 的多任务处理能力指的是系统能够同时管理和执行多个任务或进程的能力。多个任务看似同时运行，实际上是通过快速切换来实现的。这种切换由操作系统的调度器控制。</p>
</blockquote>
<p><strong>多核和多 CPU</strong></p>
<ul>
<li><p><strong>单核与多核</strong>：</p>
<ul>
<li><p><strong>单核</strong>：系统只有一个处理核心，所有任务都由这一核心处理。虽然能够完成基本的计算任务，但在同时执行多个任务时效率较低。</p>
</li>
<li><p><strong>多核</strong>：系统有多个处理核心（如双核、四核等），每个核心可以独立执行任务。这种架构可以提高并行处理能力，允许多个任务同时进行，从而提升整体性能。</p>
</li>
</ul>
</li>
<li><p><strong>单 CPU 与多 CPU</strong>：</p>
<ul>
<li><p><strong>单 CPU</strong>：系统只配备一个中央处理单元（CPU），类似于单核，但可以是一个复杂的多核处理器。</p>
</li>
<li><p><strong>多 CPU</strong>：系统配备多个 CPU，每个 CPU 可以独立处理任务，通常用于需要极高性能和处理能力的服务器</p>
</li>
<li><p>或高性能计算机。多 CPU 系统通过并行处理可以显著提高计算能力。</p>
</li>
</ul>
</li>
</ul>
<p><strong>RTX51 包含两个版本：</strong></p>
<p>RTX51 Tiny</p>
<ul>
<li>RTX51 Tiny是一个非常小型的实时操作系统，具有基本的任务调度功能，包括任务优先级和时间片轮转等RTX51 Tiny适用于基于51系列单片机的应用程序，特别是对于小型和简单的应用程序，因为它不需要太多的RAM和ROM资源。</li>
<li>相对于 RTX51 Full 不具备如下功能：<ul>
<li>由循环多任务处理和信号实现任务切换</li>
<li>不支持优先任务切换</li>
<li>不包含信息子程序</li>
<li>无存储器库分配子程序</li>
</ul>
</li>
</ul>
<p>RTX51 Full</p>
<ul>
<li>RTX51 Full则是一个功能更为强大的实时操作系统，它不仅支持基本的任务调度功能，还提供了更多的RTOS特性，例如信号量、邮箱、消息队列、事件标志和互斥量等，使得它更加适合于需要更高级RTOS特性的应用程序。</li>
</ul>
<p>RTX51 Tiny是一个轻量级的RTOS，适用于简单的应用程序，而RTX51 Full则提供了更多的RTOS特性，适用于更为复杂的应用程序。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="RTX51-Tiny-环境搭建"><a href="#RTX51-Tiny-环境搭建" class="headerlink" title="RTX51 Tiny 环境搭建"></a>RTX51 Tiny 环境搭建</h3><ol>
<li>新建一个项目</li>
<li>打开keil安装目录，来到<code>C51\RtxTiny2\SourceCode</code>目录，拷贝<code>Conf_tny.A51</code>和<code>RTX51TNY.LIB</code>到项目中。</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51bin.png" alt="RTX51bin"></p>
<ol start="3">
<li>打开配置，来到<code>Target</code>中，将<code>Operating system</code>修改为<code>RTX-51 Tny</code></li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51IDE.png" alt="RTX51IDE"></p>
<ol start="4">
<li>新建好<code>main.c</code>, 代码如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RTX51TNY.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8H.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P5.3 闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_init</span><span class="params">()</span> &#123;</span><br><span class="line">	P5M1 &amp;= ~<span class="number">0x08</span>; P5M0 &amp;= ~<span class="number">0x08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数名可随意, 建议不要使用start, 会和I2C.h里的Start冲突</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_start</span><span class="params">()</span> _task_ 0 &#123;</span><br><span class="line">	sys_init();</span><br><span class="line">	<span class="comment">// 创建任务 1</span></span><br><span class="line">	os_create_task(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 结束任务 0</span></span><br><span class="line">	os_delete_task(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_1</span><span class="params">()</span> _task_ 1 &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P53 = <span class="number">1</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">		</span><br><span class="line">		P53 = <span class="number">0</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不再有main函数</li>
<li>代码入口为标记为 <code>_task_ 0</code>的函数。</li>
<li><code>_task_</code>标记的函数，表示这个是独立的任务，多个task可以同时执行。</li>
</ul>
<h3 id="RTX51-注意事项"><a href="#RTX51-注意事项" class="headerlink" title="RTX51 注意事项"></a>RTX51 注意事项</h3><p>一、<strong>RTX51 对于系统硬件的要求</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51renwu.png" alt="RTX51renwu"></p>
<p>二、<strong>RTX51 任务的状态及定义</strong></p>
<p>RTX51 区分 2 类任务: <strong>快速任务</strong>和<strong>标准任务</strong>。快速任务有很快的响应速度，每个快速任务使用 8051 一个单独的寄存器组，并且有自己的堆栈区域。RTX51 支持最大同时有 3 个快速任务。标准任务需要多一点的时间来进行任务切换，因此使用的内部 RAM 相对快速任务要少，所有的标准任务共用 1 个寄存器组和堆栈。当任务切换的时候，当前任务的寄存器状态和堆栈内容转移到外部存储器中。</p>
<p>在 RTX51 Full 中，可以通过特定的 API 或函数来创建任务，并在创建时指定任务的类型（快速或标准）。<strong>RTX51 Tiny 则不支持快速任务。</strong></p>
<p>RTX51 FULL 支持任务最多达 64 个，但一般 RTX51 TINY 支持最大 16 个标准任务。</p>
<p>三、<strong>RTX51 自带延迟与 delay_ms() 延时的区别</strong></p>
<p>在 RTX51 Tiny 中 共有三个等待延时函数分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait</span>            <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ, </span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">int</span> dummy)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait1</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait2</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks)</span>;</span><br><span class="line"><span class="comment">// 参数如下：</span></span><br><span class="line"><span class="comment">/* constants for os_wait function：也就是等待函数的 typ */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_SIG 0x01 <span class="comment">/* 等待一个信号。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_TMO 0x02 <span class="comment">/* 等待由 ticks 指定的超时时间。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_IVL 0x80 <span class="comment">/* 等待由 ticks 指定的时间间隔。*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数中：K_TMO、K_IVL 看解释十分相似，但其实区别很大：</span></span><br><span class="line"><span class="comment">当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。</span></span><br><span class="line"><span class="comment">当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>os_wait</strong></p>
<p>暂停当前任务，等待一个或多个事件；例如一个时间间隔、超时或来自其他任务或中断的信号。typ 参数指定要等待的事件或事件组合，可以是上述参数中的常量之一：</p>
<p>typ 可以通过竖线（|）字符进行逻辑或操作。例如，K_TMO | K_SIG 表示任务等待超时或信号。</p>
<ul>
<li>**<code>typ</code>**：这是一个指定等待类型的参数。RTX51 中可能定义了多种等待类型，如等待事件、消息、信号量等。具体的类型值取决于 RTX51 的具体实现和文档。</li>
<li>**<code>ticks</code>**：这是等待的时间长度，以操作系统的“tick”为单位。一个 tick 的长度取决于 RTX51 的配置，通常与系统的时钟频率有关。</li>
<li>**<code>dummy</code>**：这个参数在大多数实现中可能并不真正使用，而是为了保持函数签名的兼容性或预留未来的扩展。在一些版本中，这个参数可能已经被移除或替换为更有用的参数。</li>
</ul>
<p><strong>os_wait1</strong></p>
<p>暂停当前任务并等待事件发生。os_wait1 函数是 os_wait 函数的一个子集，只支持 K_SIG 这个值，表示等待一个信号。</p>
<p><strong>os_wait2</strong></p>
<p>同 os_wait 基本一致</p>
<blockquote>
<p>当 K_SIG 和 K_IVL 组合使用时，必须使用 <code>os_reset_interval</code> 函数来消除定时器延迟问题。</p>
</blockquote>
<p><strong>以 os_wait2 为例 与 delay_ms() 区别在：</strong></p>
<p>在 RTOS 中，如果 delay_ms() 被用于多个任务，它可能会导致任务调度的不公平或不可预测性，因为<strong>任务在等待期间会阻塞其他任务的执行</strong>。</p>
<p>如果多个任务都使用 delay_ms() 等待 100ms，那么每个任务都会独立地进入延时状态，并阻塞其他任务的执行（除非RTOS有特别的机制来处理这种情况）。</p>
<p>举个例子：</p>
<ol>
<li><p>假设我有 三个任务分别为 func1、func2、func3，三个任务都设置 delay_ms 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 3 &#x3D; 450ms、300ms、150ms，因为他们</p>
</li>
<li><p>假设我有 三个任务分别为 func1、func2、func3三个任务，其中 func1 设置 delay_ms，其他都设置 K_TMO 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 2 &#x3D; 300ms、200ms、100ms，因为他们</p>
</li>
</ol>
<blockquote>
<p>在 RTX51 Tiny 中，当多个任务处于休眠状态时，它们会共享同一个时间片。这意味着，当系统调度时，如果所有处于休眠状态的任务都没有被唤醒，调度器不会为它们分配不同的时间片。实际上，只有在任务被唤醒并准备好执行时，调度器才会考虑这些任务。</p>
<p>因此，在多个任务休眠的情况下，系统不会为每个休眠任务分配独立的时间片。它们会在系统处于闲置状态时共用资源，直到有任务需要执行或有事件发生以唤醒其中的某个任务。</p>
</blockquote>
<p>四、<strong>K_TMO 与 K_IVL 的区别</strong></p>
<p>当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。<br>当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</p>
<p><strong>K_SIG 信号等待</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、报错：<strong>WARNING L7: MODULE NAME NOT UNIQUE MODULE:  .\Objects\Conf_tny.obj (?RTX51_TINY_KERNAL)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51Bug1.png" alt="RTX51Bug1"></p>
<p>将 Conf_tny.A51 放在 RTX51TNY.LIB 前面即可</p>
]]></content>
      <categories>
        <category>RTOS</category>
      </categories>
      <tags>
        <tag>RTX51</tag>
      </tags>
  </entry>
  <entry>
    <title>系统移植</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>移植 FreeRTOS 的主要原因是将其核心功能与目标硬件平台结合，从而为嵌入式开发提供实时操作系统支持，解决裸机开发中的不足。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>开发板。案例是以立创天空星为开发板。</li>
<li>Windows 系统的电脑。当前是以 Win11 的电脑来实现案例的。</li>
<li>Keil 开发工具。并且已经安装好 GD32 依赖环境。</li>
<li>FreeRTOS 源码包。下载地址为: <a href="https://github.com/FreeRTOS/FreeRTOS/releases">https://github.com/FreeRTOS/FreeRTOS/releases</a></li>
</ol>
<ul>
<li>这里建议从 <a href="https://www.freertos.org/zh-cn-cmn-s">FreeRTOS 官网</a>下载非 LTS 版本，因为 LTS 的版本不包含示例项目。</li>
</ul>
<p>我们下载好 FreeRTOS 源码包之后可以参照官方示例代码，也就是 Demo 中的例程进行参考。</p>
<h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><p><a href="https://freertos.org/zh-cn-cmn-s/Documentation/02-Kernel/03-Supported-devices/01-FreeRTOS-porting-guide">FreeRTOS 移植指南</a></p>
<h3 id="熟悉目录结构"><a href="#熟悉目录结构" class="headerlink" title="熟悉目录结构"></a>熟悉目录结构</h3><p>从顶部开始，下载被分割成两个子目录：FreeRTOS 和 FreeRTOS-Plus。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+-FreeRTOS-Plus <span class="comment">// 包含[FreeRTOS Plus]（/文档/03库/02 FreeRTOS Plus/01简介）组件和演示项目。</span></span><br><span class="line">|</span><br><span class="line">+-FreeRTOS 	    <span class="comment">// 包含FreeRTOS实时内核源文件和演示项目</span></span><br></pre></td></tr></table></figure>

<p><strong>FreeRTOS：</strong>包含 FreeRTOS 内核（Kernel）的源代码（例如 task.c, queue.c, timers.c 等核心文件）。</p>
<p><strong>FreeRTOS-Plus：</strong>包含 FreeRTOS Plus 系列库和组件，这些是对 FreeRTOS 内核功能的扩展。</p>
<p><strong>FreeRTOS 内核目录结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FreeRTOS</span><br><span class="line">    |</span><br><span class="line">    +-Demo   <span class="comment">// 包含演示应用程序项目。</span></span><br><span class="line">    |</span><br><span class="line">    +-Source <span class="comment">// 包含 RTOS 内核源代码。</span></span><br></pre></td></tr></table></figure>

<p><strong>FreeRTOS&#x2F;Source 目录的结构如下所示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FreeRTOS</span><br><span class="line">    |</span><br><span class="line">    +-Source            <span class="comment">// FreeRTOS内核文件</span></span><br><span class="line">        |</span><br><span class="line">        +-include      <span class="comment">// FreeRTOS内核头文件</span></span><br><span class="line">        |</span><br><span class="line">        +-Portable    <span class="comment">// 处理器相关的代码</span></span><br><span class="line">            |</span><br><span class="line">            +-MemMang <span class="comment">// 内存管理实现</span></span><br><span class="line">            +-....    <span class="comment">// 与处理器相关的代码</span></span><br></pre></td></tr></table></figure>

<p><strong>FreeRTOS&#x2F;Demo 目录的结构如下所示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FreeRTOS</span><br><span class="line">    |</span><br><span class="line">    +-Demo</span><br><span class="line">        |</span><br><span class="line">        +-Common    The demo application files that are used by all the demos.</span><br><span class="line">        +-Dir x     The demo application build files <span class="keyword">for</span> port x</span><br><span class="line">        +-Dir y     The demo application build files <span class="keyword">for</span> port y</span><br></pre></td></tr></table></figure>

<h3 id="拷贝FreeRTOS源码"><a href="#拷贝FreeRTOS源码" class="headerlink" title="拷贝FreeRTOS源码"></a>拷贝FreeRTOS源码</h3><p>FreeRTOS 官方提供了丰富且详细的示例代码，我们只需根据需求拷贝并适配即可。</p>
<p>在 FreeRTOS&#x2F;Demo 目录下，有大量针对不同架构平台的示例项目。我们需要找到与当前使用的架构和开发环境匹配的示例代码进行移植。</p>
<p>当前我们的开发环境为 Keil，编译器是 GCC，目标处理器的内核架构为 Cortex-M4F。按照这些条件选择合适的示例代码即可。</p>
<blockquote>
<p>CORTEX_M4F_STM32F407ZG-SK 这里先不要参考这个， SK 指代的是 STM32 官方自带的 IDE，它可以在创建项目的时候自动添加 FreeRTOS 相关的库文件，所以我们打开会发现除了一个 .h 外它不包含任何与 FreeRTOS 相关的库文件；</p>
</blockquote>
<p>在示例代码中我们可以找 CORTEX_M4F_CEC1302_Keil_GCC 这个示例代码进行参考，通过 Keil 将其打开：</p>
<p>会发现它包含的文件如下：</p>
<ul>
<li>FreeRTOS&#x2F;Source&#x2F;include 目录下所有的头文件</li>
<li>FreeRTOS&#x2F;Source&#x2F;Portable 目录下处理器相关的代码 </li>
<li>FreeRTOS&#x2F;Source 目录下 FreeRTOS 处理器相关代码</li>
<li>FreeRTOSConfig.h 头文件；</li>
</ul>
<p>我们参照例程将这些文件拷贝到我们自己对应的 Middleware&#x2F;FreeRTOS 目录下；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/FreeRTOS</span><br><span class="line">│</span><br><span class="line">├── /portable      </span><br><span class="line">│   ├── /GCC/ARM_CM4F          # 针对 ARM Cortex-M4 架构和 GCC 编译器的移植代码</span><br><span class="line">│   │   ├── port.c   </span><br><span class="line">│   │   └── portmacro.h</span><br><span class="line">│   └──  /MemMang              # 内存管理相关代码        </span><br><span class="line">│       └── heap_4.c                                 </span><br><span class="line">│</span><br><span class="line">├── /include                  # FreeRTOS 公共头文件</span><br><span class="line">│   ├── FreeRTOS.h         </span><br><span class="line">│   └── …                     </span><br><span class="line">│</span><br><span class="line">├── croutine.c                  # 协程相关代码</span><br><span class="line">├── event_groups.c            # 事件组相关代码</span><br><span class="line">├── <span class="built_in">list</span>.c                    # 链表操作代码</span><br><span class="line">├── <span class="built_in">queue</span>.c                   # 队列操作代码</span><br><span class="line">├── stream_buffer.c           # 流缓冲区相关代码</span><br><span class="line">├── tasks.c                   # 任务管理相关代码</span><br><span class="line">└── timers.c                  # 定时器管理相关代码</span><br><span class="line">    </span><br><span class="line">/User   </span><br><span class="line">│    </span><br><span class="line">└── FreeRTOSConfig.h          # FreeRTOS 配置文件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单点来说就是将 FreeRTOS&#x2F;Source 下所有的文件都复制到我们 FreeRTOS 目录中；删除 Portable 中不需要的文件，再将 FreeRTOSConfig.h   放置在 main.c 同级目录下即可；</p>
</blockquote>
<p>将上述 FreeRTOS 文件添加到到 Keil 工程中，添加后的目录如下：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/freertosmljg.png" alt="freertosmljg"></p>
<p>添加完成后运行，解决对应错误即可。</p>
<h3 id="添加-FreeRTOSConfig-h-配置文件"><a href="#添加-FreeRTOSConfig-h-配置文件" class="headerlink" title="添加 FreeRTOSConfig.h 配置文件"></a>添加 FreeRTOSConfig.h 配置文件</h3><p>FreeRTOSConfg.h 是 FreeRTOS 操作系统的配置文件，FreeRTOS 操作系统是可裁剪的，用户可以根据需求对 FreeRTOS 进行裁剪,裁剪掉不需要用到的 FreeRTOS 功能,以此来节约 MCU中寸土寸金的内存资源。</p>
<p>该文件可以从示例代码中进行复制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSConfig.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FREERTOS_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREERTOS_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ			( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ			( ( TickType_t ) 1 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES		( 5 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE	( ( unsigned short ) 128 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE		( ( size_t ) ( 17 * 1024 ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN		( 16 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD		1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the following definitions to 1 to include the API function, or zero</span></span><br><span class="line"><span class="comment">to exclude the API function. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete				1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay				1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255</span></span><br><span class="line"><span class="comment">(lowest) to 0 (1?) (highest). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configKERNEL_INTERRUPT_PRIORITY 		255</span></span><br><span class="line"><span class="comment">/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!</span></span><br><span class="line"><span class="comment">See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY 	191 <span class="comment">/* equivalent to 0xb0, or priority 11. */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the value being used as per the ST library which permits 16</span></span><br><span class="line"><span class="comment">priority values, 0 to 15.  This must correspond to the</span></span><br><span class="line"><span class="comment">configKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest</span></span><br><span class="line"><span class="comment">NVIC value of 255. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_KERNEL_INTERRUPT_PRIORITY	15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler    PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler       SVC_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortSysTickHandler   SysTick_Handler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* FREERTOS_CONFIG_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="修改中断相关文件"><a href="#修改中断相关文件" class="headerlink" title="修改中断相关文件"></a>修改中断相关文件</h3><p>来到 stm32f10x_it.c 文件中。修改三个函数 SVC_Handler, PendSV_Handler, SysTick_Handler 将函数通过宏定义包裹:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stm32f10x_it.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_SUPPORT_OS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles SVCall exception.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_SUPPORT_OS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles PendSVC exception.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_SUPPORT_OS</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles SysTick Handler.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="配置时钟"><a href="#配置时钟" class="headerlink" title="配置时钟"></a>配置时钟</h2><p>在 FreeRTOS 成功移植并且不报错之后，系统就已经具备了基本的任务调度能力，但要让它完全正常运行，还需要完成一些硬件初始化和配置工作。这些配置工作通常与时钟、外设、系统节拍等相关，确保 FreeRTOS 的调度器能够正确地运行并与硬件配合。</p>
<h3 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h3><p>配置当前 FreeRTOS 的 <strong>CPU 主频</strong>（即系统时钟频率）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSConfig.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ ( SystemCoreClock )</span></span><br></pre></td></tr></table></figure>

<p>SystemCoreClock 通常是由硬件库定义的全局变量，它会根据系统时钟初始化过程自动更新。</p>
<h3 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h3><p>滴答时钟用于产生系统节拍中断，驱动 FreeRTOS 的任务调度器。</p>
<p>滴答时钟的频率由 configTICK_RATE_HZ 定义;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ ( ( TickType_t ) 1000 )</span></span><br></pre></td></tr></table></figure>

<p>这里的 1000 表示每秒产生 1000 次节拍中断，即 1 毫秒一次。</p>
<p>滴答频率的选择需要根据应用需求决定：</p>
<ul>
<li>高频（如 1000 Hz）：调度更频繁，但 CPU 负载增加。</li>
<li>低频（如 100 Hz）：调度较少，适合实时性要求不高的场景。</li>
</ul>
<p><strong>时间片的长度</strong>由滴答时钟（tick rate）与调度方式决定。如果启用了<strong>时间片轮转</strong>，每个任务的时间片是基于系统的滴答周期来分配的，如果启用了<strong>抢占式调度（configUSE_PREEMPTION 1）</strong>系统会在每个滴答周期内检查是否有更高优先级的任务需要执行，确保高优先级任务及时获得 CPU 时间。</p>
<blockquote>
<p>由于滴答时钟已经交予 FreeRTOS 进行是使用，我们就不能在 main 中初始化 SysTick 了（systick_config()），因为二者同时去操作 SysTick 寄存器就会产生一些错误问题；</p>
<p>所以这里我们还是和前面一样通过宏进行判断，如果移植了 FreeRTOS 就让 FreeRTOS 控制滴答时钟的配置，否则就是用我们芯片自己的；</p>
</blockquote>
<h2 id="自定义延时函数"><a href="#自定义延时函数" class="headerlink" title="自定义延时函数"></a>自定义延时函数</h2><p>在某些情况下我们需要使用我们自定义的延时函数，这里我们还是和之前一样过读取 <strong>SysTick 定时器的计数值</strong>，利用系统的时钟频率来精确计算经过的时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// systick.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">uint32_t</span> delay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief    configure systick</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* setup systick timer for 1000Hz interrupts */</span></span><br><span class="line">    <span class="keyword">if</span>(SysTick_Config(SystemCoreClock / <span class="number">1000U</span>)) &#123;</span><br><span class="line">        <span class="comment">/* capture error */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure the systick handler priority */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, <span class="number">0x00</span>U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_SUPPORT_OS</span></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief    delay a time in milliseconds</span></span><br><span class="line"><span class="comment">    \param[in]  count: count in milliseconds</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    delay = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief    delay decrement</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">        delay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1us</span><span class="params">(<span class="type">uint32_t</span> count)</span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ticks;</span><br><span class="line">  <span class="type">uint32_t</span> told, tnow, reload, tcnt = <span class="number">0</span>;</span><br><span class="line">  reload = SysTick-&gt;LOAD;</span><br><span class="line">  ticks = count * (SystemCoreClock / <span class="number">1000000</span>);</span><br><span class="line">  told = SysTick-&gt;VAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    tnow=SysTick-&gt;VAL;</span><br><span class="line">    <span class="keyword">if</span>(tnow != told) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tnow&lt;told) tcnt+=told-tnow;</span><br><span class="line">      <span class="keyword">else</span> tcnt+=reload-tnow+told;</span><br><span class="line">      told=tnow;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(tcnt&gt;=ticks)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    delay_1us(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="验证FreeRTOS移植是否正常"><a href="#验证FreeRTOS移植是否正常" class="headerlink" title="验证FreeRTOS移植是否正常"></a>验证FreeRTOS移植是否正常</h2><p>在”魔术棒中进行如下设置”</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20250213185805043.png" alt="image-20250213185805043"></p>
<p>编译没问题后我们点击图中右上角的调试按钮，在调试界面中点击左上角的”View” -&gt; “Analysis Windows” 选择 “Logic Analyzer”。</p>
<p>在 main.c 中分别右键 a1，a2，选择 “Add ‘a1’ to” -&gt; “Analyzer”。</p>
<p>设置 a1 ，a2 只显示 0 和 1，在 Logic Analyzer 中分别右键然后将默认选项的 “Analog” 改为 “bit”；</p>
<p>点击左上角 “Run”运行可以观测到如下结果：</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20250213190611896.png" alt="image-20250213190611896"></p>
<blockquote>
<p>注意查看切换时间是否一与 FreeRTOSConfig.h 中设置的是否一致；</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>我没有调用 FreeRTOS 相关函数他为啥会自动运行并报错呢</strong></p>
<p>FreeRTOS 的部分代码（例如任务调度器、内存管理等）可能依赖于特定的硬件初始化或全局配置。如果你的工程中没有正确配置它的基础环境，编译或链接时就可能报错。</p>
<p>FreeRTOS 的部分代码可能会在工程初始化或链接时被调用，即使未在 <code>main</code> 中使用。</p>
<p>二、<strong>error: use of undeclared identifier ‘SystemCoreClock’错误</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ICCARM__</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在 port.c 文件中，这个变量只有在 <strong>ICCARM</strong> 这个宏存在，也就是说编译器是 ICC 的时候才执行其中的代码，而我们是 Keil 编译器，所以我们需要修改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ICCARM__)||defined(__CC_ARM)||defined(__GNUC__)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>三、<strong>重复定义错误</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中断处理函数重复定义</span></span><br><span class="line">Error: L6200E: Symbol SysTick_Handler multiply <span class="title function_">defined</span> <span class="params">(by port.o and gd32f4xx_it.o)</span>.</span><br><span class="line">Error: L6200E: Symbol SVC_Handler multiply <span class="title function_">defined</span> <span class="params">(by port.o and gd32f4xx_it.o)</span>.</span><br><span class="line">Error: L6200E: Symbol PendSV_Handler multiply <span class="title function_">defined</span> <span class="params">(by port.o and gd32f4xx_it.o)</span>.</span><br></pre></td></tr></table></figure>

<p><strong>中断处理函数重复定义错误原因：</strong></p>
<p>FreeRTOS 的移植代码（port.c 文件）会定义 Cortex-M 核心的中断处理函数，例如：</p>
<ul>
<li>SysTick_Handler：用于系统节拍定时器（SysTick）的中断服务。</li>
<li>PendSV_Handler：用于上下文切换。</li>
<li>SVC_Handler：用于启动第一个任务。</li>
</ul>
<p>同时，你的工程中可能有一个文件（例如 gd32f4xx_it.c），也定义了这些中断处理函数，导致冲突。</p>
<p>我们希望的是，如果移植了 FreeRTOS 就使用 FreeRTOS 中的函数，否则就使用我们自己函数；这就可以通过宏定义来实现：</p>
<p>当我们移植 FreeRTOS 时，我们可以手动在 Keil 中添加一个自定义宏（ SYS_SUPPORT_OS 这个宏定义），将重复的函数包裹起来；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gd32f407xx.it.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_SUPPORT_OS</span></span><br><span class="line"><span class="comment">/* this function handles SVC exception */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* this function handles PendSV exception */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* this function handles SysTick exception */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gd32f407xx.it.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_SUPPORT_OS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* if SVC exception occurs, go to infinite loop */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* if PendSV exception occurs, go to infinite loop */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">//    led_spark();</span></span><br><span class="line">    delay_decrement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>四、<strong>变量未定义错误</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Error: L6218E: Undefined symbol <span class="title function_">vApplicationStackOverflowHook</span> <span class="params">(referred from tasks.o)</span>.</span><br><span class="line">Error: L6218E: Undefined symbol <span class="title function_">vApplicationIdleHook</span> <span class="params">(referred from tasks.o)</span>.</span><br><span class="line">Error: L6218E: Undefined symbol <span class="title function_">vApplicationTickHook</span> <span class="params">(referred from tasks.o)</span>.</span><br><span class="line">Error: L6218E: Undefined symbol <span class="title function_">vApplicationMallocFailedHook</span> <span class="params">(referred from heap_4_1.o)</span>.</span><br></pre></td></tr></table></figure>

<p>上述错误表明你的工程中缺少一些 FreeRTOS 要求的钩子函数的定义。这些函数用于处理特定的系统事件，如任务堆栈溢出、空闲任务的操作、系统时钟节拍钩子等。虽然它们在某些场景中是可选的，但如果在配置文件 FreeRTOSConfig.h 中启用了相关功能而未定义这些钩子函数，就会导致链接时的 undefined symbol 错误。</p>
<p>这里我们以 vApplicationStackOverflowHook 为例了解如何解决</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configCHECK_FOR_STACK_OVERFLOW &gt; 0 )</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t xTask, <span class="type">char</span> * pcTaskName )</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) &amp;&amp; ( portSTACK_GROWTH &gt; 0 ) )</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> taskCHECK_FOR_STACK_OVERFLOW() &#123;                                                             </span></span><br><span class="line">        <span class="keyword">if</span>( pxCurrentTCB-&gt;pxTopOfStack &gt;= pxCurrentTCB-&gt;pxEndOfStack - portSTACK_LIMIT_PADDING ) &#123;                 		vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB-&gt;pcTaskName ); </span><br><span class="line">        &#125;                                                                                             </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FreeRTOSConfig.h</span></span><br><span class="line">#configCHECK_FOR_STACK_OVERFLOW 	 <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK			 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK			 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MALLOC_FAILED_HOOK 0</span></span><br></pre></td></tr></table></figure>

<p>可以看到 vApplicationStackOverflowHook 的声明与使用是通过 configCHECK_FOR_STACK_OVERFLOW 这个宏是否 &gt; 0 来控制的，所以我们这里有两个解决方案，1 是将 configCHECK_FOR_STACK_OVERFLOW 定义小于 0，而是手动实现这个函数；这里我们简单一点我们将这个宏的值改为 0；</p>
<p>其他三个也是同理；</p>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>软件定时器</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>软件定时器能够让函数在未来设定的时间执行。由定时器执行的函数称为定时器回调函数。从定时器启动到其回调函数执行之间的时间 被称为定时器的周期。简而言之， 当定时器的周期到期时，定时器的回调函数会被执行。</p>
<p>请注意，在使用软件定时器之前，必须明确地创建它。</p>
<p><strong>定时器服务任务</strong>（主要）利用现有 FreeRTOS 功能， 允许在对应用程序的可执行二进制文件的大小造成影响最小的情况下， 将定时器功能添加到应用程序中。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>FreeRTOS 的定时器实现<strong>不从中断上下文中执行定时器回调函数</strong>， 不消耗<strong>任何</strong>处理时间， 除非定时器实际上已经过期，不给 tick 中断增加任何处理开销，并且在中断被禁用时不走行任何链接列表结构体。</p>
<blockquote>
<p>FreeRTOS 定时器的回调函数并不会直接在中断服务程序（ISR）中运行，而是在<strong>定时器服务任务的上下文中执行</strong>。</p>
<p>定时器没有到期时，它只需要记录剩余的时间。</p>
<p>只有当定时器到期后，才会触发定时器服务任务执行定时器回调函数。</p>
<p>在 tick 中断中，仅简单地更新 tick 计数，定时器到期后，将任务转移到定时器服务任务中处理。</p>
<p>中断被禁用时，尽量不执行复杂的链表操作，确保系统的实时性和稳定性。</p>
</blockquote>
<p>定时器回调函数在<strong>定时器服务任务</strong>的上下文中执行不从中断上下文中执行。因此，定时器回调函数永远不试图阻塞是<strong>至关重要的</strong> 。</p>
<blockquote>
<p>如果某个定时器回调函数执行了阻塞操作（例如死循环），定时器服务任务将被阻塞，导致以下问题：</p>
<ul>
<li><p>其他定时器的回调函数无法被及时执行。</p>
</li>
<li><p>定时器服务任务无法处理新到期的定时器。</p>
</li>
<li><p>可能阻塞其他依赖于定时器服务任务的功能，例如动态软件定时器的创建或删除。</p>
</li>
</ul>
</blockquote>
<p>例如，定时器回调函数在访问队列或信号量时，不得调用 vTaskDelay()、 vTaskDelayUntil()，也不得指定非零阻塞时间。</p>
<h2 id="定时器服务-守护进程任务和定时器命令队列"><a href="#定时器服务-守护进程任务和定时器命令队列" class="headerlink" title="定时器服务&#x2F;守护进程任务和定时器命令队列"></a>定时器服务&#x2F;守护进程任务和定时器命令队列</h2><p>定时器是一个不属于核心 FreeRTOS 内核的可选功能，由 <strong>定时器服务任务（定时器守护进程任务）</strong>提供。</p>
<p>FreeRTOS 提供了一组与定时器相关的 API 函数。其中许多函数使用标准 FreeRTOS 队列向定时器服务任务发送命令。用于此目的的队列称为<strong>定时器命令队列</strong>。“定时器命令队列” 专用于 FreeRTOS 定时器实现，无法直接访问。</p>
<p>下图演示了这种情景。左边的代码表示 一个函数，属于用户应用程序的一部分， 并由作为同一用户应用程序的一部分创建的任务调用。右边的代码表示 定时器服务任务实现。 <strong>定时器命令队列将用户应用任务和定时器服务任务连接在一起</strong>（定时器 API 将任务添加到定时器任务队列中，定时器服务程序从任务队列中获取命令并执行）。 在此演示案例中，应用程序代码 调用 xTimerReset() API 函数。其结果是复位命令会发送到定时器命令队列中， 再由定时器服务任务来处理。应用程序代码 只会调用 xTimerReset() API 函数，不会（也无法）直接 访问定时器命令队列。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/FreeRTOS/rtosrjdsjrwdd.png" alt="rtosrjdsjrwdd"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>要使 FreeRTOS 软件计时器 API 在应用程序中可用， 只需：</p>
<ol>
<li>将 FreeRTOS&#x2F;Source&#x2F;timers.c 源文件添加到项目中，以及</li>
<li>在应用程序 FreeRTOSConfig.h 头文件中定义下表详述的常量。</li>
</ol>
<p><strong>常量</strong></p>
<ul>
<li><p>configUSE_TIMERS</p>
<p>设置为 1 以包括定时器功能。<strong>当 configUSE_TIMERS 设置为 1 时， RTOS 定时器服务任务将在调度器启动时自动创建</strong>。</p>
</li>
<li><p>configTIMER_TASK_PRIORITY</p>
<p>设置定时器服务任务的优先级。与所有任务一样，定时器服务任务可以 在 0 到 (configMAX_PRIORITIES - 1) 之间的任何优先级运行。</p>
<p>需要仔细选择此数值，以满足应用程序的要求。例如，如果 定时器服务任务被设置为系统中最高优先级的任务， 则发送到定时器服务任务（当调用定时器 API 函数时）和过期的定时器的命令都将立即得到处理。 相反，如果定时器服务任务被赋予低优先级， 则发送到定时器服务任务和过期定时器的命令将不会被处理， 直到定时器服务任务成为能够运行的最高优先级任务。然而，值得注意的是，定时器到期时间是相对于发送命令的时间计算的， 而不是相对于处理命令的时间计算的。</p>
</li>
<li><p>configTIMER_QUEUE_LENGTH</p>
<p>这设置了定时器命令队列在任一时间可以容纳的未处理命令的最大数量 。定时器命令队列可能已满的原因包括：</p>
<ul>
<li>在 RTOS 调度器启动之前（即创建定时器服务任务之前） 进行多次定时器 API 函数调用。</li>
<li>从中断服务程序 (ISR) 进行多次（中断安全）定时器 API 函数调用。</li>
<li>从优先级高于定时器服务任务的任务进行多次定时器 API 函数调用。</li>
</ul>
</li>
<li><p>configTIMER_TASK_STACK_DEPTH</p>
<p>设置分配给定时器服务任务的堆栈大小（以字为单位，而不是以字节为单位）。</p>
<p>定时器回调函数在定时器服务任务的上下文中执行。因此，定时器服务任务的堆栈要求 取决于定时器回调函数的堆栈要求。</p>
</li>
</ul>
<h2 id="定时器运行机制"><a href="#定时器运行机制" class="headerlink" title="定时器运行机制"></a>定时器运行机制</h2><p><strong>定时器创建</strong>：用户通过 xTimerCreate() 函数创建一个定时器，并为其指定一个时间间隔和回调函数。</p>
<p><strong>启动定时器</strong>：定时器通过 xTimerStart() 或 xTimerChangePeriod() 启动。一旦定时器启动，它就开始计时。</p>
<p><strong>计时</strong>：软件定时器的计时是基于系统的 tick 中断。每次 tick 中断发生时，FreeRTOS 会检查所有定时器，看是否有定时器已到期。如果有到期的定时器，它会将其移到待处理队列中，等待定时器服务任务处理。</p>
<p><strong>定时器回调</strong>：所有定时器的回调函数都由定时器服务任务（Timer Service Task）来执行。当定时器到期时，回调函数会在定时器服务任务上下文中执行，而不是在中断上下文中执行。定时器服务任务在</p>
<p><strong>定时器服务任务</strong>：定时器服务任务是一个系统级的任务，通常以最低优先级运行。它会定期检查是否有定时器回调需要执行。</p>
<h2 id="定时器-API"><a href="#定时器-API" class="headerlink" title="定时器 API"></a>定时器 API</h2><h3 id="xTimerCreate"><a href="#xTimerCreate" class="headerlink" title="xTimerCreate"></a>xTimerCreate</h3><p>创建一个新的软件定时器实例， 并返回一个可以引用定时器的句柄。</p>
<p>定时器是在休眠状态下创建的。需要显示的激活使用；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timers.h</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span></span><br><span class="line">             <span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> TickType_t xTimerPeriod,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span><br><span class="line"><span class="params">               TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>pcTimerName</p>
<p>分配给定时器的可读文本名称。这样做纯粹是为了协助调试。 RTOS 内核本身只通过句柄引用定时器，而不是通过其名称。</p>
</li>
<li><p>xTimerPeriod</p>
<p>定时器的周期。周期以滴答为单位，宏 pdMS_TO_TICKS() 可用于 将以毫秒为单位的时间转换为以滴答为单位的时间。</p>
</li>
<li><p>uxAutoReload</p>
<p>如果 uxAutoReload 设置为 pdTRUE， 那么定时器将以 xTimerPeriod 参数设置的频率重复过期。如果 uxAutoReload 设置为 pdFALSE，则此定时器为一次性定时器， 它会在到期后进入休眠状态。</p>
</li>
<li><p>pvTimerID</p>
<p>分配给正在创建的定时器的标识符。通常情况下， 当同一回调函数分配给多个定时器时，该 ID 将用于定时器回调函数， 以识别哪个定时器过期，或者与 vTimerSetTimerID 和 pvTimerGetTimerID()API 函数一起用于在定时器回调函数调用之间保存值。</p>
</li>
<li><p>pxCallbackFunction</p>
<p>定时器到期时调用的函数。回调函数必须具有 TimerCallbackFunction_t 定义的原型，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vCallbackFunction</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果定时器创建成功， 则返回新创建的定时器的句柄。如果由于剩余的 FreeRTOS 堆不足以分配定时器结构体而无法创建定时器， 则返回 NULL。</li>
</ul>
<h3 id="xTimerStart"><a href="#xTimerStart" class="headerlink" title="xTimerStart"></a>xTimerStart</h3><p>xTimerStart 用于启动之前使用 xTimerCreate API 函数创建的定时器。如果定时器已经启动且已处于活跃状态， 则 xTimerStart()</p>
<p> 具有与 xTimerReset API 函数相同的功能。</p>
<p>在 RTOS 调度器启动之前调用 xTimerStart() 是有效的， 但是完成此操作后，直到启动 RTOS 调度器之前，定时器都不会真正启动。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( xTimerStart(xTimer, xBlockTime ) != pdPASS ) &#123;</span><br><span class="line">     <span class="comment">// 启动失败的处理</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xTimer</p>
<p>正在启动&#x2F;重新启动的定时器的句柄。</p>
</li>
<li><p>xBlockTime</p>
<p>在调用 xTimerStart 时队列已满的情况下，调用任务处于阻塞状态以等待启动命令成功发送到定时器命令队列的时间（单位：滴答）。</p>
<p>如果在 RTOS 调度器启动之前就调用 xTimerStart ，则 xBlockTime 将被忽略</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li><p>在经过 xBlockTime 个滴答后，启动命令依旧无法发送至定时器命令队列，则返回 pdFAIL</p>
</li>
<li><p>如果能将此命令成功发送到定时器命令队列，则返回 pdPASS</p>
<p>实际处理命令的时间取决于定时器服务&#x2F;守护进程任务相对于系统中其他任务的优先级，尽管定时器到期时间与实际调用 xTimerStart  的时间有关。</p>
<p>定时器服务&#x2F;守护进程任务的优先级由 configTIMER_TASK_PRIORITY 配置常量设置。</p>
</li>
</ul>
<h3 id="xTimerStartFromISR"><a href="#xTimerStartFromISR" class="headerlink" title="xTimerStartFromISR"></a>xTimerStartFromISR</h3><p>从中断服务例程调用的 xTimerStart() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( xTimerStartFromISR( xBacklightTimer,&amp;xHigherPriorityTaskWoken ) != pdPASS ) &#123;</span><br><span class="line">    <span class="comment">// 启动失败的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xTimer</p>
<p>正在启动&#x2F;重新启动的定时器的句柄。</p>
</li>
<li><p>pxHigherPriorityTaskWoken</p>
<p>定时器服务&#x2F;守护进程任务大部分时间都处于“阻塞”状态，等待消息到达定时器命令队列。调用 xTimerStartFromISR() 会将消息写入定时器命令队列，从而让定时器服务&#x2F;守护进程任务转换为非阻塞状态。</p>
<p>如果调用 xTimerStartFromISR() 导致定时器服务&#x2F;守护进程任务退出阻塞状态，并且定时器服务&#x2F;守护进程任务的优先级等于或高于当前执行的任务 （被中断的任务），则 *pxHigherPriorityTaskWoken 将在 xTimerStartFromISR() 函数内部被设置为 pdTRUE。如果 xTimerStartFromISR () 将此值设置为 pdTRUE， 那么应在退出中断之前执行上下文切换。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<p>如果启动命令无法发送至定时器命令队列，则返回 pdFAIL。如果命令成功发送至定时器命令队列， 则返回 pdPASS。实际处理命令的时间取决于定时器服务&#x2F;守护进程任务相对于系统中其他任务的优先级， 尽管定时器到期时间是相对于实际调用 xTimerStartFromISR() 的时间而言。定时器服务&#x2F;守护进程 任务优先级由 configTIMER_TASK_PRIORITY 配置常量设置。</p>
<h3 id="xTimerStop"><a href="#xTimerStop" class="headerlink" title="xTimerStop"></a>xTimerStop</h3><p>停止先前使用 xTimerStart()、xTimerReset()、xTimerStartFromISR()、xTimerResetFromISR()、xTimerChangePeriod() 和xTimerChangePeriodFromISR() API 函数创建的定时器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xTimerStop(xTimer, xBlockTime);</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xTimer</p>
<p>正在停止的定时器的句柄。</p>
</li>
<li><p>xBlockTime</p>
<p>指定在调用 xTimerStop 时队列已满的情况下，调用任务处于阻塞状态以等待停止命令成功发送到定时器命令队列的时间（单位：滴答）。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li><p><em>pdFAIL</em></p>
<p>如果在 xBlockTime 滴答已过之后仍无法向定时器命令队列发送删除命令，则返回 pdFAIL</p>
</li>
<li><p>pdPASS</p>
<p>如果能将此命令成功发送到定时器命令队列，则返回 pdPASS</p>
</li>
</ul>
<h3 id="xTimerDelete"><a href="#xTimerDelete" class="headerlink" title="xTimerDelete"></a>xTimerDelete</h3><p>xTimerDelete() 可删除之前使用 xTimerCreate() 函数创建的定时器。</p>
<p>请注意，删除静态分配的定时器时， 在 xTimerIsTimerActive() 指示该定时器处于非活动状态之前，无法重复使用其静态内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">(TimerHandle_t xTimer,TickType_t xBlockTime)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p><em>xTimer</em></p>
<p>正在删除的定时器的句柄。</p>
</li>
<li><p><em>xBlockTime</em></p>
<p>指定在调用 xTimerDelete() 时队列已满的情况下， 调用任务处于阻塞状态以等待删除命令成功发送到定时器命令队列的时间 （单位：滴答）。如果 在 RTOS 调度器启动前调用 xTimerDelete()，xBlockTime 将被忽略。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果在 xBlockTime 滴答已过之后仍无法向定时器命令队列发送删除命令， 则返回 pdFAIL。</li>
<li>如果能将此命令成功发送到定时器命令队列，则返回 pdPASS。实际处理命令的时间 取决于定时器服务&#x2F;守护进程任务相对于系统中其他任务的优先级 。定时器服务&#x2F;守护进程任务的优先级由 configTIMER_TASK_PRIORITY 配置常量设置。</li>
</ul>
<h3 id="XTimerlsTimerActive"><a href="#XTimerlsTimerActive" class="headerlink" title="XTimerlsTimerActive"></a>XTimerlsTimerActive</h3><p>查询软件定时器是否处于活动或休眠状态。</p>
<p>如果出现以下情况，定时器将处于休眠状态：</p>
<ol>
<li>已创建但尚未启动</li>
<li>这是一个尚未重启的过期的一次性计时器。</li>
</ol>
<p>xTimerStart()、xTimerReset()、xTimerStartFromISR()、xTimerResetFromISR()、xTimerChangePeriod() 和xTimerChangePeriodFromISR() 函数都可以用于将定时器转换为活跃状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerIsTimerActive</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><p>xTimer</p>
<p>被查询的定时器。</p>
</li>
</ul>
<p><strong>返回：</strong></p>
<ul>
<li>如果定时器处于休眠状态，将返回 pdFALSE。</li>
<li>如果定时器处于活动状态，将返回 pdFALSE 以外的值。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskHandle_t  start_handler;</span><br><span class="line">TimerHandle_t timer1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart0_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\r\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timerCallback</span><span class="params">(TimerHandle_t xTimer)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timer\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 时钟初始化</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">    <span class="comment">// 配置GPIO模式</span></span><br><span class="line">    gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    NVIC_SetPriorityGrouping(NVIC_PRIGROUP_PRE4_SUB0);</span><br><span class="line"></span><br><span class="line">    GPIO_config();</span><br><span class="line">    Usart0_init();</span><br><span class="line">    </span><br><span class="line">    timer1 = xTimerCreate(<span class="string">&quot;Timer1&quot;</span>, pdMS_TO_TICKS(<span class="number">1000</span>), pdTRUE, (<span class="type">void</span> *)<span class="number">1</span>, timerCallback);</span><br><span class="line">    xTimerStart(timer1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>小技巧</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FreeRTOSConfig.h </span></span><br><span class="line"><span class="comment">// 注释掉原有内容</span></span><br><span class="line"><span class="comment">//#define configASSERT( x ) if( ( x ) == 0 ) &#123; taskDISABLE_INTERRUPTS(); for( ;; ); &#125;</span></span><br><span class="line"><span class="comment">//#define configASSERT( x ) 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 替换成新的内容：断言结果通过printf输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vAssertCalled(char, int) printf(<span class="string">&quot;-&gt; Error: %s, %d\r\n&quot;</span>, char, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configASSERT( x ) <span class="keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span></span><br></pre></td></tr></table></figure>

<p>二、<strong>定时器回调函数为什么不可以阻塞</strong></p>
<p><strong>定时器回调函数的执行方式</strong>： FreeRTOS 定时器回调函数是在定时器管理任务（<code>vTimerTask</code>）中执行的，这意味着定时器回调函数会在 <code>vTimerTask</code> 任务的上下文中执行。这个任务的优先级通常较低，它会在其他更高优先级的任务（包括中断）执行之后被调度。</p>
<p><strong>阻塞操作</strong>： 在 FreeRTOS 中，如果定时器回调函数中调用了 <code>vTaskDelay</code>、<code>vTaskDelayUntil</code> 或类似的 API 来显式地让自己“阻塞”，或者如果回调函数执行了一个需要较长时间的操作（例如等待 I&#x2F;O 或同步操作），那么它会占用 <code>vTimerTask</code> 的执行时间，导致其他定时器的回调函数被延迟执行。</p>
<p><strong>任务调度</strong>： 如果一个定时器回调函数在执行过程中阻塞了，那么 FreeRTOS 将不会在此期间调度其他定时器回调函数。由于定时器回调函数是由同一个任务 (<code>vTimerTask</code>) 执行的，如果 <code>vTimerTask</code> 被阻塞，其他定时器的回调也会被延迟直到 <code>vTimerTask</code> 完成当前任务。因此，多个定时器回调函数的并行性可能会受到影响。</p>
<p>三、<strong>调用 xTimerDelete 删除了该定时器，然后再次调用 xTimerStart，仍然可以重新启动同一个定时器</strong></p>
<p>？</p>
<p>四、<strong>软件定时器启动后是如何计数的</strong></p>
<p>在 FreeRTOS 中，定时器的计时值是通过系统的 Tick 定时器中断来减少的，但这个过程并不会占用额外的时间片，它是在 <strong>中断上下文</strong> 中执行的。</p>
<p><strong>Tick 定时器中断</strong>（也叫做时钟中断）是由硬件定时器触发的，通常会以固定的时间间隔触发（例如，每 1 毫秒）。</p>
<p>每次 Tick 中断发生时，FreeRTOS 会执行一个中断服务例程（ISR），并执行以下几项重要操作：</p>
<ol>
<li><strong>增加 Tick 计数器</strong>：每次 Tick 中断时，系统的 Tick 计数器会增加 1。</li>
<li><strong>更新定时器的计时值</strong>：FreeRTOS 会检查所有软件定时器的计时值（xTimeToExpiration），并在每次 Tick 中断时，将这些定时器的计时值减去 1。</li>
</ol>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RTX51系统</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>RTX51 是 KEIL 公司开发的针对 8051 系列单片机的多任务实时操作系统（RTOS）。它提供了<strong>多任务处理</strong>能力，允许程序以<strong>并行</strong>方式执行，适用于对时间要求严格的嵌入式应用。RTX51 具有简单的 API 和任务调度机制，使开发者能够更方便地管理任务和资源，确保系统的响应性和稳定性。RTX51 系统提供了任务管理、任务调度、任务通讯、定时器、信号量、邮箱等实时操作系统的基本功能，并与 Keil 公司的 C51 编译器紧密集成，从而方便开发人员进行开发和调试。</p>
<blockquote>
<p>RTX51 的多任务处理能力指的是系统能够同时管理和执行多个任务或进程的能力。多个任务看似同时运行，实际上是通过快速切换来实现的。这种切换由操作系统的调度器控制。</p>
</blockquote>
<p><strong>多核和多 CPU</strong></p>
<ul>
<li><p><strong>单核与多核</strong>：</p>
<ul>
<li><p><strong>单核</strong>：系统只有一个处理核心，所有任务都由这一核心处理。虽然能够完成基本的计算任务，但在同时执行多个任务时效率较低。</p>
</li>
<li><p><strong>多核</strong>：系统有多个处理核心（如双核、四核等），每个核心可以独立执行任务。这种架构可以提高并行处理能力，允许多个任务同时进行，从而提升整体性能。</p>
</li>
</ul>
</li>
<li><p><strong>单 CPU 与多 CPU</strong>：</p>
<ul>
<li><p><strong>单 CPU</strong>：系统只配备一个中央处理单元（CPU），类似于单核，但可以是一个复杂的多核处理器。</p>
</li>
<li><p><strong>多 CPU</strong>：系统配备多个 CPU，每个 CPU 可以独立处理任务，通常用于需要极高性能和处理能力的服务器</p>
</li>
<li><p>或高性能计算机。多 CPU 系统通过并行处理可以显著提高计算能力。</p>
</li>
</ul>
</li>
</ul>
<p><strong>RTX51 包含两个版本：</strong></p>
<p>RTX51 Tiny</p>
<ul>
<li>RTX51 Tiny是一个非常小型的实时操作系统，具有基本的任务调度功能，包括任务优先级和时间片轮转等RTX51 Tiny适用于基于51系列单片机的应用程序，特别是对于小型和简单的应用程序，因为它不需要太多的RAM和ROM资源。</li>
<li>相对于 RTX51 Full 不具备如下功能：<ul>
<li>由循环多任务处理和信号实现任务切换</li>
<li>不支持优先任务切换</li>
<li>不包含信息子程序</li>
<li>无存储器库分配子程序</li>
</ul>
</li>
</ul>
<p>RTX51 Full</p>
<ul>
<li>RTX51 Full则是一个功能更为强大的实时操作系统，它不仅支持基本的任务调度功能，还提供了更多的RTOS特性，例如信号量、邮箱、消息队列、事件标志和互斥量等，使得它更加适合于需要更高级RTOS特性的应用程序。</li>
</ul>
<p>RTX51 Tiny是一个轻量级的RTOS，适用于简单的应用程序，而RTX51 Full则提供了更多的RTOS特性，适用于更为复杂的应用程序。</p>
<h2 id="STC8H"><a href="#STC8H" class="headerlink" title="STC8H"></a>STC8H</h2><h3 id="RTX51-Tiny-环境搭建"><a href="#RTX51-Tiny-环境搭建" class="headerlink" title="RTX51 Tiny 环境搭建"></a>RTX51 Tiny 环境搭建</h3><ol>
<li>新建一个项目</li>
<li>打开keil安装目录，来到<code>C51\RtxTiny2\SourceCode</code>目录，拷贝<code>Conf_tny.A51</code>和<code>RTX51TNY.LIB</code>到项目中。</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51bin.png" alt="RTX51bin"></p>
<ol start="3">
<li>打开配置，来到<code>Target</code>中，将<code>Operating system</code>修改为<code>RTX-51 Tny</code></li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51IDE.png" alt="RTX51IDE"></p>
<ol start="4">
<li>新建好<code>main.c</code>, 代码如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RTX51TNY.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC8H.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P5.3 闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_init</span><span class="params">()</span> &#123;</span><br><span class="line">	P5M1 &amp;= ~<span class="number">0x08</span>; P5M0 &amp;= ~<span class="number">0x08</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数名可随意, 建议不要使用start, 会和I2C.h里的Start冲突</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_start</span><span class="params">()</span> _task_ 0 &#123;</span><br><span class="line">	sys_init();</span><br><span class="line">	<span class="comment">// 创建任务 1</span></span><br><span class="line">	os_create_task(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 结束任务 0</span></span><br><span class="line">	os_delete_task(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_1</span><span class="params">()</span> _task_ 1 &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P53 = <span class="number">1</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">		</span><br><span class="line">		P53 = <span class="number">0</span>;</span><br><span class="line">		os_wait1(K_TMO);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不再有main函数</li>
<li>代码入口为标记为 <code>_task_ 0</code>的函数。</li>
<li><code>_task_</code>标记的函数，表示这个是独立的任务，多个task可以同时执行。</li>
</ul>
<h3 id="RTX51-注意事项"><a href="#RTX51-注意事项" class="headerlink" title="RTX51 注意事项"></a>RTX51 注意事项</h3><p>一、<strong>RTX51 对于系统硬件的要求</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51renwu.png" alt="RTX51renwu"></p>
<p>二、<strong>RTX51 任务的状态及定义</strong></p>
<p>RTX51 区分 2 类任务: <strong>快速任务</strong>和<strong>标准任务</strong>。快速任务有很快的响应速度，每个快速任务使用 8051 一个单独的寄存器组，并且有自己的堆栈区域。RTX51 支持最大同时有 3 个快速任务。标准任务需要多一点的时间来进行任务切换，因此使用的内部 RAM 相对快速任务要少，所有的标准任务共用 1 个寄存器组和堆栈。当任务切换的时候，当前任务的寄存器状态和堆栈内容转移到外部存储器中。</p>
<p>在 RTX51 Full 中，可以通过特定的 API 或函数来创建任务，并在创建时指定任务的类型（快速或标准）。<strong>RTX51 Tiny 则不支持快速任务。</strong></p>
<p>RTX51 FULL 支持任务最多达 64 个，但一般 RTX51 TINY 支持最大 16 个标准任务。</p>
<p>三、<strong>RTX51 自带延迟与 delay_ms() 延时的区别</strong></p>
<p>在 RTX51 Tiny 中 共有三个等待延时函数分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait</span>            <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ, </span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">int</span> dummy)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait1</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">os_wait2</span>           <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> typ,</span></span><br><span class="line"><span class="params">                                         <span class="type">unsigned</span> <span class="type">char</span> ticks)</span>;</span><br><span class="line"><span class="comment">// 参数如下：</span></span><br><span class="line"><span class="comment">/* constants for os_wait function：也就是等待函数的 typ */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_SIG 0x01 <span class="comment">/* 等待一个信号。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_TMO 0x02 <span class="comment">/* 等待由 ticks 指定的超时时间。*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_IVL 0x80 <span class="comment">/* 等待由 ticks 指定的时间间隔。*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数中：K_TMO、K_IVL 看解释十分相似，但其实区别很大：</span></span><br><span class="line"><span class="comment">当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。</span></span><br><span class="line"><span class="comment">当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>os_wait</strong></p>
<p>暂停当前任务，等待一个或多个事件；例如一个时间间隔、超时或来自其他任务或中断的信号。typ 参数指定要等待的事件或事件组合，可以是上述参数中的常量之一：</p>
<p>typ 可以通过竖线（|）字符进行逻辑或操作。例如，K_TMO | K_SIG 表示任务等待超时或信号。</p>
<ul>
<li>**<code>typ</code>**：这是一个指定等待类型的参数。RTX51 中可能定义了多种等待类型，如等待事件、消息、信号量等。具体的类型值取决于 RTX51 的具体实现和文档。</li>
<li>**<code>ticks</code>**：这是等待的时间长度，以操作系统的“tick”为单位。一个 tick 的长度取决于 RTX51 的配置，通常与系统的时钟频率有关。</li>
<li>**<code>dummy</code>**：这个参数在大多数实现中可能并不真正使用，而是为了保持函数签名的兼容性或预留未来的扩展。在一些版本中，这个参数可能已经被移除或替换为更有用的参数。</li>
</ul>
<p><strong>os_wait1</strong></p>
<p>暂停当前任务并等待事件发生。os_wait1 函数是 os_wait 函数的一个子集，只支持 K_SIG 这个值，表示等待一个信号。</p>
<p><strong>os_wait2</strong></p>
<p>同 os_wait 基本一致</p>
<blockquote>
<p>当 K_SIG 和 K_IVL 组合使用时，必须使用 <code>os_reset_interval</code> 函数来消除定时器延迟问题。</p>
</blockquote>
<p><strong>以 os_wait2 为例 与 delay_ms() 区别在：</strong></p>
<p>在 RTOS 中，如果 delay_ms() 被用于多个任务，它可能会导致任务调度的不公平或不可预测性，因为<strong>任务在等待期间会阻塞其他任务的执行</strong>。</p>
<p>如果多个任务都使用 delay_ms() 等待 100ms，那么每个任务都会独立地进入延时状态，并阻塞其他任务的执行（除非RTOS有特别的机制来处理这种情况）。</p>
<p>举个例子：</p>
<ol>
<li><p>假设我有 三个任务分别为 func1、func2、func3，三个任务都设置 delay_ms 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 3 &#x3D; 450ms、300ms、150ms，因为他们</p>
</li>
<li><p>假设我有 三个任务分别为 func1、func2、func3三个任务，其中 func1 设置 delay_ms，其他都设置 K_TMO 分别为 150ms、100ms、50ms，那么当这三个任务执行时，他们真正的等待时间就会变成 150 x 2 &#x3D; 300ms、200ms、100ms，因为他们</p>
</li>
</ol>
<blockquote>
<p>在 RTX51 Tiny 中，当多个任务处于休眠状态时，它们会共享同一个时间片。这意味着，当系统调度时，如果所有处于休眠状态的任务都没有被唤醒，调度器不会为它们分配不同的时间片。实际上，只有在任务被唤醒并准备好执行时，调度器才会考虑这些任务。</p>
<p>因此，在多个任务休眠的情况下，系统不会为每个休眠任务分配独立的时间片。它们会在系统处于闲置状态时共用资源，直到有任务需要执行或有事件发生以唤醒其中的某个任务。</p>
</blockquote>
<p>四、<strong>K_TMO 与 K_IVL 的区别</strong></p>
<p>当使用 K_TMO 时，任务从调用 os_wait 函数的当前时刻开始计时，等待指定的时间（以系统ticks 为单位）后恢复为就绪状态。这个时间段不包括任务在等待之前和之后执行的时间。<br>当使用 K_IVL 时，任务从上一次执行结束（或上一次调用 os_wait 并返回）的时刻开始计时，等待指定的时间（以系统ticks为单位）后再次执行。这个时间段包括任务自身的执行时间。</p>
<p><strong>K_SIG 信号等待</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、报错：<strong>WARNING L7: MODULE NAME NOT UNIQUE MODULE:  .\Objects\Conf_tny.obj (?RTX51_TINY_KERNAL)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/RTX51/RTX51Bug1.png" alt="RTX51Bug1"></p>
<p>将 Conf_tny.A51 放在 RTX51TNY.LIB 前面即可</p>
]]></content>
      <categories>
        <category>RTOS</category>
      </categories>
      <tags>
        <tag>RTX51</tag>
      </tags>
  </entry>
  <entry>
    <title>SmartConfig</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/SmartConfig/</url>
    <content><![CDATA[<p>SmartConfig 是一种用于 ESP32 系列设备的快速配置 Wi-Fi 网络的技术。它通过智能手机或其他智能设备将 Wi-Fi 配置信息（SSID、密码）无线传输到 ESP32 设备中，免去手动输入的麻烦，适用于没有显示屏或输入设备的物联网设备。</p>
<p>SmartConfig 主要用于设备首次连接 Wi-Fi 网络时，或在需要切换网络的情况下。<strong>它通过广播 Wi-Fi 配置信息，将网络设置传输给ESP32 设备，后者接收到信息后自动连接到指定的 Wi-Fi 网络。</strong></p>
<h2 id="SmartConfig工作原理"><a href="#SmartConfig工作原理" class="headerlink" title="SmartConfig工作原理"></a>SmartConfig工作原理</h2><p><strong>手机App生成配置信息</strong>：用户通过手机 APP（如 ESP32 提供的 SmartConfig 工具或自定义的 App）选择 Wi-Fi 网络并输入密码。手机会将这些信息通过 UDP 广播发送到局域网中的 ESP32 设备。</p>
<p><strong>ESP32设备接收配置</strong>：ESP32 设备在启动时，开启 SmartConfig 服务并监听特定的 UDP 广播端口。当它接收到从手机发送的 Wi-Fi 配置包时，便获取到 Wi-Fi SSID 和密码。</p>
<p><strong>连接Wi-Fi网络</strong>：ESP32 设备使用接收到的 SSID 和密码连接 Wi-Fi，并通过设置完成后可以执行其他业务逻辑。</p>
<p><strong>反馈连接结果</strong>：连接成功后，ESP32 设备可以通过 LED 灯或其他指示器向用户反馈状态（例如，通过蓝色 LED 表示连接成功）。</p>
<h2 id="ESP32实现"><a href="#ESP32实现" class="headerlink" title="ESP32实现"></a>ESP32实现</h2><h3 id="ESP32设备代码"><a href="#ESP32设备代码" class="headerlink" title="ESP32设备代码"></a>ESP32设备代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_wifi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_netif.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_smartconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FreeRTOS 事件组，用于在我们连接并准备好发送请求时发出信号。</span></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_wifi_event_group;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事件组允许为每个事件使用多个位，但我们只关心一个事件——我们是否已连接到 AP 并获得 IP 地址 */</span></span><br><span class="line"><span class="comment">// CONNECTED_BIT：当 Wi-Fi 连接成功并获得 IP 地址时，会设置这个标志位。</span></span><br><span class="line"><span class="comment">// ESPTOUCH_DONE_BIT：当 SmartConfig 获取到 Wi-Fi SSID 和密码时，会设置这个标志位。</span></span><br><span class="line"><span class="comment">// *TAG：用于日志打印时作为标签标识。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CONNECTED_BIT = BIT0;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ESPTOUCH_DONE_BIT = BIT1;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;smartconfig_example&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SmartConfig 任务</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">smartconfig_example_task</span><span class="params">(<span class="type">void</span> * parm)</span> &#123;</span><br><span class="line">    EventBits_t uxBits;</span><br><span class="line">    <span class="comment">// 设置 SmartConfig 模式的类型，注意这里要与我们 App 的模式一致，不然会不兼容</span></span><br><span class="line">    ESP_ERROR_CHECK( esp_smartconfig_set_type(SC_TYPE_ESPTOUCH) );</span><br><span class="line">    <span class="comment">// 使用默认配置并启动 SmartConfig 配置</span></span><br><span class="line">    <span class="comment">// 启动后设备开始监听来自手机或其他设备的 SmartConfig 信号。</span></span><br><span class="line">    <span class="type">smartconfig_start_config_t</span> cfg = SMARTCONFIG_START_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK( esp_smartconfig_start(&amp;cfg) );</span><br><span class="line">    <span class="comment">// 死循环等待事件信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// xEventGroupWaitBits() 函数会阻塞当前任务，直到事件组中的某些标志位被设置。</span></span><br><span class="line">        uxBits = xEventGroupWaitBits(s_wifi_event_group, CONNECTED_BIT | ESPTOUCH_DONE_BIT, <span class="literal">true</span>, <span class="literal">false</span>, portMAX_DELAY);</span><br><span class="line">        <span class="keyword">if</span>(uxBits &amp; CONNECTED_BIT) &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;WiFi Connected to ap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(uxBits &amp; ESPTOUCH_DONE_BIT) &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;smartconfig over&quot;</span>);</span><br><span class="line">            <span class="comment">// 停止 SmartConfig 过程，释放相关资源。</span></span><br><span class="line">            esp_smartconfig_stop();</span><br><span class="line">            <span class="comment">// 删除当前任务</span></span><br><span class="line">            vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_handler</span><span class="params">(<span class="type">void</span>* arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                                <span class="type">int32_t</span> event_id, <span class="type">void</span>* event_data)</span>&#123;</span><br><span class="line">									</span><br><span class="line">	<span class="comment">// 当Wi-Fi STA 模式启动时，启动SmartConfig任务。								</span></span><br><span class="line">    <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) &#123;</span><br><span class="line">        xTaskCreate(smartconfig_example_task, <span class="string">&quot;smartconfig_example_task&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// Wi-Fi连接丢失时，会重新连接Wi-Fi。		</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) &#123;</span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">        xEventGroupClearBits(s_wifi_event_group, CONNECTED_BIT);</span><br><span class="line">	<span class="comment">// Wi-Fi连接成功并获得IP地址时，设置 CONNECTED_BIT 标志，表示设备已连接。	</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) &#123;</span><br><span class="line">        xEventGroupSetBits(s_wifi_event_group, CONNECTED_BIT);</span><br><span class="line">	<span class="comment">// 扫描完成事件	</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_SCAN_DONE) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Scan done&quot;</span>);</span><br><span class="line">	<span class="comment">// 找到可用的频道事件	</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_FOUND_CHANNEL) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Found channel&quot;</span>);</span><br><span class="line">	<span class="comment">// 当SmartConfig获取到Wi-Fi SSID和密码时，更新Wi-Fi配置并重新连接。	</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_GOT_SSID_PSWD) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Got SSID and password&quot;</span>);</span><br><span class="line">		<span class="comment">// 当 SC_EVENT_GOT_SSID_PSWD 事件触发时，表示SmartConfig已经成功获取了Wi-Fi的SSID和密码。</span></span><br><span class="line">		<span class="comment">// 这些信息会被保存到 wifi_config_t 结构中。</span></span><br><span class="line">        <span class="type">smartconfig_event_got_ssid_pswd_t</span> *evt = (<span class="type">smartconfig_event_got_ssid_pswd_t</span> *)event_data;</span><br><span class="line">        <span class="type">wifi_config_t</span> wifi_config;</span><br><span class="line">        <span class="type">uint8_t</span> ssid[<span class="number">33</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">uint8_t</span> password[<span class="number">65</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">uint8_t</span> rvd_data[<span class="number">33</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">        bzero(&amp;wifi_config, <span class="keyword">sizeof</span>(<span class="type">wifi_config_t</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(wifi_config.sta.ssid, evt-&gt;ssid, <span class="keyword">sizeof</span>(wifi_config.sta.ssid));</span><br><span class="line">        <span class="built_in">memcpy</span>(wifi_config.sta.password, evt-&gt;password, <span class="keyword">sizeof</span>(wifi_config.sta.password));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 CONFIG_SET_MAC_ADDRESS_OF_TARGET_AP 选项启用时，</span></span><br><span class="line"><span class="comment">这段代码会在 SmartConfig 事件 SC_EVENT_GOT_SSID_PSWD 中捕获到目标 AP 的 SSID 和 密码 后</span></span><br><span class="line"><span class="comment">同时设置目标 AP 的 MAC 地址（BSSID）。</span></span><br><span class="line"><span class="comment">这使得 ESP32 只会连接到指定的 AP，而忽略其他具有相同 SSID 的 AP。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SET_MAC_ADDRESS_OF_TARGET_AP</span></span><br><span class="line">        wifi_config.sta.bssid_set = evt-&gt;bssid_set;</span><br><span class="line">        <span class="keyword">if</span> (wifi_config.sta.bssid_set == <span class="literal">true</span>) &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;Set MAC address of target AP: &quot;</span>MACSTR<span class="string">&quot; &quot;</span>, MAC2STR(evt-&gt;bssid));</span><br><span class="line">            <span class="built_in">memcpy</span>(wifi_config.sta.bssid, evt-&gt;bssid, <span class="keyword">sizeof</span>(wifi_config.sta.bssid));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(ssid, evt-&gt;ssid, <span class="keyword">sizeof</span>(evt-&gt;ssid));</span><br><span class="line">        <span class="built_in">memcpy</span>(password, evt-&gt;password, <span class="keyword">sizeof</span>(evt-&gt;password));</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;SSID:%s&quot;</span>, ssid);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;PASSWORD:%s&quot;</span>, password);</span><br><span class="line">        <span class="keyword">if</span> (evt-&gt;type == SC_TYPE_ESPTOUCH_V2) &#123;</span><br><span class="line">            ESP_ERROR_CHECK( esp_smartconfig_get_rvd_data(rvd_data, <span class="keyword">sizeof</span>(rvd_data)) );</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;RVD_DATA:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">33</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, rvd_data[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 先关闭连接，随后调用 esp_wifi_set_config() 配置Wi-Fi，并尝试连接。</span></span><br><span class="line">        ESP_ERROR_CHECK( esp_wifi_disconnect() );</span><br><span class="line">        ESP_ERROR_CHECK( esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config) );</span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">	<span class="comment">// SmartConfig过程完成，发送了确认消息。	</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_SEND_ACK_DONE) &#123;</span><br><span class="line">        xEventGroupSetBits(s_wifi_event_group, ESPTOUCH_DONE_BIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">initialise_wifi</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    s_wifi_event_group = xEventGroupCreate();</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    <span class="type">esp_netif_t</span> *sta_netif = esp_netif_create_default_wifi_sta();</span><br><span class="line">    assert(sta_netif);</span><br><span class="line"></span><br><span class="line">    <span class="type">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_init(&amp;cfg) );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		注册三个事件：</span></span><br><span class="line"><span class="comment">		监听所有的 WIFI 事件</span></span><br><span class="line"><span class="comment">		监听 Wi-Fi 连接成功并获得 IP 地址时的事件</span></span><br><span class="line"><span class="comment">		监听所有的 SmartConfig 事件</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    ESP_ERROR_CHECK( esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, <span class="literal">NULL</span>) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;event_handler, <span class="literal">NULL</span>) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_event_handler_register(SC_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, <span class="literal">NULL</span>) );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置 WIFI 模式为 STA，并启动</span></span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_STA) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_start() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 调用 nvs_flash_init() 初始化非易失性存储（NVS）</span></span><br><span class="line">    ESP_ERROR_CHECK( nvs_flash_init() );</span><br><span class="line">	<span class="comment">// 初始化 Wi-Fi</span></span><br><span class="line">    initialise_wifi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>ESP32 的 SmartConfig 的 App 叫 ESP touch</p>
<p><a href="https://www.espressif.com/en/support/download/apps?keys=&field_technology_tid%5B%5D=20">ESP touch官方下载地址</a></p>
<p>下载完成后，我们的手机先要连接到一个 WiFi，然后打开  ESP touch，模式要选择与代码中设置的一致，然后操作即可。</p>
]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>BLE蓝牙</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/BLE%E8%93%9D%E7%89%99/</url>
    <content><![CDATA[<p>BLE（Bluetooth Low Energy，蓝牙低功耗）是一种无线技术标准，旨在提供低功耗和低延迟的无线通信。它是蓝牙技术的一种变体，特别适用于对电池寿命和功耗有严格要求的应用。</p>
<p><strong>BLE 的特点</strong></p>
<ul>
<li>低功耗：BLE 设备在待机状态下消耗极少的电量，适合长时间运行的设备。</li>
<li>短距离通信：典型的通信范围为 10 米至 100 米，具体取决于环境和设备。</li>
<li>快速连接：BLE 设备能够快速连接和断开，适合需要快速响应的应用。</li>
<li>多设备连接：支持多个设备同时连接，适合物联网（IoT）场景。</li>
</ul>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>BLE 蓝牙协议栈是蓝牙设备之间通信的基础架构。它定义了数据的传输方式、设备的发现机制、连接过程以及应用层的服务交互。蓝牙协议栈通常分为多个层级，每个层次实现不同的功能，确保设备之间的可靠通信。以下是BLE协议栈的一个大致分层架构：</p>
<p><strong>物理层（Physical Layer, PHY）</strong></p>
<p>物理层是 BLE 协议栈的最低层，定义了如何通过无线电波传输数据。BLE 使用的频段为 2.4 GHz ISM（工业、科学和医学）频段，具体划分为 40 个通道（其中 3 个是用于广告数据的）。每个通道的带宽为1 MHz，传输速度最高为 1 Mbps。</p>
<ul>
<li>传输模式：基于频率跳跃的扩频技术（FHSS），避免干扰。</li>
<li>信号编码：采用GFSK（Gaussian Frequency Shift Keying）调制技术，支持较低的功耗。</li>
</ul>
<p><strong>链路层（Link Layer）</strong></p>
<p>链路层负责数据包的格式、信道管理、设备发现、连接建立和连接维持等任务。它处理 BLE 设备之间的基础通信，负责信号的发送、接收和处理低层数据。</p>
<ul>
<li>设备发现：BLE 设备会广播自己的存在，其他设备可以扫描这些广告包来发现目标设备。</li>
<li>连接管理：链路层还负责连接的建立、断开、连接参数的协商和维护。</li>
<li>分包与重传：链路层实现了数据包的分割和重传机制，确保数据的完整传输。</li>
</ul>
<p><strong>控制器层（Controller Layer）</strong></p>
<p>控制器层通常包括物理层和链路层，它负责所有与硬件直接交互的功能。在一些高端应用中，控制器层可能是单独的硬件模块，负责处理BLE 信号的传输和接收。控制器层和主机层通过 HCI（Host Controller Interface）进行通信。</p>
<p><strong>主机层（Host Layer）</strong>⭐</p>
<p>主机层位于协议栈的上方，负责处理高层应用和管理设备的连接、服务发现、数据传输等任务。主机层实现了以下几个关键协议：</p>
<ul>
<li><p>GAP（Generic Access Profile）：负责设备间的发现、连接管理以及角色定义。GAP 协议定义了设备如何通过广播进行自我公开、如何扫描并建立连接，以及如何处理设备的连接和断开。它是 BLE 协议栈中管理设备访问行为的关键协议，确保设备能够在蓝牙网络中进行有效的通信。</p>
</li>
<li><p>L2CAP（Logical Link Control and Adaptation Protocol）：提供数据分段、组装和传输的功能，允许多个应用层协议共享底层链路。</p>
</li>
<li><p>ATT（Attribute Protocol）：用于设备间的属性数据交换。ATT 定义了如何存取蓝牙设备的各种数据（例如，传感器数据），通过服务和特性进行访问。</p>
</li>
<li><p>GATT（Generic Attribute Profile）：基于 ATT 协议之上的高层协议，定义了 BLE 设备之间数据交互的标准化方式。GATT 使用“服务”和“特性”模型，设备通过特性（characteristic）交换数据。</p>
</li>
</ul>
<p><strong>应用层（Application Layer）</strong></p>
<p>应用层是 BLE 协议栈的最高层，负责根据特定的应用需求处理业务逻辑。开发者可以在这一层设计 BLE 通信的具体行为，如控制设备、传输数据或处理用户输入等。应用层主要通过 GATT 协议进行操作，可以定义特定的服务和特性。例如：</p>
<ul>
<li>心率监测器服务（Heart Rate Service）</li>
<li>电池服务（Battery Service）</li>
<li>自定义服务（例如，温度传感器）</li>
</ul>
<p>此外，应用层也可以使用以下协议进行更高级的功能：</p>
<ul>
<li>SM（Security Manager）：用于加密和认证设备间的通信，确保数据的安全性。</li>
<li>L2CAP：提供面向连接的传输服务。</li>
</ul>
<ol start="6">
<li>安全管理层（Security Manager, SM）</li>
</ol>
<p>安全管理层负责对设备进行配对、身份验证和加密。BLE 设备可以通过配对建立加密连接，以确保数据在传输过程中的机密性和完整性。常见的安全机制包括：</p>
<ul>
<li>身份验证：通过 PIN 码、键盘、显示器或其他方式进行身份认证。</li>
<li>加密：采用 AES 加密算法保证数据的安全。</li>
<li>隐私：BLE 设备支持地址隐私，以避免设备被追踪。</li>
</ul>
<p><strong>在蓝牙通信过程中，GAP（Generic Access Profile）和 GATT（Generic Attribute Profile）是两个核心协议。二者又分别依赖于 ATT（Attribute Protocol）和 L2CAP（Logical Link Control and Adaptation Protocol）协议。</strong></p>
<ul>
<li><strong>GAP</strong>：管理设备的广播、扫描、连接建立和断开，决定设备的通信角色（中心、外围、广播者、观察者）。它是所有蓝牙连接的基础。</li>
<li><strong>GATT</strong>：依赖 GAP 协议建立的连接，负责数据的标准化交互。它基于 ATT 协议，提供数据读取、写入等功能，使用“服务”和“特性”的模型进行数据传输。GATT 将 ATT 中 attribute 的内容分为服务、特征、值或描述。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/GPAxieyijiagou.png" alt="GPAxieyijiagou"></p>
<blockquote>
<p><strong>这张图很好地展示了两者的关系：</strong></p>
<ol>
<li><strong>GAP</strong> 位于较高的逻辑层，主要处理设备发现、连接和访问角色管理。它依赖于下层协议（如L2CAP）来完成数据传输的支持。</li>
<li><strong>GATT</strong> 基于 ATT 协议，用于具体的数据交互。它在 GAP 建立的连接基础上工作，服务于应用数据的传输。</li>
</ol>
</blockquote>
<h3 id="GAP-协议"><a href="#GAP-协议" class="headerlink" title="GAP 协议"></a>GAP 协议</h3><p>GAP（Generic Access Profile）是蓝牙低功耗（BLE）协议栈的一部分，属于主机层（Host Layer）。它定义了<strong>设备如何发现彼此、如何连接、如何广播信息以及如何设置通信角色。</strong></p>
<p><strong>主要特点：</strong></p>
<p>GAP 协议定义了 BLE 设备的四种角色，角色的选择决定了设备在通信中的行为。</p>
<ul>
<li><p>设备角色：GAP定义了设备在BLE通信中的角色，包括：</p>
<ul>
<li><p>广播设备（Advertiser）：发送广播包以进行设备发现。</p>
</li>
<li><p>扫描设备（Scanner）：监听并响应广播包，发现其他设备。</p>
</li>
<li><p>主设备（Central）：发起连接的设备（通常是手机或主控制器）。</p>
</li>
<li><p>从设备（Peripheral）：被连接的设备（如传感器、穿戴设备）。</p>
</li>
</ul>
</li>
<li><p>设备发现：GAP定义了设备如何通过广播和扫描发现其他设备。设备可以处于可发现模式或不可发现模式。</p>
</li>
<li><p>连接管理：GAP负责建立、管理和终止连接。它处理连接间隔、超时和其他连接参数。</p>
</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>GAP 广泛应用于各种 BLE 设备之间的发现和连接过程，确保设备能够有效地找到并连接到彼此。</p>
<h3 id="GATT协议"><a href="#GATT协议" class="headerlink" title="GATT协议"></a>GATT协议</h3><p>GATT（Generic Attribute Profile）位于蓝牙低功耗（BLE）协议栈中的主机层（Host Layer），位于ATT（Attribute Protocol）之上。<br>它定义了设备之间如何交换数据和互动的规则，并使用“服务”和“特性”这种方式来规范通信，让不同设备可以按照统一的标准进行数据传输和操作。</p>
<p>GATT 定义了一个框架，将 ATT 的属性结构组织起来，分为服务、特征、值或描述。</p>
<p><strong>主要特点：</strong></p>
<ul>
<li><p>服务和特性：GATT 基于服务和特性构建，服务是一组相关的特性。每个服务和特性都有唯一的UUID标识符。</p>
</li>
<li><p>数据模型：GATT 使用层次结构的数据模型，设备通过服务和特性与其他设备进行交互。</p>
</li>
<li><p>数据传输方式：GATT 支持读取、写入、通知和指示等操作：</p>
<ul>
<li><p>读取（Read）：客户端可以请求服务器读取特性值。</p>
</li>
<li><p>写入（Write）：客户端可以向服务器写入特性值。</p>
</li>
<li><p>通知（Notify）：服务器可以主动向客户端发送特性值的变化。</p>
</li>
<li><p>指示（Indicate）：服务器向客户端发送特性值的变化，并等待客户端的确认。</p>
</li>
</ul>
</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>GATT通常用于传感器、健康设备、智能家居设备等场景，如心率监测器、温度传感器等。这些设备通过GATT服务和特性与其他BLE设备（如手机应用）进行数据交换。</p>
<h3 id="ATT协议"><a href="#ATT协议" class="headerlink" title="ATT协议"></a>ATT协议</h3><p><strong>ATT</strong>（<strong>Attribute Protocol</strong>）其实就是一种<strong>蓝牙设备间交换数据的规则</strong>。在蓝牙低能耗（BLE）设备之间通信时，数据通常是以“属性”（Attribute）的形式进行组织和交换的。ATT 协议就是管理这些数据的“规则本”，它规定了如何读取、写入或者修改这些属性。</p>
<p>ATT 协议中的<strong>属性</strong>就是数据的基本单位。每个属性都有一个“名字”（也就是<strong>UUID</strong>，可以理解为“标签”）和一些<strong>数据</strong>。</p>
<p><strong>属性的构成</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/bleattxy.png" alt="bleattxy"></p>
<ul>
<li><p><strong>属性句柄（Attribute Handle）</strong>：唯一标识属性的编号，用于访问属性。</p>
</li>
<li><p><strong>属性类型（Attribute Type）</strong>：标识属性的种类（如电池电量、心率等也就是我们说的 UUID）。</p>
</li>
<li><p><strong>属性值（Attribute Value）</strong>：存储实际的数据（如电池百分比、温度值等）。</p>
</li>
<li><p><strong>属性权限（Attribute Permissions）</strong>：定义对属性的访问权限（如可读、可写、通知等）。</p>
</li>
</ul>
<p><a href="http://www.corenchip.com/2280.html">UUID 查询表</a></p>
<h3 id="总结🙃🙃🙃"><a href="#总结🙃🙃🙃" class="headerlink" title="总结🙃🙃🙃"></a>总结🙃🙃🙃</h3><ul>
<li><strong>GAP</strong>：负责设备发现和连接管理，定义设备的角色和连接过程。</li>
<li><strong>GATT</strong>：负责设备之间的数据交换和数据组织，通过服务和特性来定义如何读取、写入和通知数据。</li>
<li><strong>ATT</strong>：负责在设备之间传输<strong>具体的数据单元（属性）</strong>，通过定义<strong>属性（Attribute）</strong>来组织和传输数据。每个属性都有一个唯一的标识符（UUID）和数据值。</li>
<li><strong>L2CAP</strong>：负责<strong>数据封装和分段</strong>，实现应用层和传输层之间的可靠数据传输。</li>
</ul>
<p>这两个协议相辅相成，构成了蓝牙低功耗通信的基础，使得不同设备能够高效地进行数据交换和管理。</p>
<h2 id="广播数据包格式"><a href="#广播数据包格式" class="headerlink" title="广播数据包格式"></a>广播数据包格式</h2><p>在 BLE 中，GAP 协议通过广播数据包的形式与其他设备进行交互。广播数据包的主要作用是：</p>
<ul>
<li><strong>设备发现</strong>：向周围设备提供设备的身份信息（如设备名称、UUID 等），使其他设备能够快速发现并识别蓝牙设备。</li>
<li><strong>服务信息传递</strong>：传输设备支持的服务类型和功能。</li>
<li><strong>连接准备</strong>：当其他设备响应广播并发起连接请求后，可建立 BLE 连接。</li>
</ul>
<p>广播数据包的有效负载（Payload）最大为 <strong>37 字节</strong>，前 6 个字节为 MAC 地址，后 <strong>31 字节</strong> 可供开发者使用。这 31 字节被分为一个或多个 <strong>AD Structure</strong>（广播数据结构），每个 AD Structure 包含以下部分：</p>
<ol>
<li><strong>长度字段（Length）</strong>：1 字节，表示该结构的总长度。</li>
<li><strong>类型字段（Type）</strong>：1 字节，定义数据的类型（如设备名称、服务 UUID、设备类别等）。</li>
<li><strong>值字段（Value）</strong>：可变长度，包含具体的数据内容。</li>
</ol>
<p>广播数据包不直接发起连接请求，而是通过提供设备信息，等待中心设备（Scanner）发起连接请求。一旦中心设备响应广播包并发起连接请求，双方可以建立 BLE 连接。</p>
<p>值得注意的是，设备地址（6 字节）用于标识设备，但不占用广播数据包的 31 字节有效负载空间。通过合理设计广播数据内容，可以实现快速设备发现和低功耗的连接准备。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/ADStructuregeshi.png" alt="ADStructuregeshi"></p>
<blockquote>
<p>每个AD Structure包含3部分内容，分别是：</p>
<ol>
<li>Length(1字节):        广播数据包的长度</li>
<li>AD Type(1字节)：   广播的类型</li>
<li>AD Data（n字节）: 数据</li>
</ol>
</blockquote>
<p><strong>常见的广播类型如下</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/blegblx.png" alt="blegblx"></p>
<p>假设我此时有如下一组广播数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设这是一组广播数据</span></span><br><span class="line"><span class="number">02</span> <span class="number">01</span> <span class="number">06</span> <span class="number">09</span> <span class="number">08</span> <span class="number">54</span> <span class="number">6F</span> <span class="number">6F</span> <span class="number">55</span> <span class="number">70</span> <span class="number">70</span> <span class="number">65</span> <span class="number">72</span> <span class="number">03</span> <span class="number">19</span> C1 <span class="number">03</span></span><br><span class="line"><span class="comment">// 我们将它按照 AD structure 拆分后为：</span></span><br><span class="line"><span class="number">02</span> <span class="number">01</span> <span class="number">06</span>	<span class="comment">// 02 表示数据长度，01 表示广播类型为设备标识 06是具体的标识内容   </span></span><br><span class="line"><span class="number">09</span> <span class="number">08</span> <span class="number">54</span> <span class="number">6F</span> <span class="number">6F</span> <span class="number">55</span> <span class="number">70</span> <span class="number">70</span> <span class="number">65</span> <span class="number">72</span> <span class="comment">// 同理 09 表示长度，08 表示广播类型，后面就是类型的具体数据</span></span><br><span class="line"><span class="number">03</span> <span class="number">19</span> C1 <span class="number">03</span> <span class="comment">// 03 表示长度，19 表示类型，后面表示具体的数据    </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>在设置广播的设备外观时候，要采用低位先行的方式，比如我们要设备外观为键盘，键盘对应的数据位 0x03C1，那么我们在广播数据中填写的值就要是 03 19 C1 03（这里要采用低位先行的策略）</p>
</blockquote>
<p>其他的设备外观数据我们可以在蓝牙官方的<a href="https://www.bluetooth.com/wp-content/uploads/Files/Specification/HTML/Assigned_Numbers/out/en/Assigned_Numbers.pdf">已分配编号</a>表中进行查找</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="蓝牙通信中的角色"><a href="#蓝牙通信中的角色" class="headerlink" title="蓝牙通信中的角色"></a>蓝牙通信中的角色</h3><p>主机（客户端）：可以发起扫描并主动连接从机设备的角色（发起连接），比如手机；</p>
<p>从机（服务端）：发起广播，等待主设备的连接（也可以被别人连接），比如蓝牙灯、手环；</p>
<blockquote>
<p>同一个 BLE 设备既可以作为主机也可以作为从机</p>
</blockquote>
<h3 id="BLE通信信道"><a href="#BLE通信信道" class="headerlink" title="BLE通信信道"></a>BLE通信信道</h3><p>BLE 蓝牙使用使用 2.4GHz 频道，一共有 40 个信道，37、38、39是蓝牙广播信道，剩余 37 个是数据信道。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/bletxxd.png" alt="bletxxd"></p>
<h3 id="广播间隔和广播事件"><a href="#广播间隔和广播事件" class="headerlink" title="广播间隔和广播事件"></a>广播间隔和广播事件</h3><p><strong>广播间隔</strong>：从机每经过一个时间间隔发送一次广播数据，这个时间间隔称为广播间隔(20ms 到 10.24s)</p>
<p><strong>广播事件</strong>：一次广播的动作，每次广播事件会在37，38，39信道上依次广播</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/blelygbjg.png" alt="blelygbjg"></p>
<h3 id="BLE连接后"><a href="#BLE连接后" class="headerlink" title="BLE连接后"></a>BLE连接后</h3><p>主机扫描到从机设备后，向从机设备发起连接请求；并且得到回应后双方才正式开始通信。此时有几个概念要注意下</p>
<p><strong>连接事件</strong>：在 BLE 连接中使用跳频方案，两个设备在特定时间、频道上彼此发送和接收数据。这些设备稍后在新的通道上通过约定的时间相遇，这次用于收发数据的相遇称为连接事件。</p>
<p><strong>连接间隔</strong>：两次连接事件之间的时间间隔称为连接间隔。1.25ms 为单位，范围从最小值 7.5ms 到最大值 4.0s.</p>
<p><strong>从机延迟</strong>：可以跳过的最大事件数。从设备（比如一个心率监测器）在连接事件中跳过的最大次数。如果从设备的任务没有及时完成，它可以选择跳过某些连接事件，以节省电池。这个延迟值通常是通过连接参数来配置的，最大值通常可以达到 500。</p>
<p><strong>监控超时</strong>：两次成功连接事件之间的最长时间。如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态。(100ms-32秒)。</p>
<p><strong>有效连接间隔</strong>：实际有效的交互通信间隔，有效连接间隔 &#x3D; 连接间隔 * (1+从机延迟)。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>ESP32 广播蓝牙，手机可以使用APP进行连接并且发送和接收数据，可以使用”BLE调试助手“进行测试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ble.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BLE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BLE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化并启动蓝牙BLE</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ble_cfg_net_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置特征1的值</span></span><br><span class="line"><span class="comment"> * @param value 值</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ble_set_ch1_value</span><span class="params">(<span class="type">uint16_t</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置特征2的值</span></span><br><span class="line"><span class="comment"> * @param value 值</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ble_set_ch2_value</span><span class="params">(<span class="type">uint16_t</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// ble.c    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_bt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_gap_ble_api.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_gatts_api.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_bt_defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_bt_main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_gatt_common_api.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG <span class="string">&quot;BLE_CFG&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLE_DEVICE_NAME <span class="string">&quot;ESP32-HOME&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESP_APP_ID 0x55</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_IND_ID1 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_IND_ID2 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝牙模块</span></span><br><span class="line"><span class="keyword">enum</span>&#123;</span><br><span class="line">    <span class="comment">//服务1</span></span><br><span class="line">    SV1_IDX_SVC,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征1</span></span><br><span class="line">    SV1_CH1_IDX_CHAR,</span><br><span class="line">    SV1_CH1_IDX_CHAR_VAL,</span><br><span class="line">    SV1_CH1_IDX_CHAR_CFG,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征2</span></span><br><span class="line">    SV1_CH2_IDX_CHAR,</span><br><span class="line">    SV1_CH2_IDX_CHAR_VAL,</span><br><span class="line">    SV1_CH2_IDX_CHAR_CFG,</span><br><span class="line"></span><br><span class="line">    SV1_IDX_NB,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    <span class="comment">//服务2</span></span><br><span class="line">    SV2_IDX_SVC,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征1</span></span><br><span class="line">    SV2_CH1_IDX_CHAR,</span><br><span class="line">    SV2_CH1_IDX_CHAR_VAL,</span><br><span class="line">    SV2_CH1_IDX_CHAR_CFG,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征2</span></span><br><span class="line">    SV2_CH2_IDX_CHAR,</span><br><span class="line">    SV2_CH2_IDX_CHAR_VAL,</span><br><span class="line">    SV2_CH2_IDX_CHAR_CFG,</span><br><span class="line"></span><br><span class="line">    SV2_IDX_NB,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> GATTS_SERVICE_UUID_TEST       = <span class="number">0x18FF</span>;   <span class="comment">//自定义服务1</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> GATTS_CHAR_UUID_CH1           = <span class="number">0x2AFE</span>;   <span class="comment">//特征1 UUID</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> GATTS_CHAR_UUID_CH2           = <span class="number">0x2AFF</span>;   <span class="comment">//特征2 UUID</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> GATTS_SERVICE2_UUID_TEST       = <span class="number">0x18F3</span>;   <span class="comment">//自定义服务2</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> GATTS_CHAR2_UUID_CH1           = <span class="number">0x2AF1</span>;   <span class="comment">//特征1 UUID</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> GATTS_CHAR2_UUID_CH2           = <span class="number">0x2AF2</span>;   <span class="comment">//特征2 UUID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主要服务声明UUID 0x2800</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> primary_service_uuid         = ESP_GATT_UUID_PRI_SERVICE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//次要服务声明UUID 0x2801</span></span><br><span class="line"><span class="comment">//static const uint16_t second_service_uuid          = ESP_GATT_UUID_SEC_SERVICE;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特征声明UUID 0x2803</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> character_declaration_uuid   = ESP_GATT_UUID_CHAR_DECLARE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特征描述UUID 0x2902</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> character_client_config_uuid = ESP_GATT_UUID_CHAR_CLIENT_CONFIG;</span><br><span class="line"><span class="comment">//读权限</span></span><br><span class="line"><span class="comment">//static const uint8_t char_prop_read                =  ESP_GATT_CHAR_PROP_BIT_READ;</span></span><br><span class="line"><span class="comment">//写权限</span></span><br><span class="line"><span class="comment">//static const uint8_t char_prop_write               = ESP_GATT_CHAR_PROP_BIT_WRITE;</span></span><br><span class="line"><span class="comment">//读写、通知权限</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> char_prop_read_write_notify   = ESP_GATT_CHAR_PROP_BIT_WRITE | ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_NOTIFY;</span><br><span class="line"><span class="comment">//读、通知权限</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> char_prop_read_notify = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_NOTIFY;</span><br><span class="line"><span class="comment">//特征1客户端特征配置</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> sv1_ch1_client_cfg[<span class="number">2</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">//特征2客户端特征配置</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> sv1_ch2_client_cfg[<span class="number">2</span>]  = &#123;<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">//特征1客户端特征配置</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> sv2_ch1_client_cfg[<span class="number">2</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">//特征2客户端特征配置</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> sv2_ch2_client_cfg[<span class="number">2</span>]  = &#123;<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gatt的访问接口，一个Profile（APP）对应1个</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> gl_gatts_if = ESP_GATT_IF_NONE;</span><br><span class="line"><span class="comment">//连接ID，连接成功后</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> gl_conn_id = <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char1的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> sv1_char1_value[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,<span class="number">0x16</span>&#125;;</span><br><span class="line"><span class="comment">//char2的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> sv1_char2_value[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,<span class="number">0x25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char1的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> sv2_char1_value[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,<span class="number">0xAA</span>&#125;;</span><br><span class="line"><span class="comment">//char2的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> sv2_char2_value[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,<span class="number">0xEE</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//att的handle表</span></span><br><span class="line"><span class="type">uint16_t</span> sv1_handle_table[SV1_IDX_NB];</span><br><span class="line"></span><br><span class="line"><span class="comment">//att的handle表</span></span><br><span class="line"><span class="type">uint16_t</span> sv2_handle_table[SV2_IDX_NB];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该标志位用于跟踪广播配置状态，</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> adv_config_done       = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADV_CONFIG_FLAG 设置广播名称成功标志位</span></span><br><span class="line"><span class="comment">// SCAN_RSP_CONFIG_FLAG 设置扫描回复数据成功标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADV_CONFIG_FLAG             (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCAN_RSP_CONFIG_FLAG        (1 &lt;&lt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广播参数</span></span><br><span class="line"><span class="type">static</span> <span class="type">esp_ble_adv_params_t</span> adv_params = &#123;</span><br><span class="line">    .adv_int_min       = <span class="number">0x20</span>,                <span class="comment">//最小广播间隔，单位:0.625ms</span></span><br><span class="line">    .adv_int_max       = <span class="number">0x40</span>,                <span class="comment">//最大广播间隔，单位:0.625ms</span></span><br><span class="line">    .adv_type          = ADV_TYPE_IND,        <span class="comment">//广播类型(可连接的非定向广播)</span></span><br><span class="line">    .own_addr_type     = BLE_ADDR_TYPE_PUBLIC,<span class="comment">//使用固定地址广播</span></span><br><span class="line">    .channel_map       = ADV_CHNL_ALL,        <span class="comment">//在37、38、39信道进行广播</span></span><br><span class="line">    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,   <span class="comment">//广播过滤策略（接收任何scan和任何连接）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gatt描述表</span></span><br><span class="line"><span class="comment">// 在ESP32中一张表只能对应一个服务，可以有多个特征</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">esp_gatts_attr_db_t</span> gatt1_db[SV1_IDX_NB] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//服务声明</span></span><br><span class="line">    <span class="comment">// ESP_GATT_AUTO_RSP：表示对这个属性的响应由 ESP32 自动处理，不需要应用层干预。</span></span><br><span class="line">    <span class="comment">// 权限（ESP_GATT_PERM_READ）：表示该服务的声明可以被读取。</span></span><br><span class="line">    <span class="comment">// ESP_UUID_LEN_16 UUID 长度</span></span><br><span class="line">    <span class="comment">// (uint8_t *)&amp;primary_service_uuid:将服务标识为主要服务的 UUID (0x2800)</span></span><br><span class="line">    <span class="comment">// 大小：第一个 sizeof(uint16_t) 表示 UUID 的最大程度</span></span><br><span class="line">    <span class="comment">// 第二个 sizeof(GATTS_SERVICE_UUID_TEST) 表示服务 UUID 的实际大小。</span></span><br><span class="line">    <span class="comment">// GATTS_SERVICE_UUID_TEST 是服务的实际 UUID。</span></span><br><span class="line">    [SV1_IDX_SVC]        =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;primary_service_uuid, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="keyword">sizeof</span>(GATTS_SERVICE_UUID_TEST), (<span class="type">uint8_t</span> *)&amp;GATTS_SERVICE_UUID_TEST&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征1</span></span><br><span class="line">    <span class="comment">//特征声明</span></span><br><span class="line">    <span class="comment">// ESP_GATT_PERM_READ 这是特征声明的权限，表示特征声明本身是只读的。</span></span><br><span class="line">    <span class="comment">// char_prop_read_write_notify 定义了该特征的属性（即允许读、写、通知）。</span></span><br><span class="line">    <span class="comment">// 这是特征的属性（Properties），表示特征值支持的操作类型（读、写、通知等）。</span></span><br><span class="line">    [SV1_CH1_IDX_CHAR]     =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), (<span class="type">uint8_t</span> *)&amp;char_prop_read_write_notify&#125;&#125;,   <span class="comment">//特征值1允许读写和通知</span></span><br><span class="line">    <span class="comment">//特征值</span></span><br><span class="line">    <span class="comment">// ESP_GATT_RSP_BY_APP 对写/读操作的响应应由应用程序处理。</span></span><br><span class="line">    <span class="comment">// 也就是我们需要自己写函数进行调用回复</span></span><br><span class="line">    <span class="comment">// GATTS_CHAR_UUID_CH1 自定义特征1的UUID</span></span><br><span class="line">    <span class="comment">// 该特征值可以被读取和写入。</span></span><br><span class="line">    <span class="comment">// 大小：sizeof(sv1_char1_value) 表示该特征值的长度</span></span><br><span class="line">    <span class="comment">// 数据内容存储在 sv1_char1_value 变量中。</span></span><br><span class="line">    [SV1_CH1_IDX_CHAR_VAL] =</span><br><span class="line">    &#123;&#123;ESP_GATT_RSP_BY_APP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;GATTS_CHAR_UUID_CH1, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, </span><br><span class="line">      <span class="keyword">sizeof</span>(sv1_char1_value), <span class="keyword">sizeof</span>(sv1_char1_value), (<span class="type">uint8_t</span> *)sv1_char1_value&#125;&#125;,</span><br><span class="line">    <span class="comment">//特征描述-&gt;客户端特征配置</span></span><br><span class="line">    <span class="comment">// 数据内容存储在 sv1_ch1_client_cfg 变量中。</span></span><br><span class="line">    [SV1_CH1_IDX_CHAR_CFG]  =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="keyword">sizeof</span>(sv1_ch1_client_cfg), (<span class="type">uint8_t</span> *)sv1_ch1_client_cfg&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征2</span></span><br><span class="line">    <span class="comment">//特征声明</span></span><br><span class="line">    [SV1_CH2_IDX_CHAR]      =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), (<span class="type">uint8_t</span> *)&amp;char_prop_read_notify&#125;&#125;,  <span class="comment">//特征值2只允许读和通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征值</span></span><br><span class="line">    [SV1_CH2_IDX_CHAR_VAL]  =</span><br><span class="line">    &#123;&#123;ESP_GATT_RSP_BY_APP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;GATTS_CHAR_UUID_CH2, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(sv1_char2_value), <span class="keyword">sizeof</span>(sv1_char2_value), (<span class="type">uint8_t</span> *)sv1_char2_value&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征描述-&gt;客户端特征配置</span></span><br><span class="line">    [SV1_CH2_IDX_CHAR_CFG]      =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="keyword">sizeof</span>(sv1_ch2_client_cfg), (<span class="type">uint8_t</span> *)&amp;sv1_ch2_client_cfg&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gatt描述表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">esp_gatts_attr_db_t</span> gatt2_db[SV1_IDX_NB] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//服务2声明</span></span><br><span class="line">    [SV2_IDX_SVC]        =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;primary_service_uuid, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="keyword">sizeof</span>(GATTS_SERVICE2_UUID_TEST), (<span class="type">uint8_t</span> *)&amp;GATTS_SERVICE2_UUID_TEST&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征1</span></span><br><span class="line">    <span class="comment">//特征声明</span></span><br><span class="line">    [SV2_CH1_IDX_CHAR]     =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), (<span class="type">uint8_t</span> *)&amp;char_prop_read_notify&#125;&#125;,</span><br><span class="line">    <span class="comment">//特征值</span></span><br><span class="line">    [SV2_CH1_IDX_CHAR_VAL] =</span><br><span class="line">    &#123;&#123;ESP_GATT_RSP_BY_APP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;GATTS_CHAR2_UUID_CH1, ESP_GATT_PERM_READ, </span><br><span class="line">      <span class="keyword">sizeof</span>(sv2_char1_value), <span class="keyword">sizeof</span>(sv2_char1_value), (<span class="type">uint8_t</span> *)sv2_char1_value&#125;&#125;,</span><br><span class="line">    <span class="comment">//特征描述-&gt;客户端特征配置</span></span><br><span class="line">    [SV2_CH1_IDX_CHAR_CFG]  =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="keyword">sizeof</span>(sv2_ch1_client_cfg), (<span class="type">uint8_t</span> *)sv2_ch1_client_cfg&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征2</span></span><br><span class="line">    <span class="comment">//特征声明</span></span><br><span class="line">    [SV2_CH2_IDX_CHAR]      =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>), (<span class="type">uint8_t</span> *)&amp;char_prop_read_write_notify&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征值</span></span><br><span class="line">    [SV2_CH2_IDX_CHAR_VAL]  =</span><br><span class="line">    &#123;&#123;ESP_GATT_RSP_BY_APP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;GATTS_CHAR2_UUID_CH2, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,</span><br><span class="line">      <span class="keyword">sizeof</span>(sv2_char2_value), <span class="keyword">sizeof</span>(sv2_char2_value), (<span class="type">uint8_t</span> *)sv2_char2_value&#125;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特征描述-&gt;客户端特征配置</span></span><br><span class="line">    [SV2_CH2_IDX_CHAR_CFG]      =</span><br><span class="line">    &#123;&#123;ESP_GATT_AUTO_RSP&#125;, &#123;ESP_UUID_LEN_16, (<span class="type">uint8_t</span> *)&amp;character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="keyword">sizeof</span>(sv2_ch2_client_cfg), (<span class="type">uint8_t</span> *)&amp;sv2_ch2_client_cfg&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该数组的目的是存储一个 128 位的 UUID，</span></span><br><span class="line"><span class="comment">// 但由于 BLE 广播数据通常使用 16 位或 32 位的 UUID 来节省空间，我们只在数组中包括了实际需要的部分。</span></span><br><span class="line"><span class="comment">// 它实际上包含了一个16位（2字节）服务 UUID 和其它一些与设备相关的数据。0x000018FF</span></span><br><span class="line"><span class="comment">// GATTS_SERVICE_UUID_TEST 是自定义的UUID</span></span><br><span class="line"><span class="comment">// GATTS_SERVICE_UUID_TEST&amp;0xff 获取 UUID 的低字节。</span></span><br><span class="line"><span class="comment">// (GATTS_SERVICE_UUID_TEST&gt;&gt;8)&amp;0xff 获取 UUID 的高字节。</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> adv_service_uuid16[] = &#123;</span><br><span class="line">    <span class="comment">/* LSB &lt;------------------------------&gt; MSB */</span></span><br><span class="line">    <span class="number">0xfb</span>, <span class="number">0x34</span>, <span class="number">0x9b</span>, <span class="number">0x5f</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">    GATTS_SERVICE_UUID_TEST&amp;<span class="number">0xff</span>,(GATTS_SERVICE_UUID_TEST&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The length of adv data must be less than 31 bytes</span></span><br><span class="line"><span class="comment">//static uint8_t test_manufacturer[TEST_MANUFACTURER_DATA_LEN] =  &#123;0x12, 0x23, 0x45, 0x56&#125;;</span></span><br><span class="line"><span class="comment">//adv data广播数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">esp_ble_adv_data_t</span> adv_data = &#123;</span><br><span class="line">    <span class="comment">// 如果设置为 true，设备会在接收到扫描请求后，回复包含更多信息的数据；</span></span><br><span class="line">    <span class="comment">// 如果设置为 false，则不返回扫描响应。</span></span><br><span class="line">    .set_scan_rsp = <span class="literal">false</span>, <span class="comment">//此广播数据是否启用扫描响应，</span></span><br><span class="line">    <span class="comment">// 如果设置为 true，设备广播时会包含其设备名称，这样其他设备可以看到设备的名字；</span></span><br><span class="line">    <span class="comment">// 如果设置为 false，则不包含设备名称。</span></span><br><span class="line">    .include_name = <span class="literal">true</span>, <span class="comment">//是否包含名字</span></span><br><span class="line">    <span class="comment">// 发射功率表示设备的信号强度，其他设备可以使用此信息来估算与该设备的距离。</span></span><br><span class="line">    <span class="comment">// 如果设置为 true，则会广播发射功率；如果设置为 false，则不广播。</span></span><br><span class="line">    .include_txpower = <span class="literal">false</span>, <span class="comment">//是否包含发射功率</span></span><br><span class="line">    <span class="comment">// 控制设备在连接时，设备之间交换数据的频率。</span></span><br><span class="line">    .min_interval = <span class="number">0x0006</span>, <span class="comment">//最小连接间隔 单位1.25ms</span></span><br><span class="line">    .max_interval = <span class="number">0x0010</span>, <span class="comment">//最大连接间隔 单位1.25ms</span></span><br><span class="line">    <span class="comment">// 设置设备的外观，这是一个标准化的值，设备可以根据此值告诉其他设备它是什么类型。</span></span><br><span class="line">    .appearance = <span class="number">0x00</span>,     <span class="comment">//apperance</span></span><br><span class="line">    .manufacturer_len = <span class="number">0</span>, <span class="comment">//厂商信息长度</span></span><br><span class="line">    .p_manufacturer_data =  <span class="literal">NULL</span>, <span class="comment">//厂商信息</span></span><br><span class="line">    <span class="comment">// 这个指针指向具体的服务数据内容。</span></span><br><span class="line">    .service_data_len = <span class="number">0</span>,      <span class="comment">//服务数据长度</span></span><br><span class="line">    .p_service_data = <span class="literal">NULL</span>,     <span class="comment">//服务数据</span></span><br><span class="line">    <span class="comment">// 服务 UUID（统一唯一标识符）用于标识 BLE 服务的类型。</span></span><br><span class="line">    .service_uuid_len = <span class="keyword">sizeof</span>(adv_service_uuid16),    <span class="comment">//服务UUID长度</span></span><br><span class="line">    .p_service_uuid = adv_service_uuid16,              <span class="comment">//服务UUID</span></span><br><span class="line">    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),<span class="comment">//普通发现模式|不支持EDR经典蓝牙</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描回复数据，用于主机在主动扫描时，向设备发起扫描请求，设备需要回复的内容</span></span><br><span class="line"><span class="type">static</span> <span class="type">esp_ble_adv_data_t</span> scan_rsp_data = &#123;</span><br><span class="line">    <span class="comment">// true 表示开启扫描回复数据，设备将回复扫描请求的主机。</span></span><br><span class="line">    .set_scan_rsp = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否在扫描回复数据中包含设备的名字。</span></span><br><span class="line">    .include_name = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否在扫描回复数据中包含设备的发射功率。</span></span><br><span class="line">    .include_txpower = <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设备的外观</span></span><br><span class="line">    .appearance = <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// 厂商数据的长度与内容</span></span><br><span class="line">    .manufacturer_len = <span class="number">0</span>, <span class="comment">//TEST_MANUFACTURER_DATA_LEN,</span></span><br><span class="line">    .p_manufacturer_data =  <span class="literal">NULL</span>, <span class="comment">//&amp;test_manufacturer[0],</span></span><br><span class="line">    <span class="comment">// 指定服务数据的长度与内容</span></span><br><span class="line">    .service_data_len = <span class="number">0</span>,</span><br><span class="line">    .p_service_data = <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// 指定服务 UUID 的长度与内容</span></span><br><span class="line">    .service_uuid_len = <span class="keyword">sizeof</span>(adv_service_uuid16),</span><br><span class="line">    .p_service_uuid = adv_service_uuid16,</span><br><span class="line">    <span class="comment">// 设置设备的广播标志。</span></span><br><span class="line">    <span class="comment">// ESP_BLE_ADV_FLAG_GEN_DISC：设备支持通用发现（General Discoverable Mode），可以被扫描到。</span></span><br><span class="line">    <span class="comment">// ESP_BLE_ADV_FLAG_BREDR_NOT_SPT：设备不支持经典蓝牙（BR/EDR），只支持 BLE。</span></span><br><span class="line">    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gatt事件回调函数</span></span><br><span class="line"><span class="comment"> * @param event 事件ID</span></span><br><span class="line"><span class="comment"> * @param gatts_if gatt接口，一个profile对应一个</span></span><br><span class="line"><span class="comment"> * @param </span></span><br><span class="line"><span class="comment"> *		event: 事件类型，指示发生了什么操作，如注册、读取、写入等。</span></span><br><span class="line"><span class="comment"> *		gatts_if: 表示 GATT 服务器接口。用于在 GATT 服务器和应用程序之间进行交互。</span></span><br><span class="line"><span class="comment"> * 			他是与 profile 对应的我们这里只设置了一个 profile 所以 gatts_if 可以不用管。</span></span><br><span class="line"><span class="comment"> *		param: 事件参数，包含具体事件的信息。它是一个结构体，类型为 esp_ble_gatts_cb_param_t</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gatts_profile_event_handler</span><span class="params">(<span class="type">esp_gatts_cb_event_t</span> event, <span class="type">esp_gatt_if_t</span> gatts_if, <span class="type">esp_ble_gatts_cb_param_t</span> *param)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="comment">// 当 GATT profile 注册成功时触发的事件，表示设备的 GATT 服务已成功启动。    </span></span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_REG_EVT:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//设置 BLE 广播时的设备名称</span></span><br><span class="line">            <span class="type">esp_err_t</span> set_dev_name_ret = esp_ble_gap_set_device_name(BLE_DEVICE_NAME);</span><br><span class="line">            <span class="keyword">if</span> (set_dev_name_ret)&#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;set device name failed, error code = %x&quot;</span>, set_dev_name_ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置广播数据，完成广播的初始化。</span></span><br><span class="line">            <span class="type">esp_err_t</span> ret = esp_ble_gap_config_adv_data(&amp;adv_data);</span><br><span class="line">            <span class="keyword">if</span> (ret)&#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;config adv data failed, error code = %x&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            adv_config_done |= ADV_CONFIG_FLAG;</span><br><span class="line">            <span class="comment">//设置扫描回复参数</span></span><br><span class="line">            <span class="comment">// 即在设备广播过程中，其他设备扫描到该设备时，设备可以返回给扫描者更多的详细信息。</span></span><br><span class="line">            <span class="comment">// 也可以理解为，主机扫描到设备后，设备需要回复给主机的内容。</span></span><br><span class="line">            ret = esp_ble_gap_config_adv_data(&amp;scan_rsp_data);</span><br><span class="line">            <span class="keyword">if</span> (ret)&#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;config scan response data failed, error code = %x&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            adv_config_done |= SCAN_RSP_CONFIG_FLAG;      </span><br><span class="line">            <span class="comment">// 注册两个服务的属性表（gatt1_db 和 gatt2_db）。（每个属性表包含符合与特征）</span></span><br><span class="line">            <span class="comment">// 每个属性表都与一个 svc_ind_id 关联，并根据 gatts_if 注册到 GATT 服务器中。</span></span><br><span class="line">            <span class="comment">// 注册attr表1 第一个服务</span></span><br><span class="line">            <span class="comment">// gatt1_db 这是一个指向服务属性数据库的指针，定义了服务的属性表，包括服务的特征和描述符等。</span></span><br><span class="line">            <span class="comment">// gatts_if GATT服务器的接口标识符。</span></span><br><span class="line">            <span class="comment">// SV1_IDX_NB 指定了要添加到服务数据库中的最大属性数量。每个服务、特征和描述符都是一个属性。</span></span><br><span class="line">            <span class="comment">// 它应该与 gatt1_db 中定义的属性数量相匹配。</span></span><br><span class="line">            <span class="comment">// SVC_IND_ID1 这是服务的实例ID。</span></span><br><span class="line">            <span class="comment">// 在一个GATT服务器中，可以有多个服务实例，每个实例都有一个唯一的实例ID。</span></span><br><span class="line">            <span class="type">esp_err_t</span> create_attr_ret = esp_ble_gatts_create_attr_tab(gatt1_db, gatts_if, SV1_IDX_NB, SVC_IND_ID1);</span><br><span class="line">            <span class="keyword">if</span> (create_attr_ret)&#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;create attr1 table failed, error code = %x&quot;</span>, create_attr_ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注册attr表2 第二个服务</span></span><br><span class="line">            create_attr_ret = esp_ble_gatts_create_attr_tab(gatt2_db, gatts_if, SV2_IDX_NB, SVC_IND_ID2);</span><br><span class="line">            <span class="keyword">if</span> (create_attr_ret)&#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;create attr2 table failed, error code = %x&quot;</span>, create_attr_ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// param 事件参数，</span></span><br><span class="line">            <span class="comment">// param-&gt;reg.status：这是 ESP_GATTS_REG_EVT 事件中的字段，表示注册结果。</span></span><br><span class="line">            <span class="comment">// 保存到全局变量，因为发送数据的时候会用到这个接口</span></span><br><span class="line">            <span class="keyword">if</span>(param-&gt;reg.status == ESP_GATT_OK)&#123;</span><br><span class="line">                gl_gatts_if = gatts_if;</span><br><span class="line">                <span class="comment">//gl_conn_id = param-&gt;connect.conn_id;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 收到客户端请求读取某个特征的值时触发此事件。</span></span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_READ_EVT:</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;ESP_GATTS_READ_EVT&quot;</span>);</span><br><span class="line">            <span class="comment">// 定义一个响应结构体，也就是要返回的数据</span></span><br><span class="line">            <span class="type">esp_gatt_rsp_t</span> rsp;</span><br><span class="line">            <span class="comment">// 将响应结构体清零，确保没有残留数据。</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;rsp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">esp_gatt_rsp_t</span>));</span><br><span class="line">            <span class="comment">// 设置响应结构体中的句柄，表示要返回的特征值的句柄。</span></span><br><span class="line">            rsp.attr_value.handle = param-&gt;read.handle;</span><br><span class="line">            <span class="comment">// 服务1中特征1的特征值句柄。</span></span><br><span class="line">            <span class="comment">// 在GATT协议中，每个特征值或描述符的句柄是全局唯一的，即使它们属于不同的服务。</span></span><br><span class="line">            <span class="comment">// 所以可以不用去判断属于哪一个服务；主机只在乎特征值，其他都是配置自动回复的</span></span><br><span class="line">            <span class="comment">// 所以我们只用判断是哪一个特征值就可以了</span></span><br><span class="line">            <span class="keyword">if</span>(sv1_handle_table[SV1_CH1_IDX_CHAR_VAL] == param-&gt;read.handle)&#123;</span><br><span class="line">                <span class="comment">// 将 sv1_char2_value 的数据复制到响应结构体中。</span></span><br><span class="line">                rsp.attr_value.len = <span class="keyword">sizeof</span>(sv1_char2_value);</span><br><span class="line">                <span class="built_in">memcpy</span>(rsp.attr_value.value,sv1_char2_value,<span class="keyword">sizeof</span>(sv1_char2_value));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务1中特征2的特征值句柄。</span></span><br><span class="line">            <span class="keyword">if</span>(sv1_handle_table[SV1_CH2_IDX_CHAR_VAL] == param-&gt;read.handle)&#123;</span><br><span class="line">                rsp.attr_value.len = <span class="keyword">sizeof</span>(sv2_char2_value);</span><br><span class="line">                <span class="built_in">memcpy</span>(rsp.attr_value.value,sv2_char2_value,<span class="keyword">sizeof</span>(sv2_char2_value));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将准备好的响应数据发送给客户端。</span></span><br><span class="line">            <span class="comment">// gatts_if：GATT服务器接口。</span></span><br><span class="line">            <span class="comment">// param-&gt;read.conn_id：连接的ID，表示是哪个客户端发起的请求。</span></span><br><span class="line">            <span class="comment">// param-&gt;read.trans_id：事务ID，用于标识本次读取请求。</span></span><br><span class="line">            <span class="comment">// ESP_GATT_OK：表示响应成功。</span></span><br><span class="line">            <span class="comment">// &amp;rsp：指向响应结构体的指针。</span></span><br><span class="line">            esp_ble_gatts_send_response(gatts_if, param-&gt;read.conn_id, param-&gt;read.trans_id,ESP_GATT_OK, &amp;rsp);</span><br><span class="line">       	    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当客户端发送写入请求时，BLE栈会触发该事件。</span></span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_WRITE_EVT:</span><br><span class="line">            <span class="comment">// is_prep：表示是否是准备写入（长写入）。</span></span><br><span class="line">            <span class="comment">// 如果是 true，设备首先会将这些数据保存下来，等主机确认了最后一包这个预写的数据发完后</span></span><br><span class="line">            <span class="comment">// 我们的设备才一次性的把这些数据更新到内存中去</span></span><br><span class="line">            <span class="keyword">if</span> (!param-&gt;write.is_prep)&#123;</span><br><span class="line">                <span class="comment">// the data length of gattc write  must be less than GATTS_DEMO_CHAR_VAL_LEN_MAX.</span></span><br><span class="line">                ESP_LOGI(TAG, <span class="string">&quot;GATT_WRITE_EVT, handle = %d, value len = %d, value :&quot;</span>, param-&gt;write.handle, param-&gt;write.len);</span><br><span class="line">                <span class="comment">// 打印写入请求的详细信息，包括句柄、数据长度和数据内容。</span></span><br><span class="line">                <span class="comment">// 以十六进制格式打印数据内容。</span></span><br><span class="line">                esp_log_buffer_hex(TAG, param-&gt;write.value, param-&gt;write.len);</span><br><span class="line">                <span class="comment">// 分别保存特征1客户端写入数据的第一个和第二个字节.</span></span><br><span class="line">                <span class="keyword">if</span>(param-&gt;write.handle == sv1_handle_table[SV1_CH1_IDX_CHAR_CFG])&#123; </span><br><span class="line">                    sv1_ch1_client_cfg[<span class="number">0</span>] = param-&gt;write.value[<span class="number">0</span>];</span><br><span class="line">                    sv1_ch1_client_cfg[<span class="number">1</span>] = param-&gt;write.value[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 分别保存特征2客户端写入数据的第一个和第二个字节.</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;write.handle == sv1_handle_table[SV1_CH2_IDX_CHAR_CFG])&#123;</span><br><span class="line">                    sv1_ch2_client_cfg[<span class="number">0</span>] = param-&gt;write.value[<span class="number">0</span>];</span><br><span class="line">                    sv1_ch2_client_cfg[<span class="number">1</span>] = param-&gt;write.value[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 分别保存特征1特征值写入数据的第一个和第二个字节.</span></span><br><span class="line">                <span class="comment">// 特征2只允许读和通知所以不考虑写入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;write.handle == sv1_handle_table[SV1_CH1_IDX_CHAR_VAL])&#123;</span><br><span class="line">                    sv1_char2_value[<span class="number">0</span>] = param-&gt;write.value[<span class="number">0</span>];</span><br><span class="line">                    sv1_char2_value[<span class="number">1</span>] = param-&gt;write.value[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 如果客户端需要响应，则发送响应。</span></span><br><span class="line">                <span class="comment">// gatts_if：GATT服务器接口。</span></span><br><span class="line">				<span class="comment">//param-&gt;write.conn_id：连接的ID，表示是哪个客户端发起的请求。</span></span><br><span class="line">				<span class="comment">//param-&gt;write.trans_id：事务ID，用于标识本次写入请求。</span></span><br><span class="line">				<span class="comment">//ESP_GATT_OK：表示响应成功。</span></span><br><span class="line">				<span class="comment">//NULL：表示没有额外的响应数据。</span></span><br><span class="line">                <span class="keyword">if</span> (param-&gt;write.need_rsp)&#123;</span><br><span class="line">                    esp_ble_gatts_send_response(gatts_if, param-&gt;write.conn_id, param-&gt;write.trans_id, ESP_GATT_OK, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_EXEC_WRITE_EVT:</span><br><span class="line">            <span class="comment">// the length of gattc prepare write data must be less than GATTS_DEMO_CHAR_VAL_LEN_MAX.</span></span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;ESP_GATTS_EXEC_WRITE_EVT&quot;</span>);</span><br><span class="line">            <span class="comment">//example_exec_write_event_env(&amp;prepare_write_env, param);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_MTU_EVT:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;ESP_GATTS_MTU_EVT, MTU %d&quot;</span>, param-&gt;mtu.mtu);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_CONF_EVT:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;ESP_GATTS_CONF_EVT, status = %d, attr_handle %d&quot;</span>, param-&gt;conf.status, param-&gt;conf.handle);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_START_EVT:</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;SERVICE_START_EVT, status %d, service_handle %d&quot;</span>, param-&gt;start.status, param-&gt;start.service_handle);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当 BLE 设备与客户端（例如手机或其他 BLE 设备）建立连接后，会触发这个事件。    </span></span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_CONNECT_EVT:</span><br><span class="line">            <span class="comment">// 印连接事件的相关信息。</span></span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;ESP_GATTS_CONNECT_EVT, conn_id = %d&quot;</span>, param-&gt;connect.conn_id);</span><br><span class="line">            esp_log_buffer_hex(TAG, param-&gt;connect.remote_bda, <span class="number">6</span>);</span><br><span class="line">            <span class="comment">// 初始化连接参数结构体 esp_ble_conn_update_params_t</span></span><br><span class="line">            <span class="type">esp_ble_conn_update_params_t</span> conn_params = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">// 将客户端的蓝牙地址复制到结构体中。</span></span><br><span class="line">            <span class="built_in">memcpy</span>(conn_params.bda, param-&gt;connect.remote_bda, <span class="keyword">sizeof</span>(<span class="type">esp_bd_addr_t</span>));</span><br><span class="line">            <span class="comment">// 设置连接参数</span></span><br><span class="line">            <span class="comment">// iOS 对 BLE 连接参数有严格的限制，开发者需要遵循 Apple 的官方文档，否则可能导致连接失败或不稳定。</span></span><br><span class="line">            <span class="comment">// 表示从机可以忽略多少个连接事件。这里设置为 0，表示从机不会忽略任何事件。</span></span><br><span class="line">            conn_params.latency = <span class="number">0</span>;    <span class="comment">//从机延迟</span></span><br><span class="line">            conn_params.max_int = <span class="number">0x20</span>; <span class="comment">// 最大连接间隔 = 0x20*1.25ms = 40ms</span></span><br><span class="line">            conn_params.min_int = <span class="number">0x10</span>; <span class="comment">// 最小连接间隔 = 0x10*1.25ms = 20ms</span></span><br><span class="line">            <span class="comment">// 如果在这个时间内没有通信，连接会被认为断开。</span></span><br><span class="line">            conn_params.timeout = <span class="number">400</span>;  <span class="comment">// 监控超时 = 400*10ms = 4000ms</span></span><br><span class="line">            <span class="comment">// 向客户端发送更新连接参数的请求。客户端可以选择接受或拒绝这些参数。</span></span><br><span class="line">            esp_ble_gap_update_conn_params(&amp;conn_params);</span><br><span class="line">            <span class="comment">// 将连接句柄保存到全局变量 gl_conn_id 中，以便后续使用</span></span><br><span class="line">            gl_conn_id = param-&gt;connect.conn_id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_DISCONNECT_EVT:  <span class="comment">//收到断开连接事件</span></span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;ESP_GATTS_DISCONNECT_EVT, reason = 0x%x&quot;</span>, param-&gt;disconnect.reason);</span><br><span class="line">            <span class="comment">// 注意断开后要从新设置连接，并将连接id设为一个无效值</span></span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">            gl_conn_id = <span class="number">0xFFFF</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当 GATT 服务的属性表创建成功时触发  </span></span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_CREAT_ATTR_TAB_EVT: </span><br><span class="line">            <span class="comment">// 检查属性表是否创建成功。</span></span><br><span class="line">            <span class="keyword">if</span> (param-&gt;add_attr_tab.status != ESP_GATT_OK)&#123;</span><br><span class="line">                    ESP_LOGE(TAG, <span class="string">&quot;create attribute table failed, svc id = %d,error code=0x%x&quot;</span>,param-&gt;add_attr_tab.svc_inst_id, param-&gt;add_attr_tab.status);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 处理服务属性表1的结果。SVC_IND_ID1 服务实例 1 的 ID</span></span><br><span class="line">            <span class="keyword">if</span>(param-&gt;add_attr_tab.svc_inst_id == SVC_IND_ID1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 num_handle 不等于 SV1_IDX_NB，说明属性表创建异常，记录错误日志。</span></span><br><span class="line">                <span class="comment">// SV1_IDX_NB：服务实例 1 的属性表预期包含的属性数量。</span></span><br><span class="line">                <span class="keyword">if</span> (param-&gt;add_attr_tab.num_handle != SV1_IDX_NB)&#123;</span><br><span class="line">                    ESP_LOGE(TAG, <span class="string">&quot;create attribute table abnormally, num_handle (%d) \</span></span><br><span class="line"><span class="string">                            doesn&#x27;t equal to NETCFG_IDX_NB(%d)&quot;</span>, param-&gt;add_attr_tab.num_handle, SV1_IDX_NB);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;create attribute table successfully, the number handle = %d\n&quot;</span>,param-&gt;add_attr_tab.num_handle);</span><br><span class="line">                    <span class="comment">// 将创建的属性句柄数组复制到 sv1_handle_table 中，以便后续使用。</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(sv1_handle_table, param-&gt;add_attr_tab.handles, <span class="keyword">sizeof</span>(sv1_handle_table));</span><br><span class="line">                    <span class="comment">// 启动服务实例 1</span></span><br><span class="line">                    esp_ble_gatts_start_service(sv1_handle_table[SV1_IDX_SVC]);</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;add_attr_tab.svc_inst_id == SVC_IND_ID2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (param-&gt;add_attr_tab.num_handle != SV2_IDX_NB)&#123;</span><br><span class="line">                    ESP_LOGE(TAG, <span class="string">&quot;create attribute table abnormally, num_handle (%d) \</span></span><br><span class="line"><span class="string">                            doesn&#x27;t equal to NETCFG_IDX_NB(%d)&quot;</span>, param-&gt;add_attr_tab.num_handle, SV2_IDX_NB);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;create attribute table successfully, the number handle = %d\n&quot;</span>,param-&gt;add_attr_tab.num_handle);</span><br><span class="line">                    <span class="built_in">memcpy</span>(sv2_handle_table, param-&gt;add_attr_tab.handles, <span class="keyword">sizeof</span>(sv2_handle_table));</span><br><span class="line">                    esp_ble_gatts_start_service(sv2_handle_table[SV2_IDX_SVC]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_STOP_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_OPEN_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_CANCEL_OPEN_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_CLOSE_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_LISTEN_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_CONGEST_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_UNREG_EVT:</span><br><span class="line">        <span class="keyword">case</span> ESP_GATTS_DELETE_EVT:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GAP事件回调函数</span></span><br><span class="line"><span class="comment"> * GAP是蓝牙协议栈中定义设备如何发现、连接和与其他设备交互的部分。</span></span><br><span class="line"><span class="comment"> * @param event BLE GAP 事件类型，枚举类型</span></span><br><span class="line"><span class="comment"> * @param param 一个指向 esp_ble_gap_cb_param_t 的指针，包含与当前事件相关的参数。</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gap_event_handler</span><span class="params">(<span class="type">esp_gap_ble_cb_event_t</span> event, <span class="type">esp_ble_gap_cb_param_t</span> *param)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="comment">// 该事件触发时，表示广播数据已经成功设置    </span></span><br><span class="line">        <span class="keyword">case</span> ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:</span><br><span class="line">            <span class="comment">// 将标志位置为0</span></span><br><span class="line">            adv_config_done &amp;= (~ADV_CONFIG_FLAG);</span><br><span class="line">            <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始广播，adv_params中是配置的广播参数</span></span><br><span class="line">                esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 该事件触发时，表示扫描响应数据已经成功设置    </span></span><br><span class="line">        <span class="keyword">case</span> ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:</span><br><span class="line">            <span class="comment">// 将标志位置为0</span></span><br><span class="line">            adv_config_done &amp;= (~SCAN_RSP_CONFIG_FLAG);</span><br><span class="line">            <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始广播</span></span><br><span class="line">                esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 此事件表示广播成功启动    </span></span><br><span class="line">        <span class="keyword">case</span> ESP_GAP_BLE_ADV_START_COMPLETE_EVT:</span><br><span class="line">            <span class="comment">/* advertising start complete event to indicate advertising start successfully or failed */</span></span><br><span class="line">            <span class="keyword">if</span> (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;advertising start failed&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ESP_LOGI(TAG, <span class="string">&quot;advertising start successfully&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:             <span class="comment">//停止广播成功事件</span></span><br><span class="line">            <span class="keyword">if</span> (param-&gt;adv_stop_cmpl.status != ESP_BT_STATUS_SUCCESS) &#123;</span><br><span class="line">                ESP_LOGE(TAG, <span class="string">&quot;Advertising stop failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ESP_LOGI(TAG, <span class="string">&quot;Stop adv successfully\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:        <span class="comment">//更新连接参数成功事件</span></span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;update connection params status = %d, min_int = %d, max_int = %d,conn_int = %d,latency = %d, timeout = %d&quot;</span>,</span><br><span class="line">                  param-&gt;update_conn_params.status,</span><br><span class="line">                  param-&gt;update_conn_params.min_int,</span><br><span class="line">                  param-&gt;update_conn_params.max_int,</span><br><span class="line">                  param-&gt;update_conn_params.conn_int,</span><br><span class="line">                  param-&gt;update_conn_params.latency,</span><br><span class="line">                  param-&gt;update_conn_params.timeout);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化并启动蓝牙BLE</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ble_cfg_net_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// esp_err_t ret;</span></span><br><span class="line">    <span class="comment">// 释放 Classic Bluetooth（经典蓝牙）模式的内存。</span></span><br><span class="line">    <span class="comment">// ESP32 支持多种蓝牙模式，ESP_BT_MODE_CLASSIC_BT 是经典蓝牙模式，</span></span><br><span class="line">    <span class="comment">// 调用该函数会释放其相关的内存资源，因为这里我们要使用的是 BLE 模式，经典蓝牙模式不再需要。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));</span><br><span class="line">	<span class="comment">// 引用提供的蓝牙默认配置</span></span><br><span class="line">    <span class="type">esp_bt_controller_config_t</span> bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();</span><br><span class="line">    <span class="comment">// 使用默认配置初始化蓝牙控制器</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_bt_controller_init(&amp;bt_cfg));</span><br><span class="line">    <span class="comment">// 启用蓝牙控制器并指定使用蓝牙低能耗 (BLE) 模式</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_BLE));</span><br><span class="line">    <span class="comment">// 定义并初始化蓝牙堆栈（Bluedroid）的配置结构体</span></span><br><span class="line">    <span class="comment">// Bluedroid 是 ESP32 官方封装好的蓝牙协议栈支持经典蓝牙和低功耗蓝牙。</span></span><br><span class="line">    <span class="type">esp_bluedroid_config_t</span> bluedroid_cfg = BT_BLUEDROID_INIT_CONFIG_DEFAULT();</span><br><span class="line">    <span class="comment">// 使用指定的配置初始化蓝牙堆栈</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_bluedroid_init_with_cfg(&amp;bluedroid_cfg));</span><br><span class="line">    <span class="comment">// 启用蓝牙堆栈</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_bluedroid_enable());</span><br><span class="line">    <span class="comment">// 注册 GATT 事件用于注册处理 GATT 服务器事件的回调函数</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_ble_gatts_register_callback(gatts_profile_event_handler));</span><br><span class="line">    <span class="comment">// 注册 GAP（通用访问配置文件）事件回调函数处理与 BLE 连接相关的事件，例如设备扫描、连接、断开连接等。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_ble_gap_register_callback(gap_event_handler));</span><br><span class="line">    <span class="comment">// 注册一个 GATT 应用,通常来说一个应用注册一个 ID 即可。</span></span><br><span class="line">    <span class="comment">// 例如你的设备需要同时支持心率服务和温度服务，那么你需要为这两个服务分别定义不同的应用 ID。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_ble_gatts_app_register(ESP_APP_ID));</span><br><span class="line">    <span class="comment">// 设置本地的 GATT MTU（最大传输单元）。指在网络协议中一次传输的数据包的最大字节数。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_ble_gatt_set_local_mtu(<span class="number">500</span>));</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个函数是暴露给外部去使用的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置特征1的值</span></span><br><span class="line"><span class="comment"> * @param value 值</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ble_set_ch1_value</span><span class="params">(<span class="type">uint16_t</span> value)</span>&#123;</span><br><span class="line">    sv1_char2_value[<span class="number">0</span>] = value&amp;<span class="number">0xff</span>;</span><br><span class="line">    sv1_char2_value[<span class="number">1</span>] = value&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    <span class="comment">//判断连接是否有效，以及客户端特征配置是否不为0</span></span><br><span class="line">    <span class="comment">// 因为 0 表示不能上报</span></span><br><span class="line">    <span class="keyword">if</span>(gl_conn_id != <span class="number">0xFFFF</span> &amp;&amp; (sv1_ch1_client_cfg[<span class="number">0</span>] | sv1_ch1_client_cfg[<span class="number">1</span>]))&#123;</span><br><span class="line">        <span class="comment">// 更新 GATT 服务器中特征的值。</span></span><br><span class="line">        <span class="comment">// v1_handle_table[SV1_CH1_IDX_CHAR_VAL]：特征的句柄（Handle）</span></span><br><span class="line">        <span class="comment">// 2：特征值的长度（2 字节）。</span></span><br><span class="line">        <span class="comment">// (const uint8_t*)&amp;sv1_char2_value：特征值的数据。</span></span><br><span class="line">        esp_ble_gatts_set_attr_value(sv1_handle_table[SV1_CH1_IDX_CHAR_VAL], <span class="number">2</span>, (<span class="type">const</span> <span class="type">uint8_t</span>*)&amp;sv1_char2_value);</span><br><span class="line">        <span class="comment">// 向客户端发送通知（Indication）。</span></span><br><span class="line">        <span class="comment">// gl_gatts_if：GATT 服务器的接口 ID。</span></span><br><span class="line">        <span class="comment">// gl_conn_id：连接句柄，表示当前连接。</span></span><br><span class="line">        <span class="comment">// sv1_handle_table[SV1_CH1_IDX_CHAR_VAL]：特征的句柄。</span></span><br><span class="line">        <span class="comment">// 2：特征值的长度。m</span></span><br><span class="line">        <span class="comment">// (uint8_t*)&amp;sv1_char2_value：特征值的数据。</span></span><br><span class="line">        <span class="comment">// false：表示发送的是通知（Notification），而不是指示（Indication）。</span></span><br><span class="line">        <span class="comment">// 如果是 true，则表示发送的是指示（Indication），客户端需要回复确认。</span></span><br><span class="line">        <span class="comment">// 注意这里发送的通知或指示，要看特征中配置的是通知还是指示</span></span><br><span class="line">        esp_ble_gatts_send_indicate(gl_gatts_if, gl_conn_id,sv1_handle_table[SV1_CH1_IDX_CHAR_VAL], <span class="number">2</span>, (<span class="type">uint8_t</span>*)&amp;sv1_char2_value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置特征2的值</span></span><br><span class="line"><span class="comment"> * @param value 值</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ble_set_ch2_value</span><span class="params">(<span class="type">uint16_t</span> value)</span>&#123;</span><br><span class="line">    sv2_char2_value[<span class="number">0</span>] = value&amp;<span class="number">0xff</span>;</span><br><span class="line">    sv2_char2_value[<span class="number">1</span>] = value&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    <span class="comment">//判断连接是否有效，以及客户端特征配置是否不为0</span></span><br><span class="line">    <span class="keyword">if</span>(gl_conn_id != <span class="number">0xFFFF</span> &amp;&amp; (sv1_ch2_client_cfg[<span class="number">0</span>] | sv1_ch2_client_cfg[<span class="number">1</span>]))&#123;</span><br><span class="line">        esp_ble_gatts_set_attr_value(sv1_handle_table[SV1_CH2_IDX_CHAR_VAL], <span class="number">2</span>, (<span class="type">const</span> <span class="type">uint8_t</span>*)&amp;sv2_char2_value);</span><br><span class="line">        esp_ble_gatts_send_indicate(gl_gatts_if, gl_conn_id,sv1_handle_table[SV1_CH2_IDX_CHAR_VAL], <span class="number">2</span>, (<span class="type">uint8_t</span>*)&amp;sv2_char2_value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">=============================================================</span><br><span class="line"><span class="comment">// main.c    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_err.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ble.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mytask1(<span class="type">void</span>* param)&#123;</span><br><span class="line">    <span class="type">uint16_t</span> count1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> count2 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">3000</span>));</span><br><span class="line">        ble_set_ch1_value(count1++);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">700</span>));</span><br><span class="line">        ble_set_ch2_value(count2++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 NVS (Non-Volatile Storage)，它是一个用于存储配置、状态信息等的非易失性存储</span></span><br><span class="line">    ESP_ERROR_CHECK(nvs_flash_init());</span><br><span class="line">    <span class="comment">// 初始化蓝牙配置</span></span><br><span class="line">    ble_cfg_net_init();</span><br><span class="line">    <span class="comment">// 创建一个名为 mytask1 的 FreeRTOS 任务并将其固定到指定的 CPU 核心。</span></span><br><span class="line">    <span class="comment">// 这个任务我们拿来做自己的事情</span></span><br><span class="line">    xTaskCreatePinnedToCore(mytask1,<span class="string">&quot;mytask&quot;</span>,<span class="number">4096</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行后可以通过蓝牙检索到名为”ESP32-HOME”的设备，通过上述的微信小程序可成功连接到蓝牙；</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>头文件报错</strong></p>
<p>例如：fatal error: esp_bt.h: No such file or directory</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/wenti1.png" alt="wenti1"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/wenti2.png" alt="wenti2"></p>
]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>C模块</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>在 <strong>MicroPython</strong> 中，<strong>C 模块</strong>是指用 C 语言编写并编译的模块，它可以作为扩展模块嵌入到 MicroPython 中，与 Python 代码一起运行。C 模块的主要作用是扩展 MicroPython 的功能，尤其在性能和底层硬件交互方面有显著优势。</p>
<p>MicroPython 中自带的模块无法满足需求（如我们这里需要一个摄像头的驱动、需要特殊的通信协议、算法库等），这里就需要通过 C 模块实现新的功能扩展。</p>
<blockquote>
<p>C 模块并不是任意的他必须能被 MicroPython 解释器加载并执行的，也就是说他需要符合 MicroPython 的规范或者说他能够被 MicroPython 解释器所识别才可以被编译到 MicroPython 中去。</p>
</blockquote>
<p><strong>C 模块作用</strong></p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241211171604360.png" alt="image-20241211171604360"></p>
<blockquote>
<p><strong>ESP-IDF 是 ESP32 官方提供的开发框架</strong>，包含硬件驱动、协议栈和工具链，用于底层硬件控制和系统功能实现。<br><strong>MicroPython 固件</strong>对 ESP-IDF 的底层 C 接口进行了二次封装，将硬件控制和系统功能以更易用的 Python 接口暴露给开发者，同时提供了 <strong>MicroPython 解释器</strong>，用于解释和执行 MicroPython 脚本代码。这种封装机制让开发者可以通过简洁的 Python 语法快速控制 ESP32 的硬件，例如 GPIO、I2C 和 Wi-Fi 等外设。</p>
<p>然而，对于某些硬件外设或功能，MicroPython 并未直接提供二次封装的接口支持。这种情况下，我们可以使用 <strong>C 模块</strong>来扩展 MicroPython 的功能：</p>
<ol>
<li><strong>C 模块的作用</strong><br>C 模块允许开发者直接调用硬件提供的底层 C API 驱动，同时将这些驱动接口封装为 Python 可调用的形式。这种方式结合了 <strong>C 语言的高性能和硬件控制能力</strong>，以及 <strong>Python 的简单易用性</strong>。</li>
<li><strong>C 模块的实现方式</strong><br>开发者可以通过 MicroPython 提供的扩展机制，将 C 代码中的硬件控制逻辑按照 MicroPython 规定的格式封装为自定义 Python 模块接口。应用层代码可以直接调用这些接口，而无需直接编写 C 代码。</li>
</ol>
</blockquote>
<p><strong>Python 调用 C 函数的实现原理</strong></p>
<p>关键在于，如何用 C 语言的形式在 MicroPython 源代码中表示函数的入参和出参</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241211223614684.png" alt="image-20241211223614684"></p>
<blockquote>
<p>在 Python 中万物皆对象，我们要将接收到的对象转换为我们对应的数值，然后再将处理后的结果从数值转换为对象然后返回；</p>
</blockquote>
<h2 id="编写-C-模块"><a href="#编写-C-模块" class="headerlink" title="编写 C 模块"></a>编写 C 模块</h2><p>这里我们以 cexample C 模块为例，可以在 GitHub 上下载 MciroPython 的源码然后在 \examples\usercmodule\cexample 文件中找到该示例。</p>
<p>该目录下有三个文件</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241211233039943.png" alt="image-20241211233039943"></p>
<p>三个文件的作用如下：</p>
<p><strong>.c 文件</strong></p>
<p>核心文件，负责实现 C 模块的具体功能逻辑。</p>
<p>定义 MicroPython 模块中要暴露给 Python 层的函数和对象。</p>
<p>需要按照 MicroPython 的 C API 格式实现，主要包括：</p>
<ul>
<li>模块方法表：定义模块中的函数。</li>
<li>模块对象结构：描述模块的属性和方法。</li>
<li>模块注册：将模块注册到 MicroPython 的虚拟机中。</li>
</ul>
<p><strong>.make 文件</strong></p>
<p>提供模块的编译配置，用于 <strong>CMake 构建系统</strong>。</p>
<p>描述如何将 examplemodule.c 编译并链接到 MicroPython 的固件中。</p>
<p>定义模块的源文件、目标名称及依赖关系。</p>
<p><strong>.mk 文件</strong></p>
<p>提供模块的编译配置，用于 <strong>Makefile 构建系统</strong>。</p>
<p>定义如何通过 Make 工具将模块编译和链接到 MicroPython 的固件中。</p>
<p>功能类似于 micropython.cmake，但适用于传统的 Makefile 系统。</p>
<p><strong>这里展示第一个示例：通过模块.函数名的方式调用的如何定义</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .c 内容示例</span></span><br><span class="line">/* 第一部分：添加所需要 API 的头文件 */</span><br><span class="line">// 包含 MicroPython API.</span><br><span class="line">// 提供了 MicroPython 运行时相关的各种函数、类型定义等基础功能，是在 C 代码中与 MicroPython 交互的核心头文件</span><br><span class="line"><span class="comment">#include &quot;py/runtime.h&quot;</span></span><br><span class="line">// 用于在涉及定时器（Timer）类示例等场景下获取时间相关操作的支持，方便后续代码与 MicroPython 中时间相关特性协同工作。</span><br><span class="line"><span class="comment">#include &quot;py/mphal.h&quot;</span></span><br><span class="line"></span><br><span class="line">/* 第二部分：实现功能 */</span><br><span class="line">// 这是将从 Python 调用的函数，名为 cexample.add_ints（a，b）。</span><br><span class="line">// 这里定义了一个名为 example_add_ints(a, b) 的静态函数</span><br><span class="line">// 它可以在 MicroPython 环境下实现 C 和 Python 的交互</span><br><span class="line">static mp_obj_t example_add_ints(mp_obj_t a_obj, mp_obj_t b_obj) &#123;</span><br><span class="line">    // 从 MicroPython 输入对象中提取整数。</span><br><span class="line">    <span class="built_in">int</span> a = mp_obj_get_int(a_obj);</span><br><span class="line">    <span class="built_in">int</span> b = mp_obj_get_int(b_obj);</span><br><span class="line"></span><br><span class="line">    // 相加后转换为 MicroPython 对象返回。</span><br><span class="line">    <span class="keyword">return</span> mp_obj_new_int(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 第三部分：将 example_add_ints 函数添加到 example_add_ints_obj 这个模块当中 */</span><br><span class="line">// 定义对上述函数的 Python 引用。使得这个 C 函数可以在 MicroPython 模块的层面被识别和调用，</span><br><span class="line">static MP_DEFINE_CONST_FUN_OBJ_2(example_add_ints_obj, example_add_ints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 第四部分：将模块注册到模块列表 */</span><br><span class="line">// 定义模块的所有属性。</span><br><span class="line">// 表条目是属性名(字符串)和MicroPython对象引用的键/值对。</span><br><span class="line">// 所有标识符和字符串都写为 MP_QSTR_xxx，并将由构建系统优化为字长整数(互联字符串)。</span><br><span class="line">// 这里定义了模块名以及模块内可被外部访问的函数等相关属性信息。</span><br><span class="line">static const mp_rom_map_elem_t example_module_globals_table[] = &#123;</span><br><span class="line">    &#123; MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_cexample) &#125;,</span><br><span class="line">    &#123; MP_ROM_QSTR(MP_QSTR_add_ints), MP_ROM_PTR(&amp;example_add_ints_obj) &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 第五部分：将模块列表注册到 example_module_globals 字典对象中 */</span><br><span class="line">static MP_DEFINE_CONST_DICT(example_module_globals, example_module_globals_table);</span><br><span class="line"></span><br><span class="line">/* 第六部分：定义模块对象 */</span><br><span class="line">const mp_obj_module_t example_user_cmodule = &#123;</span><br><span class="line">    .base = &#123; &amp;mp_type_module &#125;,</span><br><span class="line">    .<span class="built_in">globals</span> = (mp_obj_dict_t *)&amp;example_module_globals,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 第七部分：注册该模块，使其在 Python 中可用 */</span><br><span class="line">// 注册到 MicroPython 环境中，使得在 Python 代码里可以导入并使用这个 C 语言实现的模块及其提供的功能</span><br><span class="line">MP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么我们在 MicroPython 中使用他的步骤如下：</p>
<p>import cexample</p>
<p>cexample.add_ints(a，b)，即可使用</p>
<p>这里注意导入时候前面要有个 c </p>
</blockquote>
<p><strong>这里展示第二种：导入一个模块后，通过模块声明一个对象，然后对象.函数名的形式如何定义</strong></p>
<h2 id="编译到-MicroPython"><a href="#编译到-MicroPython" class="headerlink" title="编译到 MicroPython"></a>编译到 MicroPython</h2>]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT协议</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/MQTT%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>MQTT(Message Queuing Telemetry Transport，消息队列遥测传输协议)，是一种基于发布&#x2F;订阅(publish&#x2F;subscribe)模式的”轻量级”通讯协议，该协议构建于 TCP&#x2F;IP 协议上，由 IBM 在 1999 年发布。MQTT 最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。</p>
<p><strong>协议类型</strong>：发布&#x2F;订阅（Pub&#x2F;Sub）模式。</p>
<p><strong>传输层协议</strong>：基于 TCP&#x2F;IP 协议栈，默认使用 <strong>TCP</strong> 作为传输协议，但也有针对 <strong>WebSocket</strong> 和 <strong>TLS</strong> 等协议的扩展。</p>
<p><strong>轻量级</strong>：头部非常小，适合在带宽受限、计算能力有限的嵌入式设备中使用。</p>
<h2 id="MQTT协议特性"><a href="#MQTT协议特性" class="headerlink" title="MQTT协议特性"></a>MQTT协议特性</h2><p><strong>发布&#x2F;订阅模型</strong></p>
<ul>
<li><strong>发布者（Publisher）</strong>：向特定的“主题（Topic）”发布消息。</li>
<li><strong>订阅者（Subscriber）</strong>：对一个或多个主题进行订阅，接收相关的消息。</li>
<li><strong>代理（Broker）</strong>：充当消息的中转站，管理客户端的连接、消息路由和交付。</li>
</ul>
<p>这种模型使得通信双方不需要直接互相了解或联系，而是通过代理来传递消息，提升了系统的灵活性和扩展性。</p>
<p><strong>消息传递</strong></p>
<ul>
<li><p><strong>主题（Topic）</strong>：消息的标识符，通常是一个层级结构的字符串。例如，home&#x2F;livingroom&#x2F;light。</p>
</li>
<li><p>QoS（Quality of Service）级别</p>
<p>：MQTT 提供了三种消息传递服务质量级别：</p>
<ul>
<li><strong>QoS 0</strong>：最多一次传送（At most once），消息可能丢失，不会重发。</li>
<li><strong>QoS 1</strong>：至少一次传送（At least once），消息会重发，直到确认收到。</li>
<li><strong>QoS 2</strong>：只有一次传送（Exactly once），确保消息只发送一次。</li>
</ul>
</li>
</ul>
<p><strong>持久化会话（Session Persistence）</strong></p>
<ul>
<li>MQTT 允许在断开连接后保留客户端的会话状态，包括订阅信息和未接收的消息。连接恢复后，可以继续接收消息，而无需重新订阅。</li>
</ul>
<p><strong>遗嘱消息（Last Will and Testament, LWT）</strong></p>
<ul>
<li>MQTT 允许在客户端异常断开时，代理发送一个遗嘱消息。这有助于检测客户端的状态，并通知其他订阅者。</li>
</ul>
<p><strong>低带宽和高效性</strong></p>
<ul>
<li>MQTT 协议的消息头非常小，最大只有 2 字节，适合带宽受限或不稳定的网络环境。</li>
</ul>
<h2 id="MQTT协议包结构"><a href="#MQTT协议包结构" class="headerlink" title="MQTT协议包结构"></a>MQTT协议包结构</h2><p>MQTT（<strong>Message Queuing Telemetry Transport</strong>）协议结构主要由 <strong>固定报头（Fixed Header）</strong> 和 <strong>可变报头（Variable Header）</strong> 以及 <strong>有效载荷（Payload）</strong> 构成。可变头部与有效荷载不一定每个报文都有，内容根据报文类型不同而不同。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>固定头部</strong></td>
<td>1-2 字节</td>
<td>包括消息类型、标志和剩余长度。</td>
</tr>
<tr>
<td><strong>可变头部</strong></td>
<td>0 到 N 字节</td>
<td>包含主题名称、消息标识符等。</td>
</tr>
<tr>
<td><strong>有效载荷</strong></td>
<td>N 字节</td>
<td>包含消息的实际数据。</td>
</tr>
</tbody></table>
<h3 id="固定报头"><a href="#固定报头" class="headerlink" title="固定报头"></a>固定报头</h3><p><strong>第一字节</strong>：</p>
<ul>
<li><strong>0-3 位</strong>：用于指定报文类型的标志位。</li>
<li><strong>4-7 位</strong>：用于表示报文类型。</li>
</ul>
<p><strong>第二字节及后续字节</strong>：</p>
<ul>
<li><strong>剩余长度（Remaining Length）</strong>：从第二字节开始，表示后续可变报头和消息负载的总长度。</li>
<li>剩余长度字段最多可以使用<strong>四个字节</strong>。</li>
<li>单个字节最大值为 <strong>0x7F</strong>（十六进制），即 127 字节。</li>
<li>如果剩余长度字段的最高位（第 8 位）为 <strong>1</strong>，则表示后续还有更多字节存在，这种机制被称为“延续位”。</li>
<li>因此，最后一字节的最大值只能是 <strong>0x7F</strong>。</li>
</ul>
<p><strong>固定报头第一个字节表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/gdbzdygzj.png" alt="gdbzdygzj"></p>
<blockquote>
<p>DUP<sup>1</sup>：用于标识消息是否是重复的。0：表示该消息是新的，1：表示该消息是重复的。</p>
<p>QoS<sup>2</sup>：定义消息传递的可靠性。MQTT协议提供了三个级别的QoS，分别为：</p>
<ul>
<li><strong>QoS 0</strong>：至多一次（At most once）——消息最多被传输一次，不做重传保证。适用于不需要严格可靠性的场景。</li>
<li><strong>QoS 1</strong>：至少一次（At least once）——消息至少传输一次，保证消息到达。会进行重试以确保消息被接收。</li>
<li><strong>QoS 2</strong>：只有一次（Exactly once）——消息只会传输一次，并且通过四次握手保证消息的唯一性。适用于高可靠性需求的场景。</li>
<li><strong>值</strong>：00：QoS 0、01：QoS 1、10：QoS 2</li>
</ul>
<p>RETAIN<sup>3</sup>：指示消息是否应该被保留在代理服务器上，以便后续的新订阅者能够立即接收到这条消息。</p>
<ul>
<li><p>如果设置了 RETAIN，则该消息会在代理中保留，直到有新的相同主题的消息发布。此时，新的订阅者一旦订阅该主题，会立即收到这条保留的消息。</p>
</li>
<li><p><strong>值</strong>：0：表示消息不会被保留。1：表示消息将被保留。</p>
</li>
</ul>
</blockquote>
<h3 id="可变报头与有效荷载"><a href="#可变报头与有效荷载" class="headerlink" title="可变报头与有效荷载"></a>可变报头与有效荷载</h3><p>不同类型的报文可变报头与有效荷载均不相同，这里以 CONNECT 与 CONNACK 为例：</p>
<p>CONNECT 报文是用于客户端向服务器发起连接请求的报文，服务器会验证其中的信息并且返回 CONNACK 告知客户端结果。CONNECT 包含固定包头、可变包头、消息载荷。CONNACK 包含固定包头、可变包头。</p>
<p><strong>CONNECT 报文格式介绍</strong><br>可变包头由如下构成协议名(Protocol Name)、协议等级(Protocol Level)、连接标志(Connect Flags)、保持连接(Keep Alive)</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/connectkbbt.png" alt="connectkbbt"></p>
<blockquote>
<p>协议名：一般 3.1.1 以后都用 MQTT</p>
<p>协议等级：4 代表 3.1.1，3 代表 3.1.1 之前的版本，5 代表 5.0</p>
<p>保持连接时间：<strong>客户端传输完成一个控制报文的时刻，到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔</strong></p>
<ul>
<li>如果保持连接时间设置为<code>60</code>秒，那么每60秒客户端必须至少向服务器发送一次消息（或进行心跳检查），如果没有，则服务器可能会断开连接。</li>
</ul>
</blockquote>
<h4 id="连接标志"><a href="#连接标志" class="headerlink" title="连接标志"></a>连接标志</h4><p>连接标志，主要用于指示 payload(有效荷载) 域存在哪些内容</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/ljbz.png" alt="ljbz"></p>
<blockquote>
<p>Clean Session：标识客户端是(0)否(1)建立一个持久化的会话，当 Clean Session 的标识设为 0 时，代表客户端希望建立一个持久会话的连接，代理服务器将存储该客户端订阅的主题和未接受的消息,否则(设置为1)代理服务器不会存储这些数据，同时在建立连接时清除这个客户端之前存在的持久化会话所保存的数据。</p>
</blockquote>
<p>如果连接标志包含所有内容，必须按如下这个顺序出现:客户端标识符，遗嘱主题，遗嘱消息，用户名，密 码，阿里云 IOT 不支持 will，因此 payload(有效荷载) 简化成如下：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/payloadcd.png" alt="payloadcd"></p>
<blockquote>
<p>所谓遗嘱功能，就是当服务器检测到客户端非正常断开连接时，就会向客户端遗嘱主题中发送相应的遗嘱消息；上图中就是不使用遗嘱功能的 payload 图。</p>
</blockquote>
<p><strong>CONNACK 报文格式介绍</strong></p>
<p>可变包头由如下构成:连接确认标志，返回码</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/connackkbbt.png" alt="connackkbbt"></p>
<p>当 CONNECT 报文中的 Clean Session 标志设置为 1 时，当前会话标志为。</p>
<p>CONNACK 没有 payload </p>
<h2 id="PUBLISH-发布-与SUBSCIRBE-订阅-报文"><a href="#PUBLISH-发布-与SUBSCIRBE-订阅-报文" class="headerlink" title="PUBLISH(发布)与SUBSCIRBE(订阅)报文"></a>PUBLISH(发布)与SUBSCIRBE(订阅)报文</h2><ul>
<li><p><strong>发布者（Publisher）</strong></p>
<p>负责将消息发布到主题上，发布者一次只能向一个主题发送数据，发布者发布消息时也无需关心订阅者是否在线。</p>
</li>
<li><p><strong>订阅者（Subscriber）</strong></p>
<p>订阅者通过订阅主题接收消息，且可一次订阅多个主题。MQTT 还支持通过<a href="https://www.emqx.com/zh/blog/introduction-to-mqtt5-protocol-shared-subscription">共享订阅</a>的方式在多个订阅者之间实现订阅的负载均衡。</p>
</li>
<li><p><strong>代理（Broker）</strong></p>
<p>负责接收发布者的消息，并将消息转发至符合条件的订阅者。另外，代理也需要负责处理客户端发起的连接、断开连接、订阅、取消订阅等请求。</p>
</li>
<li><p><strong>主题（Topic）</strong></p>
<p>主题是 MQTT 进行消息路由的基础，它类似 URL 路径，使用斜杠 &#x2F; 进行分层，比如 sensor&#x2F;1&#x2F;temperature。一个主题可以有多个订阅者，代理会将该主题下的消息转发给所有订阅者；一个主题也可以有多个发布者，代理将按照消息到达的顺序转发。</p>
</li>
</ul>
<p><strong>MQTT 发布与订阅流程</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/mqttlc.png" alt="mqttlc"></p>
<blockquote>
<p>MQTT 是基于主题来进行消息流向的；</p>
<p>topic(主题)：topic 在 MQTT 里面是消息传递的基础，代表了消息的流向，从本质上看，topic 是一串字符串，可以使用正斜杠对topic 进行分级。</p>
<p>例子：比如我向 A 代理服务器订阅了如下主题消息”&#x2F;编程知识&#x2F;嵌入式&#x2F;C语言”，当有其他人向 A 服务器推送了主题“&#x2F;编程知识&#x2F;嵌入式&#x2F;C语言”的消息时候，那么代理服务器就会把这条消息推送给我；如果别人推送的是“&#x2F;编程知识&#x2F;嵌入式&#x2F;C++”，由于主题不匹配，那么代理服务器就不会把这条消息推送给我们。</p>
</blockquote>
<h3 id="订阅协议格式"><a href="#订阅协议格式" class="headerlink" title="订阅协议格式"></a>订阅协议格式</h3><p>图片展示了与订阅和响应相关的数据格式，主要分为两部分：<strong>订阅请求报文</strong>和<strong>订阅响应报文</strong>。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/dyqq.png" alt="dyqq"></p>
<blockquote>
<p><strong>固定报头</strong>：</p>
<ul>
<li>包含高 4 位的订阅报文类型（byte1），以及底 4 位的固定QOS（Quality of Service）值（byte1）。</li>
<li>从第二字节开始，表示后续可变报头和消息负载的总长度。</li>
</ul>
<p><strong>可变报头</strong>：</p>
<ul>
<li>PacketID：标识报文的唯一ID。PacketID 的作用是为报文的发送和接收提供唯一性，确保发送方和接收方在处理时能够正确地匹配请求和响应报文；也就是说发送与回应中的 PacketID 要保持一致。</li>
</ul>
<p><strong>帧载荷</strong>：</p>
<ul>
<li><p>2 byte 主题长度，表示主题的字节数。</p>
</li>
<li><p>主题内容（byte3到byteN），即具体的订阅内容。</p>
</li>
<li><p>服务质量要求QoS：比如有个客户端要向这个主题发布一条消息，那么客户端发布报文的 QoS 等级就不能高于此处的 QoS 等级。</p>
</li>
</ul>
</blockquote>
<h3 id="发布协议格式"><a href="#发布协议格式" class="headerlink" title="发布协议格式"></a>发布协议格式</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/dyxy.png" alt="dyxy"></p>
<h2 id="实现ESP32连接MQTT"><a href="#实现ESP32连接MQTT" class="headerlink" title="实现ESP32连接MQTT"></a>实现ESP32连接MQTT</h2><h3 id="MQTTX客户端工具"><a href="#MQTTX客户端工具" class="headerlink" title="MQTTX客户端工具"></a>MQTTX客户端工具</h3><p>这里要使用一个 MQTTX 这个工具。</p>
<p><a href="https://mqttx.app/">MQTTX 官网下载</a></p>
<p>我们要利用这个工具去连接到一个免费的给我们测试用的 MQTT 服务器中，操作如下：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/mqttlj.png" alt="mqttlj"></p>
<p>点击连接后就可以了。</p>
<h3 id="ESP32实现"><a href="#ESP32实现" class="headerlink" title="ESP32实现"></a>ESP32实现</h3><p><strong>实现分为两个部分，首先要让 ESP32 连接到互联网，之后才可以进行 MQTT 操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sta.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_wifi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置一个认证模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA2_PSK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SSID、密码、最大连接次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_SSID      <span class="string">&quot;Redmi Note 14 5G&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_PASS      <span class="string">&quot;wang123456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_MAXIMUM_RETRY  100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FreeRTOS 事件组，当我们连接时发出信号</span></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_wifi_event_group;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件组连接和失败标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_CONNECTED_BIT BIT0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_FAIL_BIT      BIT1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印日志用的标识符</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *TAG = <span class="string">&quot;wifi station&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前连接次数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_retry_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功标志,使用二进制信号量</span></span><br><span class="line">SemaphoreHandle_t  wifi_is_connected = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_handler</span><span class="params">(<span class="type">void</span>* arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                                <span class="type">int32_t</span> event_id, <span class="type">void</span>* event_data)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断事件的类型：WIFI_EVENT 表示wifi事件，WIFI_EVENT_STA_START 表示模式为 STA 启动模式</span></span><br><span class="line">    <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) &#123;</span><br><span class="line">        <span class="comment">// 连接到这个 WiFi</span></span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">    <span class="comment">// 表示 WiFi 断开事件    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) &#123;</span><br><span class="line">        <span class="comment">// 判断当前重复连接次数是否小于最大重复次数</span></span><br><span class="line">        <span class="keyword">if</span> (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) &#123;</span><br><span class="line">            esp_wifi_connect();</span><br><span class="line">            s_retry_num++;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;retry to connect to the AP&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果达到最大重试次数，设置 WIFI_FAIL_BIT 标志，通知连接失败。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印失败日志</span></span><br><span class="line">        ESP_LOGI(TAG,<span class="string">&quot;connect to the AP fail&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得 IP 地址事件    </span></span><br><span class="line">    <span class="comment">// IP_EVENT_STA_GOT_IP 表示 Wi-Fi 站点 (STA) 成功通过 DHCP（动态主机配置协议）获取到了 IP 地址。  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) &#123;</span><br><span class="line">        <span class="type">ip_event_got_ip_t</span>* event = (<span class="type">ip_event_got_ip_t</span>*) event_data;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;got ip:&quot;</span> IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));</span><br><span class="line">        s_retry_num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置 WIFI_CONNECTED_BIT 标志，表示连接成功。</span></span><br><span class="line">        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);</span><br><span class="line">    <span class="comment">// 表示 Wi-Fi 站点 (STA) 成功连接到 Wi-Fi 网络的 接入点 (AP)。  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_CONNECTED) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;esp32 connected to AP!&quot;</span>);</span><br><span class="line">        xSemaphoreGive(wifi_is_connected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wifi_init_sta</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个事件组，用于任务间通信和同步。</span></span><br><span class="line">    s_wifi_event_group = xEventGroupCreate();</span><br><span class="line">	<span class="comment">// 初始化底层的网络接口模块，为后续的网络通信做好准备。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    <span class="comment">// 创建默认的事件循环，用于处理系统事件（如 Wi-Fi 的连接、断开、获取 IP 地址等事件）。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    <span class="comment">// 创建默认的 Wi-Fi STA 接口（Station），这是 ESP32 的网络接口之一，用于连接到路由器。</span></span><br><span class="line">    <span class="comment">// 该函数会返回一个网卡对象，但是我们一般用不到</span></span><br><span class="line">    esp_netif_create_default_wifi_sta();</span><br><span class="line">    <span class="comment">/*初始化 WiFi 驱动*/</span></span><br><span class="line">    <span class="comment">// 通过 WIFI_INIT_CONFIG_DEFAULT() 宏生成默认配置结构体。</span></span><br><span class="line">    <span class="type">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    <span class="comment">// 初始化 Wi-Fi 驱动</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line">    <span class="comment">// 创建二进制信号量，用于后续 MQTT 判断</span></span><br><span class="line">    wifi_is_connected = xSemaphoreCreateBinary();</span><br><span class="line">	<span class="comment">// 注册 Wi-Fi 和 IP 事件处理程序</span></span><br><span class="line">    <span class="type">esp_event_handler_instance_t</span> instance_any_id;</span><br><span class="line">    <span class="type">esp_event_handler_instance_t</span> instance_got_ip;</span><br><span class="line">    <span class="comment">// WIFI_EVENT 表示事件类型</span></span><br><span class="line">    <span class="comment">// ESP_EVENT_ANY_ID 表示监听所有的 Wi-Fi 事件，而不是单一特定事件。</span></span><br><span class="line">    <span class="comment">// event_handler 表示处理函数</span></span><br><span class="line">    <span class="comment">// 自定义参数填 NULL</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_any_id));</span><br><span class="line">    <span class="comment">// 同上，这里表示注册一个 IP 事件</span></span><br><span class="line">    <span class="comment">// 当我们连接到路由器，获取到 IP 后就会触发这个事件</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class="line">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_got_ip));</span><br><span class="line">	<span class="comment">// 配置 WiFi STA 模式参数</span></span><br><span class="line">    <span class="type">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            <span class="comment">// 要连接的 Wi-Fi 路由器的 SSID。</span></span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            <span class="comment">// Wi-Fi 路由器的密码。</span></span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               设置加密模式</span></span><br><span class="line"><span class="comment">               如果 Wi-Fi 密码符合 WPA2 标准，即密码长度为 8 字节或以上（这是 WPA2 的最低要求）</span></span><br><span class="line"><span class="comment">               则认证模式（Authmode）默认设置为 WPA2。</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">			   ESP32 会自动判断提供的密码是否满足 WPA2 标准，并相应地设置 Wi-Fi 的认证模式为 WPA2。</span></span><br><span class="line"><span class="comment">               如果用户未主动修改 authmode 的值，这个默认设置将会被使用。</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">               如果你需要连接到较旧（已被淘汰）的 Wi-Fi 网络（例如 WEP 或 WPA 加密方式的网络）</span></span><br><span class="line"><span class="comment">               需要手动将 authmode 的阈值设置为 WIFI_AUTH_WEP 或 WIFI_AUTH_WPA_PSK。</span></span><br><span class="line"><span class="comment">               当连接到 WEP 或 WPA 网络时，密码必须符合这些网络的要求：</span></span><br><span class="line"><span class="comment">					WEP：密码可以是 5 个字符（40 位）或 13 个字符（104 位）等格式。</span></span><br><span class="line"><span class="comment">					WPA：密码通常需要在 8 到 63 个字符之间。</span></span><br><span class="line"><span class="comment">             */</span>       </span><br><span class="line">            .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,</span><br><span class="line">            <span class="comment">// 保护管理帧，提升网络安全性。</span></span><br><span class="line">            <span class="comment">// 表示设备支持 PMF 功能。</span></span><br><span class="line">            <span class="comment">// 设备不强制要求 PMF。如果接入点支持 PMF，则会使用；如果接入点不支持，也允许连接。</span></span><br><span class="line">            .pmf_cfg.capable = <span class="literal">true</span>,</span><br><span class="line">            .pmf_cfg.required = <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置 Wi-Fi 模式为 WIFI_MODE_STA，即客户端模式。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );</span><br><span class="line">    <span class="comment">// 配置 Wi-Fi STA 的参数（如 SSID 和密码）。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config) );</span><br><span class="line">    <span class="comment">// 启动 Wi-Fi 驱动，开始尝试连接到配置好的 Wi-Fi 网络。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start() );</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_sta finished.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 等待连接结果 */</span></span><br><span class="line">    <span class="comment">/* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum</span></span><br><span class="line"><span class="comment">     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */</span></span><br><span class="line">    <span class="comment">// 等待事件组中的指定事件位（WIFI_CONNECTED_BIT | WIFI_FAIL_BIT）被设置。</span></span><br><span class="line">    <span class="comment">// pdFALSE、pdFALSE 表示不清除事件位、表示任意一个事件位设置即可返回。</span></span><br><span class="line">    <span class="comment">// portMAX_DELAY 超时时间，portMAX_DELAY 表示无限等待，直到事件发生。</span></span><br><span class="line">    <span class="comment">// 返回的是事件组中设置的事件位状态，即调用 xEventGroupWaitBits 时，事件组中的状态位。</span></span><br><span class="line">    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,</span><br><span class="line">            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually</span></span><br><span class="line"><span class="comment">     * happened. */</span></span><br><span class="line">    <span class="comment">// 判断连接状态</span></span><br><span class="line">    <span class="comment">// WIFI_CONNECTED_BIT（Wi-Fi 连接成功的标志）</span></span><br><span class="line">    <span class="keyword">if</span> (bits &amp; WIFI_CONNECTED_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;connected to ap SSID:%s password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    <span class="comment">// WIFI_FAIL_BIT（Wi-Fi 连接失败的标志）    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits &amp; WIFI_FAIL_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Failed to connect to SSID:%s, password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    <span class="comment">// 表示发生了意料之外的情况（理论上不应该进入）。    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;UNEXPECTED EVENT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sta_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// NVS是 ESP32 内部的一块非易失性存储空间，通常用于保存 Wi-Fi 配置、设备配置信息等需要掉电保持的数据。</span></span><br><span class="line">    <span class="comment">// 当我们使用 SSID 和 密码连接成功后，IDF 的底层会帮我们把这组 SSID 和密码保存到 NVS 中，下次</span></span><br><span class="line">    <span class="comment">// 系统启动的时候，启动 STA 模式连接后，就会使用这组 SSID 和密码继续连接；</span></span><br><span class="line">    <span class="type">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="comment">// 如果返回值为 ESP_ERR_NVS_NO_FREE_PAGES 或 ESP_ERR_NVS_NEW_VERSION_FOUND</span></span><br><span class="line">    <span class="comment">// 则表示当前 NVS 存储有问题（如存储空间不足或版本不兼容）。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">      <span class="comment">// nvs_flash_erase() 擦除 NVS 存储，清空之前的数据。</span></span><br><span class="line">      <span class="comment">// ESP_ERROR_CHECK 用于检查函数返回值。如果函数返回错误，会触发异常，打印错误日志并终止程序。</span></span><br><span class="line">      ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">      <span class="comment">// 重新初始化 NVS (nvs_flash_init())，确保可以正常使用  </span></span><br><span class="line">      ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK(ret);</span><br><span class="line">	<span class="comment">// 使用 ESP-IDF 提供的日志系统，打印一条信息日志，表明接下来将配置 Wi-Fi 工作模式为 STA</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;ESP_WIFI_MODE_STA&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置并启动 Wi-Fi 的 STA 模式，使 ESP32 作为 Wi-Fi 客户端连接到指定的路由器。</span></span><br><span class="line">    wifi_init_sta();</span><br><span class="line">&#125;</span><br><span class="line">===================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mqtt_client.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MQTTX 配置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_ADDRESS <span class="string">&quot;mqtt://broker-cn.emqx.io&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_PORT 1883</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_USER <span class="string">&quot;kay&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_PWD <span class="string">&quot;wang123456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_CLIENTID <span class="string">&quot;esp32_ClientID&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题</span></span><br><span class="line"><span class="comment">// ESP32 向 MQTT_TOPIC_ESP32_SEND 发送信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_TOPIC_ESP32_SEND <span class="string">&quot;/topic/esp32_send&quot;</span></span></span><br><span class="line"><span class="comment">// MQTTX 向 MQTT_TOPIC_ESP32_RECV 发送信息，ESP32 接收</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_TOPIC_ESP32_RECV <span class="string">&quot;/topic/esp32_recv&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *TAG = <span class="string">&quot;mqtt5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SemaphoreHandle_t  wifi_is_connected;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">sta_main</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief 注册的事件处理程序，用于接收 MQTT 事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  该函数由 MQTT 客户端事件循环调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param handler_args 用户数据，注册到该事件的。</span></span><br><span class="line"><span class="comment"> * @param base 事件基类（在此示例中始终为 MQTT Base）。</span></span><br><span class="line"><span class="comment"> * @param event_id 接收到的事件的 ID。</span></span><br><span class="line"><span class="comment"> * @param event_data 事件数据，类型为 esp_mqtt_event_handle_t。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mqtt5_event_handler</span><span class="params">(<span class="type">void</span> *handler_args, <span class="type">esp_event_base_t</span> base, <span class="type">int32_t</span> event_id, <span class="type">void</span> *event_data)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印事件是从哪个事件循环基础（base）触发的，并且标明了事件的 ID，便于识别是哪种事件。</span></span><br><span class="line">    ESP_LOGD(TAG, <span class="string">&quot;Event dispatched from event loop base=%s, event_id=%&quot;</span> PRIi32, base, event_id);</span><br><span class="line">    <span class="type">esp_mqtt_event_handle_t</span> event = event_data;</span><br><span class="line">    <span class="type">esp_mqtt_client_handle_t</span> client = event-&gt;client;</span><br><span class="line">    <span class="type">int</span> msg_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前设备的堆内存状态，输出的信息包括当前的可用堆内存大小和最低可用堆内存大小，</span></span><br><span class="line">    ESP_LOGD(TAG, <span class="string">&quot;free heap size is %&quot;</span> PRIu32 <span class="string">&quot;, minimum %&quot;</span> PRIu32, esp_get_free_heap_size(), esp_get_minimum_free_heap_size());</span><br><span class="line">    <span class="keyword">switch</span> ((<span class="type">esp_mqtt_event_id_t</span>)event_id) &#123;</span><br><span class="line">    <span class="comment">// MQTT 连接成功事件    </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_CONNECTED:</span><br><span class="line">        <span class="comment">// MQTT 连接成功</span></span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT connected&quot;</span>);</span><br><span class="line">        <span class="comment">// 连接成功后就可以进行发布与订阅</span></span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        msg_id = esp_mqtt_client_subscribe(client, MQTT_TOPIC_ESP32_RECV, <span class="number">1</span>);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;sent subscribe successful, msg_id=%d&quot;</span>, msg_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// MQTT 断开事件    </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_DISCONNECTED:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT_EVENT_DISCONNECTED&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 向服务器订阅一个主题，服务器返回给我们 ACK 后会触发这个事件 </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_SUBSCRIBED:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT_EVENT_SUBSCRIBED, msg_id=%d&quot;</span>, event-&gt;msg_id);</span><br><span class="line">        msg_id = esp_mqtt_client_publish(client, <span class="string">&quot;/topic/qos0&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;sent publish successful, msg_id=%d&quot;</span>, msg_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 当 MQTT 客户端请求取消订阅某个主题时，服务器会返回响应，确认取消订阅的请求已被处理并成功完成。该事件便在客户端收到响应时触发。    </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_UNSUBSCRIBED:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT_EVENT_UNSUBSCRIBED, msg_id=%d&quot;</span>, event-&gt;msg_id);</span><br><span class="line">        esp_mqtt_client_disconnect(client);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// MQTT 发布事件,当我们发布一条消息服务端给我们成功返回ACK之后会触发这个事件    </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_PUBLISHED:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT_EVENT_PUBLISHED, msg_id=%d&quot;</span>, event-&gt;msg_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ESP32 收到服务器发送过来的消息时候会触发这个事件    </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_DATA:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT_EVENT_DATA&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印主题，与数据内容</span></span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;TOPIC=%.*s&quot;</span>, event-&gt;topic_len, event-&gt;topic);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;DATA=%.*s&quot;</span>, event-&gt;data_len, event-&gt;data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 在在连接过程中发生了错误，会触发这个事件    </span></span><br><span class="line">    <span class="keyword">case</span> MQTT_EVENT_ERROR:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT_EVENT_ERROR&quot;</span>);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;MQTT5 return code is %d&quot;</span>, event-&gt;error_handle-&gt;connect_return_code);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Other event id:%d&quot;</span>, event-&gt;event_id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mqtt_start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">esp_mqtt_client_config_t</span> mqtt_cfg = &#123;</span><br><span class="line">        .broker.address.uri = MQTT_ADDRESS,</span><br><span class="line">        .broker.address.port = MQTT_PORT,</span><br><span class="line">        .credentials.client_id = MQTT_CLIENTID,</span><br><span class="line">        .credentials.username = MQTT_USER,</span><br><span class="line">        .credentials.authentication.password = MQTT_PWD,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// mqtt 初始化</span></span><br><span class="line">    <span class="type">esp_mqtt_client_handle_t</span> client = esp_mqtt_client_init(&amp;mqtt_cfg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册了一个 MQTT 客户端事件处理程序,</span></span><br><span class="line">    <span class="comment">// 监听来自于 client 这个示例中所有的 MQTT 事件，在 mqtt5_event_handler 函数中进行处理</span></span><br><span class="line">    <span class="comment">// ESP_EVENT_ANY_ID 监听所有的事件</span></span><br><span class="line">    esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt5_event_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    esp_mqtt_client_start(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    sta_main();</span><br><span class="line">    <span class="comment">// 只有在连接到网络之后会进行 MQTT 的一些列操作   </span></span><br><span class="line">    <span class="comment">// 等待获取信号量 </span></span><br><span class="line">    xSemaphoreTake(wifi_is_connected, portMAX_DELAY);</span><br><span class="line">    mqtt_start();</span><br><span class="line">    xSemaphoreGive(wifi_is_connected);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后即可通过 MQTTX 实现与 EPS32 之间的数据交互，如图所示：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/mqttjg.png" alt="mqttjg"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>导入的头文件报错</strong></p>
<p>ctrl + shift + P 选择：ESP-IDF: Add vscode configuration Folder</p>
<p>即可加入 IDF 路径</p>
<p>二、<strong>新建的多个文件报错</strong></p>
<p>Build 下就好了</p>
]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>ESP32 是一款功能强大的微控制器，支持多种开发环境，主要包括 <strong>Arduino IDE</strong>、<strong>ESP-IDF</strong> 和 <strong>MicroPython</strong>。这些开发环境各有优势，开发者可以根据项目需求和个人技能选择合适的工具进行开发。</p>
<h2 id="Arduino"><a href="#Arduino" class="headerlink" title="Arduino"></a>Arduino</h2><p><strong>Arduino IDE</strong> 是最简单和最受欢迎的开发环境之一，它使得开发者能够使用 Arduino 编程语言（基于 C&#x2F;C++）来编写和上传代码到 ESP32。通过安装相应的 <strong>ESP32 开发板支持包</strong>，用户可以在 Arduino IDE 中轻松开发 ESP32 项目。</p>
<p>&#x2F;&#x2F; TODO</p>
<h2 id="ESP-IDF"><a href="#ESP-IDF" class="headerlink" title="ESP-IDF"></a>ESP-IDF</h2><p><strong>ESP-IDF</strong> 是 <strong>Espressif</strong> 官方为 ESP32 系列提供的原生开发框架，适用于开发更复杂、定制化的应用。ESP-IDF 是一个功能完整的 SDK，支持 Wi-Fi、蓝牙、低功耗操作等高级功能，并允许直接控制硬件。</p>
<blockquote>
<p>ESP-IDF独立于项目以外，通过环境变量引导编译与链接，ESP-IDF 与项目工程分离</p>
<p>项目工程编译与链接必须依赖ESP-IDF，<strong>项目工程依赖于ESP-IDF</strong></p>
</blockquote>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><strong>下载</strong></p>
<p>下载 <a href="https://dl.espressif.com/dl/esp-idf/?idf=4.4">ESP-IDF</a> 的安装包，该安装包会安装一系列需要的组件：</p>
<ul>
<li>内置的 Python</li>
<li>交叉编译器</li>
<li>OpenOCD</li>
<li><a href="https://cmake.org/download/">CMake</a> 和 <a href="https://ninja-build.org/">Ninja</a> 编译工具</li>
<li>ESP-IDF</li>
</ul>
<p><strong>安装</strong></p>
<p>傻瓜式安装即可，注意安装步骤中的“安装前检查”和“完全安装”。</p>
<p>弹出如下两个终端表示安装成功：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/azcg.png" alt="azcg"></p>
<p><strong>配置环境变量</strong></p>
<p>安装成功后检查如下环境变量是否添加成功，如果没有就手动添加</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/mlhhjpz1.png" alt="mlhhjpz1"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/mlhhjpz2.png" alt="mlhhjpz2"></p>
<p><strong>测试是否可用</strong></p>
<p>1.拷贝 Espressif\Espressif\frameworks\esp-idf-v5.3.2\examples\get-started 下的 sample_project 文件到桌面</p>
<p>以管理员身份运行 ESP-IDF 5.3 CMD ，cd 到 sample_project 目录下执行 idf.py build</p>
<p>生成如下命令后说明编译成功</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/csky.png" alt="csky"></p>
<blockquote>
<p>生成后最关键的是如下三个文件：</p>
<p>sample_project\build 下的 main.bin</p>
<p>sample_project\build\bootloader 下的 bootloader.bin</p>
<p>sample_project\build\partition_table 下的 partition_table.bin 三个文件</p>
</blockquote>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>&#x2F;&#x2F; TODO</p>
<h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p><strong>在上面的环境搭建中，相当于我们配置死了某个具体版本的 ESP-IDF 库，如果我们确实要使用这个版本就没有问题，但是如果我们需要使用其他版本的 ESP-IDF 库就不行了，所以我们在使用 VSCode 进行开发时候，可以忽略上面的环境搭建，直接在 VSCode 中进行环境搭建</strong></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>在 VSCode 中安装 ESP-IDF 扩展插件</strong></p>
<p>&#x2F;&#x2F; TODO</p>
<p><strong>配置 ESP-IDF 插件</strong></p>
<p>ctrl + shift + P &gt; Configure ESP-IDF Extension</p>
<p>这里可以选择我们之前下载好的 ESP-IDF 官方库，如果没有下载可以直接看<strong>切换版本</strong>章节</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfpeizhi1.png" alt="idfpeizhi1.png"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfhjpz2.png" alt="idfhjpz2"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfhjpz3.png" alt="idfhjpz3"></p>
<p>等待其完成即可</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/hjpz4.png" alt="hjpz4"></p>
<h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p><strong>下载其他的 ESP-IDF 版本</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfpeizhi1.png" alt="idfpeizhi1.png"></p>
<p>这里需要指定全新的安装目录，记住这两个目录后面要设置环境变量用。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfqhbb2.png" alt="idfqhbb2"></p>
<p>上一步完成后要进行第二步工具下载</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfhjpz3.png" alt="idfhjpz3"></p>
<p>如下则表示配置成功</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/hjpz4.png" alt="hjpz4"></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>等加载完成后，我们需要配置下该版本的环境变量，这里注意<strong>我们使用哪个版本就配置哪个版本的环境变量</strong></p>
<p>这里设置的路径就是上面我们设置的安装路径</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfhjblpz.png" alt="idfhjblpz"></p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>VSCode 先进入一个空的文件夹</p>
<p>ctrl + shift + p 选择 Create Project from Extension Template</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/idfxjxm1.png" alt="idfxjxm1"></p>
<p>选择工程目录</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/xzgcml.png" alt="xzgcml"></p>
<p>选择工程模板</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/xzgcmb.png" alt="xzgcmb"></p>
<p>如果上述步骤都没有问题就可以看到如下界面</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/wcym.png" alt="wcym"></p>
<p>对于下面这一列 Cmake 命令列表如果发现不显示，则需要检查下环境变量配置是否正确；</p>
<p>然后点击工具条中的构建项目即可编译完成。</p>
<blockquote>
<p>如果 VSCode 中还安装了 Cmake-Tools 插件，那么在下面的 Cmake 工具条中会提示三个错误一个警告，这是由于 ESP-IDF 与 Cmake-Tools 插件冲突所致，Cmake-Tools 会报错找不到 ESP32 编译所需要的一些工具，因为 ESP-IDF 使用的是自己的环境变量（Cmake-TOOls 不识别），所以这里报错并不影响程序的编译运行；</p>
</blockquote>
<h2 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h2><p><a href="https://micropython.org/download/">MicroPython 固件</a>下载地址</p>
<p>固件烧录</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/gjsl.png" alt="gjsl"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/gsrm.png" alt="gsrm"></p>
<h2 id="esptool"><a href="#esptool" class="headerlink" title="esptool"></a>esptool</h2><p>一个基于 Python 的、开源的、独立于平台的实用程序，用于与 Espressif 芯片中的 ROM 引导加载程序进行通信。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/esptools1.png" alt="esptools1"></p>
<p>保证可以正常连接</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/esptools2.png" alt="esptools2"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/esptools3.png" alt="esptools3"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>测试时报错如下</strong></p>
<pre><code>lld: error: unable to find library -lunwind
lld: error: unable to find library -lunwind
clang: error: linker command failed with exit code 1 (use -v to see invocation)
ninja: build stopped: subcommand failed.
</code></pre>
<p>说明在执行 idf.py build 时候没有以管理员身份运行。</p>
<p>二、<strong>配置环境时报错如下</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/error2.png" alt="error2"></p>
<p>删除 d:\Tools\SDK\ESP32\Espressif\Espressif\tools\ 目录下的 idf-get 和 idf-python 目录重试即可</p>
]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>烧录方式</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/%E7%83%A7%E5%BD%95%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>ESP32 是一款功能强大的物联网芯片，支持多种固件烧录方式以满足不同的开发需求。这些方式主要包括 <strong>USB 串口烧录</strong>、<strong>JTAG 烧录</strong>、<strong>OTA 无线升级</strong>、<strong>SD 卡烧录</strong>和<strong>外部编程器烧录</strong>。每种方法都有其特定的适用场景和特点，以下为详细说明。</p>
<h2 id="USB-串口烧录"><a href="#USB-串口烧录" class="headerlink" title="USB 串口烧录"></a>USB 串口烧录</h2><p>ESP32 自带了 UART 烧录，特别是 ESP32-S3 芯片还支持 USB 烧录，我们只需要简单配置下 VSCode 就可以进行烧录。</p>
<p>当我们便写完代码后先 Build 下；然后通过 USB 将 ESP32S3 连接到我们的 PC，此时我们需要以此选择<strong>端口</strong>、<strong>烧录方式</strong>、<strong>设备目标</strong></p>
<p><strong>端口</strong>：S3 系列芯片因为支持 USB 烧录所以会弹出两个端口分别是 UART 和 USB 端口，这里我们任选一个；</p>
<p><strong>烧录方式</strong>：这里我们选择 UART 方式，其他如 JTAG 需要其他软件的支持，这里我们使用最简单的即可；</p>
<p><strong>设备目标</strong>：这里要选择我们所使用的 MCU 的型号，如我们用是的 ESP32-S3，这里就要选择esp32s3，因为不同的芯片他的 flash 起始地址可能不同，如果选错则会导致烧录失败；</p>
<p>当上面都执行完成后，我们点击<strong>烧录</strong>，就可以将代码烧录到我们的 Flash 中</p>
<p>如果想要看到控制台的打印信息点击<strong>监控设备</strong>即可；</p>
<h2 id="MicriPython"><a href="#MicriPython" class="headerlink" title="MicriPython"></a>MicriPython</h2><p><a href="https://micropython.org/download/">MicroPython 固件</a>下载地址</p>
<p>固件烧录</p>
<h2 id="esptool"><a href="#esptool" class="headerlink" title="esptool"></a>esptool</h2><p>一个基于 Python 的、开源的、独立于平台的实用程序，用于与 Espressif 芯片中的 ROM 引导加载程序进行通信。</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241211101509338.png" alt="image-20241211101509338"></p>
<p>保证可以正常连接</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241211102120061.png" alt="image-20241211102120061"></p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241211102650036.png" alt="image-20241211102650036"></p>
]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云IOT</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/%E9%98%BF%E9%87%8C%E4%BA%91IOT/</url>
    <content><![CDATA[<p>阿里云 IoT（Internet of Things，物联网）是阿里巴巴集团旗下的云计算平台，专注于为物联网设备提供全面的解决方案，包括设备管理、数据采集、存储、分析和应用服务。</p>
<p>支持设备的快速接入，可以通过设备 SDK、MQTT、CoAP 等协议，方便设备与云端建立连接。</p>
<h2 id="阿里云文档说明"><a href="#阿里云文档说明" class="headerlink" title="阿里云文档说明"></a>阿里云文档说明</h2><p><a href="https://iot.aliyun.com/">阿里云IoT - 所知不止于感知</a></p>
<p>注册登陆后点击”文档”，在文档中心点击“阿里云物联网平台”，在左边的”操作指南”中点击”设备接入”，即可找到设备接入相关信息。这里我们使用的是”使用协议自主接入”。</p>
<blockquote>
<p>注意要在 MQTT 协议中选择”MQTT-TLS 连结通信”</p>
<p>文档中详细的表明了接入需要的参数该如何设置</p>
</blockquote>
<h2 id="添加设备"><a href="#添加设备" class="headerlink" title="添加设备"></a>添加设备</h2><p>在首页右上角点击”控制台”,进入后搜索”物联网平台”，在物联网平台中选择”公共实例”。</p>
<p>在公共示例左边点击”设备管理”，选择”产品”；我们要先创建一个产品，操作如下：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ESP32/ESP32S3/aliiottjsb.png" alt="aliiottjsb"></p>
<p>在在控制台中的”设备管理” -&gt; “设备”中新建一个设备</p>
<blockquote>
<p>通常设备在接入阿里云的时候需要一个”三元”认证，认证信息在创建的设备中可以看到。</p>
</blockquote>
<p><strong>物模型</strong></p>
<p>物模型是阿里云对设备在云端的功能描述，包括设备的属性、服务和事件。</p>
<p>在首页”文档” -&gt; 文档中心的”阿里云物联网平台” -&gt; “操作指南”下的”设备接入” -&gt; “使用协议自主接入” -&gt; “基于 Alink 协议自主开发” 中的”设备属性、事件、服务”，中查看数据首发的一系列格式。</p>
<h2 id="ESP32接入阿里IOT"><a href="#ESP32接入阿里IOT" class="headerlink" title="ESP32接入阿里IOT"></a>ESP32接入阿里IOT</h2>]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFi驱动</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ESP32/ESP32_S3/WiFi%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p>Wi-Fi（Wireless Fidelity）是基于IEEE 802.11标准的无线网络通信技术，允许设备<strong>通过无线电波在局域网内进行数据传输和联网操作</strong>。它是目前最常见的<strong>无线局域网（WLAN）技术</strong>，广泛用于家庭、办公以及公共场所。Wi-Fi 网络<strong>通常采用 TCP&#x2F;IP 协议进行通信</strong>。</p>
<h2 id="Wi-Fi的工作原理"><a href="#Wi-Fi的工作原理" class="headerlink" title="Wi-Fi的工作原理"></a><strong>Wi-Fi的工作原理</strong></h2><p>Wi-Fi通过在 2.4GHz 和 5GHz（部分设备支持6GHz）频段内的无线电波来传输数据：</p>
<ol>
<li><strong>接入点（AP）</strong> 作为中心设备，将有线网络（如光纤或以太网）转换为无线信号。</li>
<li><strong>终端设备（STA）</strong> 接收无线信号，并通过网络协议与其他设备通信。</li>
<li>数据通过无线信道在 AP 和 STA 之间传输，网络协议负责保障数据的可靠性和安全性。</li>
</ol>
<h2 id="Wi-Fi网络中常见的两种工作模式"><a href="#Wi-Fi网络中常见的两种工作模式" class="headerlink" title="Wi-Fi网络中常见的两种工作模式"></a><strong>Wi-Fi网络中常见的两种工作模式</strong></h2><p><strong>Access Point (AP) 模式：无线接入点模式</strong></p>
<ul>
<li><strong>功能</strong>：负责发射无线信号，允许终端设备（如手机和笔记本电脑）接入。</li>
<li><strong>应用场景</strong>：常见于家庭路由器、企业办公路由器等，起到网络中枢的作用。</li>
<li><strong>特点</strong>：支持多个设备接入、通常配备密码和加密机制（如WPA2或WPA3）以保障安全、AP 和 AP 可以互相连接。</li>
</ul>
<p><strong>Station (STA) 模式：终端模式</strong></p>
<ul>
<li><strong>功能</strong>：STA模式的设备连接到AP，作为网络终端使用，获取网络访问权限。</li>
<li><strong>应用场景</strong>：手机、平板电脑、智能家居设备等通常以STA模式连接至网络。</li>
<li><strong>特点</strong>：不具备发射无线信号的功能、设备仅作为终端使用，<strong>不允许其他设备通过其转发连接或者接入</strong>。</li>
</ul>
<h2 id="ESP32中的WiFi"><a href="#ESP32中的WiFi" class="headerlink" title="ESP32中的WiFi"></a>ESP32中的WiFi</h2><p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/v5.4/esp32/index.html">ESP32 官方指南</a></p>
<p>ESP32 内置WiFi模块，支持以下三种主要的工作模式，用于满足不同的网络需求：</p>
<p><strong>STA模式（Station Mode，终端模式）</strong></p>
<ul>
<li>ESP32 作为无线终端连接到路由器，获取 IP 地址，访问外部服务器或与局域网内其他设备通信。</li>
<li><strong>应用场景</strong>：上传数据到云端，与局域网设备通信。</li>
<li><strong>典型特点</strong>：与路由器通信，设备需要提供 WiFi 网络的 SSID 和密码。</li>
</ul>
<p><strong>AP模式（Access Point Mode，无线接入点模式）</strong></p>
<ul>
<li>ESP32 作为无线热点，创建一个WiFi网络，允许其他设备（如手机、平板等）连接到它。</li>
<li><strong>应用场景</strong>：点对点通信，设备初始配网或本地控制。</li>
<li><strong>典型特点</strong>：无需路由器，ESP32 自己生成网络并分配 IP。</li>
</ul>
<p><strong>AP+STA模式（双模式）</strong></p>
<ul>
<li>ESP32同时作为无线终端连接路由器（STA），又作为无线热点（AP）提供网络接入。</li>
<li><strong>应用场景</strong>：需要同时与云端通信和本地设备交互，例如智能家居设备配网和数据上传。</li>
<li><strong>典型特点</strong>：结合 STA 和 AP 功能，支持双重连接。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="STA模式"><a href="#STA模式" class="headerlink" title="STA模式"></a>STA模式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_wifi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置一个认证模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA2_PSK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SSID、密码、最大连接次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_SSID      <span class="string">&quot;Redmi Note 14 5G&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_PASS      <span class="string">&quot;wang123456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_MAXIMUM_RETRY  100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FreeRTOS 事件组，当我们连接时发出信号</span></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_wifi_event_group;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件组连接和失败标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_CONNECTED_BIT BIT0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_FAIL_BIT      BIT1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印日志用的标识符</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;wifi station&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前连接次数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_retry_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_handler</span><span class="params">(<span class="type">void</span>* arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                                <span class="type">int32_t</span> event_id, <span class="type">void</span>* event_data)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断事件的类型：WIFI_EVENT 表示wifi事件，WIFI_EVENT_STA_START 表示模式为 STA 启动模式</span></span><br><span class="line">    <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) &#123;</span><br><span class="line">        <span class="comment">// 连接到这个 WiFi</span></span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">    <span class="comment">// 表示 WiFi 断开事件    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) &#123;</span><br><span class="line">        <span class="comment">// 判断当前重复连接次数是否小于最大重复次数</span></span><br><span class="line">        <span class="keyword">if</span> (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) &#123;</span><br><span class="line">            esp_wifi_connect();</span><br><span class="line">            s_retry_num++;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;retry to connect to the AP&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果达到最大重试次数，设置 WIFI_FAIL_BIT 标志，通知连接失败。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印失败日志</span></span><br><span class="line">        ESP_LOGI(TAG,<span class="string">&quot;connect to the AP fail&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得 IP 地址事件    </span></span><br><span class="line">    <span class="comment">// IP_EVENT_STA_GOT_IP 表示已经成功连接到 Wi-Fi 并从 DHCP 获取到 IP 地址。    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) &#123;</span><br><span class="line">        <span class="type">ip_event_got_ip_t</span>* event = (<span class="type">ip_event_got_ip_t</span>*) event_data;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;got ip:&quot;</span> IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));</span><br><span class="line">        s_retry_num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置 WIFI_CONNECTED_BIT 标志，表示连接成功。</span></span><br><span class="line">        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);</span><br><span class="line">    <span class="comment">// 打印是否连接成功事件    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_CONNECTED) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;esp32 connected to AP!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wifi_init_sta</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个事件组，用于任务间通信和同步。</span></span><br><span class="line">    s_wifi_event_group = xEventGroupCreate();</span><br><span class="line">	<span class="comment">// 初始化底层的网络接口模块，为后续的网络通信做好准备。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    <span class="comment">// 创建默认的事件循环，用于处理系统事件（如 Wi-Fi 的连接、断开、获取 IP 地址等事件）。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    <span class="comment">// 创建默认的 Wi-Fi STA 接口（Station），这是 ESP32 的网络接口之一，用于连接到路由器。</span></span><br><span class="line">    <span class="comment">// 该函数会返回一个网卡对象，但是我们一般用不到</span></span><br><span class="line">    esp_netif_create_default_wifi_sta();</span><br><span class="line">    <span class="comment">/*初始化 WiFi 驱动*/</span></span><br><span class="line">    <span class="comment">// 通过 WIFI_INIT_CONFIG_DEFAULT() 宏生成默认配置结构体。</span></span><br><span class="line">    <span class="type">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    <span class="comment">// 初始化 Wi-Fi 驱动</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line">	<span class="comment">// 注册 Wi-Fi 和 IP 事件处理程序</span></span><br><span class="line">    <span class="type">esp_event_handler_instance_t</span> instance_any_id;</span><br><span class="line">    <span class="type">esp_event_handler_instance_t</span> instance_got_ip;</span><br><span class="line">    <span class="comment">// WIFI_EVENT 表示事件类型</span></span><br><span class="line">    <span class="comment">// ESP_EVENT_ANY_ID 表示监听所有的 Wi-Fi 事件，而不是单一特定事件。</span></span><br><span class="line">    <span class="comment">// event_handler 表示处理函数</span></span><br><span class="line">    <span class="comment">// 自定义参数填 NULL</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_any_id));</span><br><span class="line">    <span class="comment">// 同上，这里表示注册一个 IP 事件</span></span><br><span class="line">    <span class="comment">// 当我们连接到路由器，获取到 IP 后就会触发这个事件</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class="line">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_got_ip));</span><br><span class="line">	<span class="comment">// 配置 WiFi STA 模式参数</span></span><br><span class="line">    <span class="type">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            <span class="comment">// 要连接的 Wi-Fi 路由器的 SSID。</span></span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            <span class="comment">// Wi-Fi 路由器的密码。</span></span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               设置加密模式</span></span><br><span class="line"><span class="comment">               如果 Wi-Fi 密码符合 WPA2 标准，即密码长度为 8 字节或以上（这是 WPA2 的最低要求）</span></span><br><span class="line"><span class="comment">               则认证模式（Authmode）默认设置为 WPA2。</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">			   ESP32 会自动判断提供的密码是否满足 WPA2 标准，并相应地设置 Wi-Fi 的认证模式为 WPA2。</span></span><br><span class="line"><span class="comment">               如果用户未主动修改 authmode 的值，这个默认设置将会被使用。</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">               如果你需要连接到较旧（已被淘汰）的 Wi-Fi 网络（例如 WEP 或 WPA 加密方式的网络）</span></span><br><span class="line"><span class="comment">               需要手动将 authmode 的阈值设置为 WIFI_AUTH_WEP 或 WIFI_AUTH_WPA_PSK。</span></span><br><span class="line"><span class="comment">               当连接到 WEP 或 WPA 网络时，密码必须符合这些网络的要求：</span></span><br><span class="line"><span class="comment">					WEP：密码可以是 5 个字符（40 位）或 13 个字符（104 位）等格式。</span></span><br><span class="line"><span class="comment">					WPA：密码通常需要在 8 到 63 个字符之间。</span></span><br><span class="line"><span class="comment">             */</span>       </span><br><span class="line">            .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,</span><br><span class="line">            <span class="comment">// 保护管理帧，提升网络安全性。</span></span><br><span class="line">            <span class="comment">// 表示设备支持 PMF 功能。</span></span><br><span class="line">            <span class="comment">// 设备不强制要求 PMF。如果接入点支持 PMF，则会使用；如果接入点不支持，也允许连接。</span></span><br><span class="line">            .pmf_cfg.capable = <span class="literal">true</span>,</span><br><span class="line">            .pmf_cfg.required = <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置 Wi-Fi 模式为 WIFI_MODE_STA，即客户端模式。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );</span><br><span class="line">    <span class="comment">// 配置 Wi-Fi STA 的参数（如 SSID 和密码）。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config) );</span><br><span class="line">    <span class="comment">// 启动 Wi-Fi 驱动，开始尝试连接到配置好的 Wi-Fi 网络。</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start() );</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_sta finished.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 等待连接结果 */</span></span><br><span class="line">    <span class="comment">/* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum</span></span><br><span class="line"><span class="comment">     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */</span></span><br><span class="line">    <span class="comment">// 等待事件组中的指定事件位（WIFI_CONNECTED_BIT | WIFI_FAIL_BIT）被设置。</span></span><br><span class="line">    <span class="comment">// pdFALSE、pdFALSE 表示不清除事件位、表示任意一个事件位设置即可返回。</span></span><br><span class="line">    <span class="comment">// portMAX_DELAY 超时时间，portMAX_DELAY 表示无限等待，直到事件发生。</span></span><br><span class="line">    <span class="comment">// 返回的是事件组中设置的事件位状态，即调用 xEventGroupWaitBits 时，事件组中的状态位。</span></span><br><span class="line">    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,</span><br><span class="line">            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually</span></span><br><span class="line"><span class="comment">     * happened. */</span></span><br><span class="line">    <span class="comment">// 判断连接状态</span></span><br><span class="line">    <span class="comment">// WIFI_CONNECTED_BIT（Wi-Fi 连接成功的标志）</span></span><br><span class="line">    <span class="keyword">if</span> (bits &amp; WIFI_CONNECTED_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;connected to ap SSID:%s password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    <span class="comment">// WIFI_FAIL_BIT（Wi-Fi 连接失败的标志）    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits &amp; WIFI_FAIL_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Failed to connect to SSID:%s, password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    <span class="comment">// 表示发生了意料之外的情况（理论上不应该进入）。    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;UNEXPECTED EVENT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// NVS是 ESP32 内部的一块非易失性存储空间，通常用于保存 Wi-Fi 配置、设备配置信息等需要掉电保持的数据。</span></span><br><span class="line">    <span class="comment">// 当我们使用 SSID 和 密码连接成功后，IDF 的底层会帮我们把这组 SSID 和密码保存到 NVS 中，下次</span></span><br><span class="line">    <span class="comment">// 系统启动的时候，启动 STA 模式连接后，就会使用这组 SSID 和密码继续连接；</span></span><br><span class="line">    <span class="type">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="comment">// 如果返回值为 ESP_ERR_NVS_NO_FREE_PAGES 或 ESP_ERR_NVS_NEW_VERSION_FOUND</span></span><br><span class="line">    <span class="comment">// 则表示当前 NVS 存储有问题（如存储空间不足或版本不兼容）。</span></span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">      <span class="comment">// nvs_flash_erase() 擦除 NVS 存储，清空之前的数据。</span></span><br><span class="line">      <span class="comment">// ESP_ERROR_CHECK 用于检查函数返回值。如果函数返回错误，会触发异常，打印错误日志并终止程序。</span></span><br><span class="line">      ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">      <span class="comment">// 重新初始化 NVS (nvs_flash_init())，确保可以正常使用  </span></span><br><span class="line">      ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK(ret);</span><br><span class="line">	<span class="comment">// 使用 ESP-IDF 提供的日志系统，打印一条信息日志，表明接下来将配置 Wi-Fi 工作模式为 STA</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;ESP_WIFI_MODE_STA&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置并启动 Wi-Fi 的 STA 模式，使 ESP32 作为 Wi-Fi 客户端连接到指定的路由器。</span></span><br><span class="line">    wifi_init_sta();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AP模式"><a href="#AP模式" class="headerlink" title="AP模式"></a>AP模式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_mac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_wifi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 WiFi SSID（热点名称）、密码、信道和最大连接数。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_SSID      <span class="string">&quot;ESP32Test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_PASS      <span class="string">&quot;wang123456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_CHANNEL   4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_MAX_STA_CONN       6</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;wifi softAP&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wifi_event_handler</span><span class="params">(<span class="type">void</span>* arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                                    <span class="type">int32_t</span> event_id, <span class="type">void</span>* event_data)</span>&#123;</span><br><span class="line">    <span class="comment">// WIFI_EVENT_AP_STACONNECTED: 设备成功连接到热点。                                    </span></span><br><span class="line">    <span class="keyword">if</span> (event_id == WIFI_EVENT_AP_STACONNECTED) &#123;</span><br><span class="line">        <span class="type">wifi_event_ap_staconnected_t</span>* event = (<span class="type">wifi_event_ap_staconnected_t</span>*) event_data;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;station &quot;</span>MACSTR<span class="string">&quot; join, AID=%d&quot;</span>,</span><br><span class="line">                 MAC2STR(event-&gt;mac), event-&gt;aid);</span><br><span class="line">    <span class="comment">// WIFI_EVENT_AP_STADISCONNECTED: 设备断开与热点的连接。             </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_id == WIFI_EVENT_AP_STADISCONNECTED) &#123;</span><br><span class="line">        <span class="type">wifi_event_ap_stadisconnected_t</span>* event = (<span class="type">wifi_event_ap_stadisconnected_t</span>*) event_data;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;station &quot;</span>MACSTR<span class="string">&quot; leave, AID=%d, reason=%d&quot;</span>,</span><br><span class="line">                 MAC2STR(event-&gt;mac), event-&gt;aid, event-&gt;reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wifi_init_softap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// WiFi 初始化</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    esp_netif_create_default_wifi_ap();</span><br><span class="line"></span><br><span class="line">    <span class="type">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line">	<span class="comment">// 注册事件</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;wifi_event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">// WiFi 配置</span></span><br><span class="line">    <span class="type">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            .ssid_len = <span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_SSID),</span><br><span class="line">            .channel = EXAMPLE_ESP_WIFI_CHANNEL,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            .max_connection = EXAMPLE_MAX_STA_CONN,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT</span></span><br><span class="line">            .authmode = WIFI_AUTH_WPA3_PSK,</span><br><span class="line">            .sae_pwe_h2e = WPA3_SAE_PWE_BOTH,</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT */</span></span></span><br><span class="line">            .authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            .pmf_cfg = &#123;</span><br><span class="line">                    .required = <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_PASS) == <span class="number">0</span>) &#123;</span><br><span class="line">        wifi_config.ap.authmode = WIFI_AUTH_OPEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &amp;wifi_config));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_softap finished. SSID:%s password:%s channel:%d&quot;</span>,</span><br><span class="line">             EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS, EXAMPLE_ESP_WIFI_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//Initialize NVS</span></span><br><span class="line">    <span class="type">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">      ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">      ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK(ret);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;ESP_WIFI_MODE_AP&quot;</span>);</span><br><span class="line">    wifi_init_softap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手机打开搜索对应 WiFi 名称输入密码即可连接；如果搜不出来可以刷新下，他的信号有可能在中间位置，要往下翻一翻；</p>
<h3 id="AP-STA模式"><a href="#AP-STA模式" class="headerlink" title="AP+STA模式"></a>AP+STA模式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_mac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_wifi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_netif.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IP_NAPT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lwip/lwip_napt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* STA Configuration */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_STA_SSID           <span class="string">&quot;Redmi Note 14 5G&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_STA_PASSWD         <span class="string">&quot;wang123456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_MAXIMUM_RETRY           6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// STA 下的模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD   WIFI_AUTH_WPA2_PSK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AP Configuration */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_AP_SSID            <span class="string">&quot;ESP_AP&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_AP_PASSWD          <span class="string">&quot;wang123456&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ESP_WIFI_CHANNEL            4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_MAX_STA_CONN                6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// WIFI_CONNECTED_BIT 和 WIFI_FAIL_BIT：用作FreeRTOS事件标志位。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_CONNECTED_BIT BIT0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_FAIL_BIT      BIT1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DHCP server option*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHCPS_OFFER_DNS             0x02</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG_AP = <span class="string">&quot;WiFi SoftAP&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG_STA = <span class="string">&quot;WiFi Sta&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_retry_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FreeRTOS event group to signal when we are connected/disconnected */</span></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t s_wifi_event_group;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wifi_event_handler</span><span class="params">(<span class="type">void</span> *arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                               <span class="type">int32_t</span> event_id, <span class="type">void</span> *event_data)</span>&#123;</span><br><span class="line">    <span class="comment">// 有设备连接到ESP32的AP模式。                            </span></span><br><span class="line">    <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_AP_STACONNECTED) &#123;</span><br><span class="line">        <span class="type">wifi_event_ap_staconnected_t</span> *event = (<span class="type">wifi_event_ap_staconnected_t</span> *) event_data;</span><br><span class="line">        ESP_LOGI(TAG_AP, <span class="string">&quot;Station &quot;</span>MACSTR<span class="string">&quot; joined, AID=%d&quot;</span>,</span><br><span class="line">                 MAC2STR(event-&gt;mac), event-&gt;aid);</span><br><span class="line">    <span class="comment">// 设备从ESP32的AP断开。             </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_AP_STADISCONNECTED) &#123;</span><br><span class="line">        <span class="type">wifi_event_ap_stadisconnected_t</span> *event = (<span class="type">wifi_event_ap_stadisconnected_t</span> *) event_data;</span><br><span class="line">        ESP_LOGI(TAG_AP, <span class="string">&quot;Station &quot;</span>MACSTR<span class="string">&quot; left, AID=%d, reason:%d&quot;</span>,</span><br><span class="line">                 MAC2STR(event-&gt;mac), event-&gt;aid, event-&gt;reason);</span><br><span class="line">    <span class="comment">// STA模式启动后，尝试连接到外部WiFi。             </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) &#123;</span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">        ESP_LOGI(TAG_STA, <span class="string">&quot;Station started&quot;</span>);</span><br><span class="line">    <span class="comment">// 成功获取IP地址后，将事件标志位 WIFI_CONNECTED_BIT 置位。    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) &#123;</span><br><span class="line">        <span class="type">ip_event_got_ip_t</span> *event = (<span class="type">ip_event_got_ip_t</span> *) event_data;</span><br><span class="line">        ESP_LOGI(TAG_STA, <span class="string">&quot;Got IP:&quot;</span> IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));</span><br><span class="line">        s_retry_num = <span class="number">0</span>;</span><br><span class="line">        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize soft AP */</span></span><br><span class="line"><span class="type">esp_netif_t</span> *<span class="title function_">wifi_init_softap</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">esp_netif_t</span> *esp_netif_ap = esp_netif_create_default_wifi_ap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  AP模式初始化配置</span></span><br><span class="line">    <span class="type">wifi_config_t</span> wifi_ap_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_AP_SSID,</span><br><span class="line">            .ssid_len = <span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_AP_SSID),</span><br><span class="line">            .channel = EXAMPLE_ESP_WIFI_CHANNEL,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_AP_PASSWD,</span><br><span class="line">            .max_connection = EXAMPLE_MAX_STA_CONN,</span><br><span class="line">            .authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line">            .pmf_cfg = &#123;</span><br><span class="line">                .required = <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_AP_PASSWD) == <span class="number">0</span>) &#123;</span><br><span class="line">        wifi_ap_config.ap.authmode = WIFI_AUTH_OPEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &amp;wifi_ap_config));</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG_AP, <span class="string">&quot;wifi_init_softap finished. SSID:%s password:%s channel:%d&quot;</span>,</span><br><span class="line">             EXAMPLE_ESP_WIFI_AP_SSID, EXAMPLE_ESP_WIFI_AP_PASSWD, EXAMPLE_ESP_WIFI_CHANNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> esp_netif_ap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize wifi station */</span></span><br><span class="line"><span class="type">esp_netif_t</span> *<span class="title function_">wifi_init_sta</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">esp_netif_t</span> *esp_netif_sta = esp_netif_create_default_wifi_sta();</span><br><span class="line"></span><br><span class="line">    <span class="type">wifi_config_t</span> wifi_sta_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_STA_SSID,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_STA_PASSWD,</span><br><span class="line">            .scan_method = WIFI_ALL_CHANNEL_SCAN,</span><br><span class="line">            .failure_retry_cnt = EXAMPLE_ESP_MAXIMUM_RETRY,</span><br><span class="line">            <span class="comment">/* Authmode threshold resets to WPA2 as default if password matches WPA2 standards (password len =&gt; 8).</span></span><br><span class="line"><span class="comment">             * If you want to connect the device to deprecated WEP/WPA networks, Please set the threshold value</span></span><br><span class="line"><span class="comment">             * to WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK and set the password with length and format matching to</span></span><br><span class="line"><span class="comment">            * WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK standards.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,</span><br><span class="line">            .sae_pwe_h2e = WPA3_SAE_PWE_BOTH,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_sta_config) );</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG_STA, <span class="string">&quot;wifi_init_sta finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> esp_netif_sta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS和NAPT设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">softap_set_dns_addr</span><span class="params">(<span class="type">esp_netif_t</span> *esp_netif_ap,<span class="type">esp_netif_t</span> *esp_netif_sta)</span>&#123;</span><br><span class="line">    <span class="type">esp_netif_dns_info_t</span> dns;</span><br><span class="line">    esp_netif_get_dns_info(esp_netif_sta,ESP_NETIF_DNS_MAIN,&amp;dns);</span><br><span class="line">    <span class="type">uint8_t</span> dhcps_offer_option = DHCPS_OFFER_DNS;</span><br><span class="line">    ESP_ERROR_CHECK_WITHOUT_ABORT(esp_netif_dhcps_stop(esp_netif_ap));</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_dhcps_option(esp_netif_ap, ESP_NETIF_OP_SET, ESP_NETIF_DOMAIN_NAME_SERVER, &amp;dhcps_offer_option, <span class="keyword">sizeof</span>(dhcps_offer_option)));</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_set_dns_info(esp_netif_ap, ESP_NETIF_DNS_MAIN, &amp;dns));</span><br><span class="line">    ESP_ERROR_CHECK_WITHOUT_ABORT(esp_netif_dhcps_start(esp_netif_ap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize NVS</span></span><br><span class="line">    <span class="type">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize event group */</span></span><br><span class="line">    s_wifi_event_group = xEventGroupCreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register Event handler */</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                    ESP_EVENT_ANY_ID,</span><br><span class="line">                    &amp;wifi_event_handler,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class="line">                    IP_EVENT_STA_GOT_IP,</span><br><span class="line">                    &amp;wifi_event_handler,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize WiFi */</span></span><br><span class="line">    <span class="type">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_APSTA));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize AP */</span></span><br><span class="line">    ESP_LOGI(TAG_AP, <span class="string">&quot;ESP_WIFI_MODE_AP&quot;</span>);</span><br><span class="line">    <span class="type">esp_netif_t</span> *esp_netif_ap = wifi_init_softap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize STA */</span></span><br><span class="line">    ESP_LOGI(TAG_STA, <span class="string">&quot;ESP_WIFI_MODE_STA&quot;</span>);</span><br><span class="line">    <span class="type">esp_netif_t</span> *esp_netif_sta = wifi_init_sta();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start WiFi */</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait until either the connection is established (WIFI_CONNECTED_BIT) or</span></span><br><span class="line"><span class="comment">     * connection failed for the maximum number of re-tries (WIFI_FAIL_BIT).</span></span><br><span class="line"><span class="comment">     * The bits are set by event_handler() (see above)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,</span><br><span class="line">                                           WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,</span><br><span class="line">                                           pdFALSE,</span><br><span class="line">                                           pdFALSE,</span><br><span class="line">                                           portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEventGroupWaitBits() returns the bits before the call returned,</span></span><br><span class="line"><span class="comment">     * hence we can test which event actually happened. */</span></span><br><span class="line">    <span class="keyword">if</span> (bits &amp; WIFI_CONNECTED_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG_STA, <span class="string">&quot;connected to ap SSID:%s password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_STA_SSID, EXAMPLE_ESP_WIFI_STA_PASSWD);</span><br><span class="line">        softap_set_dns_addr(esp_netif_ap,esp_netif_sta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits &amp; WIFI_FAIL_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG_STA, <span class="string">&quot;Failed to connect to SSID:%s, password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_STA_SSID, EXAMPLE_ESP_WIFI_STA_PASSWD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ESP_LOGE(TAG_STA, <span class="string">&quot;UNEXPECTED EVENT&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set sta as the default interface */</span></span><br><span class="line">    esp_netif_set_default_netif(esp_netif_sta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable napt on the AP netif */</span></span><br><span class="line">    <span class="keyword">if</span> (esp_netif_napt_enable(esp_netif_ap) != ESP_OK) &#123;</span><br><span class="line">        ESP_LOGE(TAG_STA, <span class="string">&quot;NAPT not enabled on the netif: %p&quot;</span>, esp_netif_ap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ESP32</category>
      </categories>
      <tags>
        <tag>ESP32-S3</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/GPIO/</url>
    <content><![CDATA[<p>在 GD32 系列微控制器中，<strong>GPIO（General Purpose Input&#x2F;Output）</strong>通用输入&#x2F;输出引脚模块，允许控制和监测外部设备。</p>
<p>GD32 的 GPIO 是由多个端口组成的，每个端口有多个引脚，每个引脚都可以独立配置。通常命名为 GPIOA，GPIOB，GPIOC 等，表示不同的 GPIO <strong>端口</strong>，每个端口中的引脚则表示为 GPIO_PIN_x（例如 GPIO_PIN_0, GPIO_PIN_1）。</p>
<h3 id="GPIO-架构"><a href="#GPIO-架构" class="headerlink" title="GPIO 架构"></a>GPIO 架构</h3><p>CPU 通过总线访问 GPIO 寄存器，通过寄存器设置指令传递到控制器，控制器根据寄存器的配置去操控各个 GPIO 端口的引脚（如 PA0、PA1、PF0 等），从而实现引脚的输入输出控制和模式配置。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407GPIOshixianyuanli.png" alt="F407GPIOshixianyuanli"></p>
<h3 id="GPIO-的工作模式"><a href="#GPIO-的工作模式" class="headerlink" title="GPIO 的工作模式"></a>GPIO 的工作模式</h3><p>在嵌入式系统的 GPIO 中，常见的三种工作模式是：<strong>推挽输出模式</strong>、<strong>开漏输出模式</strong>和<strong>高阻抗模式</strong>。每种模式在特定的应用场景下都能发挥不同的作用。</p>
<p><strong>推挽输出</strong></p>
<ul>
<li><p>推挽模式通过两个晶体管（一个与 Vcc 连接，一个与 GND 连接）实现输出。</p>
</li>
<li><p>当 GPIO 输出为高电平时，连接 Vcc 的晶体管导通，连接 GND 的晶体管关闭，使引脚输出高电平；当输出为低电平时，连接 GND 的晶体管导通，连接 Vcc 的晶体管关闭，使引脚输出低电平。</p>
</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407tuiwanshuchushiyitu.png" alt="F407tuiwanshuchushiyitu"></p>
<p><strong>开漏输出</strong></p>
<ul>
<li><p>当输出为低电平时，晶体管导通，GPIO 引脚被拉低至 GND。</p>
</li>
<li><p>当输出为高电平时，晶体管断开，电路断开，依赖外部上拉电阻将引脚拉至高电平。</p>
</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407kailoushuchushiyitu.png" alt="F407kailoushuchushiyitu"></p>
<p><strong>高阻输入</strong></p>
<ul>
<li><p>在高阻抗模式下，GPIO 引脚既不连接 Vcc，也不连接 GND，而是保持“开放”状态，像一个高电阻。</p>
</li>
<li><p>该模式下，GPIO 引脚的输入电压可以被检测，但引脚自身不消耗电流。</p>
</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407gaozushurushiyitu.png" alt="F407gaozushurushiyitu"></p>
<h3 id="GPIO-输出线与"><a href="#GPIO-输出线与" class="headerlink" title="GPIO 输出线与"></a>GPIO 输出线与</h3><p><strong>推挽线与（禁止）</strong></p>
<p>在推挽输出中，如果两个引脚分别处于高电平和低电平，直接线与会导致高电平（Vcc）与低电平（地）相连，形成短路，这可能会损坏微控制器或连接的设备。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407tuiwanxianyu.png" alt="F407tuiwanxianyu"></p>
<blockquote>
<p>开漏模式可以在高电平时输出逻辑 1，但由于电流路径、上升时间和阻抗匹配等因素，开漏模式的响应速度通常慢于推挽模式。这使得推挽输出在需要快速切换的应用中更加有效。</p>
</blockquote>
<h3 id="GPIO-输入模式"><a href="#GPIO-输入模式" class="headerlink" title="GPIO 输入模式"></a>GPIO 输入模式</h3><p>GPIO 的输入模式通常包括<strong>浮空输入</strong>、<strong>上拉输入</strong>、<strong>下拉输入</strong>、<strong>模拟输入</strong>四种基本类型，每种模式适用于不同的应用场景：</p>
<p><strong>浮空输入</strong></p>
<ul>
<li><p><strong>特点</strong>：引脚不连接任何电压源，输入状态未定义。</p>
</li>
<li><p><strong>应用</strong>：适用于不需要任何外部信号的场景，但可能受到电磁干扰，导致输入状态不稳定。</p>
</li>
<li><p><strong>注意</strong>：在这种模式下，建议避免直接使用，因为引脚的状态可能会因为噪声而波动。</p>
</li>
</ul>
<p><strong>上拉输入</strong></p>
<ul>
<li><p><strong>特点</strong>：通过内置电阻将引脚连接到 Vcc（高电平），当未连接外部信号时，输入状态为高电平。</p>
</li>
<li><p><strong>应用</strong>：常用于按钮开关，确保在未按下时输入为高电平，按下时输入为低电平。</p>
</li>
<li><p><strong>优点</strong>：能够有效防止浮空输入带来的干扰，确保输入状态稳定。</p>
</li>
</ul>
<p><strong>下拉输入</strong></p>
<ul>
<li><p><strong>特点</strong>：通过内置电阻将引脚连接到地（低电平），当未连接外部信号时，输入状态为低电平。</p>
</li>
<li><p><strong>应用</strong>：同样用于按钮开关，当按钮未按下时输入为低电平，按下时输入为高电平。</p>
</li>
<li><p><strong>优点</strong>：与上拉输入类似，可以有效防止输入状态不稳定。</p>
</li>
</ul>
<p><strong>模拟输入</strong></p>
<ul>
<li><p><strong>特点</strong>：引脚可以读取连续的电压值，而不是简单的高低电平。</p>
</li>
<li><p><strong>应用</strong>：用于传感器输入（如温度传感器、光敏电阻等），可以提供更丰富的信息。</p>
</li>
<li><p><strong>优点</strong>：能够获取更细腻的变化，适合需要高精度读数的应用。</p>
</li>
</ul>
<h2 id="ARM-系列的-GPIO"><a href="#ARM-系列的-GPIO" class="headerlink" title="ARM 系列的 GPIO"></a>ARM 系列的 GPIO</h2><p><strong>引脚内部结构框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMGPIO.png" alt="F407ARMGPIO"></p>
<h3 id="GD32-STM32-系列中-GPIO-的工作模式"><a href="#GD32-STM32-系列中-GPIO-的工作模式" class="headerlink" title="GD32&#x2F;STM32 系列中 GPIO 的工作模式"></a>GD32&#x2F;STM32 系列中 GPIO 的工作模式</h3><p><strong>浮空输入</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMfukongshuru.png" alt="F407ARMfukongshuru"></p>
<p><strong>上拉输入</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMshanglashuru.png" alt="F407ARMshanglashuru"></p>
<p><strong>下拉输入</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMxialashuru.png" alt="F407ARMxialashuru"></p>
<p><strong>模拟输入</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMmonishuru.png" alt="F407ARMmonishuru"></p>
<p><strong>推挽输出</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMtuiwanshuchu.png" alt="F407ARMtuiwanshuchu"></p>
<p><strong>开漏输出</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMkailoushuchu.png" alt="F407ARMkailoushuchu"></p>
<p><strong>复用推挽输出</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMfuyongtuiwanshuchu.png" alt="F407ARMfuyongtuiwanshuchu"></p>
<p><strong>复用开漏输出</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARMfuyongkailou.png" alt="F407ARMfuyongkailou"></p>
<h2 id="GPIO-实现"><a href="#GPIO-实现" class="headerlink" title="GPIO 实现"></a>GPIO 实现</h2><p><strong>功能：通过按键控制LED灯</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx_gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx_rcu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO_LED</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_LED_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能GPIOB外部时钟</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOB);</span><br><span class="line">    <span class="comment">// 设置工作模式GPIO_MODE_OUTPUT</span></span><br><span class="line">    gpio_mode_set(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO_PIN_2);</span><br><span class="line">     <span class="comment">// 配置输出选项</span></span><br><span class="line">    gpio_output_options_set(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO_Key</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_KEY_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置GPIOC外部时钟</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    <span class="comment">// 设置工作模式</span></span><br><span class="line">    gpio_mode_set(GPIOC, GPIO_MODE_INPUT, GPIO_PUPD_PULLUP, GPIO_PIN_0);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    systick_config();</span><br><span class="line">    GPIO_KEY_Config();</span><br><span class="line">    GPIO_LED_Config();</span><br><span class="line"></span><br><span class="line">    FlagStatus KeyFllag =  gpio_input_bit_get(GPIOC, GPIO_PIN_0);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        FlagStatus ThisKeyFllag =  gpio_input_bit_get(GPIOC, GPIO_PIN_0);</span><br><span class="line">        <span class="keyword">if</span>(KeyFllag == <span class="number">1</span> &amp;&amp; ThisKeyFllag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 按下</span></span><br><span class="line">            KeyFllag = <span class="number">0</span>;</span><br><span class="line">            gpio_bit_set(GPIOB, GPIO_PIN_2);</span><br><span class="line">            delay_1ms(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyFllag == <span class="number">0</span> &amp;&amp; ThisKeyFllag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 松开</span></span><br><span class="line">            KeyFllag = <span class="number">1</span>;</span><br><span class="line">            gpio_bit_reset(GPIOB, GPIO_PIN_2);</span><br><span class="line">            delay_1ms(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>步骤：</p>
<ol>
<li>查看板子原理图，找到使用的引脚是哪一个，外部有无上&#x2F;下拉电阻；这样方便确定输入或者输出的工作模式。</li>
</ol>
<ul>
<li>开启外部时钟</li>
<li>选择GPIO的工作模式</li>
<li>如果是输出要配置输出模式，复用要配置并指定复用的功能是哪一个;</li>
</ul>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>GPIO 的默认初始</strong></p>
<p>在 ARM32 中，GPIO 引脚的默认电平状态总结如下：</p>
<ol>
<li><strong>输出模式</strong>：<ul>
<li>引脚配置为输出模式时，默认电平为<strong>低电平（0）</strong>。</li>
<li>即使设置了上拉模式，电平仍为低，因为引脚输出的是寄存器的值，而寄存器的初始值为 0，除非在代码中手动设置为高电平。</li>
<li>当 GPIO 引脚配置为输出引脚，输出寄存器（GPIOx_OCTL）的值将会从相应 I&#x2F;O 引脚上输出。<strong>端口输出控制寄存器（GPIOx_OCTL）复位初值为：0x0000 0000</strong></li>
</ul>
</li>
<li><strong>输入模式</strong>：<ul>
<li>引脚配置为输入模式时，默认电平取决于<strong>上拉</strong>或<strong>下拉</strong>配置：<ul>
<li><strong>上拉（Pull-up）</strong>：默认电平为<strong>高电平</strong>。</li>
<li><strong>下拉（Pull-down）</strong>：默认电平为<strong>低电平</strong>。</li>
<li><strong>浮空（No Pull）</strong>：引脚未连接上拉或下拉，电平浮动，容易受到噪声影响。</li>
</ul>
</li>
<li>当 GPIO 引脚配置为输入引脚时，所有的 GPIO 引 脚内部都有一个可选择的<strong>弱上拉</strong>和<strong>弱下拉</strong>电阻。外部引脚上的数据在每个 AHB 时钟周期时都 会装载到数据输入寄存器（GPIOx_ISTAT）。<strong>端口输入状态寄存器（GPIOx_ISTAT）复位初值为 0x0000 XXXX</strong></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/ADC/</url>
    <content><![CDATA[<p>在嵌入式开发中，<strong>ADC</strong>（Analog-to-Digital Converter，模拟-数字转换器）是一种将模拟信号转换为数字信号的硬件组件。它的主要功能是将输入的模拟信号（如温度、压力、电压等）转换为相应的数字信号，使微控制器（MCU）或处理器能够读取和处理这些信息。</p>
<p>ADC采样的频率越高，得到的数字信号就越接近原来的模拟信号，也就是保真度越高，但是需要更多的资源和计算功耗。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADCguocheng.png" alt="F407ADCguocheng"></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>逐次逼近型 ADC (SAR-ADC)</strong></p>
<ul>
<li><strong>工作原理</strong>：逐步逼近输入信号的电压值，每次比较输入信号与参考电压，逐步调整数字输出直到找到最接近的值。</li>
<li><strong>特点</strong>：中等速度、高精度、低功耗，适用于常规数据采集。</li>
</ul>
<p><strong>Flash ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：使用多个并行的比较器同时比较输入信号与不同的参考电压级别，直接输出数字结果。</li>
<li><strong>特点</strong>：极高速、低分辨率、硬件复杂，适用于实时信号处理。</li>
</ul>
<p><strong>Sigma-Delta ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：通过过采样将模拟信号转换为数字信号，使用噪声整形将高频噪声移至高频区，然后通过数字滤波器还原数字信号。</li>
<li><strong>特点</strong>：高分辨率、精度高、速度较慢，适用于高精度测量。</li>
</ul>
<p><strong>Pipeline ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：将转换过程分为多个阶段，每个阶段逐步完成一部分转换，最终合并结果输出。</li>
<li><strong>特点</strong>：高速、适中分辨率，适用于视频、通信等高速应用。</li>
</ul>
<p><strong>Dual-Slope ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：首先对输入信号进行积分，然后用已知参考电压再次积分，通过比较两个积分时间来确定输入信号的数字值。</li>
<li><strong>特点</strong>：高精度、速度较慢、抗噪声能力强，适用于精密测量。</li>
</ul>
<p><strong>并行型 ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：通过多个并行的比较器同时对输入信号进行比较，快速得出数字结果。</li>
<li><strong>特点</strong>：极高速、低分辨率，硬件需求高，适合高速数据采集。</li>
</ul>
<p><strong>差分型 ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：测量两个输入端点之间的电压差，消除共模噪声，提高精度。</li>
<li><strong>特点</strong>：抗共模噪声能力强，适用于差分信号的测量。</li>
</ul>
<p><strong>异步 ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：不依赖固定时钟，根据输入信号的变化动态调整采样频率。</li>
<li><strong>特点</strong>：灵活，适用于时钟不稳定或需要动态调整采样频率的特殊场合。</li>
</ul>
<p><strong>温控型 ADC</strong></p>
<ul>
<li><strong>工作原理</strong>：通过比较器对输入信号进行测量，采用热计数器方法，最终通过计数来确定数字值。</li>
<li><strong>特点</strong>：高精度，适用于精密仪器和特殊测量系统。</li>
</ul>
<h2 id="逐次逼近型工作原理"><a href="#逐次逼近型工作原理" class="headerlink" title="逐次逼近型工作原理"></a>逐次逼近型工作原理</h2><p>逐次逼近型 ADC 的工作原理是将模拟信号通过<strong>采样</strong>转换为离散的数字信号，然后再通过<strong>量化</strong>、<strong>编码</strong>等处理，最终得到对应的数字表示。</p>
<p><strong>采样</strong></p>
<p>采样（Sampling）是将连续的模拟信号转化为离散的数字信号的过程；ADC 通过以固定周期的脉冲采集模拟型号，这样就可以得到一个在时间上离散的信号。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADCcaiyang.png" alt="F407ADCcaiyang"></p>
<p><strong>量化</strong></p>
<p>虽然采样可以把连续信号变成一系列离散的值，但这些离散的值本身可能是无限精细的（理论上是连续的），计算机无法直接处理这样的无限精度。量化的目的是将这些信号值映射到有限数量的离散数字上，确保信号可以被计算机和数字设备正确处理。</p>
<p>量化是把<strong>采样得到的连续信号值</strong>转换成<strong>离散的数字值</strong>的过程。它将信号值映射到<strong>一定数量的离散级</strong>别上，这些离散的数字值是计算机能理解和处理的。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADClianghua.png" alt="F407ADClianghua"></p>
<p><strong>分辨率：</strong>是指数字信号可以表示的<strong>离散级别</strong>的数量，通常由<strong>位数（bit）</strong>来表示。</p>
<p>例如，8位（8-bit）的分辨率表示量化系统能够表示 2<sup>8</sup> &#x3D; 256 个不同的离散等级，16位（16-bit）则能表示 2<sup>16</sup> &#x3D;  65536 个不同的等级。</p>
<p><strong>编码</strong></p>
<p>将量化后的数字值转化为标准的数字格式的过程，用 0 和 1 组合为每个量化区间编号,代替原来的电压值。</p>
<p><strong>ADC 转换流程图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/STC8H/ADCzhuanhuanliuchengtu.png" alt="ADCzhuanhuanliuchengtu"></p>
<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>在 ARM32 的 ADC 模块中，针对单个通道或多个通道的转换，有几种不同的 <strong>运行模式</strong> 来控制采样和转换的行为：</p>
<p><strong>单次运行模式（Single Conversion Mode）</strong></p>
<ul>
<li><p><strong>工作原理</strong>：在单次运行模式下，ADC 每次启动转换时只转换一个通道的数据。每次转换完成后，ADC 停止工作，直到下一次触发才能进行新的转换。</p>
</li>
<li><p><strong>触发方式</strong>：可以通过外部触发信号（例如定时器中断）或软件触发启动。</p>
</li>
</ul>
<p><strong>连续运行模式（Continuous Conversion Mode）</strong></p>
<ul>
<li><p><strong>工作原理</strong>：在连续运行模式下，ADC 一旦启动，就会不断地进行转换，转换完成后立刻开始下一次转换，直到停止为止。转换通道可以是单个通道，也可以是多个通道（如果使用扫描模式）。 </p>
</li>
<li><p><strong>触发方式</strong>：通常通过软件或外部触发启动，启动后 ADC 将连续进行转换。</p>
</li>
</ul>
<p><strong>扫描运行模式（Scan Mode）</strong></p>
<ul>
<li><strong>工作原理：</strong>在扫描模式下，ADC 会按照用户预先设置的顺序，自动依次对多个输入通道进行采样和转换。这些通道可以是同一组或不同组的模拟输入。扫描模式通常与 <strong>连续转换模式</strong> 或 <strong>间断转换模式</strong> 配合使用，这样可以在不干扰其他通道转换的情况下，完成多个通道的采样。</li>
</ul>
<p><strong>间断运行模式（Discontinuous Mode）</strong></p>
<ul>
<li><strong>工作原理</strong>：在间断运行模式下，ADC 会在多个通道的转换之间插入空闲时间，形成一个“间断”采样的过程。与连续模式不同，间断模式在转换时会分批次处理多个通道，每批次完成几个通道的采样，再进行下一批次的转换。</li>
<li><strong>触发方式</strong>：通常用于扫描模式下，选择如何将多个通道分批次进行转换。</li>
</ul>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><p>当需要有多个 ADC 模块工作时，可以使用 ADC 同步模式。在 ADC 同步模式下，根据 ADC_SYNCCTL 寄存器中 SYNCM[4:0]位所选的模式，转换的启动可以是 ADC0&#x2F;ADC1&#x2F;ADC2 的交替触发或同步触发。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADCtongbumoshi.png" alt="F407ADCtongbumoshi"></p>
<blockquote>
<p>当 ADC 工作在同步模式，而非独立模式时，如果需要再将 ADC 配置成其他同步模式，则需要<strong>在配置成其他同步模式前，首先将 ADC 配置成独立模式。</strong></p>
</blockquote>
<h2 id="常规通道和注入通道"><a href="#常规通道和注入通道" class="headerlink" title="常规通道和注入通道"></a>常规通道和注入通道</h2><p><strong>常规通道</strong></p>
<p>常规通道是 ADC 的标准通道，主要用于常规的采样和转换。它们通常是逐一进行采样的，即采样一个通道，转换完成后，再切换到下一个通道。</p>
<p><strong>注入通道</strong></p>
<p>注入通道是一种更为复杂和灵活的 ADC 通道，它允许在常规转换过程中进行优先级较高的快速采样。插入通道具有更高的优先级，可以在常规转换进行的同时，进行插入通道的转换。</p>
<p>每个注入通道（如 ADC_INJ1, ADC_INJ2, ADC_INJ3, ADC_INJ4）通常有独立的数据寄存器，可以存储不同通道的转换结果。</p>
<p>每个注入通道都对应有一个数据寄存器所以当我们需要同时采集不超过四个，且也不想用 DMA 时我们就可以采用注入通道；当转换完成后我们通过 EOIC 标志位去获取对应通道中的数据；只会在最后一个转换完成后产生一次标志位；</p>
<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p> ARM32 的 ADC 数据宽度通常为 12 位（例如 STM32F4 系列），但每个 ADC 数据寄存器通常是 16 位宽。因此，12 位的转换结果会存储在 16 位的寄存器中；所以我们这里需要指定数据的对齐方式。</p>
<p>两种对齐方式：</p>
<p><strong>左对齐 （Left Align）</strong>：</p>
<ul>
<li>在左对齐模式下，12 位的 ADC 结果会被存储在 16 位的数据寄存器的高 12 位，而低 4 位会被填充为 0。</li>
<li>例如，如果 ADC 转换的结果是 <code>0x0ABC</code>（12 位的值），那么存储到寄存器中的数据为 <code>0xABC0</code>。</li>
</ul>
<p><strong>右对齐（Right Align）</strong>：</p>
<ul>
<li>在右对齐模式下，12 位的 ADC 结果会存储在 16 位数据寄存器的低 12 位，而高 4 位会被填充为 0。</li>
<li>例如，如果 ADC 转换的结果是 <code>0x0ABC</code>（12 位的值），那么存储到寄存器中的数据为 <code>0x0ABC</code>。</li>
</ul>
<h2 id="模块框图"><a href="#模块框图" class="headerlink" title="模块框图"></a>模块框图</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/STM32/STM32F407/F407ADCcxukuangtu.png" alt="F407yihuofeimen"></p>
<blockquote>
<p>当采样任务少于 4 个时，可以使用注入组，因为注入组的每个通道都有一个独立的寄存器，可以同时进行四个采集任务</p>
</blockquote>
<p><strong>输入端口</strong></p>
<ul>
<li><p>**V_REF+ &#x2F; V_REF-**：基准电压输入端，用于确定 ADC 的量程范围。转换的数字结果在 <code>V_REF-</code> 对应 0，<code>V_REF+</code> 对应最大值（如 4095 在 12 位 ADC）。</p>
</li>
<li><p><strong>V_DDA &#x2F; V_SSA</strong>：供电引脚，用于提供 ADC 模块的工作电源。</p>
</li>
<li><p><strong>ADCx_IN0 到 ADCx_IN15</strong>：这些是模拟输入通道。可以连接到外部模拟信号，通过多路复用器（Analog Mux）选择要转换的通道。</p>
</li>
</ul>
<p><strong>多路复用器（Analog Mux）</strong></p>
<ul>
<li><p>多路复用器负责在多个输入通道中选择一个进行转换。此 ADC 模块最多可以支持 16 个通道的输入信号，允许在不同的通道之间切换。</p>
</li>
<li><p><strong>GPIO 端口</strong>：ADC 输入通道可以通过 GPIO 配置连接到传感器等外部设备，获得输入的模拟信号。</p>
</li>
<li><p>还有内置温度传感器、内部参考电压（V_REFINT）和电池电压监测端（V_BAT）。</p>
</li>
</ul>
<p><strong>通道分组</strong></p>
<p><strong>Injected Channels（注入通道）</strong>：最多可以配置 4 个注入通道。这些通道用于优先级较高的采样任务，一般在特定触发事件时被触发。</p>
<p><strong>Regular Channels（常规通道）</strong>：最多可以配置 16 个常规通道，用于定期进行采样，转换完成后的数据存储在常规数据寄存器中。</p>
<p><strong>触发控制</strong></p>
<ul>
<li><p><strong>注入通道触发控制</strong>：图中的 JEXTSEL 和 JEXTEN 控制注入通道的触发源，可以选择来自不同定时器（TIMx）的触发信号。</p>
</li>
<li><p><strong>常规通道触发控制</strong>：EXTSEL 和 EXTEN 控制常规通道的触发源，也可选择来自不同定时器（TIMx）的触发信号。</p>
</li>
<li><p>可以选择的触发源包括多种定时器的输出事件（如 TIM1_CH4, TIM2_TRGO 等），在外部事件发生时启动 ADC 转换。</p>
</li>
</ul>
<p><strong>ADC 模块</strong></p>
<ul>
<li>核心的 ADC 模块负责将模拟信号转换为数字信号。该模块可以通过 ADCCLK 时钟驱动，提供一定的采样速率。</li>
<li>ADC 数据寄存器<ul>
<li><strong>Regular Data Register</strong>：用于存储常规通道的转换结果。</li>
<li><strong>Injected Data Registers</strong>：用于存储注入通道的转换结果，每个注入通道有一个独立的数据寄存器。</li>
</ul>
</li>
</ul>
<p><strong>模拟看门狗（Analog Watchdog）</strong></p>
<ul>
<li>模拟看门狗是一种用于监控输入信号的硬件功能。它可以设定一个上限和下限（12 位精度），当 ADC 输入信号超出设定的阈值范围时，会触发报警或中断。</li>
<li>主要用于安全监控或报警用途，例如检测温度、电压或电流是否超出安全范围。</li>
</ul>
<p><strong>标志和中断控制</strong></p>
<ul>
<li><p>Flags（标志位）</p>
<p>：用于指示 ADC 的状态。常见的标志位包括：</p>
<ul>
<li><strong>OVR（Overrun）</strong>：DMA 数据覆盖错误标志。</li>
<li><strong>EOC（End of Conversion）</strong>：常规通道转换完成标志。</li>
<li><strong>JEOC（Injected End of Conversion）</strong>：注入通道转换完成标志。</li>
<li><strong>AWD（Analog Watchdog）</strong>：模拟看门狗事件标志。</li>
</ul>
</li>
<li><p><strong>中断使能位</strong>：用于控制是否允许 ADC 模块生成中断。包括 OVRIE（覆盖中断）、EOCIE（转换完成中断）、JEOCIE（注入完成中断）、AWDIE（看门狗中断）等。</p>
</li>
<li><p><strong>NVIC 中断</strong>：ADC 可将中断信号发送至 NVIC（嵌套向量中断控制器）进行处理。</p>
</li>
</ul>
<p><strong>DMA 支持</strong></p>
<ul>
<li>ADC 转换完成后可以通过 DMA（直接存储器访问）自动将数据转移到内存，而不需要 CPU 参与。</li>
<li><strong>DMA request</strong>：当常规通道完成转换后可以触发 DMA 请求，将数据自动传输到指定的存储区域。</li>
</ul>
<h2 id="特性表"><a href="#特性表" class="headerlink" title="特性表"></a>特性表</h2><p>在数据手册中：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADCshujutexingbiao.png" alt="F407ADCshujutexingbiao"></p>
<p><strong>温度传感器特性表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADCwenduchuanganqitexbiao.png" alt="F407ADCwenduchuanganqitexbiao"></p>
<h2 id="温度计算"><a href="#温度计算" class="headerlink" title="温度计算"></a>温度计算</h2><p><strong>温度传感器计算公式如下：</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ADCwendujisuan.png" alt="F407ADCwendujisuan"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>功能：通过 ADC 采集芯片内部的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSP_USART.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	通过 ADC 采集芯片内部温度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// ADC 配置	</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	adc_deinit();</span><br><span class="line">	rcu_periph_clock_enable(RCU_ADC0);	</span><br><span class="line">	<span class="comment">// 分频</span></span><br><span class="line">	<span class="comment">// 查看时钟树发现 ADC 组大支持 40MHz</span></span><br><span class="line">	<span class="comment">// 而 ADC 的两个时钟来源均超过 40 所以我们要先进行选择和分频</span></span><br><span class="line">	<span class="comment">// 选择时钟来源和分频 选择APB2，4分频</span></span><br><span class="line">	adc_clock_config(ADC_ADCCK_PCLK2_DIV4);</span><br><span class="line">	<span class="comment">// 因为我们就一个 ADC 工作所以这里要选择独立模式</span></span><br><span class="line">	<span class="comment">// 独立模式是相对于同步模式来说的，所以在同步中设置</span></span><br><span class="line">	adc_sync_mode_config(ADC_SYNC_MODE_INDEPENDENT);</span><br><span class="line">	<span class="comment">// 设置工作模式，单次还是多次，扫描还是不扫描</span></span><br><span class="line">	<span class="comment">// 只有 ADC0 支持内部通道，芯片温度属于内部通道</span></span><br><span class="line">	adc_special_function_config(ADC0, ADC_SCAN_MODE,  DISABLE);<span class="comment">// 失能扫描</span></span><br><span class="line">	adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, DISABLE); <span class="comment">// 非连续 </span></span><br><span class="line">	<span class="comment">// 是否打开插入通道(自动转换)，我们使用常规通道所以不打开</span></span><br><span class="line">	adc_special_function_config(ADC0, ADC_INSERTED_CHANNEL_AUTO, DISABLE);</span><br><span class="line">	<span class="comment">// 设置分辨率</span></span><br><span class="line">	adc_resolution_config(ADC0, ADC_RESOLUTION_12B);</span><br><span class="line">	<span class="comment">// 设置对齐方向</span></span><br><span class="line">	adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">	<span class="comment">// 设置转换通道的个数（包括常规通道和插入通道）</span></span><br><span class="line">	<span class="comment">// 我们这里只用到一个常规通道，所以就打开一个，如果是注入通道就选择注入同到</span></span><br><span class="line">	adc_channel_length_config(ADC0, ADC_ROUTINE_CHANNEL, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 将通道和引脚对应起来，或者说绑定起来</span></span><br><span class="line">    <span class="comment">// 注入通道方法为 adc_INSERTED_channel_config</span></span><br><span class="line">	<span class="comment">// 参数一、指定要配置的 ADC 外设</span></span><br><span class="line">	<span class="comment">// 参数二、要使用的通道编号，也就是在 ADC 的那个通道中进行转换</span></span><br><span class="line">	<span class="comment">// 参数三、通道编号，具体的哪个物理输入通道进行采样。</span></span><br><span class="line">	<span class="comment">// 参数四、设置 ADC 采样的时常</span></span><br><span class="line">    <span class="comment">// 如果想要对外部引脚的外设进行采样,</span></span><br><span class="line">	adc_routine_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_16, ADC_SAMPLETIME_480);</span><br><span class="line">	<span class="comment">// 在对内部引脚进行采样时，需要特别设置一下的参数</span></span><br><span class="line">	adc_channel_16_to_18(ADC_TEMP_VREF_CHANNEL_SWITCH, ENABLE);</span><br><span class="line">	<span class="comment">// 使能 ADC</span></span><br><span class="line">	adc_enable(ADC0);	</span><br><span class="line">	<span class="comment">// ADC 使能后需等待 1 时间后才能采样，</span></span><br><span class="line">	delay_1us(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 延迟14个CK_ADC以等待ADC稳定；	</span></span><br><span class="line">	adc_calibration_enable(ADC0);	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取温度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_mcu_temperature</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="comment">// 触发采集</span></span><br><span class="line">	<span class="comment">// 我们这里通过软件进行触发</span></span><br><span class="line">	adc_software_trigger_enable(ADC0, ADC_ROUTINE_CHANNEL);</span><br><span class="line">	<span class="comment">// 等待 EOC 标志位置为，也就是等待采集成功</span></span><br><span class="line">	<span class="keyword">while</span>(RESET == adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">	<span class="comment">// 常规序列转换结束时硬件置位，软件写 0 或读 ADC_RDATA 寄存器清除。</span></span><br><span class="line">	<span class="type">uint16_t</span> mcu_temperature_code = adc_routine_data_read(ADC0);</span><br><span class="line">   	<span class="comment">// 这里最好不要重复清除，当多任务时候，上面清楚后另一个任务可能就会立即写入</span></span><br><span class="line">	<span class="comment">// 这里如果后面在清除，可能会影响后续转换的值</span></span><br><span class="line">	<span class="comment">//adc_flag_clear(ADC0, ADC_FLAG_EOC);</span></span><br><span class="line">	<span class="comment">// 将对应的编码值转换为温度</span></span><br><span class="line">    <span class="comment">// 查看手册可以得到温度的转换公式：</span></span><br><span class="line">    <span class="comment">// 25V 下的电压为 1.45</span></span><br><span class="line">    <span class="comment">// 当前的电压值：(mcu_temperature_code / 4096 * 3.3) = 1.45</span></span><br><span class="line">    <span class="comment">// 4.1mV 要记得改为 V ==&gt; 4.1 1 1000</span></span><br><span class="line">    <span class="comment">// ((1.45 - 当前的电压值) /  (4.1 / 1000)) + 25</span></span><br><span class="line">	<span class="type">float</span> mcu_temperature = (<span class="number">1.45</span> - (<span class="number">3.3</span> * mcu_temperature_code / <span class="number">4096</span>)) / (<span class="number">4.1</span> / <span class="number">1000</span>) + <span class="number">25</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mcu_temperature = %f\n&quot;</span>, mcu_temperature);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">    usart0_init();</span><br><span class="line">	adc_config();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;App_start...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		delay_1ms(<span class="number">1000</span>);</span><br><span class="line">		get_mcu_temperature();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br><span class="line">============================================================================</span><br><span class="line"><span class="comment">// 在常规通道组中，多个通道通信采样时候只有最后一个会触发 EOC 标志位</span></span><br><span class="line"><span class="comment">// 所以当我们需要通过进行多个通道采样的时候，就需要放一次采样一次，以此来得到真确的结果；</span></span><br><span class="line"><span class="comment">// 该方法同时只能有一个通道进行工作，效率比较低    </span></span><br><span class="line"><span class="comment">// 添加电位器引脚的GPIO配置</span></span><br><span class="line">rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">gpio_mode_set(GPIOC, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, GPIO_PIN_4);    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 读取温度和电位器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_mcu_temperature</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="comment">// 先将内部温度对应的物理通道放入通道进行采样</span></span><br><span class="line">    adc_routine_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_16, ADC_SAMPLETIME_480);    </span><br><span class="line">	adc_software_trigger_enable(ADC0, ADC_ROUTINE_CHANNEL);</span><br><span class="line">	<span class="keyword">while</span>(RESET == adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">	<span class="type">uint16_t</span> mcu_temperature_code = adc_routine_data_read(ADC0);</span><br><span class="line">	<span class="type">float</span> mcu_temperature = (<span class="number">1.45</span> - (<span class="number">3.3</span> * mcu_temperature_code / <span class="number">4096</span>)) / (<span class="number">4.1</span> / <span class="number">1000</span>) + <span class="number">25</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mcu_temperature = %f\n&quot;</span>, mcu_temperature);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再将电位器对应的物理通道放入通道进行采样</span></span><br><span class="line">    adc_routine_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_14, ADC_SAMPLETIME_480);    </span><br><span class="line">	adc_software_trigger_enable(ADC0, ADC_ROUTINE_CHANNEL);</span><br><span class="line">	<span class="keyword">while</span>(RESET == adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">	<span class="type">uint16_t</span> mcu_temperature_code = adc_routine_data_read(ADC0);</span><br><span class="line">	<span class="type">float</span> mcu_dianweiqi = (<span class="number">3.3</span> * mcu_temperature_code / <span class="number">4096</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mcu_dianweiqi = %f\n&quot;</span>, mcu_dianweiqi);	</span><br><span class="line">&#125;   </span><br><span class="line">==================================================================================</span><br><span class="line"><span class="comment">// 使用 DMA 实现多个通道的数据采集</span></span><br><span class="line"><span class="comment">// 当同时有多个通道时，只有最后一个通道会返回 EOC 标志位，所以我们可以使用 DMA 让每次采集完就把数据搬运出来</span></span><br><span class="line"><span class="comment">// 而不是等所有通道都采集完之后 EOC 置位才进行采集；    </span></span><br><span class="line"><span class="comment">/*************** ADC 中的 DMA配置 *********************/</span></span><br><span class="line"><span class="comment">// 当 DMA 使能后，每次转换完成后都启用 DMA 传输</span></span><br><span class="line">adc_dma_request_after_last_enable(ADC0);</span><br><span class="line"><span class="comment">// DMA 使能</span></span><br><span class="line">adc_dma_mode_enable(ADC0);</span><br><span class="line"><span class="comment">// 要放在 ADC 使能之前</span></span><br><span class="line"><span class="comment">// 触发采集，软件触发</span></span><br><span class="line">adc_software_trigger_enable(ADC0, ADC_ROUTINE_CHANNEL);</span><br><span class="line"><span class="comment">// DMA 初始化</span></span><br><span class="line"><span class="comment">// DMA 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_dma_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 重置下 DMA</span></span><br><span class="line">	dma_deinit(DMA1, DMA_CH0);	</span><br><span class="line">	<span class="comment">// 使能外设DMA1时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_DMA1);</span><br><span class="line">	<span class="comment">// 配置 DMA 的传输模式(多数据传输/单数据传输)</span></span><br><span class="line">	<span class="comment">// 这里选择单数据传输</span></span><br><span class="line">	dma_single_data_parameter_struct  dma_single_init;</span><br><span class="line">    <span class="comment">// 结构体初始化函数</span></span><br><span class="line">	dma_single_data_para_struct_init(&amp;dma_single_init);</span><br><span class="line">	<span class="comment">// 外设地址</span></span><br><span class="line">	dma_single_init.periph_addr = (<span class="type">uint32_t</span>)(&amp;ADC_RDATA(ADC0));</span><br><span class="line">	<span class="comment">// 是否要使能外设地址偏移</span></span><br><span class="line">	dma_single_init.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">	<span class="comment">// 内存地址，发送时候才知道，暂时无法配置	</span></span><br><span class="line">	dma_single_init.memory0_addr = (<span class="type">uint32_t</span>)dta;		</span><br><span class="line">	<span class="comment">// 使能内存地址偏移</span></span><br><span class="line">	dma_single_init.memory_inc = DMA_MEMORY_INCREASE_ENABLE;	</span><br><span class="line">	<span class="comment">// 数据宽度，即每次搬运的数据大小</span></span><br><span class="line">	dma_single_init.periph_memory_width = DMA_PERIPH_WIDTH_16BIT;	</span><br><span class="line">	<span class="comment">// 是否需要循环执行		</span></span><br><span class="line">	dma_single_init.circular_mode = DMA_CIRCULAR_MODE_ENABLE;	</span><br><span class="line">	<span class="comment">// 数据搬运的方向 内存 -&gt; 外设</span></span><br><span class="line">	dma_single_init.direction = DMA_PERIPH_TO_MEMORY;	</span><br><span class="line">	<span class="comment">// 数据传输的位数，即我们需要发送少多少个（periph_memory_width）大小的数据</span></span><br><span class="line">    <span class="comment">// 这也要等到发送时候才能知道</span></span><br><span class="line">	dma_single_init.number = <span class="number">2U</span>;</span><br><span class="line">	<span class="comment">// 优先级可以默认</span></span><br><span class="line">	dma_single_init.priority = DMA_PRIORITY_HIGH;	</span><br><span class="line"> 	<span class="comment">// DMA 初始化配置</span></span><br><span class="line">	dma_single_data_mode_init(DMA1, DMA_CH0, &amp;dma_single_init);</span><br><span class="line">	<span class="comment">// DMA 通道功能选择</span></span><br><span class="line">	dma_channel_subperipheral_select(DMA1, DMA_CH0, DMA_SUBPERI0);	</span><br><span class="line">	<span class="comment">// 使能DMA1</span></span><br><span class="line">	dma_channel_enable(DMA1, DMA_CH0);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adc_gpio_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_mode_set(GPIOC, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, GPIO_PIN_4);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取温度和电位器电压</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_mcu_temperature</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="type">float</span> mcu_dianweiqi = (<span class="number">3.3</span> * dta[<span class="number">0</span>] / <span class="number">4095</span>);	</span><br><span class="line">	<span class="type">float</span> mcu_temperature = (<span class="number">1.45</span> - (<span class="number">3.3</span> * dta[<span class="number">1</span>] / <span class="number">4095</span>)) / (<span class="number">4.1</span> / <span class="number">1000</span>) + <span class="number">25</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mcu_dianweiqi = %f\n&quot;</span>, mcu_dianweiqi);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mcu_temperature = %f\n&quot;</span>, mcu_temperature);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意在使用常规通道时候，不要多次清除 EOC 标志位；在多任务时可能会出现数据错误问题；</p>
<p>adc_flag_clear(ADC0, ADC_FLAG_EOC); &#x2F;&#x2F; 清除 EOC 标志位；</p>
<p>adc_routine_data_read(); &#x2F;&#x2F; 读取对应寄存器也会清楚 EOC 标志位；</p>
<p>二者不需要同时存在</p>
</blockquote>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/DMA/</url>
    <content><![CDATA[<p><strong>DMA（Direct Memory Access，直接内存访问）</strong>是一种数据传输机制，它允许嵌入式系统中的外设在无需CPU干预的情况下，直接与内存之间进行数据交换。</p>
<h2 id="DMA-传输方式"><a href="#DMA-传输方式" class="headerlink" title="DMA 传输方式"></a>DMA 传输方式</h2><p>DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：</p>
<p><strong>内存到内存（Memory-to-Memory）</strong>：数据在内存之间传输。</p>
<p><strong>外设到内存（Peripheral-to-Memory）</strong>：将外设数据写入内存。</p>
<p><strong>内存到外设（Memory-to-Peripheral）</strong>：将内存数据写入外设。</p>
<p><strong>外设到外设（Peripheral-to-Peripheral）</strong>：将外设数据写入外设。</p>
<blockquote>
<p>外设到外设的方式可以理解成内存到内存，因为 DMA 的传输模式本身其实并不存在外设到外设这种传输方式；</p>
</blockquote>
<h3 id="DMA-三种传输模式的数据流"><a href="#DMA-三种传输模式的数据流" class="headerlink" title="DMA 三种传输模式的数据流"></a>DMA 三种传输模式的数据流</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DMAsangechuanshuliu.png" alt="F407DMAsangechuanshuliu.png"></p>
<ul>
<li>外设到存储器：通过 AHB 外设主机接口从外设读取数据，通过 AHB 存储器主机接口向存 储器写入数据；</li>
<li>存储器到外设：通过 AHB 存储器主机接口从存储器读取数据，通过 AHB 外设主机接口向 外设写入数据；</li>
<li>存储器到存储器：通过 AHB 外设主机接口从存储器读取数据，通过 AHB 存储器主机接口 向存储器写入数据。</li>
</ul>
<h3 id="外设握手"><a href="#外设握手" class="headerlink" title="外设握手"></a>外设握手</h3><p>为了保证数据的有效传输，DMA 控制器中引入了外设和存储器的握手机制，包括请求信号和应 答信号：</p>
<ul>
<li><strong>请求信号：</strong>由外设发出，表明外设已经准备好发送或接收数据；</li>
<li><strong>应答信号：</strong>由 DMA 控制器响应，表明 DMA 控制器已经发送 AHB 命令去访问外设。</li>
</ul>
<p><strong>握手机制</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DMAwoshoujizhi.png" alt="F407DMAwoshoujizhi"></p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p>支持单数据传输和多数据传输模式：</p>
<ul>
<li><strong>多数据传输模式：</strong>在存储器数据宽度和外设数据宽度不同的时候，自动打包&#x2F;解包数据；</li>
<li><strong>单数据传输模式：</strong>当且仅当 FIFO 空的时候从源地址读取数据，存进 FIFO，然后把 FIFO 的数据写到目标地址。</li>
</ul>
<p><strong>FIFO</strong></p>
<p>DMA 控制器的每个通道都有一个 4 字深度的 FIFO 用于缓冲数据，从源地址读取的数据会先暂时保存在 FIFO 中，再传输到目的地址。根据 FIFO 的配置，DMA 控制器支持两种数据处理模式： 单数据传输模式和多数据传输模式。<strong>在存储器到存储器模式下，DMA 控制器仅支持多数据传输 模式。</strong></p>
<h2 id="DMA-参数"><a href="#DMA-参数" class="headerlink" title="DMA 参数"></a>DMA 参数</h2><p>在使用DMA时，通常需要配置以下主要参数：</p>
<ul>
<li><p><strong>direction（传输方向）</strong></p>
<ul>
<li>定义 DMA 数据传输的方向，有以下几种选项：<ul>
<li>DMA_PERIPH_TO_MEMORY: 从外设传输到内存。</li>
<li>DMA_MEMORY_TO_PERIPH: 从内存传输到外设。</li>
<li>DMA_MEMORY_TO_MEMORY: 从内存传输到内存（一些 DMA 控制器可能不支持）。</li>
</ul>
</li>
</ul>
<p><strong>periph_addr（外设地址）</strong></p>
<ul>
<li>设置 DMA 读取数据的源地址，通常是外设的寄存器地址（如 USART 的数据寄存器地址）。这个地址通常是固定的，不会变化。</li>
</ul>
<p><strong>memory0_addr（内存地址）</strong></p>
<ul>
<li>设置 DMA 将数据传输到的内存地址，或者在读取模式下 DMA 从此内存地址获取数据传输到外设。这个地址在递增模式下会自动递增。</li>
</ul>
<p><strong>periph_inc（外设地址递增模式）</strong></p>
<ul>
<li>设置外设地址是否递增：<ul>
<li>DMA_PERIPH_INCREASE_ENABLE: 每次传输后外设地址递增。</li>
<li>DMA_PERIPH_INCREASE_DISABLE: 外设地址保持不变（常用）。</li>
</ul>
</li>
</ul>
<p><strong>memory_inc（内存地址递增模式）</strong></p>
<ul>
<li>设置内存地址是否递增：<ul>
<li>DMA_MEMORY_INCREASE_ENABLE: 每次传输后内存地址递增。</li>
<li>DMA_MEMORY_INCREASE_DISABLE: 内存地址保持不变。</li>
</ul>
</li>
</ul>
<p><strong>periph_memory_width（数据宽度）</strong></p>
<ul>
<li>定义传输的数据宽度，有以下几种选择：<ul>
<li>DMA_PERIPH_WIDTH_8BIT: 8 位传输（字节 Byte, 8位）。</li>
<li>DMA_PERIPH_WIDTH_16BIT: 16 位传输（半字 Half-word, 16位）。</li>
<li>DMA_PERIPH_WIDTH_32BIT: 32 位传输（字 Word, 32位）。</li>
</ul>
</li>
</ul>
<p><strong>circular_mode（循环模式）</strong></p>
<ul>
<li>定义 DMA 传输是否启用循环模式：<ul>
<li>DMA_CIRCULAR_MODE_ENABLE: 启用循环模式，在传输完指定数据量后自动重新开始。</li>
<li>DMA_CIRCULAR_MODE_DISABLE: 禁用循环模式，传输一次完成后停止。</li>
</ul>
</li>
</ul>
<p><strong>priority（优先级）</strong></p>
<ul>
<li>设置 DMA 通道的优先级：<ul>
<li>DMA_PRIORITY_LOW: 低优先级。</li>
<li>DMA_PRIORITY_MEDIUM: 中等优先级。</li>
<li>DMA_PRIORITY_HIGH: 高优先级。</li>
<li>DMA_PRIORITY_VERY_HIGH: 最高优先级。</li>
</ul>
</li>
</ul>
<p><strong>number（传输数据量）</strong></p>
<ul>
<li>设置 DMA 传输的数据项数量（如传输多少个字节或字）。DMA 会根据这个数量确定何时完成传输。</li>
</ul>
</li>
</ul>
<h2 id="DMA-执行流程"><a href="#DMA-执行流程" class="headerlink" title="DMA 执行流程"></a>DMA 执行流程</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DMAkuangtu.png" alt="F407DMAkuangtu"></p>
<p>USART 向 DMA 请求传输数据的完整流程：</p>
<ol>
<li><strong>USART 外设触发 DMA 请求</strong></li>
</ol>
<ul>
<li>在 APB 总线上的 USART 外设在准备好要<strong>发送</strong>或<strong>接收</strong>的数据时，会<strong>向 DMA 控制器发出 DMA 请求信号</strong>。这个请求信号通过总线桥传递到 DMA 控制器。</li>
</ul>
<ol start="2">
<li><strong>DMA 控制器接收请求</strong></li>
</ol>
<ul>
<li>USART 的 DMA 请求到达相应的 DMA 控制器时，该 DMA 控制器会根据预设配置选择合适的 DMA 通道进行数据传输。</li>
<li>“仲裁器”会根据通道的优先级判断哪个通道的请求优先执行。仲裁器确保当多个通道请求同时发生时，高优先级的请求优先得到处理。</li>
</ul>
<ol start="3">
<li><strong>DMA 控制器将数据搬运到内存</strong></li>
</ol>
<ul>
<li><p>DMA 控制器根据配置将数据从 USART 的数据寄存器搬运到指定的内存地址。这个过程利用 AHB 总线进行数据传输。</p>
</li>
<li><p>如果是“外设到内存”模式，DMA 会从 USART 数据寄存器读取数据并写入到 SRAM 的指定内存地址。</p>
</li>
</ul>
<ol start="4">
<li><strong>地址和传值自动更新</strong></li>
</ol>
<ul>
<li>每次搬运一个字节或字的数据后，DMA 会根据配置选择是否递增内存地址。对于连续数据搬运，通常设置内存地址递增，而外设地址保持不变，因为数据总是从 USART 的同一个数据寄存器读取。</li>
<li>传输过程中，外设每传输一次数据，CNT 减 1。如果寄存 器 DMA_CHxCTL 的 CMEN 位或 SBMEN 位置 1，在每次传输完成时，CNT会由硬件自动重新装载。</li>
</ul>
<ol start="5">
<li><strong>传输完成或中途抢占</strong></li>
</ol>
<ul>
<li><p>DMA 会持续传输，直到传输的字节数达到预设值。如果在传输过程中有更高优先级的 DMA 请求发起（如来自另一个 USART 或其他外设），高优先级请求可以中断当前传输并优先完成。</p>
</li>
<li><p>当所有预定数据传输完毕后，DMA 控制器会在相应的通道设置传输完成标志 FTF，并可以触发中断通知 CPU 数据传输完成。</p>
</li>
</ul>
<blockquote>
<p>以 Hhello 为例，上述流程会执行五次，直到 CNT &#x3D;&#x3D; 0，将 FTF 位置1；</p>
</blockquote>
<h2 id="DMA-通道映射表"><a href="#DMA-通道映射表" class="headerlink" title="DMA 通道映射表"></a>DMA 通道映射表</h2><p><strong>DMA通道外设映射表</strong>，用于配置 DMA 控制器与外设之间的连接关系</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DMAtongdaoyinshe.png" alt="F407DMAtongdaoyinshe"></p>
<h2 id="传输控制器"><a href="#传输控制器" class="headerlink" title="传输控制器"></a>传输控制器</h2><p>DMA 和外设均可配置为传输控制器：</p>
<ul>
<li>DMA 作为传输控制器：可配置数据传输长度，最大为 65535。</li>
<li>外设作为传输控制器：数据传输的完成取决于外设的最后一个传输请求。</li>
</ul>
<blockquote>
<p>默认情况下都是 DMA 作为传输控制器，可通过 dma_flow_controller_config 函数进行修改</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>功能：通过 DMA 实现 USART 的数据收发</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DMA 配置（内存 -&gt; 外设）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_USART0_Tx_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 使能外设DMA1时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_DMA1);</span><br><span class="line">	<span class="comment">// 配置 DMA 的传输模式(多数据传输/单数据传输)</span></span><br><span class="line">	<span class="comment">// 这里选择单数据传输</span></span><br><span class="line">	dma_single_data_parameter_struct  dma_single_init;</span><br><span class="line">    <span class="comment">// 结构体初始化函数</span></span><br><span class="line">	dma_single_data_para_struct_init(&amp;dma_single_init);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 外设地址</span></span><br><span class="line">	dma_single_init.periph_addr = (<span class="type">uint32_t</span>)(&amp;USART_DATA(USART0));</span><br><span class="line">	<span class="comment">// 是否要使能外设地址偏移</span></span><br><span class="line">	dma_single_init.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">	<span class="comment">// 内存地址，发送时候才知道，暂时无法配置	</span></span><br><span class="line">	<span class="comment">// dma_single_init.memory0_addr = 0U;		</span></span><br><span class="line">	<span class="comment">// 使能内存地址偏移</span></span><br><span class="line">	dma_single_init.memory_inc = DMA_MEMORY_INCREASE_ENABLE;	</span><br><span class="line">	<span class="comment">// 数据宽度，即每次搬运的数据大小</span></span><br><span class="line">	dma_single_init.periph_memory_width = DMA_PERIPH_WIDTH_8BIT;	</span><br><span class="line">	<span class="comment">// 是否需要循环执行		</span></span><br><span class="line">	dma_single_init.circular_mode = DMA_CIRCULAR_MODE_DISABLE;	</span><br><span class="line">	<span class="comment">// 数据搬运的方向 内存 -&gt; 外设</span></span><br><span class="line">	dma_single_init.direction = DMA_MEMORY_TO_PERIPH;	</span><br><span class="line">	<span class="comment">// 数据传输的位数，即我们需要发送少多少个（periph_memory_width）大小的数据</span></span><br><span class="line">    <span class="comment">// 这也要等到发送时候才能知道</span></span><br><span class="line">	<span class="comment">// init_struct-&gt;number = 0U;</span></span><br><span class="line">	<span class="comment">// 优先级可以默认</span></span><br><span class="line">	dma_single_init.priority = DMA_PRIORITY_LOW;	</span><br><span class="line"> 	<span class="comment">// DMA 初始化配置</span></span><br><span class="line">	dma_single_data_mode_init(DMA1, DMA_CH7, &amp;dma_single_init);</span><br><span class="line">	<span class="comment">// DMA 通道功能选择</span></span><br><span class="line">	dma_channel_subperipheral_select(DMA1, DMA_CH7, DMA_SUBPERI4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MDA 配置（外设 -&gt; 内存）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MDA1_USART0_Rx_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空 DAM1 下 DMA_CH5 通道的配置</span></span><br><span class="line">	dma_deinit(DMA1, DMA_CH5);</span><br><span class="line">    <span class="comment">// 使能DMA1外设时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_DMA1);</span><br><span class="line">	<span class="comment">// 创建DMA配置文件</span></span><br><span class="line">	dma_single_data_parameter_struct dma_usart0_rx_init;</span><br><span class="line">	<span class="comment">// 初始化DMA配置</span></span><br><span class="line">	dma_single_data_para_struct_init(&amp;dma_usart0_rx_init);</span><br><span class="line">	<span class="comment">// 配置数据搬运的方向</span></span><br><span class="line">	dma_usart0_rx_init.direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    <span class="comment">// 配置外设地址</span></span><br><span class="line">	dma_usart0_rx_init.periph_addr = (<span class="type">uint32_t</span>)(&amp;USART_DATA(USART0));</span><br><span class="line">	<span class="comment">// 配置内存地址</span></span><br><span class="line">	dma_usart0_rx_init.memory0_addr = (<span class="type">uint32_t</span>)dts;</span><br><span class="line">	<span class="comment">// 配置内存地址偏移使能</span></span><br><span class="line">	dma_usart0_rx_init.memory_inc = DMA_MEMORY_INCREASE_ENABLE;</span><br><span class="line">    <span class="comment">// 关闭外设地址偏移使能</span></span><br><span class="line">	dma_usart0_rx_init.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">	<span class="comment">// 配置数据发送宽度（每一次发送的数据宽度）</span></span><br><span class="line">	dma_usart0_rx_init.periph_memory_width = DMA_PERIPH_WIDTH_8BIT;</span><br><span class="line">    <span class="comment">// 是否重复执行</span></span><br><span class="line">	dma_usart0_rx_init.circular_mode = DMA_CIRCULAR_MODE_DISABLE;</span><br><span class="line">	<span class="comment">// 配置传输的数据长度</span></span><br><span class="line">	dma_usart0_rx_init.number = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 初始化DMA配置	</span></span><br><span class="line">	dma_single_data_mode_init(DMA1, DMA_CH5, &amp;dma_usart0_rx_init);</span><br><span class="line">	<span class="comment">// 选择DMA1通道5下的具体执行编号</span></span><br><span class="line">	dma_channel_subperipheral_select(DMA1, DMA_CH5, DMA_SUBPERI4);</span><br><span class="line">	<span class="comment">// 使能DMA1</span></span><br><span class="line">	dma_channel_enable(DMA1, DMA_CH5);	</span><br><span class="line">&#125;</span><br><span class="line">=========================================================================</span><br><span class="line"><span class="comment">// 如果使用 USART，那么在 USART 配置文件中中也要开启 DMA 使能</span></span><br><span class="line"><span class="comment">/*=================DMA配置配置=================*/</span></span><br><span class="line"><span class="comment">// 启用 USART 的 DMA 发送功能    </span></span><br><span class="line">usart_dma_transmit_config(USART0, USART_TRANSMIT_DMA_ENABLE);</span><br><span class="line"><span class="comment">// 启用 USART 的 DMA 接收功能  </span></span><br><span class="line">usart_dma_receive_config(USART0, USART_RECEIVE_DMA_ENABLE); </span><br><span class="line"></span><br><span class="line">==========================================================================</span><br><span class="line"><span class="comment">// UART0 中断处理函数</span></span><br><span class="line"><span class="type">void</span> USART0_IRQHandler(<span class="type">void</span>) &#123;	</span><br><span class="line">	<span class="keyword">if</span>(SET == usart_interrupt_flag_get(USART0, USART_INT_FLAG_IDLE)) &#123;</span><br><span class="line">		usart_data_receive(USART0);</span><br><span class="line">		<span class="comment">// LDLE 串口空中断时先关闭 DMA 使能，方便清除标志位后开启</span></span><br><span class="line">		dma_channel_disable(DMA1, DMA_CH5);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;rece_data = %c, %c, %c, %c, %c\n&quot;</span>, dts[<span class="number">0</span>], dts[<span class="number">1</span>], dts[<span class="number">2</span>], dts[<span class="number">3</span>], dts[<span class="number">4</span>]);</span><br><span class="line">		<span class="comment">// 清除 TFT 标志位(置0)，当传输完成后它会自动置 1</span></span><br><span class="line">        <span class="comment">// 所以此处并不需要进行阻塞判断</span></span><br><span class="line">		dma_flag_clear(DMA1, DMA_CH5, DMA_FLAG_FTF);</span><br><span class="line">		<span class="comment">// 重新使能 DMA 标志位</span></span><br><span class="line">		dma_channel_enable(DMA1, DMA_CH5);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_data</span><span class="params">(<span class="type">uint8_t</span> dat)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置内存数据地址</span></span><br><span class="line">	dma_memory_address_config(DMA1, DMA_CH7, DMA_MEMORY_0, (<span class="type">uint32_t</span>)(&amp;dat));</span><br><span class="line">    <span class="comment">// 配置数据传输的位数(个数)</span></span><br><span class="line">	dma_transfer_number_config(DMA1, DMA_CH7, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使能 DMA1</span></span><br><span class="line">	dma_channel_enable(DMA1, DMA_CH7);</span><br><span class="line">	<span class="comment">// 发送完后 FTF 会置 1</span></span><br><span class="line">    <span class="comment">// 为了保证发送完成，此处需要阻塞进行等待</span></span><br><span class="line">	<span class="keyword">while</span>(RESET == dma_flag_get(DMA1, DMA_CH7, DMA_FLAG_FTF));</span><br><span class="line">	<span class="comment">// 清除中断标志位</span></span><br><span class="line">	dma_flag_clear(DMA1, DMA_CH7, DMA_FLAG_FTF);</span><br><span class="line">&#125;</span><br><span class="line">================================================================</span><br><span class="line"><span class="comment">// 如果需要启用 DMA 中断，则需要在进行 DMA 配置时添加如下配置    </span></span><br><span class="line"><span class="comment">// 1. 使能 NIVC</span></span><br><span class="line">nvic_irq_enable(DMA1_Channel0, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 配置 DMA 中断源</span></span><br><span class="line"><span class="comment">// 使能 DMA 中断</span></span><br><span class="line">dma_interrupt_enable(DMA1, DMA_CH0, DMA_INT_FTF);</span><br><span class="line"><span class="comment">// 最后在使能 DMA</span></span><br><span class="line"><span class="comment">// 2. 编写 NVIC 使能时指定的中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA1_Channel0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(SET == dma_interrupt_flag_get(DMA1, DMA_CH0, DMA_INT_FLAG_FTF)) &#123;</span><br><span class="line">        <span class="comment">// 清除标志位，我们需要查看寄存器的标志位说明了解是否需要手动清除</span></span><br><span class="line">        dma_interrupt_flag_clear(DMA1, DMA_CH0, DMA_INT_FLAG_FTF);</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(dst) / <span class="keyword">sizeof</span>(dst[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)dst[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置 DMA，在相关外设中启用 DMA 的发送过能，（如果需要可开启中断）；</p>
</li>
<li><p>在使用中断时候我们通常需要进行标志位判断，这时候我们就需要知道当中断触发时候标志位是 0 还是 1，我们就需要去查看用户手册中当前章节的终端说明或者寄存器中该标志位的说明；</p>
</li>
<li><p>FTF 标志位在复位时自动置 0，当传输完成后自动置 1，需要我们手动置 0；</p>
</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><strong>重复执行</strong></p>
<p>当 DMA 完成一轮数据传输后，会自动将目标地址重置回初始地址，并继续进行下一轮的传输。</p>
<p><strong>usart_dma_transmit_config(USART0, USART_TRANSMIT_DMA_ENABLE);</strong></p>
<p>这条语句用于启用 USART0 的 DMA 发送功能。它将配置 USART0，使得数据的发送不再通过 CPU 逐个字节传输，而是通过 DMA 控制器来直接将数据从内存传输到 USART 数据寄存器，从而提高数据传输效率，减少 CPU 的负担。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>DMA 的配置文件重复执行两次后为什么 FTF 标志位的值会从 0 变成 1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dma_deinit(DMA1, DMA_CH5);</span><br><span class="line">dma_flag_clear(DMA1, DMA_CH7, DMA_FLAG_FTF);</span><br></pre></td></tr></table></figure>

<p>上面两行代码可以解决这个问题：</p>
<p>当你 <strong>第一次配置并启动 DMA</strong>，但并没有实际进行数据搬运操作时，FTF（全传输完成标志）会保持为 0，因为没有触发实际的传输操作。但是，当你 <strong>第二次重新配置 DMA</strong> 并执行初始化时，此时不管你有没有使能 DMA；DMA 控制器都会认为之前的传输已经完成，因此它会 <strong>错误地将 <code>FTF</code> 置为 1</strong>。</p>
<p>二、<strong>为什么外设 -&gt; 内存需要清除 FTF 标志位，而内存 -&gt; 内存、内存 -&gt; 外设就不需要呢</strong></p>
<p>问题的关键在于 DMA 配置的时机和操作的顺序，</p>
<p>其实内存 -&gt; 内存、内存 -&gt; 外设也存在这个问题，区别在于，内存 -&gt; 内存、内存 -&gt; 外设二者的发送源要到具体的发送时候才可以确定，也就说我们要到那个时候才会去配置发送源和开启 DMA 使能，那么前面执行的两次初始化配置对于 DMA 来说和 1 次没区别。</p>
<p>三、<strong>当我们通过 USART 向内存写入的数据，超过我们在 PWM 中所定义的个数时，第二次打印的头一个字节会是 PWM 中定义的个数的下一个字节，为什么</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假设，我们定义传输长度为 <span class="number">5</span></span><br><span class="line"></span><br><span class="line">我们第一次传输 hello1，它会显示 hello</span><br><span class="line"></span><br><span class="line">我们第二次传输hello,	它会显示<span class="number">1</span>hell</span><br><span class="line"></span><br><span class="line">为什么？</span><br></pre></td></tr></table></figure>

<p>因为当你外设传递的数据位数，超过你 DMA 配置数据长度时，他会将 DMA 配置数据长度 + 1 位数的字节存在他的缓冲区里面，其他全部丢弃，造成后面的数据就都会错位一个字节；</p>
<p>解决：尽可能定义大的空间把所有数据都接到；</p>
<p>三、<strong>当我们要使用 DMA 功能时候没有头绪要怎么做</strong></p>
<p>通过用户手册<strong>查看 DMA 关系映射表</strong>：在使用 DMA 时，首先要找到 DMA 与我们要搬运的外设之间的对应关系；</p>
<p>通过用户手册查看 DMA 的关系映射表，找到外设所映射的通道在那个 DMA 中，进行配置即可；</p>
<p>例如，我们要使用 ADC0 时，找到 ADC0 对应的是 DMA1 中通道0的第一个通道 000，那么我们只需要配置 DMA1 并指定通道1，子通道为 000 即可；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/I2C/</url>
    <content><![CDATA[<p>在嵌入式开发中，<strong>I2C（Inter-Integrated Circuit）</strong>是一种用于<strong>短距离通信</strong>的<strong>半双工同步串行</strong>通信<strong>协议</strong>，仅需两条线（数据线 SDA 和时钟线 SCL）即可实现<strong>多主多从</strong>通信。主设备通过发送<strong>时钟信号</strong>控制通信节奏，以<strong>字节</strong>为单位与从设备进行数据交换。每个从设备具有<strong>唯一</strong>地址，主设备可以通过寻址选择特定从设备进行读写。</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li><p><strong>半双工通信</strong>：I2C 使用两根信号线即可完成通信，具备半双工特性，即数据在同一时间内只能沿一个方向传输。</p>
</li>
<li><p><strong>双线连接</strong>：I2C 使用两条线进行通信：</p>
<ul>
<li><p><strong>SDA（数据线）</strong>：负责数据的双向传输。</p>
</li>
<li><p><strong>SCL（时钟线）</strong>：提供同步信号，由主设备产生。</p>
</li>
</ul>
</li>
<li><p><strong>多主多从</strong>：IIC 支持多主多从结构，多个主设备可以连接到同一条总线上，但同时只有一个主设备可以主动控制总线。</p>
</li>
<li><p><strong>从设备地址</strong>：每个从设备通过唯一的 7 位或 10 位地址被识别，主设备通过地址区分和选择要通信的从设备。</p>
</li>
</ul>
<blockquote>
<p>SDA 和 SCL 都是双向线，当总线空闲时，两条线都是高电平；连接到总线的设备输出极必须是开漏或者开集，以提供线与功能。</p>
</blockquote>
<h2 id="I2C-时序"><a href="#I2C-时序" class="headerlink" title="I2C 时序"></a>I2C 时序</h2><p>IIC 的传输速率一般是 100kbps，最高可以达到 400kbps（快速模式）或更高（高速模式可达 3.4Mbps），并且遵循一定的时序约束：</p>
<ul>
<li><strong>时钟同步</strong>：主设备通过 SCL 控制传输节奏，数据必须在 SCL 高电平时保持稳定，只有在 SCL 低电平期间数据才允许变化。</li>
<li><strong>确认应答（ACK&#x2F;NACK）</strong>：每传输 8 位数据后，接收方在第九个时钟周期内向发送方反馈 ACK（低电平）或 NACK（高电平）以表示数据接收状态。</li>
</ul>
<h2 id="I2C-通信信号"><a href="#I2C-通信信号" class="headerlink" title="I2C 通信信号"></a>I2C 通信信号</h2><p><strong>起始条件</strong></p>
<ul>
<li>主设备将 SDA 线从高电平拉至低电平，同时保持 SCL 线为高电平，表示通信开始。所有从设备都会检测到该起始信号，准备响应。</li>
</ul>
<p><strong>从设备地址</strong></p>
<ul>
<li><p>主设备在起始信号后发送从设备的7位地址（或10位地址，取决于协议版本）并在地址后加上 1 位读写位。</p>
<ul>
<li>读写位为 0 表示写操作（主设备向从设备发送数据），为 1 表示读操作（主设备从从设备读取数据）。</li>
</ul>
</li>
<li><p>总线上的所有设备都接收地址信号，只有与地址匹配的从设备会响应。</p>
</li>
</ul>
<p><strong>应答（ACK）</strong></p>
<ul>
<li>匹配的从设备将 SDA 线拉低，表示“应答”（ACK），通知主设备可以进行下一步。若没有从设备应答，则 SDA 保持高电平（非应答，NACK）。</li>
</ul>
<p><strong>数据传输</strong></p>
<ul>
<li><p>数据以字节为单位传输，每字节包含 8 位。</p>
</li>
<li><p>每发送完一字节数据，从设备（写操作时）或主设备（读操作时）都需要发送一个 ACK。</p>
</li>
<li><p>数据传输过程中，SDA 数据线在 SCL 时钟线的高电平期间保持稳定，数据变化发生在低电平期间。</p>
</li>
</ul>
<p><strong>停止条件</strong></p>
<ul>
<li><p>当通信结束时，主设备将 SDA 从低电平拉至高电平，同时保持 SCL 为高电平，表示通信完成。</p>
</li>
<li><p>所有从设备返回待机模式，等待下一次通信。</p>
</li>
</ul>
<h2 id="I2C-通信过程"><a href="#I2C-通信过程" class="headerlink" title="I2C 通信过程"></a>I2C 通信过程</h2><h3 id="I2C-写入过程："><a href="#I2C-写入过程：" class="headerlink" title="I2C 写入过程："></a><strong>I2C 写入过程：</strong></h3><ol>
<li><strong>起始信号（START）</strong></li>
<li><strong>发送从设备地址 + 写标志（0）</strong></li>
<li><strong>接收从设备的应答（ACK）</strong></li>
<li><strong>发送数据字节</strong></li>
<li><strong>接收从设备的应答（ACK）</strong></li>
<li><strong>重复步骤 4 和 5，直到发送完所有数据</strong></li>
<li><strong>发送停止信号（STOP）</strong></li>
</ol>
<h3 id="I2C-读取过程："><a href="#I2C-读取过程：" class="headerlink" title="I2C 读取过程："></a><strong>I2C 读取过程：</strong></h3><ol>
<li><strong>起始信号（START）</strong></li>
<li><strong>发送从设备地址 + 写标志（0）</strong></li>
<li><strong>接收从设备的应答（ACK）</strong></li>
<li><strong>起始信号（START）</strong></li>
<li><strong>发送从设备地址 + 读标志（1）</strong></li>
<li><strong>接收从设备的应答（ACK）</strong></li>
<li><strong>读取数据字节</strong></li>
<li><strong>主设备发送应答（ACK）或不应答（NACK）</strong></li>
<li><strong>重复步骤 7 和 8，直到读取完所有数据</strong></li>
<li><strong>发送停止信号（STOP）</strong></li>
</ol>
<h2 id="I2C-通信规则"><a href="#I2C-通信规则" class="headerlink" title="I2C 通信规则"></a>I2C 通信规则</h2><ul>
<li><strong>上升沿</strong>：I2C 协议在 <strong>SCL（时钟线）上升沿捕获数据</strong>。当 SCL 线上升沿到来时，从设备或主设备读取当前 SDA（数据线）上的数据位。</li>
<li><strong>高电平</strong>：在 <strong>SCL 高电平期间传输数据</strong>。SDA 线上发送的数据位在 SCL 高电平时被稳定保持。</li>
<li><strong>下降沿</strong>：当 SCL 从高到低时，I²C 通信方可 <strong>在 SDA 上准备下一位数据</strong>。</li>
<li><strong>低电平</strong>：SCL 低电平期间用于 <strong>设置下一个数据位</strong>，主设备或从设备可以改变 SDA 线上的状态。</li>
</ul>
<p>这样每次上升沿都捕获数据位，确保数据的稳定性，而下降沿或低电平则允许调整数据线上的数据。</p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="C:\Users\kay\Desktop\image-20241109111048626.png" alt="image-20241109111048626"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
<h2 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h2><p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20241111211544630.png" alt="image-20241111211544630"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 SCL 和 SDA 所在的端口和引脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL_PIN  GPIO_PIN_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA_PIN  GPIO_PIN_7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 SCL 和 SDA 的操作宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL_HIGH() HAL_GPIO_WritePin(I2C_SCL_PORT, I2C_SCL_PIN, GPIO_PIN_SET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL_LOW()  HAL_GPIO_WritePin(I2C_SCL_PORT, I2C_SCL_PIN, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA_HIGH() HAL_GPIO_WritePin(I2C_SDA_PORT, I2C_SDA_PIN, GPIO_PIN_SET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA_LOW()  HAL_GPIO_WritePin(I2C_SDA_PORT, I2C_SDA_PIN, GPIO_PIN_RESET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 SDA 状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA_READ() HAL_GPIO_ReadPin(I2C_SDA_PORT, I2C_SDA_PIN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Delay</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++); <span class="comment">// 调整延时以符合时序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    I2C_SDA_HIGH();</span><br><span class="line">    I2C_SCL_HIGH();</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA_LOW();  <span class="comment">// SDA 从高到低，产生起始信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL_LOW();  <span class="comment">// SCL 拉低，准备传输数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    I2C_SCL_LOW();</span><br><span class="line">    I2C_SDA_LOW();</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL_HIGH();  <span class="comment">// SCL 拉高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA_HIGH();  <span class="comment">// SDA 从低到高，产生停止信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendNACK</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    I2C_SCL_LOW();</span><br><span class="line">    I2C_SDA_HIGH();  <span class="comment">// SDA 拉高，表示非应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL_HIGH();  <span class="comment">// SCL 拉高，发送 NACK</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL_LOW();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收应答信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">I2C_ReceiveACK</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    I2C_SCL_LOW();</span><br><span class="line">    I2C_SDA_HIGH();  <span class="comment">// 释放 SDA，等待应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL_HIGH();  <span class="comment">// SCL 拉高，接收应答信号</span></span><br><span class="line">    <span class="type">int</span> ack = (I2C_SDA_READ() == GPIO_PIN_RESET);  <span class="comment">// SDA 低电平表示 ACK，高电平表示 NACK</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL_LOW();</span><br><span class="line">    <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        I2C_SCL_LOW();</span><br><span class="line">        <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">            I2C_SDA_HIGH();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            I2C_SDA_LOW();</span><br><span class="line">        &#125;</span><br><span class="line">        data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL_HIGH();  <span class="comment">// SCL 拉高，发送一位数据</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SCL_LOW();  <span class="comment">// 一字节发送完，拉低 SCL 准备接收 ACK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReceiveByte</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> data = <span class="number">0</span>;</span><br><span class="line">    I2C_SDA_HIGH();  <span class="comment">// 释放 SDA，准备接收数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        I2C_SCL_LOW();</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL_HIGH();  <span class="comment">// 拉高 SCL，接收一位数据</span></span><br><span class="line">        <span class="keyword">if</span> (I2C_SDA_READ()) &#123;</span><br><span class="line">            data |= <span class="number">0x01</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SCL_LOW();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在软件时间时，高低电平的延时时间该怎么算</strong></p>
<p>在软件模拟 I²C 时，延时的设置取决于目标的通信速率。</p>
<p><strong>对于 100 kbps 的标准模式</strong>：</p>
<ul>
<li>每比特 10 微秒。</li>
<li>因此，高电平和低电平每次的延时各需要 <strong>5 微秒</strong>，从而实现 10 微秒的总周期。</li>
</ul>
<p><strong>对于 400 kbps 的快速模式</strong>：</p>
<ul>
<li>每比特 2.5 微秒。</li>
<li>在这种情况下，高电平和低电平每次的延时各 <strong>1.25 微秒</strong>。</li>
</ul>
<p>在 <strong>I2C 通信协议</strong> 中，传输 <strong>一个 bit</strong> 需要一个 <strong>高电平</strong>和<strong>低电平</strong>，这是因为 <strong>SCL（时钟信号）</strong> 是控制数据传输时序的时钟线，而 <strong>SDA（数据线）</strong> 是实际传输数据的线。每传输一个 bit，<strong>SCL 的时钟周期</strong>（一个高电平和一个低电平）就用来完成数据位的传输。</p>
<p>二、<strong>I2C 协议为什么要专门指定为开漏输出</strong></p>
<p>可能会出现这么一种情况，主设备将数据线拉高，从设备将数据线拉低，这时候如何是推挽则会造成短路，这是电路中绝不允许出现的情况，而开漏则不会有这种问题；因为他只能输出低电平，高电平要靠外部的上拉电阻进行提供；</p>
<p><strong>避免电平冲突</strong>：主设备和从设备都可以安全地拉低总线电平，而不会出现高低电平冲突的情况。</p>
<p><strong>总线仲裁</strong>：虽然单主单从不需要仲裁，但在通信中如果出现错误或异常，开漏设计可以让设备可靠地检测总线状态，并进行恢复。</p>
<p><strong>方便扩展</strong>：即使现在是单主单从，未来可以轻松扩展成多主或多从系统，而不需要修改硬件设计。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>Init</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/Init/</url>
    <content><![CDATA[<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>下载相关文件，GD32F407 的用户手册、数据手册、选型手册、固件使用指南（一般下载固件库时会附带）等。</p>
<p><a href="https://www.gd32mcu.com/cn/download/">官网下载地址</a></p>
<h2 id="创建项目与配置"><a href="#创建项目与配置" class="headerlink" title="创建项目与配置"></a>创建项目与配置</h2><p><strong>创建项目</strong></p>
<p>在工程目录中创捷下列文件夹</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录结构</span></span><br><span class="line">Demo01</span><br><span class="line">└── Docs/		 <span class="comment">// 说明文档 README.md</span></span><br><span class="line">└── Project/	 <span class="comment">// 存放 Keil 文件和生成的一些配置文件、hex 文件     </span></span><br><span class="line">├── CMSIS/       <span class="comment">// CMSIS 中 ARM 相关文件</span></span><br><span class="line">├── Firmware/    <span class="comment">// 官方标准固件库中的驱动程序</span></span><br><span class="line">├── Drivers/     <span class="comment">// 外设硬件驱动程序</span></span><br><span class="line">├── Middleware/  <span class="comment">// 中间件组件</span></span><br><span class="line">├── App/         <span class="comment">// 应用层代码</span></span><br><span class="line">└── User/        <span class="comment">// 入口层     </span></span><br></pre></td></tr></table></figure>

<p><strong>文件移植</strong></p>
<p>将官方标准固件库中我们需要的的文件拷贝到对应的工程目录中去：</p>
<blockquote>
<p><strong>CMSIS</strong> –&gt; 官方标准固件库中的 CMSIS 中的代码；</p>
<p><strong>Firmware</strong> –&gt; 官方标准固件库中的外设驱动；</p>
<p><strong>Drivers</strong> –&gt; 我们自己封装的驱动，如按键、显示屏等；</p>
<p><strong>Middleware</strong> –&gt; 项目中的中间件，如上位机的可视化界面等；</p>
<p><strong>App</strong> –&gt; 具体的业务处理逻辑</p>
<p><strong>User</strong> –&gt; 程序的入口和一些工具文件</p>
<p><strong>Project</strong> –&gt; Keil 文件的目录</p>
</blockquote>
<p>那么具体都是要拷贝哪些软件呢，</p>
<ul>
<li><p>将对应目录下文件都拷贝过去，然后将所有 .c 文件添加进项目中然后在解决错误问题(不建议）</p>
</li>
<li><p>查看官方的示例代码，看看人家官方示例是需要拷贝那些，</p>
<ul>
<li>打开 Keil 查看他的工程目录，然后从官方库中复制对应的文件到我们自己的项目中；(注意，一般工程中只会显示 .c 文件但我们要记得将对应的 .h 文件一起拷贝)</li>
</ul>
</li>
</ul>
<p><strong>在 Keil 工程中创建工程目录并添加对应的文件</strong></p>
<ul>
<li>创建 Keil 工程并新建对应的工程目录</li>
<li>将工程文件夹下的 .C 文件添加到 Keil 工程中去</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407Keilyinruwenjian.png" alt="F407Keilyinruwenjian"></p>
<p><strong>添加 Include PATH 路径</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407Keilinclude.png" alt="F407Keilinclude"></p>
<h3 id="Keil配置"><a href="#Keil配置" class="headerlink" title="Keil配置"></a>Keil配置</h3><ol>
<li><strong>芯片的型号要与所用硬件一致</strong></li>
</ol>
<p>“”魔术棒” –&gt; “Device” 下的芯片型号与我们用的硬件是否一样，不一样就要改；</p>
<ol start="2">
<li><strong>编译器版本是否正确</strong></li>
</ol>
<p>“”魔术棒” –&gt; “Target” 下 ARM Compiler 的版本是否为 “Use default compiler version 6”，如果 “missing compiler version 5” 表示 5 这个版本的不存在那么我们也要去安装；</p>
<p>勾选 “Use Micro LIB” 以优化代码；</p>
<blockquote>
<p>这里注意，编译器版本最好与官方提供的示例代码中的版本一致，不然会有非常多的一些警告</p>
</blockquote>
<ol start="3">
<li><strong>是否生成 .HEX 文件</strong></li>
</ol>
<p>“魔术棒” –&gt; “Output” 下勾选 “Create HEX File”;</p>
<ol start="4">
<li><strong>设置 C 和 C++ 的编译器版本，不然有些宏关键字它可能不识别，设置代码优化级别</strong></li>
</ol>
<p>“魔术棒” –&gt; “C&#x2F;C++” 下的 Language C 设置为 “C99”，Language C++ 设置为 “C++ 11”</p>
<p>设置编译警告的级别，选择 “Wamings” 中的内容为 “AC5-like Wamings”，表示与 Keil5 一致；</p>
<p>设置代码优化的级别，选择 “Optimizaion” 中的内容为 “-O1”，级别越高优化程序越高，但是太高了有时候会出错，此处设置为 “-O1” 即可；</p>
<ol start="5">
<li><strong>添加 Keil 工程中的使用文件的路径</strong></li>
</ol>
<p>“魔术棒” –&gt; “C&#x2F;C++” 下的 “Include Path” 中进行添加；</p>
<ol start="6">
<li><strong>选择所使用的烧录器</strong></li>
</ol>
<p>“魔术棒” –&gt; “Debug” 下右侧 “Use” 中的烧录器，此处我们设置为 “CMSIS-DAP Debugger”;</p>
<p>勾选自动复位并运行，左侧 “Setting” –&gt; “Flash Download” 中勾选 “Reset and Run”;</p>
<p>通常如果烧录器连上后可以在  “Setting” –&gt; “Debug” 右侧中的 “SW Device” 中看到；</p>
<h2 id="开发与调试"><a href="#开发与调试" class="headerlink" title="开发与调试"></a>开发与调试</h2><ol>
<li><strong>示例的 main.c 中使用的芯片与我们不一致，所以需要删掉他的头文件和其代码</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f450i_eval.h&quot;</span> <span class="comment">// 删掉</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个函数删掉</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_spark</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> __IO <span class="type">uint32_t</span> timingdelaylocal = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timingdelaylocal) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timingdelaylocal &lt; <span class="number">500U</span>) &#123;</span><br><span class="line">            gd_eval_led_on(LED1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gd_eval_led_off(LED1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timingdelaylocal--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timingdelaylocal = <span class="number">1000U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    gd_eval_led_init(LED1); <span class="comment">// 这个调用语句也删掉</span></span><br><span class="line">    systick_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gd32f4xx_it.c 中调用了 led_spark() 我们也要讲他删掉</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>编译运行这时他会报错，提示缺少一些文件，我们去看这些文件在我们的目录中是否存在，如果不存在就加进来</strong></p>
<p>这里一般情况下是缺少 “core_cmFunc.h”，”core_cm4.h”，”core_cm4_simd.h”，”core_cmlnstr.h”，这四个</p>
</li>
<li><p><strong>此时还是报错，我们点击报错的语句，发现他会跳到某些个 include 处报错：D:&#x2F;Tools&#x2F;IDE&#x2F;keil&#x2F;keil&#x2F;ARM&#x2F;Packs&#x2F;GigaDevice&#x2F;GD32F4xx_DFP&#x2F;3.0.3&#x2F;Device&#x2F;F4XX&#x2F;Include\gd32f4xx_libopt.h(11): error: ‘RTE_Components.h’ file not found；</strong></p>
</li>
</ol>
<ul>
<li><p>注意看他这个报错信息中的路径好像用的不是我们本地的那个呀，那么 ok，我们首先要将 gd32f4xx_libopt.h 包含在我们的项目本地，确保他在本地是存在的，</p>
</li>
<li><p>gd32f4xx_libopt.h 这个文件是在哪被声明使用的呢？，我们发现，他是在 gd32f4xx.h 中被声明使用的，那么 gd32f4xx.h 这个文件在本地是否存在呢，如果不存在就需要从标准固件库中添加进我们的项目中；</p>
</li>
</ul>
<p>此时，运行它使用的就是我们本地的 gd32f4xx_libopt.h 文件了，这时它有时候还会报错某些引用错误，但这是官方的标准文件是不会出错了，那么大概率就是某些头没有导入，他某些头文件的导入是通过宏来定义的；我们需要在 Keil 中定义某些宏；</p>
<ol start="4">
<li><strong>简化外设库的使用</strong></li>
</ol>
<p>我们看 gd32f4xx_libopt.h 文件发现其中定义了很多的头文件，但是它需要通过宏去判断是否导入这些头文件，所以此时我们需要添加这些宏关键字；</p>
<p>“魔术棒” –&gt; “C&#x2F;C++” 下的 “Define” 中进行添加；”USE_STDPERIPH_DRIVER,GD32F407”，这两个宏定义，</p>
<p>USE_STDPERIPH_DRIVER 用于在 gd32f4xx.h 中展开 gd32f4xx_libopt.h 头文件（这一句可以不加，它本身会做判断，不存在就自动定义）；</p>
<p>GD32F407 用于在 gd32f4xx_libopt.h 展开标准固件库中的头文件；</p>
<h2 id="烧写与验证"><a href="#烧写与验证" class="headerlink" title="烧写与验证"></a>烧写与验证</h2><p>在嵌入式开发中，<strong>拿到一块开发板后，烧录方式不能随意选择</strong>，而是需要<strong>根据开发板的硬件支持情况</strong>来选择适合的烧录方法。</p>
<p><strong>如何查看开发板的烧录方式支持情况</strong></p>
<ul>
<li><p><strong>查看数据手册</strong>：芯片的数据手册通常会列出支持的烧录接口和方法，例如 ST-Link、J-Link、UART、USB DFU 等。</p>
</li>
<li><p><strong>检查开发板的接口</strong>：查看开发板是否有特定的调试&#x2F;编程接口，例如 <strong>SWD</strong> 接口、<strong>JTAG</strong> 接口、<strong>USB</strong> 接口、或 <strong>UART</strong> 引脚等。</p>
</li>
<li><p><strong>开发板文档</strong>：一些开发板还会提供专门的用户手册，其中会详细说明支持的烧录方法和推荐的工具。</p>
</li>
</ul>
<h3 id="DAP-Link-下载"><a href="#DAP-Link-下载" class="headerlink" title="DAP-Link 下载"></a>DAP-Link 下载</h3><ol>
<li>DAP-Link 连线</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPlianxian.png" alt="F407DAPlianxian"></p>
<ol start="2">
<li>Keil 设置</li>
</ol>
<p>Debug 中的设置此处不再赘述，如果发现一直无法识别烧录器则需要换一个烧录器或者换一种烧录方式；</p>
<ol start="3">
<li>烧录</li>
</ol>
<p>“主界面” –&gt; “保存” –&gt; “Rebuild” –&gt; “Download” 即可</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407shaolumulu.png" alt="F407shaolumulu"></p>
<h3 id="使用-DFU-烧录"><a href="#使用-DFU-烧录" class="headerlink" title="使用 DFU 烧录"></a>使用 DFU 烧录</h3><p><strong>下载安装 CH340 驱动</strong></p>
<p><a href="https://www.wch.cn/download/CH341SER_EXE.html">CH341SER.EXE - 南京沁恒微电子股份有限公司</a></p>
<p><strong>下载安装 DFU 驱动</strong></p>
<p><a href="https://www.gd32mcu.com/cn/download?kw=DFU&lan=cn">兆易创新GigaDevice-资料下载兆易创新GD32 MCU</a></p>
<p><strong>下载烧录软件</strong></p>
<p><a href="https://www.gd32mcu.com/en/download?kw=GD32+All-In-One+Programmer">兆易创新GigaDevice-资料下载GigaDevice GD32 MCU</a></p>
<p><strong>Keil配置</strong></p>
<p>“魔术棒” –&gt; “Output” 下勾选 “Create HEX File”;</p>
<p><strong>烧录器使用</strong></p>
<ol>
<li>解压后以管理员身份运行</li>
<li>软件配置</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpezhi01.png" alt="F407DAPpezhi01"></p>
<ol start="3">
<li>开始进入升级模式。首先按住BOOT0不要松手，然后再按一次RESET进入到升级模式。</li>
</ol>
<p>进入升级模式成功之后，会在软件中显示设备 <strong>GD DFU DEVICE 1</strong> 。如果没有进入请多次尝试。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpeizhi02.png" alt="F407DAPpeizhi02"></p>
<ol start="4">
<li>点击 “Connect” 连接开发板。</li>
</ol>
<p>连接成功之后，会显示出芯片内存大小。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpeizhi03.png" alt="F407DAPpeizhi03"></p>
<ol start="5">
<li>查看有无读写保护</li>
</ol>
<p>主界面中选择 “Erase selected pages” ，点击 “Erase”，如果有读写保护则需要解除保护如果没有就不管他</p>
<ol start="6">
<li>下载测试代码</li>
</ol>
<p>在主界面，点击 “Browse” ,选择 .hex 文件，之后点击 “Download”；</p>
<p>然后我们按一下复位按键，就可以让程序开始运行。</p>
<ol start="6">
<li>解除写保护</li>
</ol>
<p>在主界面，点击 “Edit Option Bytes”;</p>
<p>主要内容为修改 SPC 的值为非 0XAA 和非 0XCC 值，比如 0x55</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpeizhi04.png" alt="F407DAPpeizhi04"></p>
<blockquote>
<p>但我测试时候发现，将 WP0 下面的两个沟去掉也可以接触写保护;</p>
</blockquote>
<h2 id="调整系统主频"><a href="#调整系统主频" class="headerlink" title="调整系统主频"></a>调整系统主频</h2><p>芯片选型手册</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407xinpianxuanxingbiao.png" alt="F407xinpianxuanxingbiao"></p>
<p>这张图表展示了 GD32F407VET6 芯片的主要参数和特性，以下是对各项的详细说明：</p>
<p><strong>基本参数</strong></p>
<ul>
<li><p><strong>Max Speed (MHz)</strong> - <strong>最大速度</strong>:</p>
<ul>
<li>GD32F407VET6 的主频最高可达 168 MHz，适合处理需要较高运算速度的嵌入式应用场景。</li>
</ul>
</li>
<li><p><strong>Memory (Bytes)</strong> - <strong>内存</strong>:</p>
</li>
<li><p><strong>Flash</strong>: 512 KB 的内部 Flash 存储，用于存储程序代码。</p>
</li>
<li><p><strong>SRAM</strong>: 192 KB 的 SRAM，供程序运行时使用，存储临时数据和变量。</p>
</li>
</ul>
<p><strong>输入&#x2F;输出 (I&#x2F;O)</strong></p>
<ul>
<li><strong>I&#x2F;O Pins</strong>: 提供了最多 82 个 GPIO 引脚（通用输入输出引脚），这些引脚可以用于连接外部设备或控制器件。</li>
</ul>
<p><strong>定时器 (Timer)</strong></p>
<ul>
<li><p><strong>Adv TM (16bit)</strong> - <strong>高级定时器</strong>:</p>
<ul>
<li>包含 2 个 16 位高级定时器，通常用于需要复杂 PWM 生成的应用，比如电机控制。</li>
</ul>
</li>
<li><p><strong>GPTM (16bit)</strong> - <strong>通用定时器</strong>:</p>
<ul>
<li>配置了 4 个 16 位通用定时器，适合用于普通计时任务或输入捕获。</li>
</ul>
</li>
<li><p><strong>GPTM (32bit)</strong> - <strong>32 位通用定时器</strong>:</p>
<ul>
<li>配置了 2 个 32 位通用定时器，适合计时精度要求较高的场景。</li>
</ul>
</li>
<li><p><strong>Basic TM (16bit)</strong> - <strong>基本定时器</strong>:</p>
<ul>
<li>配置了 2 个基本定时器，适合简单的计数或时间延迟任务。</li>
</ul>
</li>
<li><p><strong>WDG</strong> - <strong>看门狗定时器</strong>:</p>
<ul>
<li>配置了 2 个看门狗定时器，用于在程序异常时重启系统，以确保系统安全。</li>
</ul>
</li>
<li><p><strong>RTC</strong> - <strong>实时时钟</strong>:</p>
<ul>
<li>具备 1 个 RTC 实时时钟，通常用于计时任务，如数据记录或时间戳生成。</li>
</ul>
</li>
</ul>
<p><strong>通信接口 (Connectivity)</strong></p>
<ul>
<li><p><strong>USART + UART</strong>:</p>
<ul>
<li>提供 4 个 USART 和 2 个 UART 接口，可以用于串口通信，如与其他设备通信或调试信息输出。</li>
</ul>
</li>
<li><p><strong>I²C</strong>:</p>
<ul>
<li>配置了 3 个 I²C 接口，用于与 I²C 总线设备通信，比如传感器和存储设备。</li>
</ul>
</li>
<li><p><strong>SPI</strong>:</p>
<ul>
<li>包含 3 个 SPI 接口，支持与 SPI 设备的高速数据交换，比如与 ADC、DAC 通信。</li>
</ul>
</li>
<li><p><strong>CAN 2.0B</strong>:</p>
<ul>
<li>包含 2 个 CAN 2.0B 接口，用于工业控制网络中的数据传输。</li>
</ul>
</li>
<li><p><strong>USB OTG</strong>:</p>
<ul>
<li>配置了 USB 全速 (FS) 和高速 (HS) 双模式 OTG（On-The-Go）接口，可以用于 USB 设备或主机功能。</li>
</ul>
</li>
<li><p><strong>I²S</strong>:</p>
<ul>
<li>具有 2 个 I²S 接口，用于音频数据传输。</li>
</ul>
</li>
<li><p><strong>SDIO</strong>:</p>
</li>
<li><p>支持 SDIO 接口，可以与 SD 卡通信，用于数据存储应用。</p>
</li>
</ul>
<ol>
<li><strong>LCD-SDIO TFT</strong>:<ul>
<li>提供 1 个 LCD 接口，用于连接显示屏（如 TFT 屏幕）。</li>
</ul>
</li>
<li><strong>Camera</strong>:<ul>
<li>配置 1 个摄像头接口，支持外接摄像头模块，实现图像采集功能。</li>
</ul>
</li>
<li><strong>ETH MAC</strong>:<ul>
<li>配置了 1 个 Ethernet MAC 接口，可以用于网络通信应用。</li>
</ul>
</li>
</ol>
<p><strong>模拟接口 (Analog Interface)</strong></p>
<ul>
<li><p><strong>12-bit ADC Units (CHs)</strong> - <strong>ADC 单元和通道</strong>:</p>
<ul>
<li>配置了 3 个 12 位 ADC，拥有总共 16 个通道，用于模拟信号采集。</li>
</ul>
</li>
<li><p><strong>12-bit DAC Units</strong> - <strong>DAC 单元</strong>:</p>
<ul>
<li>配置了 2 个 12 位 DAC，用于将数字信号转换为模拟信号输出。</li>
</ul>
</li>
</ul>
<p><strong>存储器接口 (EMMC&#x2F;SDRAM)</strong></p>
<ul>
<li>EXMC<ul>
<li>配置了 1 个 EXMC 外部存储控制器接口，可以连接外部 SDRAM 或 NOR Flash 扩展存储器。</li>
</ul>
</li>
</ul>
<p><strong>封装 (Package)</strong></p>
<ul>
<li>LQFP100<ul>
<li>该型号的芯片封装类型为 LQFP100（100 引脚的低轮廓方形封装），方便焊接和电路板设计。</li>
</ul>
</li>
</ul>
<blockquote>
<p>根据手册我们要设置系统主频为 168 MHz，那么要如何实现这个 168MHz 的频率，这时候就要去看板子商家的原理图和用户手册了，看他们是如何实现的，然后选择为对应的方式，如果他们设置了外部就选择外部否则可以选择内部的（通常情况下一般都是默认选择外部高速晶振）；</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407jinzhenbufen.png" alt="F407jinzhenbufen"></p>
<p>这里我们先简单走一遍 ARM32 系列设置系统主频的流程：</p>
<p>上电复位后他会去执行 Reset_Handler 这个启动代码，它负责在系统复位（Reset）后初始化处理器状态和程序运行环境；同时在这个代码中他会去调用 SystemInit这个初始化函数；</p>
<p>在 SystemInit 这个初始化函数中，他会进行一系列的初始化配置，这里我们只关心它对于系统时钟的配置也就是调用的 SetSysClock 这个函数；</p>
<p>在 SetSysClock 这个函数中他打开了了外部时钟，并设置了锁相环等一些列操作；这里我们关心的是如何将 8MHz 外部高速晶振设置为 168MHz 的系统主频，也就是如何通过锁相环将 8MHz 设置为 168MHz；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁相环配置如下</span></span><br><span class="line">RCC-&gt;PLLCFGR = PLL_M | (PLL_N &lt;&lt; <span class="number">6</span>) | (((PLL_P &gt;&gt; <span class="number">1</span>) <span class="number">-1</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q &lt;&lt; <span class="number">24</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的锁相环配置中，我们可以看到，它是通过先除以 PLL_M 乘以 PLL_N 在除以 PLL_P 最终得到一个系统主频的，所以我们只需要修改这三个常量的值就可以了 ；</p>
<p>也就是将 PLL_M 设置为 8，PLL_N 设置为 336，PLL_P 设置为 2 即可；当然你也可以有其他的组合只要得到的是 168MHz 就可以；</p>
<blockquote>
<p>不理解记住就可以，因为只要是 Cortex-M 系列的他的锁相环基本上都是这样配置的</p>
</blockquote>
<p>此时系统主频就被配置为了 168MHz</p>
<h2 id="配置-SysTick"><a href="#配置-SysTick" class="headerlink" title="配置 SysTick"></a>配置 SysTick</h2><p>设置完系统主频后，我们还需要设置下滴答时钟以得到一个精准的延时；SysTick 的具体原理可以参考 <a href="">SysTick</a> 这一篇文章，这里只教大家如何去配置；</p>
<p>我们找到 main() 函数中系统滴答时钟的配置语句，然后跳转后找到 SysTick_Config 这个函数，这里面就是对于系统滴答时钟的配置，我们通常使用默认配置不去动他，只需要给他一个具体的周期值即可；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// STM32</span></span><br><span class="line">RCC_GetClocksFreq(&amp;RCC_Clocks);</span><br><span class="line">SysTick_Config(RCC_Clocks.HCLK_Frequency / <span class="number">100</span>);</span><br><span class="line"><span class="comment">// GD32</span></span><br><span class="line">SysTick_Config(SystemCoreClock / <span class="number">1000000U</span>);</span><br></pre></td></tr></table></figure>

<p>通过上面语句可以发现在 Cortex-M 架构中，我们只需要设置 SysTick_Config 这个函数的参数即可，在 GD32 中 SystemCoreClock 是调用的一个宏我们只需要修改他为 168000000（系统主频）即可；在 SMT32 中稍微麻烦一点我们要去看他的默认配置也就是 RCC_GetClocksFreq(&amp;RCC_Clocks) 这个函数;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GD32 中的修改</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSTEM_CLOCK_168M_PLL_8M_HXTAL        (uint32_t)(168000000)</span></span><br><span class="line"><span class="comment">// STM32 中会通过寄存器去配置所以通常情况下我们不需要去修改它，只需要修改如下即可：</span></span><br><span class="line"><span class="comment">// (我感觉 STM32 可以不需要配置，它会自动去选择时钟源，通过时钟源作为系统滴答时钟进行计算)</span></span><br><span class="line"><span class="comment">// 这一条代码我感觉通常情况下不会用到，除非我们像 GD32 那样去使用；</span></span><br><span class="line"><span class="type">uint32_t</span> SystemCoreClock = <span class="number">168000000</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般情况下我们将 GD32 中 SysTick 的代码复制到 STM32 中去使用，因为更简单些</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>外部的 8MHz 是如何实现 168MHz 的？</strong></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>MG_996R舵机</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/MG_996R%E8%88%B5%E6%9C%BA/</url>
    <content><![CDATA[<p>舵机（Servo Motor）是一种集电机、控制电路和反馈系统于一体的<strong>伺服电机系统</strong>，用于精确控制位置（角度）、速度或力矩。它最常见的用途是 <strong>角度伺服控制</strong>，即驱动一个机械装置旋转到特定角度并保持稳定。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>一个典型的舵机包括以下部分：</p>
<ol>
<li><strong>电机</strong><ul>
<li>通常是一个直流电机（DC Motor）或无刷电机，负责提供驱动力。</li>
</ul>
</li>
<li><strong>齿轮组</strong><ul>
<li>电机驱动输出轴通过齿轮组减速并放大扭矩，从而增加精度和力量。</li>
</ul>
</li>
<li><strong>控制电路</strong><ul>
<li>内部的电子控制模块接收控制信号（如 PWM 信号），将其转换为电机的转速和方向。</li>
</ul>
</li>
<li><strong>位置反馈系统（通常是电位计）</strong><ul>
<li>用于检测输出轴的当前位置，反馈给控制电路以形成闭环控制。</li>
</ul>
</li>
<li><strong>输出轴</strong><ul>
<li>连接外部机械装置，执行精确的角度控制。</li>
</ul>
</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407duojiyli.png" alt="F407duojiyli"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p><strong>精准角度控制</strong><br>舵机可以控制输出轴在特定范围内（通常为 0° 到 180° 或 360°）的位置。</p>
</li>
<li><p><strong>闭环控制</strong><br>舵机通过位置反馈系统（如电位计或编码器）不断调整输出轴的位置，确保达到目标角度。</p>
</li>
<li><p><strong>易于使用</strong><br>使用简单的 PWM 信号即可控制，无需复杂的驱动器。</p>
</li>
<li><p><strong>扭矩输出</strong><br>舵机通常以 kg.cm（千克力·厘米）为单位来表示其扭矩能力。</p>
</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>舵机的工作原理基于<strong>闭环控制系统</strong>，它通过比较控制信号与实际位置之间的差异，调整电机的转动，最终使舵机的输出轴达到并保持在目标位置。具体过程如下：</p>
<p><strong>接收 PWM 信号</strong></p>
<ul>
<li><p>MCU 输出一个 PWM 信号，通常是周期为 20ms，脉冲宽度在 1ms 到 2ms 之间。</p>
</li>
<li><p>例如，1ms 的脉冲宽度对应 0°，1.5ms 对应 90°，2ms 对应 180°。</p>
</li>
<li><p>这个 PWM 信号决定了舵机的 <strong>目标位置</strong>。</p>
</li>
</ul>
<p><strong>舵机判断是否需要转动</strong></p>
<ul>
<li><p>舵机内部有一个<strong>电位器</strong>，它持续监控舵机的<strong>实际角度</strong>。</p>
</li>
<li><p>控制电路将接收到的目标角度与电位器提供的当前角度进行比较，计算出 <strong>误差</strong>（即目标角度与当前角度之间的差值）。</p>
</li>
<li><p>如果<strong>目标角度</strong>和<strong>实际角度</strong>不一致，舵机会继续<strong>转动</strong>，通过电机和齿轮组调整到目标位置。</p>
</li>
<li><p>如果<strong>目标角度</strong>与<strong>实际角度</strong>相同，电机<strong>停止转动</strong>，舵机就会维持当前的角度。</p>
</li>
</ul>
<p><strong>电机转动</strong></p>
<ul>
<li><p><strong>是否需要转动</strong>：舵机是否继续转动取决于 <strong>当前角度</strong> 和 <strong>目标角度</strong> 之间的误差。如果两者一致，舵机不需要转动；如果存在误差，舵机会转动直到达到目标角度。</p>
</li>
<li><p><strong>PWM信号</strong> 只负责设置目标角度，舵机根据当前角度和目标角度的差值决定是否需要转动。</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>模拟舵机（Analog Servo）</strong></p>
<ul>
<li>使用模拟电路控制，接收连续的 PWM 信号。</li>
<li>优点：成本低，适合低精度应用。</li>
<li>缺点：响应速度较慢，抗干扰能力弱。</li>
</ul>
<p><strong>数字舵机（Digital Servo）</strong></p>
<ul>
<li>使用数字信号处理器（DSP）控制。</li>
<li>优点：控制更精确，响应速度快。</li>
<li>缺点：价格较高，功耗略高。</li>
</ul>
<p><strong>连续旋转舵机（Continuous Servo）</strong></p>
<ul>
<li>特点：能够连续旋转，不局限于角度范围。</li>
<li>应用：作为轮子或传动装置，用于机器人。</li>
</ul>
<p><strong>工业伺服电机（Industrial Servo Motor）</strong></p>
<ul>
<li>用于精确控制速度和位置。</li>
<li>应用：工业自动化设备、机械臂等高精度场景。</li>
</ul>
<h2 id="与普通电机的区别"><a href="#与普通电机的区别" class="headerlink" title="与普通电机的区别"></a>与普通电机的区别</h2><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">舵机</th>
<th align="center">普通电机</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>控制精度</strong></td>
<td align="center">高，可控制到具体角度或位置</td>
<td align="center">低，通常只控制速度或方向</td>
</tr>
<tr>
<td align="center"><strong>结构</strong></td>
<td align="center">集成反馈和控制电路</td>
<td align="center">仅包含电机本体</td>
</tr>
<tr>
<td align="center"><strong>控制方式</strong></td>
<td align="center">通过 PWM 信号或命令控制</td>
<td align="center">电压、电流或占空比控制</td>
</tr>
<tr>
<td align="center"><strong>应用</strong></td>
<td align="center">精确控制机械位置</td>
<td align="center">旋转运动或动力输出</td>
</tr>
</tbody></table>
<h2 id="MG-996R"><a href="#MG-996R" class="headerlink" title="MG 996R"></a>MG 996R</h2><p>MG 996R 型号对于舵机的控制如下：</p>
<p>1.5ms 对应中间位置，2ms 对应最右边位置（+90°），1ms 对应最左边位置（-90°）。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BSP_USART.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 预分频值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRESCALER (168 - 1) <span class="comment">// </span></span></span><br><span class="line"><span class="comment">// 周期为 20ms</span></span><br><span class="line"><span class="comment">// 也就是 1s = 20000ms   1000000/10000 = 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIOD (((SystemCoreClock / (PRESCALER + 1)) / 50) - 1) </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Timer8 GPIO Config</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer8_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// PE5</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOE);</span><br><span class="line">	gpio_mode_set(GPIOE, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_5);	</span><br><span class="line">	gpio_output_options_set(GPIOE, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5);</span><br><span class="line">	gpio_af_set(GPIOE, GPIO_AF_3, GPIO_PIN_5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  TImer8 Config</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TImer8_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	timer_deinit(TIMER8);</span><br><span class="line">	rcu_periph_clock_enable(RCU_TIMER8);		</span><br><span class="line">	rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL2);	</span><br><span class="line">	timer_parameter_struct initpara;		</span><br><span class="line">	timer_struct_para_init(&amp;initpara);</span><br><span class="line">	initpara.prescaler         = PRESCALER;</span><br><span class="line">    initpara.period            = PERIOD;		</span><br><span class="line">	timer_init(TIMER8, &amp;initpara);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// PWM 配置</span></span><br><span class="line">	timer_oc_parameter_struct ocpara;	</span><br><span class="line">	timer_channel_output_struct_para_init(&amp;ocpara);</span><br><span class="line">	ocpara.ocpolarity   = TIMER_OC_POLARITY_HIGH;</span><br><span class="line">	ocpara.outputstate = TIMER_CCX_ENABLE;	</span><br><span class="line">	<span class="comment">// 第一个参数是我们使用的是哪一个定时器</span></span><br><span class="line">	<span class="comment">// 第二个参数是我们使用的哪一个通道，也是就在服用编号表中看到的编号 TIMER3_CH3</span></span><br><span class="line">	timer_channel_output_config(TIMER8, TIMER_CH_0, &amp;ocpara);</span><br><span class="line">	<span class="comment">// 输出模式配置</span></span><br><span class="line">	<span class="comment">// 模式0：在向上计数时，一旦计数器值小于 TIMERx_CH0CV 时，O0CPRE 为高电平，否则为低电平。</span></span><br><span class="line">	<span class="comment">// 在向下计数时，一旦计数器的值大于 TIMERx_CH0CV 时 O0CPRE 为低电平，否则为高电平。</span></span><br><span class="line">	<span class="comment">// 在 TIMERx_CH0CV 下面就是高电平</span></span><br><span class="line">	timer_channel_output_mode_config(TIMER8, TIMER_CH_0, TIMER_OC_MODE_PWM0);</span><br><span class="line">	<span class="comment">// 配置占空比</span></span><br><span class="line">	<span class="comment">// 为了达到流水灯的效果，我们要让他一开始是 熄灭的，然后逐渐亮灭</span></span><br><span class="line">	<span class="comment">// 周期和分频会自动 + 1 ，占空比不会所以需要加回来</span></span><br><span class="line">	timer_channel_output_pulse_value_config(TIMER8, TIMER_CH_0, (<span class="type">uint16_t</span>)(PERIOD + <span class="number">1</span>) * <span class="number">2.5</span> / <span class="number">100</span>);	</span><br><span class="line">	timer_enable(TIMER8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">    usart0_init();</span><br><span class="line">	Timer8_GPIO_Config();</span><br><span class="line">	TImer8_Config();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;App_start...&quot;</span>);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>周期计算</strong></p>
<p>如何计算周期为 20ms 的 PWM 参数</p>
<p>已知：当前频率为 1000000Hz，周期为 20ms</p>
<p>频率为 1000000Hz，表示一秒钟有 1000000 个周期，每个周期的时间 &#x3D; 1 &#x2F; 1000000 &#x3D; 0.001ms</p>
<p>我想要数 20 ms,也就是说我要数 x 个数，0.001x &#x3D; 20ms，x &#x3D; 20000</p>
<p>所以我们此时 pwm 的周期应该设置为 20000</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>PID 控制算法</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>首先，对控制系统和控制理论的概念做简单的介绍。</p>
<p>学术点讲，控制系统就是能改变系统未来状态的一种<strong>装置</strong>，它独立于控制对象本身，是我们人为设计出来给控制对象以控制信号的装置；而控制理论就是帮助我们合理设计这种装置的<strong>方法和策略</strong>。</p>
<p>大白话讲就是，有一个系统（system），给它一个输入（Input），它就会有一个输出（output），现在我们想它按我们想的来输出。此时，控制系统就是产生输入的东西，控制理论则告诉我们到底给什么输入。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDkzsf.png" alt="F407PIDkzsf"></p>
<h2 id="开环控制"><a href="#开环控制" class="headerlink" title="开环控制"></a>开环控制</h2><p>开环控制指输入不依赖于输出的控制方式;</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDkhkz.png" alt="F407PIDkhkz"></p>
<p>当我们只输入时间这个控制变量的时候，就是开环控制，因为控制量时间一经设置好就不变，不随着输出——盘子清洁程度的变化而变化;</p>
<blockquote>
<p>对于一些精度不那么重要的系统来说开环控制非常友好</p>
</blockquote>
<h2 id="闭环控制"><a href="#闭环控制" class="headerlink" title="闭环控制"></a>闭环控制</h2><p>闭环控制指输出会反馈给输入端从而影响输入的控制方式;</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDbykz.png" alt="F407PIDbykz"></p>
<p>闭环控制过程中，会首先设置一个参考值，这里即盘子的清洁程度；探测结果的会反馈到控制器的输入端，与我们设置的参考值进行比较，得到误差 E；控制器根据E得到输入出结果，如果E &gt; 0，说明盘子还没洗干净，需要增加清洁时间 t，直到E &#x3D; 0，盘子被清洗干净。这一不断反馈并修正输入的过程构成了完整的闭环，即“闭环控制”;</p>
<h2 id="PID-控制算法"><a href="#PID-控制算法" class="headerlink" title="PID 控制算法"></a>PID 控制算法</h2><p>PID（Proportional-Integral-Derivative）控制算法是一种高效且简单的闭环控制算法，用于解决<strong>目标值与实际值的差异（误差）问题</strong>。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDshuom1.png" alt="F407PIDshuom1"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDshuom2.png" alt="F407PIDshuom2"></p>
<p><strong>PID 代表：Proportional（比例），Integral（积分），Derivative（微分）</strong>。</p>
<p>输入的 <strong>误差 (Error)</strong> 被送入三部分：比例通道、积分通道和微分通道。</p>
<p>三个通道各自根据误差，贡献不同的控制量（用增益系数（误差）分别乘以 K<sub>p</sub>、K<sub>I</sub>、K<sub>D</sub> 来调整每个通道的影响），然后相加形成最终的控制输出。</p>
<h3 id="Proportional（比例）"><a href="#Proportional（比例）" class="headerlink" title="Proportional（比例）"></a>Proportional（比例）</h3><p>基于当前误差的大小来做出调整。误差越大，控制器输出的调整越大。</p>
<h3 id="Integral（积分）"><a href="#Integral（积分）" class="headerlink" title="Integral（积分）"></a>Integral（积分）</h3><p>根据误差随时间的累积来做出调整。积分控制的作用是消除稳态误差（当比例控制无法完全消除误差时，积分控制会通过不断累积误差来进行调整）。</p>
<blockquote>
<p>理想状态下，通过 P 和 D 可以让小车停留在目标位置，但是实际情况是 P 在被 D 抵消的同时，重力、摩擦力等因素也会对小车产生影响，导致其永远达不到目标位置；</p>
</blockquote>
<p><strong>稳态误差</strong></p>
<p><strong>稳态误差</strong> 是控制系统在经过足够长的时间后，系统输出与目标值（期望值）之间的<strong>持续偏差</strong>。换句话说，当系统稳定后（即进入稳态时），如果输出值无法完全达到目标值，则这种残留的误差被称为稳态误差。</p>
<h3 id="Derivative（微分）"><a href="#Derivative（微分）" class="headerlink" title="Derivative（微分）"></a>Derivative（微分）</h3><p>据误差变化的速率来做出调整。它主要用于预测误差的变化趋势，并对系统的动态响应进行调整，抵消由 P 产生的震荡。  </p>
<p><strong>比例</strong>控制处理“当前误差”；</p>
<p><strong>积分</strong>控制处理“过去误差”；</p>
<p><strong>微分</strong>控制处理“误差变化趋势”。</p>
<blockquote>
<p>简单来说，就是将误差进行比例放大，微分阻尼，积分误差补偿</p>
</blockquote>
<h2 id="PID分别是如何实现的？"><a href="#PID分别是如何实现的？" class="headerlink" title="PID分别是如何实现的？"></a>PID分别是如何实现的？</h2><p><strong>比例控制（P）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算出目标位置与当前位置的误差</span></span><br><span class="line"><span class="type">double</span> error = setpoint - measured_value;</span><br><span class="line"><span class="comment">// 比例 = 误差 * Kp，Kp 是我们指定的比例系数</span></span><br><span class="line"><span class="type">double</span> Proportional = error * Kp;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>比例控制的特点：它的优点是简单、快速，并且容易理解，但存在以下问题：<ol>
<li><strong>稳态误差</strong>：比例控制可能导致<strong>稳态误差</strong>（即即使控制系统在工作时，输出值也可能永远无法完全达到目标值）。这主要是因为比例控制始终是根据当前的误差做出调整，在误差减小时，控制输出也会减小，导致误差不能完全消除。</li>
<li><strong>响应过快导致的震荡</strong>：比例控制可能会对某些系统造成过冲或震荡，尤其是在比例增益较大的情况下，系统过度调整，导致目标值的超调和再修正。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>积分控制（I）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 积分 i = i += 误差 * dt，</span></span><br><span class="line"><span class="comment">// dt 表示误差的采样间隔（采样时长）</span></span><br><span class="line"><span class="type">double</span> integral += error * dt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果系统长时间存在误差（即系统偏离目标值），积分项会不断累积这些误差，并逐渐加大控制输出，直到误差完全消除，从而让系统达到目标值。</p>
</blockquote>
<p><strong>微分控制（D）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微分 </span></span><br><span class="line"><span class="type">double</span> previous_error = <span class="number">0.0</span>; <span class="comment">// 上一次的误差</span></span><br><span class="line"><span class="comment">// D 可以理解为速度 = 距离 / 时长</span></span><br><span class="line"><span class="type">double</span> derivative = (error - previous_error) / dt;</span><br><span class="line"><span class="comment">// 更新上一次的误差</span></span><br><span class="line">previous_error = error;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>D 可以理解为速度，当速度过快时（error - previous_error &lt; 0），D 算法就会抵消一部分 P 算法计算出来的的动力，从而减缓系统的震荡；</p>
</blockquote>
<p><strong>求和</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> output = Proportional + Ki * integral + Kd * derivative;</span><br></pre></td></tr></table></figure>

<p><strong>实现如下</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 PID 参数</span></span><br><span class="line"><span class="comment">// 这三个系数要通过调试来确定</span></span><br><span class="line"><span class="type">double</span> Kp = <span class="number">1.0</span>;  <span class="comment">// 比例系数</span></span><br><span class="line"><span class="type">double</span> Ki = <span class="number">0.1</span>;  <span class="comment">// 积分系数</span></span><br><span class="line"><span class="type">double</span> Kd = <span class="number">0.01</span>; <span class="comment">// 微分系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 PID 控制器变量</span></span><br><span class="line"><span class="type">double</span> previous_error = <span class="number">0.0</span>; <span class="comment">// 上一次的误差</span></span><br><span class="line"><span class="type">double</span> integral = <span class="number">0.0</span>;       <span class="comment">// 积分累积</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PID 控制函数</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pid_control</span><span class="params">(<span class="type">double</span> setpoint, <span class="type">double</span> measured_value, <span class="type">double</span> dt)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算误差</span></span><br><span class="line">    <span class="type">double</span> error = setpoint - measured_value;</span><br><span class="line">    <span class="comment">// 计算积分部分</span></span><br><span class="line">    integral += error * dt;</span><br><span class="line">    <span class="comment">// 计算微分部分</span></span><br><span class="line">    <span class="type">double</span> derivative = (error - previous_error) / dt;</span><br><span class="line">    <span class="comment">// 计算控制输出</span></span><br><span class="line">    <span class="type">double</span> output = Kp * error + Ki * integral + Kd * derivative;</span><br><span class="line">    <span class="comment">// 更新上一次的误差</span></span><br><span class="line">    previous_error = error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> setpoint = <span class="number">10.0</span>;  <span class="comment">// 目标值</span></span><br><span class="line">    <span class="type">double</span> measured_value = <span class="number">0.0</span>; <span class="comment">// 初始测量值</span></span><br><span class="line">    <span class="type">double</span> dt = <span class="number">0.1</span>;        <span class="comment">// 时间步长（秒）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// 模拟 100 次迭代</span></span><br><span class="line">        <span class="type">double</span> output = pid_control(setpoint, measured_value, dt);</span><br><span class="line">        measured_value += output * dt; <span class="comment">// 模拟系统响应</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Iteration %d: Output = %f, Measured Value = %f\n&quot;</span>, i + <span class="number">1</span>, output, measured_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位置式PID-和-增量式PID"><a href="#位置式PID-和-增量式PID" class="headerlink" title="位置式PID 和 增量式PID"></a>位置式PID 和 增量式PID</h2><h3 id="位置式PID"><a href="#位置式PID" class="headerlink" title="位置式PID"></a>位置式PID</h3><p>位置式 PID 计算的是控制量的绝对值，即每个时刻控制输出是基于<strong>当前的误差值、误差的积分和微分来直接计算的</strong>，控制输出是绝对的目标位置。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDweizhigongshi.png" alt="F407PIDweizhigongshi"></p>
<h3 id="增量式PID"><a href="#增量式PID" class="headerlink" title="增量式PID"></a>增量式PID</h3><p>增量式 PID 计算的是控制量的增量，即当前时刻的控制输出是与前一个时刻控制输出的变化量（增量）相关，而不是直接计算出控制输出的绝对值。增量式 PID 关注的是如何调整控制量（而不是绝对的目标值），因此每一时刻的输出量是基于上一时刻的输出和当前误差来调整的。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PIDzengliangshi.png" alt="F407PIDzengliangshi"></p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>位置式 PID</th>
<th>增量式 PID</th>
</tr>
</thead>
<tbody><tr>
<td><strong>输出形式</strong></td>
<td>直接计算控制量的绝对值 u(t)u(t)u(t)</td>
<td>计算控制量的增量 Δu(t)\Delta u(t)Δu(t)</td>
</tr>
<tr>
<td><strong>计算方式</strong></td>
<td>当前位置的控制输出由误差、积分和微分直接计算</td>
<td>当前的控制输出由上一时刻的控制输出和误差的变化量计算</td>
</tr>
<tr>
<td><strong>使用目的</strong></td>
<td>适用于需要计算绝对控制输出的系统</td>
<td>适用于需要计算控制增量，控制量依赖于之前的输出的系统</td>
</tr>
<tr>
<td><strong>控制量变化</strong></td>
<td>控制量的变化直接由误差决定</td>
<td>控制量的变化由误差的增量和历史误差决定</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>简单直观，适合许多标准控制应用，输出计算清晰</td>
<td>控制器对系统响应的调节较为平稳，尤其是对于一些已知参考模型的系统</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>容易受到数值积累的影响，可能导致积分饱和等问题</td>
<td>对于初始误差较大的系统，可能需要更多的调整和调试</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Cortex-M4</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>PWM</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/PWM/</url>
    <content><![CDATA[<p>PWM（Pulse Width Modulation，脉冲宽度调制）是一种调制技术，通过改变脉冲信号的<strong>占空比</strong>来控制平均输出电压或功率。</p>
<h2 id="PWM-的相关参数"><a href="#PWM-的相关参数" class="headerlink" title="PWM 的相关参数"></a>PWM 的相关参数</h2><p>PWM主要有三个参数：频率、占空比、分辨率</p>
<p><strong>频率</strong>：</p>
<ul>
<li><strong>定义</strong>：PWM 信号的频率指的是单位时间内一个完整周期（高电平和低电平持续时间总和）的重复次数，通常以赫兹（Hz）为单位。</li>
<li><strong>例子</strong>：如果 PWM 信号的频率为 1 kHz，这意味着每秒钟会重复 1000 次完整的高低电平循环。</li>
</ul>
<p><strong>占空比</strong>：</p>
<ul>
<li><strong>定义</strong>：占空比是高电平持续时间与整个周期时间的比例，通常以百分比表示。它决定了平均输出功率。</li>
<li><strong>例子</strong>：如果一个 PWM 信号的周期为 10ms，其中高电平持续 6ms，低电平持续 4ms，则占空比为 60%（6 ms &#x2F; 10 ms × 100%）。在 LED 调光中，60% 的占空比会使 LED 发出比 30%占 空比更亮的光。</li>
</ul>
<p><strong>分辨率</strong>：</p>
<ul>
<li>就是占空比<strong>变化的快慢</strong>，<strong>占空比变化的细腻程度</strong>。占空比跳的快如按照 1% 跳变与按照 0.1% 跳变，那么 0.1% 的跳变就越细腻，越柔和。</li>
</ul>
<h2 id="PWM-工作原理"><a href="#PWM-工作原理" class="headerlink" title="PWM 工作原理"></a>PWM 工作原理</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PWMjibenjiegou.png" alt="F407PWMjibenjiegou"></p>
<p>图片 PWM 的工作过程为：定时器模块中的计数器（CNT）从 0 开始递增，当达到自动重装寄存器（ARR）设置的最大值时，计数器会自动清零并重新开始。捕获&#x2F;比较寄存器（CCR）存储一个比较值，当计数器的值小于CCR时，输出信号保持高电平；当计数器的值大于等于CCR时，输出信号变为低电平，从而生成占空比可调的 PWM 信号。通过<strong>调整 ARR 可以控制 PWM 的频率</strong>，而通过<strong>改变 CCR 的值可以调整 PWM 信号的占空比</strong>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>功能：通过 PWM 实现一个灯的闪烁</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分频值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRESCALER (168 - 1) <span class="comment">// </span></span></span><br><span class="line"><span class="comment">// 1ms 的周期 168000000 / 168 = 1000000 / 1000 = 1000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIOD (((SystemCoreClock / (PRESCALER + 1)) / 1000) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LED1 GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_LED_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// LED 总开关</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_mode_set(GPIOC, GPIO_MODE_OUTPUT, GPIO_PUPD_PULLUP, GPIO_PIN_6);</span><br><span class="line">	gpio_output_options_set(GPIOC, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_6);</span><br><span class="line">	<span class="comment">// LED1</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOD);</span><br><span class="line">	gpio_mode_set(GPIOD, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_15);</span><br><span class="line">	gpio_af_set(GPIOD, GPIO_AF_2, GPIO_PIN_15);</span><br><span class="line">	gpio_output_options_set(GPIOD, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_15);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 总开关常开</span></span><br><span class="line">	gpio_bit_reset(GPIOC, GPIO_PIN_6);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LED1 TImer Config</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TImer_LED_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_TIMER3);</span><br><span class="line">	</span><br><span class="line">	timer_deinit(TIMER3);</span><br><span class="line">	<span class="comment">// 先倍频到 168MHz</span></span><br><span class="line">	rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL4);</span><br><span class="line">	</span><br><span class="line">	timer_parameter_struct initpara;</span><br><span class="line">		</span><br><span class="line">	timer_struct_para_init(&amp;initpara);</span><br><span class="line">    <span class="comment">// 预分频倍数</span></span><br><span class="line">	initpara.prescaler         = PRESCALER;</span><br><span class="line">    <span class="comment">// 对齐方式</span></span><br><span class="line"><span class="comment">//  initpara.alignedmode       = TIMER_COUNTER_EDGE;</span></span><br><span class="line">    <span class="comment">// 计数方向</span></span><br><span class="line"><span class="comment">//  initpara.counterdirection  = TIMER_COUNTER_UP;</span></span><br><span class="line">    <span class="comment">// 周期</span></span><br><span class="line">    initpara.period            = PERIOD; <span class="comment">// 1ms</span></span><br><span class="line">		</span><br><span class="line">	timer_init(TIMER3, &amp;initpara);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定时器通道配置</span></span><br><span class="line">	timer_oc_parameter_struct ocpara;	</span><br><span class="line">	timer_channel_output_struct_para_init(&amp;ocpara);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	带N的为反向，带P的为正向。赋值的结果常量也是需要注意是否带N。</span></span><br><span class="line"><span class="comment">	// 通道使能，开启通道</span></span><br><span class="line"><span class="comment">	ocpara-&gt;outputstate  = (uint16_t)TIMER_CCX_DISABLE;</span></span><br><span class="line"><span class="comment">    ocpara-&gt;outputnstate = TIMER_CCXN_DISABLE;</span></span><br><span class="line"><span class="comment">	// 设置通道极性为高电平</span></span><br><span class="line"><span class="comment">	// 所谓的极性就是指：</span></span><br><span class="line"><span class="comment">	// 1.通道的有效电平</span></span><br><span class="line"><span class="comment">	// 2.当定时器触发时，通道的电平状态</span></span><br><span class="line"><span class="comment">    ocpara-&gt;ocpolarity   = TIMER_OC_POLARITY_HIGH;</span></span><br><span class="line"><span class="comment">    ocpara-&gt;ocnpolarity  = TIMER_OCN_POLARITY_HIGH;</span></span><br><span class="line"><span class="comment">	// 设置输出比较通道在空闲状态时的电平为低电平。</span></span><br><span class="line"><span class="comment">    ocpara-&gt;ocidlestate  = TIMER_OC_IDLE_STATE_LOW;</span></span><br><span class="line"><span class="comment">    ocpara-&gt;ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	ocpara.outputstate = TIMER_CCX_ENABLE;	</span><br><span class="line">	<span class="comment">// 第一个参数是我们使用的是哪一个定时器</span></span><br><span class="line">	<span class="comment">// 第二个参数是我们使用的哪一个通道，也是就在服用编号表中看到的编号 TIMER3_CH3</span></span><br><span class="line">	timer_channel_output_config(TIMER3, TIMER_CH_3, &amp;ocpara);</span><br><span class="line">	<span class="comment">// 输出模式配置</span></span><br><span class="line">	<span class="comment">// 模式0：在向上计数时，一旦计数器值小于 TIMERx_CH0CV 时，O0CPRE 为有效电平，否则为无效电平。</span></span><br><span class="line">	<span class="comment">// 在向下计数时，一旦计数器的值大于 TIMERx_CH0CV 时 O0CPRE 为无效电平，否则为有效电平。</span></span><br><span class="line">	<span class="comment">// 在 TIMERx_CH0CV 下面就是高电平</span></span><br><span class="line">	timer_channel_output_mode_config(TIMER3, TIMER_CH_3, TIMER_OC_MODE_PWM0);</span><br><span class="line">	<span class="comment">// 配置占空比</span></span><br><span class="line">	<span class="comment">// 为了达到流水灯的效果，我们要让他一开始是 熄灭的，然后逐渐亮灭</span></span><br><span class="line">	<span class="comment">// 周期和分频会自动 + 1 ，占空比不会所以需要加回来</span></span><br><span class="line">	timer_channel_output_pulse_value_config(TIMER3, TIMER_CH_3, (PERIOD + <span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	timer_enable(TIMER3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0~100，100~0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_duty</span><span class="params">(<span class="type">float</span> duty)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> pulse = (<span class="type">uint32_t</span>)((duty / <span class="number">100</span>) * PERIOD);</span><br><span class="line">	timer_channel_output_pulse_value_config(TIMER3, TIMER_CH_3, pulse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">	GPIO_LED_Config();</span><br><span class="line">	TImer_LED_Config();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">// 100 20*19</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			update_duty(i * <span class="number">5</span>);</span><br><span class="line">			delay_1ms(<span class="number">50</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">			update_duty(i * <span class="number">5</span>);</span><br><span class="line">			delay_1ms(<span class="number">50</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>prescaler：计数器时钟等于 TIMER_CK 时钟除以(PSC+1)，每次当更新事件产生时，PSC 的值被装入到对应的影子寄存器。</p>
</blockquote>
<p><strong>根据引脚所复用的定时器去选择通道</strong></p>
<p><strong>如果想要让多个 LED 灯实现流水效果我们可以使用同一个 PWM 的不同通道，将 GPIO 复用为某个具体的通道，然后配置通道即可</strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>通道极性和 PWM0，PWM1 的区别</strong></p>
<p>通道的极性代表的就是通道的<strong>有效电平</strong>和事件产生时通道的输出电平是高还是低；</p>
<p>PWM 模式 0。在向上计数时，一旦计数器值小于 TIMERx_CH0CV 时，O0CPRE 为有效电平，否则为无效电平。在向下计数时，一旦计数器的值大于 TIMERx_CH0CV 时，O0CPRE 为无效电平，否则为有效电平。</p>
<p>PWM 模式 1。在向上计数时，一旦计数器值小于 TIMERx_CH0CV 时，O0CPRE 为无效电平，否则为有效电平。在向下计数时，一旦计数器的值大于 TIMERx_CH0CV 时， O0CPRE 为有效电平，否则为无效电平。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/RTC/</url>
    <content><![CDATA[<p>在 STM32 微控制器中，<strong>RTC（实时时钟）</strong> 是一个片上外设，用于提供精确的时间跟踪功能。它可以记录日期和时间，并支持定时任务和闹钟功能。RTC 还具备低功耗特性，即使系统掉电或进入待机模式时，RTC 仍然能够继续运行，保持时间（外部电池）。</p>
<p><strong>RTC 本质上就是一个 1 秒计数器,通过秒来换算出时间。因此需要我们提供一个 1HZ 频率的时钟。</strong></p>
<h2 id="结构框图"><a href="#结构框图" class="headerlink" title="结构框图"></a>结构框图</h2><p>结构框图展示了其各个子模块和数据流之间的关系。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ATCjgkt.png" alt="F407ATCjgkt"></p>
<p>组件和功能的简要说明：</p>
<ol>
<li><strong>时钟源</strong>：<ul>
<li>支持多个低速时钟源，包括内部的 <strong>IRC32K</strong>、外部晶振 <strong>LXTAL</strong>（32.768kHz）和其他可选择的时钟源。</li>
<li>这些时钟源通过不同的分频器生成合适的时钟信号供 RTC 使用。</li>
</ul>
</li>
<li><strong>分频器</strong>：<ul>
<li>包含多个分频器，进行预分频和相位校准，用于生成 RTC 所需的 1Hz 信号。</li>
<li>分频器包括 7 位异步分频器（默认分频值为 128）和 15 位同步分频器（默认分频值为 256）。</li>
</ul>
</li>
<li><strong>日历模块</strong>：<ul>
<li>核心功能模块之一，用于管理日期和时间（年、月、日、时、分、秒）并保持同步。</li>
<li>支持自动增量，确保时间连续更新。</li>
</ul>
</li>
<li><strong>闹钟模块</strong>：<ul>
<li>支持两个闹钟（Alarm-0 和 Alarm-1），用于定时唤醒或中断功能。</li>
<li>通过设置不同的时间参数，可以实现多种闹钟触发。</li>
</ul>
</li>
<li><strong>输出控制</strong>：<ul>
<li>提供多个 RTC 事件的输出，控制不同的中断和标志输出，如 <strong>RTC_OUT</strong> 和 <strong>RTC_ALARM</strong> 输出。</li>
<li>具有中断标志（Alarm Flag）和输出控制，以支持闹钟事件和报警信号输出。</li>
</ul>
</li>
<li><strong>备份寄存器</strong>：<ul>
<li>提供备用数据存储，允许在主系统掉电时保存重要数据。</li>
</ul>
</li>
<li><strong>时间戳和唤醒定时器</strong>：<ul>
<li>RTC 支持时间戳功能（RTC_TS），记录某些事件发生的时间。</li>
<li>支持低功耗模式下的自动唤醒，具备唤醒定时器（RTC_WTRV），可以在特定时间间隔触发唤醒。</li>
</ul>
</li>
<li><strong>控制信号</strong>：<ul>
<li>包括多个控制信号，用于配置和管理 RTC 的工作模式和中断响应。</li>
</ul>
</li>
</ol>
<p>这张图总体上展示了 STM32 中 RTC 模块的结构，主要功能模块包括时钟源管理、分频和校准、日历功能、闹钟功能、时间戳和备份寄存器等，用于提供稳定的时间跟踪和唤醒功能。</p>
<h2 id="电源管理单元（PMU）"><a href="#电源管理单元（PMU）" class="headerlink" title="电源管理单元（PMU）"></a>电源管理单元（PMU）</h2><p><strong>电源管理单元（Power Management Unit, PMU）</strong> 是一个负责管理芯片的电源状态和功耗的模块；而<strong>RTC 位于备用域，因此它的电源和一些关键配置确实是由 PMU 管理的</strong>。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407MPUdygldy.png" alt="F407MPUdygldy"></p>
<p>组件和功能的简要说明：</p>
<p><strong>电源输入</strong></p>
<ul>
<li><strong>V_BAT</strong>：电池电压输入，一般用于供电给备份域（Backup Domain）。</li>
<li><strong>V_DD</strong>：主电源输入，提供3.3V，主要用于V_DD域供电。</li>
<li><strong>V_DDA</strong>：模拟电源输入，提供3.3V，专门供给模拟模块（如ADC和DAC）。</li>
</ul>
<p><strong>电源开关</strong></p>
<p>图中间有一个<strong>Power Switch</strong>（电源开关），用于切换电源来源，在不同电源域中提供电源管理功能。当主电源（V_DD）丢失时，它可以自动切换到V_BAT电池电源，保证备份域继续工作。</p>
<p><strong>各个电源域</strong></p>
<ul>
<li><strong>V_DD Domain</strong>（V_DD域）：提供数字模块的电源，工作电压为3.3V。<ul>
<li><strong>FWDGT</strong>：独立看门狗定时器，用于监测系统是否正常运行。</li>
<li><strong>HXTAL</strong>：高速晶振电路，用于提供高频时钟信号。</li>
<li><strong>POR&#x2F;PDR</strong>：上电复位（POR）和掉电复位（PDR）电路，用于监测电源电压的变化，在电源上电或电压跌落时复位系统。</li>
<li><strong>LDO</strong>：低压差稳压器（Low Dropout Regulator），用于提供稳定的电压给内部电路。</li>
</ul>
</li>
<li><strong>V_DDA Domain</strong>（V_DDA域）：提供模拟模块的电源，电压为3.3V。<ul>
<li><strong>IRC16M&#x2F;IRC32K</strong>：内部RC振荡器，分别提供16MHz和32KHz的内部时钟源。</li>
<li><strong>ADC</strong>：模数转换器，用于将模拟信号转换为数字信号。</li>
<li><strong>DAC</strong>：数模转换器，用于将数字信号转换为模拟信号。</li>
<li><strong>LVD</strong>：低压检测器，用于检测电压是否低于设定值。</li>
<li><strong>PLLs</strong>：锁相环，用于生成高频时钟信号。</li>
</ul>
</li>
<li><strong>Backup Domain</strong>（备份域）：主要用于低功耗备份模块，工作电压为1.2V。<ul>
<li><strong>LXTAL</strong>：低速晶振电路，用于提供低频时钟源。</li>
<li><strong>BPOR</strong>：备份域复位电路。</li>
<li><strong>RTC</strong>：实时时钟模块，用于提供时间管理功能。</li>
<li><strong>BLDO</strong>：备份低压差稳压器，用于将电压稳定在1.2V，为备份域提供稳定电源。</li>
</ul>
</li>
<li><strong>1.2V Domain</strong>（1.2V域）：核心电压域，为处理器和高速外设提供1.2V电源。<ul>
<li><strong>BSRAM</strong>：备份SRAM，支持低功耗模式下的数据保存。</li>
<li><strong>Cortex-M4</strong>：ARM Cortex-M4处理器核心。</li>
<li><strong>AHB&#x2F;IPs 和 APB&#x2F;IPs</strong>：高级高性能总线（AHB）和高级外设总线（APB），用于连接片上外设。</li>
</ul>
</li>
</ul>
<p><strong>电源管理</strong></p>
<ul>
<li><strong>PMU CTL</strong>：电源管理控制器，负责管理不同电源域的电源状态，包括低功耗模式的切换（如SLEEPING、SLEEPDEEP模式）。</li>
<li><strong>WKUP</strong>：唤醒信号，用于在低功耗模式下唤醒系统。</li>
<li><strong>WKUPR</strong>：备份域唤醒复位信号，用于在备份域中唤醒微控制器，通常用于系统的复位或重新启动。</li>
</ul>
<blockquote>
<p>RTC 的时钟源可以是低速内部 RC 振荡器（IRC32K）或低速外部晶体振荡器（LXTAL），或高速 外部晶体振荡器（HXTAL）时钟2~31 分频。当 VDD 被关闭时，RTC 只能选择 LXTAL 作为时钟源。</p>
</blockquote>
<h2 id="影子寄存器"><a href="#影子寄存器" class="headerlink" title="影子寄存器"></a>影子寄存器</h2><p>在 STM32 和 GD32 微控制器中，<strong>影子寄存器（Shadow Register）</strong> 是一种特殊的寄存器机制，用于缓冲和同步外设寄存器的内容。</p>
<p>有影子寄存器存在的寄存器实际上他是两个寄存器，一个为预装载寄存器，一个为执行寄存器（影子寄存器）；我们正常都是先更新（写入）到预装载寄存器中，然后再将预装载寄存器的内容写入到影子寄存器中去，在使用的时候通常都是使用的影子寄存器；</p>
<h2 id="BCD-码"><a href="#BCD-码" class="headerlink" title="BCD 码"></a>BCD 码</h2><p>BCD（Binary-Coded Decimal，二进制编码的十进制）是一种将十进制数编码为二进制数的表示方法。BCD 码将每个十进制数的位（0–9）单独编码成四位二进制格式。例如：</p>
<ul>
<li>十进制数 <code>5</code> 在 BCD 中表示为 <code>0101</code></li>
<li>十进制数 <code>23</code> 在 BCD 中表示为 <code>0010 0011</code></li>
</ul>
<p>BCD 编码的主要特点是 <strong>每一个十进制位（0-9）都用 4 位二进制来表示</strong>。这样可以让数字更直观地表示出来，而且在某些需要和显示设备、时间处理等操作打交道的应用中更方便。</p>
<h2 id="备份寄存器"><a href="#备份寄存器" class="headerlink" title="备份寄存器"></a>备份寄存器</h2><p>RTC 时钟内部集成 20 个 32 位（共80字节）通用备份寄存器，能够在省电模式下保存数据。当有外部事件侵入 时，备份寄存器将会复位；</p>
<p>备份寄存器的内容在系统断电、复位或主电源掉电的情况下不会丢失，只要有备用电源（如电池或超级电容）供电。备份寄存器和 RTC 的核心电路一样，可以由备用电源提供电力支持。</p>
<p>可以在用户手册 RTC 寄存器章节中中找对应的寄存器名，然后到 .h 头文件中查找使用，默认初始值为 0</p>
<h2 id="报警（闹钟）"><a href="#报警（闹钟）" class="headerlink" title="报警（闹钟）"></a>报警（闹钟）</h2><p>RTC 的闹钟功能用于在预设的时间生成一个事件或中断，提醒系统执行特定的任务。</p>
<p>RTC 闹钟的中断一般属于外部中断，因为 RTC 模块与其他外设模块（如 UART、I2C 等）一样， 属于片上的外设模块，产生的中断信号来自核心之外，因此被称为外部中断。所以要设置闹钟的中断需要开启 NIVC 和 EXTI；</p>
<p>在使用时根据用户手册中说明的进行配置即可；</p>
<blockquote>
<p>闹钟是上升沿触发，用户手册中有说明；</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>功能：串口每隔一秒打印时间</p>
<h3 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BCD2NUM(DCB) ((DCB &gt;&gt; 4)*10 + (DCB &amp; 0x0F))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 年月日，时分秒</span></span><br><span class="line"><span class="type">int</span> data_time[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTC 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 使能PMU外部时钟 PMU 是电源管理模块</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_PMU);</span><br><span class="line">	<span class="comment">// 使能备份域写保护</span></span><br><span class="line">	pmu_backup_write_enable();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 复位备份域</span></span><br><span class="line">    <span class="comment">// 当我们需要重启还继续原来的时间时，该语句需要通过 if 控制只执行一次</span></span><br><span class="line">	<span class="comment">// RCU（复位与控制单元）</span></span><br><span class="line">	rcu_bkp_reset_enable();</span><br><span class="line">	<span class="comment">// 复位备份域，只是将置位复为标志</span></span><br><span class="line">	<span class="comment">// 在置位期间他会一直复位，所以我们还需要关闭复位</span></span><br><span class="line">	rcu_bkp_reset_disable();</span><br><span class="line"><span class="comment">/***************************************/</span>    </span><br><span class="line">	<span class="comment">// 打开芯片内部 32KHz 的晶振</span></span><br><span class="line">    <span class="comment">// 如果使用外部高速晶振则不需要打开，因为我们上电时默认打开了</span></span><br><span class="line">	rcu_osci_on(RCU_IRC32K);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 等待晶振震荡稳定后才可进行使用</span></span><br><span class="line">	<span class="comment">// 晶振稳定后他返回1，如果是错误或者超时则返回 0</span></span><br><span class="line">	ErrStatus status = rcu_osci_stab_wait(RCU_IRC32K);</span><br><span class="line">	<span class="keyword">if</span>(status == ERROR) &#123; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RTC OSCI WAIT ERROR...&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> ;	</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/***************************************/</span>    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果使用的是高速晶振也就是与我们时钟主频共用一个就不需要开启晶振</span></span><br><span class="line"><span class="comment">    我们只需要指定其为时钟源即可</span></span><br><span class="line"><span class="comment">    // 选择 RTC 计数时钟</span></span><br><span class="line"><span class="comment">	rcu_rtc_clock_config(RCU_RTCSRC_IRC32K);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 选择 RTC 计数时钟</span></span><br><span class="line">	rcu_rtc_clock_config(RCU_RTCSRC_HXTAL_DIV_RTCDIV);</span><br><span class="line">	<span class="comment">// 使能外部RTC时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_RTC);</span><br><span class="line">	<span class="comment">// 等待 RTC 寄存器与 RTC 的 APB 时钟同步并且影子寄存器更新；</span></span><br><span class="line">	status = rtc_register_sync_wait();</span><br><span class="line">	<span class="keyword">if</span>(status == ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RTC CLOK sync ERROR...&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_Init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 按照用户手册中的 RTC 初始化和配置说明进行操作：</span></span><br><span class="line">	<span class="comment">// 设置 INITM 位为 1 进入初始化模式。等待 INITF 位被置 1。</span></span><br><span class="line">	<span class="comment">// 这一步在 被包含在了 rtc_init 函数中</span></span><br><span class="line">	rtc_parameter_struct rtc_initpara_struct;</span><br><span class="line">	</span><br><span class="line">	rtc_initpara_struct.year = <span class="number">0x24</span>; <span class="comment">/*!&lt; RTC year value: 0x0 - 0x99(BCD format) */</span></span><br><span class="line">    rtc_initpara_struct.month = <span class="number">0x11</span>; <span class="comment">/*!&lt; RTC month value */</span></span><br><span class="line">    rtc_initpara_struct.date = <span class="number">0x07</span>;   <span class="comment">/*!&lt; RTC date value: 0x1 - 0x31(BCD format) */</span></span><br><span class="line">    rtc_initpara_struct.day_of_week = <span class="number">0x04</span>; <span class="comment">/*!&lt; RTC weekday value */</span></span><br><span class="line">    rtc_initpara_struct.hour = <span class="number">0x20</span>;        <span class="comment">/*!&lt; RTC hour value */</span></span><br><span class="line">    rtc_initpara_struct.minute = <span class="number">0x57</span>;      <span class="comment">/*!&lt; RTC minute value: 0x0 - 0x59(BCD format) */</span></span><br><span class="line">    rtc_initpara_struct.second = <span class="number">0x32</span>;      <span class="comment">/*!&lt; RTC second value: 0x0 - 0x59(BCD format) */</span></span><br><span class="line">    rtc_initpara_struct.am_pm = RTC_PM;     <span class="comment">/*!&lt; RTC AM/PM value */</span></span><br><span class="line">    rtc_initpara_struct.display_format = RTC_24HOUR; <span class="comment">/*!&lt; RTC time notation */</span>				</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 始终源经过这两次分屏要化为 1Hz</span></span><br><span class="line">	<span class="comment">// 我们使用的晶振为 32KHz = 32000Hz / (127 + 1) = 250 / （259+1） = 1 </span></span><br><span class="line">	rtc_initpara_struct.factor_asyn = <span class="number">0x7F</span>;     <span class="comment">/*!&lt; RTC asynchronous prescaler value: 0x0 - 0x7F */</span></span><br><span class="line">    rtc_initpara_struct.factor_syn = <span class="number">0xF9</span>;         <span class="comment">/*!&lt; RTC synchronous prescaler value: 0x0 - 0x7FFF */</span></span><br><span class="line">	<span class="comment">// 启用外部高速晶振时候要记得重新设置</span></span><br><span class="line">    <span class="comment">// rtc_initpara_struct.factor_syn  = 0xF9;</span></span><br><span class="line">    </span><br><span class="line">	rtc_init(&amp;rtc_initpara_struct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清除 INITM 位退出初始化模式。</span></span><br><span class="line">	rtc_init_mode_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bsp_rtc_readDate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	rtc_parameter_struct rtc_initpara_struct;</span><br><span class="line">		</span><br><span class="line">	rtc_current_time_get(&amp;rtc_initpara_struct);</span><br><span class="line">	</span><br><span class="line">	data_time[<span class="number">0</span>] = BCD2NUM(rtc_initpara_struct.year) + <span class="number">2000</span>;</span><br><span class="line">	data_time[<span class="number">1</span>] = BCD2NUM(rtc_initpara_struct.month);</span><br><span class="line">	data_time[<span class="number">2</span>] = BCD2NUM(rtc_initpara_struct.date);</span><br><span class="line">	data_time[<span class="number">3</span>] = BCD2NUM(rtc_initpara_struct.hour);</span><br><span class="line">	data_time[<span class="number">4</span>] = BCD2NUM(rtc_initpara_struct.minute);</span><br><span class="line">	data_time[<span class="number">5</span>] = BCD2NUM(rtc_initpara_struct.second);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d %d:%d:%d&quot;</span>,data_time[<span class="number">0</span>], data_time[<span class="number">1</span>], data_time[<span class="number">2</span>], data_time[<span class="number">3</span>] ,data_time[<span class="number">4</span>] ,data_time[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">	bsp_USART0_Init();</span><br><span class="line">	RTC_Config();</span><br><span class="line">	rtc_Init();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;App_start...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		bsp_rtc_readDate();</span><br><span class="line">		delay_1ms(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===================================================</span><br><span class="line"><span class="comment">// 使用备份寄存器实现只重置一次</span></span><br><span class="line"><span class="comment">// 使用备份寄存器时候，让第二次启动（不断电）不执行复位备份域的操作    </span></span><br><span class="line"><span class="keyword">if</span>(RTC_BKP0 != <span class="number">1</span>) &#123;</span><br><span class="line">    rcu_bkp_reset_enable();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RUn2...&quot;</span>);</span><br><span class="line">    rcu_bkp_reset_disable();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 备份域默认为 0</span></span><br><span class="line"><span class="comment">// 只在第一次上电后执行，其余重启都不执行初始化操作；</span></span><br><span class="line"><span class="keyword">if</span>(RTC_BKP0 != <span class="number">1</span>) &#123;</span><br><span class="line">    rtc_Init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Run...\n&quot;</span>);</span><br><span class="line">    RTC_BKP0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 PMU 中可以看到 RTC 是位于备份域中的，在默认情况下备份域是处于写保护的状态，所以要操作 RTC 我们先要关闭写保护，也就是说我们要先操作 PMU 模块；</p>
<p>如果遇到一些参数不知道怎么填的，可以去看下官方示例，然后去对于的 .h 文件中查找；</p>
<p>两个预分频器的组合选项太多了，可以看下用户手册我们按照用户手册中的进行配置；</p>
<p>在 RTC 中有两个预分频器用来实现日历功能和其他功能。一个分频器是 7 位异步预分频器， 另一个是 15 位同步预分频器。异步分频器主要用来降低功率消耗。如果两个分频器都被使用， 建议异步分频器的值尽可能大。</p>
<p>我们看 RTC 的结构框图可以发现，异步预分是 7 位的，所以我们设置的最大值为 7F；</p>
<p><strong>复位备份域</strong></p>
<p>备份域复位会影响备份域中的所有相关模块和寄存器，包括 <strong>RTC</strong> 配置、<strong>LXTAL</strong> 配置，以及任何备份寄存器中的数据。具体来说，备份域复位会将这些模块和寄存器恢复到它们的默认状态，相当于执行了一次硬件复位。</p>
<p><strong>使用外部高速晶振要记得降频，不然无法通过两个分配器降低为 1Hz</strong></p>
<p><strong>两个分配器计算公式</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ARTCfpqjsgs.png" alt="F407ARTCfpqjsgs"></p>
<h3 id="闹钟"><a href="#闹钟" class="headerlink" title="闹钟"></a>闹钟</h3><p>闹钟就是在日历的基础上配置了两个东西：</p>
<p>闹钟的初始化配置</p>
<p>闹钟的中断处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闹钟的初始化配置</span></span><br><span class="line"><span class="comment">// 闹钟的触发实现、NVIC、EXIT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bsp_rtc_alarm_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 清除寄存器 RTC_CTL 的 ALRMxEN（x=0，1）位，禁用闹钟</span></span><br><span class="line">	rtc_alarm_disable(RTC_ALARM0);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 设置 Alarm 寄存器（RTC_ALRMxTD / RTC_ALRMxSS）	</span></span><br><span class="line">	rtc_alarm_struct rtc_alarm_time;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// mask 面具、遮盖的意思</span></span><br><span class="line">	<span class="comment">// 设置忽略响的时间，比如如果不设置，他是四号、20小时、57分钟、45秒都会响动</span></span><br><span class="line">	<span class="comment">//我们需要设置的是四号的第20个小时的57分钟的45秒才响，所以需要忽略前面三个时间</span></span><br><span class="line">	<span class="comment">// 闹钟屏蔽字段选项</span></span><br><span class="line">	rtc_alarm_time.alarm_mask = (RTC_ALARM_DATE_MASK | RTC_ALARM_HOUR_MASK | RTC_ALARM_MINUTE_MASK);         </span><br><span class="line">	<span class="comment">// 制定工作在天还是星期</span></span><br><span class="line">    rtc_alarm_time.weekday_or_date = RTC_ALARM_WEEKDAY_SELECTED;</span><br><span class="line">    rtc_alarm_time.alarm_day = <span class="number">0x04</span>;</span><br><span class="line">    rtc_alarm_time.alarm_hour = <span class="number">0x20</span>;</span><br><span class="line">    rtc_alarm_time.alarm_minute = <span class="number">0x57</span>;</span><br><span class="line">    rtc_alarm_time.alarm_second = <span class="number">0x45</span>;</span><br><span class="line">    rtc_alarm_time.am_pm = RTC_PM;                 </span><br><span class="line">	</span><br><span class="line">	rtc_alarm_config(RTC_ALARM0, &amp;rtc_alarm_time);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 闹钟的中断配置</span></span><br><span class="line">	<span class="comment">// 因为闹钟的中断属于外部中断</span></span><br><span class="line">	<span class="comment">// 所以我们需要配置 NVIC 和 EXTI</span></span><br><span class="line">	nvic_irq_enable(RTC_Alarm_IRQn, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 启用 RTC 中断，指定中断源</span></span><br><span class="line">	rtc_interrupt_enable(RTC_INT_ALARM0);</span><br><span class="line">	<span class="comment">// 清除闹钟 0 的中断标志位，防止干扰</span></span><br><span class="line">	rtc_flag_clear(RTC_FLAG_ALRM0);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置寄存器 RTC_CTL 的 ALRMxEN 位，使能闹钟</span></span><br><span class="line">	rtc_alarm_enable(RTC_ALARM0);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// EXTI 配置</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_17);</span><br><span class="line">	exti_flag_clear(EXTI_17);</span><br><span class="line">	<span class="comment">// 初始化EXTI_17 （必须初始化）</span></span><br><span class="line">	exti_init(EXTI_17,EXTI_INTERRUPT,EXTI_TRIG_RISING);</span><br><span class="line">	exti_interrupt_enable(EXTI_17);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闹钟的中断处理函数</span></span><br><span class="line"><span class="comment">/*闹钟中断属于外部中断，所以可以同时通过闹钟和EXTI的标志位进行判断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Alarm_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 以下判断，二选其一即可  </span></span><br><span class="line">  <span class="keyword">if</span>(SET == rtc_flag_get(RTC_FLAG_ALRM0))&#123;</span><br><span class="line">    rtc_flag_clear(RTC_FLAG_ALRM0);</span><br><span class="line">    exti_flag_clear(EXTI_17);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alarm_1!\n&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//  if(SET == exti_interrupt_flag_get(RTC_EXTI_LINE))&#123;</span></span><br><span class="line"><span class="comment">//    exti_interrupt_flag_clear(RTC_EXTI_LINE);</span></span><br><span class="line"><span class="comment">//    exti_flag_clear(RTC_EXTI_LINE);</span></span><br><span class="line"><span class="comment">//    rtc_flag_clear(RTC_FLAG_ALRM0);</span></span><br><span class="line"><span class="comment">//    printf(&quot;Alarm_2!\n&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 中不要忘记调用闹钟的配置函数</span></span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>在以下情况下，备份域复位是必要的：</strong></p>
<ul>
<li><strong>RTC 重新配置</strong>：在初始化或重新配置 RTC 时，通常需要清除备份域以确保干净的状态。</li>
<li><strong>备份数据清除</strong>：当系统需要清除备份域中的数据（如备份寄存器中的参数）时，可以通过复位来达到目的。</li>
<li><strong>时钟源切换</strong>：在某些情况下，当 LXTAL 或其他时钟源出现问题或需要切换时，复位备份域可以确保时钟源的重新配置和可靠启动。</li>
</ul>
<p>二、<strong>为什么 RTC 不是先开启外部时钟</strong></p>
<p>在操作时候都是要先 rcu_periph_clock_enable(XXX); 开启，那么到 RTC 时候为什么就不需要 rcu_periph_clock_enable(RTC);了呢？</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407RTCsjly.png" alt="F407RTCsjly"></p>
<p>RTC（实时时钟）在 STM32 微控制器中的工作机制与系统时钟（如 SYSCLK、HSE、HSI 等）不同，它并不会默认启用系统时钟。RTC 的时钟源与主系统时钟（系统时钟树）是独立的，它通常依赖于专用的低速时钟源，如 <strong>外部低速晶振（LSE）</strong> 或 <strong>内部低速时钟（LSI）</strong>，而不是直接依赖于系统时钟。</p>
<p>所以我们需要先给 RTC 设置一个时钟后才需要启用；</p>
<p>三、<strong>rtc_register_sync_wait() 的作用是什么</strong></p>
<p>等待 RTC 寄存器与 RTC 的 APB 时钟同步并且影子寄存器更新；</p>
<p>（同步 RTC 寄存器和影子寄存器的内容）</p>
<p>四、<strong>为什么时钟频率不一样会导致读取到的数据不一致</strong></p>
<p>由于 RTC 时钟源频率较低，而 APB 时钟较高，当 APB 去读取 RTC 寄存器而没有等待同步，可能会读取到过时的数据，导致数据有误；或者当 RTC 正在更新的时候，APB 去读会导致读取到的数据与寄存器的值不一致；</p>
<p>五、<strong>如何保证数据一致性</strong></p>
<p>由于 RTC 时钟源频率较低，而 APB 时钟较高，系统需要确保在读取寄存器时，读取到的数据是准确和一致的。因此，在读取寄存器之前需要确保寄存器和时钟源同步。</p>
<p>为了解决这个问题，ARM32 使用了同步机制来确保<strong>读取的数据始终是最新的</strong>。这个同步过程由 <strong>影子寄存器（Shadow Register）</strong> 和 <strong>标志位（RTC_CS）</strong> 来管理。</p>
<p>也就是说我们在读取数据的时候实际访问的是影子寄存器；</p>
<p>每两个 RTC 时钟，影子日历寄存器值会更新为真实日历寄存器的值，与此同时 RSYNF 位也会再次置位。</p>
<p>（RSYNF 每2 个 RTC 时钟周期被置位一次。在这时，影子日历寄存器会更新为真实的日历时间和日期。）</p>
<blockquote>
<p>注意这个置位不仅仅是指 0 变成 1，还有可能是 1 变成 1</p>
<p>硬件不会主动将这个位置 0，除非我们手动清 0，否则他也不会默认清 0；</p>
</blockquote>
<p><strong>同步的过程</strong></p>
<ol>
<li><strong>RTC 寄存器更新</strong>：当 RTC 真实日历寄存器更新时，他要等两个时钟源的周期才会将真实日历寄存器的值复制到影子日历寄存器中，并将 RSYNF 置 1；</li>
<li><strong>标志位 RSYNF</strong>：当影子寄存器的更新完成后，系统需要通过 RSYNF 标志位来通知外设（APB），寄存器已经同步。<ul>
<li><strong>RSYNF &#x3D; 0</strong>：表示主寄存器（如 RTC_TIME 和 RTC_DATE）还未同步更新，外设（APB）不应读取数据。</li>
<li><strong>RSYNF &#x3D; 1</strong>：表示主寄存器与影像寄存器已经同步，数据是最新的，APB 可以安全地读取。</li>
</ul>
</li>
<li><strong>APB 读取数据</strong>：APB 通过读取 RTC_TIME 和 RTC_DATE 寄存器来获取最新的时间数据。如果此时 RTC_CRL_RSF 标志位为 1，表示同步已完成，APB 可以放心读取这些数据；如果 RSYNF 为 0，APB 需要等待同步完成，以避免读取到不一致的值；</li>
</ol>
<p>六、<strong>闹钟的忽略选项怎么理解</strong></p>
<p>在配置 RTC 闹钟时，alarm_mask 是一个用于<strong>屏蔽（忽略）某些时间字段</strong>的选项。当设置 <code>alarm_mask</code> 中的特定位时，RTC 闹钟在比较时会忽略该位对应的时间字段。</p>
<p>alarm_mask 通常包含以下几个掩码位：</p>
<ol>
<li><strong>秒（Seconds）掩码</strong>：忽略秒字段，允许闹钟每分钟触发一次。</li>
<li><strong>分钟（Minutes）掩码</strong>：忽略分钟字段，允许闹钟每小时触发一次。</li>
<li><strong>小时（Hours）掩码</strong>：忽略小时字段，允许闹钟每天的某一时刻触发一次。</li>
<li><strong>日期（Date）掩码</strong>：忽略日期字段，允许闹钟每月的某些时间触发。</li>
<li><strong>星期（Weekday）掩码</strong>：忽略星期字段，允许闹钟按指定的日期触发，而不是星期几。</li>
</ol>
<p>七、<strong>打印输出时候串口显示问题</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">16.839</span>]收←◆<span class="number">2024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">2</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">17.849</span>]收←◆<span class="number">62024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">27</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">18.849</span>]收←◆<span class="number">2024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">28</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">19.854</span>]收←◆<span class="number">2024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">29</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">20.849</span>]收←◆<span class="number">2024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">30</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">21.849</span>]收←◆<span class="number">2024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">3</span></span><br><span class="line">[<span class="number">17</span>:<span class="number">12</span>:<span class="number">22.853</span>]收←◆<span class="number">12024</span><span class="number">-11</span>- <span class="number">7</span> <span class="number">20</span>:<span class="number">58</span>:<span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>记得要再输出后加 \n 作为换行符，不然串口显示时，自己换行就会有问题；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>门电路</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/SPI/</url>
    <content><![CDATA[<p>门电路是基本的逻辑电路，用于实现逻辑运算。它们通常由晶体管、电阻和其他元件构成，用于控制电信号的流动。。</p>
<h2 id="门电路介绍"><a href="#门电路介绍" class="headerlink" title="门电路介绍"></a>门电路介绍</h2><p>门电路是数字电路的基本组成部分，而 GPIO 作为控制和输入输出的接口，常常<strong>依赖于门电路的逻辑来实现复杂的功能</strong>。因此，在学习 GPIO 时，先介绍门电路能够帮助我们理解其工作原理和应用场景。</p>
<p><strong>NOT 门电路</strong></p>
<p>NOT（非门）是数字逻辑电路中的一种基本逻辑门，也称为<strong>反相器</strong>。它执行的是逻辑非操作，即将输入信号取反。NOT门具有一个输入和一个输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407feimen.png" alt="F407feimen"></p>
<p>A输入，B输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>1</td>
</tr>
<tr>
<td align="center">1</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>AND 门电路</strong></p>
<p>AND（与门）是数字逻辑电路中的一种基本逻辑门，用于执行逻辑与操作。AND门具有多个输入和一个输出，它的输出信号取决于所有输入信号的状态。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yumen.png" alt="F407yumen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>OR 门电路</strong></p>
<p>OR（或门）是数字逻辑电路中的一种基本逻辑门，用于执行逻辑或操作。OR门具有多个输入和一个输出，它的输出信号取决于所有输入信号的状态。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407huomen.png" alt="F407huomen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>NAND 门电路</strong></p>
<p>NAND（NOT AND）门，<strong>与非门</strong>，是一种常见的逻辑门类型，它执行逻辑与（AND）操作的反操作，并具有特殊的性质，被广泛应用于电子和计算机领域。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yufeimen.png" alt="F407yufeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>NOR 门电路</strong></p>
<p>NOR（NOT OR）门，<strong>或非门</strong>，是数字电路中的另一种基本逻辑门，它执行逻辑或（OR）操作的反操作。NOR门也被广泛应用于电子和计算机领域，用于构建各种逻辑功能。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407huofeimen.png" alt="F407huofeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>XOR 门电路</strong></p>
<p>XOR（<strong>异或门</strong>）是数字逻辑电路中的一种基本逻辑门，用于执行逻辑异或操作。异或操作是指当输入的两个信号不相同时，输出为高电平（逻辑1）；当输入的两个信号相同时，输出为低电平（逻辑0）。XOR门具有两个输入和一个输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuomen.png" alt="F407yihuomen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>XNOR 门电路</strong></p>
<p>XNOR（<strong>异或非门</strong>）是数字逻辑电路中的一种基本逻辑门，是异或门（XOR门）的补充。XNOR门执行逻辑异或操作的反操作，也称为等价门。XNOR门具有两个输入和一个输出，用于比较两个输入信号是否相等。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI_Flash</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/SPI_Flash/</url>
    <content><![CDATA[<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuomen.png" alt="F407yihuomen"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>SysTick</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/SysTick/</url>
    <content><![CDATA[<p>SysTick 叫做系统滴答时钟、系统定时器，是系统内核中的一个片上外设被捆绑在 NVIC 中，用来产生 SYSTICK 异常 SysTick_Handler（异常号:15）。<br><strong>SysTick 是一个 24bit 向下递减的计数器</strong>，当计到 0 时，从 RELOAD 寄存器中自动装载定时初值，并触发中断，进行周期性任务。</p>
<h2 id="系统定时器的用途"><a href="#系统定时器的用途" class="headerlink" title="系统定时器的用途"></a>系统定时器的用途</h2><ul>
<li><strong>没有操作系统：</strong>只用于延时（使用内核的SysTick定时器来实现延时，可以不占用系统定时器，节约资源）</li>
<li><strong>有操作系统：</strong>（ucos2、ucos3、freertos为操作系统提供精准的系统时基(1ms~50ms）</li>
</ul>
<h2 id="SysTick-时钟来源"><a href="#SysTick-时钟来源" class="headerlink" title="SysTick 时钟来源"></a>SysTick 时钟来源</h2><p>可以来自两个地方：</p>
<ul>
<li><strong>内核时钟：</strong>AHB 时钟 8 分频</li>
<li><strong>内核时钟的 1&#x2F;8：</strong>HCLK 时钟 &#x2F; (AHB 时钟)</li>
</ul>
<blockquote>
<p>通常情况下我们一般选择内核时钟，因为他的精度更高</p>
</blockquote>
<h2 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407shizhongsujiegoutu.png" alt="F407shizhongsujiegoutu"></p>
<h2 id="SysTick-寄存器"><a href="#SysTick-寄存器" class="headerlink" title="SysTick 寄存器"></a>SysTick 寄存器</h2><p><strong>操作 SysTick 通常通过直接访问寄存器来完成</strong>。SysTick 是一个硬件模块，其功能由特定的寄存器控制。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407SysTickjicuqni.png" alt="F407SysTickjicuqni"></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>SysTick 的工作流程如下：</p>
<ol>
<li>配置时钟源<ul>
<li>选择 HCLK 或 HCLK&#x2F;8 作为计数器的时钟输入。</li>
</ul>
</li>
<li>加载重载值<ul>
<li>将所需的计时周期转换为计数值，写入 LOAD 寄存器。</li>
<li>计数周期为 LOAD + 1 个时钟周期。</li>
</ul>
</li>
<li>计数递减<ul>
<li>每个时钟周期，计数器递减 1。</li>
<li>当前值保存在 VAL 寄存器。</li>
</ul>
</li>
<li>计数到零<ul>
<li>当计数器递减到零：<ul>
<li>如果启用了中断，会触发中断处理程序。</li>
<li>自动从 <code>LOAD</code> 寄存器重新加载初始值，继续计数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在 ARM32 架构中通常都帮我们写好了相关配置，我们只需要调用 SysTick_Config 这个函数并传入周期值，他会在计数到 0 时自动触发中断，我们在相应的中断处理函数中进行操作即可；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SYS_TICK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_TICK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* configure systick */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* delay a time in milliseconds */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1us</span><span class="params">(<span class="type">uint32_t</span> count)</span>;</span><br><span class="line"><span class="comment">/* delay decrement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYS_TICK_H */</span></span></span><br><span class="line">===================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">uint32_t</span> delay;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* setup systick timer for 1000Hz interrupts */</span></span><br><span class="line">    <span class="keyword">if</span>(SysTick_Config(SystemCoreClock / <span class="number">1000000U</span>)) &#123;</span><br><span class="line">        <span class="comment">/* capture error */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure the systick handler priority */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, <span class="number">0x00</span>U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span> &#123;</span><br><span class="line">    delay = count * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1us</span><span class="params">(<span class="type">uint32_t</span> count)</span> &#123;</span><br><span class="line">    delay = count;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief    delay decrement</span></span><br><span class="line"><span class="comment">    \param[in]  none</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">        delay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========================================</span><br><span class="line"><span class="type">void</span> SysTick_Handler(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    led_spark();</span></span><br><span class="line">    delay_decrement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">(<span class="type">void</span>)</span> &#123;    </span><br><span class="line">	<span class="keyword">if</span> (uwTimingDelay != <span class="number">0x00</span>) &#123; </span><br><span class="line">		uwTimingDelay--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>Timer</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/Timer/</url>
    <content><![CDATA[<p><strong>定时器</strong>（Timer）是微控制器（MCU）中的一个硬件模块，用于对<strong>时间进行精确测量</strong>或生成<strong>周期性事件</strong>。定时器的工作基于时钟信号，通过对预设计数值进行递增或递减，可以用来测量时间间隔、生成定时中断、控制PWM输出等。</p>
<h2 id="定时器的工作原理"><a href="#定时器的工作原理" class="headerlink" title="定时器的工作原理"></a>定时器的工作原理</h2><p>定时器接收来自 RCC（时钟控制器）的时钟信号，经过<strong>预分频器</strong>对时钟进行分频以生成新的计数时钟来驱动计数器。<strong>计数器按设定的方向递增或递减</strong>，当计数器的值达到<strong>自动重装载寄存器</strong>设定的阈值时，触发更新事件，生成中断信号或DMA请求，同时计数器重新加载起始值继续计数。控制模块负责启动、停止、清零和设置计数方向等操作，并可在计数达到设定值时触发其他外设输出或事件，使定时器能够实现精确的定时、周期性触发、PWM输出等功能。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407dingshiqiyuanli.png" alt="F407dingshiqiyuanli"></p>
<h2 id="定时器的分类"><a href="#定时器的分类" class="headerlink" title="定时器的分类"></a>定时器的分类</h2><p><strong>内核定时器</strong></p>
<ul>
<li>主要包括 SysTick 定时器。SysTick 是一个简单的定时器模块，由 ARM Cortex-M 内核自带。通常用于操作系统的时基生成，或者简单的定时任务，如延时和计时。</li>
</ul>
<p><strong>常规定时器</strong></p>
<ul>
<li><strong>通用定时器</strong>：用于多种应用的基础定时器，通常可以支持基本的延时、中断和计数功能。</li>
<li><strong>高级定时器</strong>：通常具有更复杂的功能，如高级 PWM 生成、死区时间控制等，适合电机控制等高要求的应用。</li>
<li><strong>基本定时器</strong>：功能比较简单，一般只支持基础的定时中断，不具备高级的捕获比较功能。</li>
</ul>
<p><strong>专用定时器</strong></p>
<ul>
<li><p><strong>独立看门狗</strong>：用于监控系统运行，防止程序跑飞或异常，当检测到系统出现问题时可以复位系统。</p>
</li>
<li><p><strong>窗口看门狗</strong>：比独立看门狗更加灵活，可以设置窗口期来进行复位操作，通常用于安全要求较高的系统。</p>
</li>
<li><p><strong>RTC（实时时钟）</strong>：提供低功耗的实时时钟功能，可以记录年月日时分秒，适用于需要精确时间管理的应用。</p>
</li>
</ul>
<h2 id="GD32F407-系列定时器说明"><a href="#GD32F407-系列定时器说明" class="headerlink" title="GD32F407 系列定时器说明"></a>GD32F407 系列定时器说明</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407dingshiqifenlei.png" alt="F407dingshiqifenlei"></p>
<h3 id="配置项目含义"><a href="#配置项目含义" class="headerlink" title="配置项目含义"></a>配置项目含义</h3><p><strong>可重复性：</strong>指定时器在达到计数上限后是否可以自动重装载并重新开始计数的能力。</p>
<p><strong>捕获&#x2F;比较通道：</strong>用于处理输入捕获、输出比较、以及 PWM（脉宽调制）等操作。</p>
<ul>
<li><strong>捕获输入</strong>用于测量输入信号的时间特性，比如脉冲宽度或周期。当外部输入信号发生时（如上升沿或下降沿），捕获通道会将当前计数器的值保存到一个捕获寄存器中。通过读取这个寄存器的值，可以计算出信号的周期或高低电平时间。</li>
<li><strong>比较输出</strong>用于生成输出控制信号，比如 PWM 输出或定时中断。定时器在计数时会不断与设置的比较值进行比较，当计数器的值与比较寄存器中的预设值相等时，会触发一个事件，比如输出信号翻转、产生中断等。</li>
</ul>
<p><strong>互补&#x2F;死区时间：</strong></p>
<ul>
<li><strong>互补输出</strong>指的是定时器产生两个<strong>相互补充的 PWM 信号</strong>，一个为高电平时另一个为低电平，反之亦然。</li>
<li><strong>死区时间</strong>是为了避免桥式电路中的<strong>短路</strong>问题而设置的延时，就是在互补信号之间插入的一段小的延时；</li>
</ul>
<p><strong>中止输入：</strong>是一种保护机制，用于紧急情况下迅速停止定时器输出的功能；允许外部信号或内部事件触发“中止”操作，从而<strong>立即停用定时器的输出</strong>。</p>
<p><strong>单脉冲：</strong>定时器在触发条件满足时，只产生<strong>一个脉冲</strong>输出，而不是连续的脉冲信号；在单脉冲模式中，定时器会等待触发信号（可以是外部信号或软件触发）。当触发信号到来时，定时器开始计数，并在达到设定的时间后输出一个单独的脉冲。</p>
<p><strong>正交译码器：也称为</strong>增量式编码器译码器<strong>，是一种用于检测和解码正交信号的电路或模块。正交译码器的主要用途是对</strong>正交编码器<strong>（Quadrature Encoder）信号进行处理，从而测量旋转或线性位移的位置和方向。</strong></p>
<p><strong>主-从管理：</strong>“主-从管理”是指定时器的工作模式，其中一个定时器作为“主定时器”，控制其他定时器作为“从定时器”的工作方式。</p>
<p><strong>内部连接：</strong>指的是定时器模块内部的不同功能或模块之间的信号连接或通信。这些内部连接允许定时器模块的不同部分相互协调和配合工作，或使定时器与其他外设（如 PWM 输出、输入捕获、输出比较等）之间进行交互。</p>
<p><strong>DMA：</strong>指定时器与 DMA（Direct Memory Access，直接内存访问）控制器协同工作的一种模式。在这个模式下，定时器的事件（例如计数溢出、比较匹配等）可以触发 DMA 控制器自动从定时器中读取数据并传输到内存，或者将内存中的数据传输到定时器的相关寄存器中，而无需 CPU 的干预。</p>
<p><strong>Debug 模式：</strong>指定时器在调试过程中如何与调试工具（如调试器、调试接口）配合工作的一种模式。</p>
<blockquote>
<p>在使用时要注意区分，不同的定时器支持的功能和配置参数不同；</p>
</blockquote>
<h2 id="计数模式"><a href="#计数模式" class="headerlink" title="计数模式"></a>计数模式</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407Timerjishumoshi.png" alt="F407Timerjishumoshi"></p>
<p><strong>向上计数模式（Upcounting Mode）</strong>：</p>
<ul>
<li>左上图展示的是<strong>向上计数模式</strong>。计数器从 0 开始计数，向上计数直到达到 CAR 的值。</li>
<li>达到 CAR 后，计数器重置为 0 并重新开始计数，同时触发一次定时器溢出中断。</li>
</ul>
<p><strong>向下计数模式（Downcounting Mode）</strong>：</p>
<ul>
<li>右上图展示的是<strong>向下计数模式</strong>。计数器从 CAR 值开始向下计数，直到计数到 0。</li>
<li>到达 0 后，计数器重置为 CAR 并重新开始计数，同时触发一次定时器中断。</li>
</ul>
<p><strong>中心对齐双向模式（Center-Aligned Both Mode）</strong>：</p>
<ul>
<li>计数器从 0 向上计数到 ARR，再从 ARR 计数到 0，完成一次完整的计数周期。</li>
<li>每次到达 ARR 和 0 时都会触发更新事件，因此在一个周期中触发两次事件。</li>
</ul>
<p><strong>中心对齐向上模式（Center-Aligned UpMode）</strong>：</p>
<ul>
<li>计数器从 0 向上计数到最大值（ARR），然后反向重新计数到 0，再次向上计数。</li>
<li>定时器模块在计数达到（ARR）时产生一个上溢事件；</li>
</ul>
<p><strong>中心对齐向下模式（Center-Aligned Down Mode）</strong>：</p>
<ul>
<li>计数器从最大值（ARR）向下计数到 0，然后反向重新计数到 ARR 值，再次向下计数。</li>
<li>在此模式下，每次计数到达 0 时触发中断或更新事件，波形在中心对称。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>功能：使用定时器实现LED灯的闪烁（改为了串口打印，因为将 GPIO 的控制权交给 Timer 之后就无法通过 GPIO 去改变引脚的状态了，这时候要使用 Timer 的捕获通道进行修改？）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART 配置...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LED1 GPIO Config</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_LED_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// LED 总开关</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_mode_set(GPIOC, GPIO_MODE_OUTPUT, GPIO_PUPD_PULLUP, GPIO_PIN_6);</span><br><span class="line">	gpio_output_options_set(GPIOC, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_6);</span><br><span class="line">	<span class="comment">// LED1</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOD);</span><br><span class="line">	gpio_mode_set(GPIOD, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_15);</span><br><span class="line">	gpio_af_set(GPIOD, GPIO_AF_2, GPIO_PIN_15);</span><br><span class="line">	gpio_output_options_set(GPIOD, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, GPIO_PIN_15);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 总开关常开</span></span><br><span class="line">	gpio_bit_reset(GPIOC, GPIO_PIN_6);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LED1 TImer Config</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TImer_LED_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">	timer_deinit(TIMER3);</span><br><span class="line">    <span class="comment">// 使能定时器外设</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_TIMER3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由时钟树或者总线框图可以看到 Timer 是挂在 APB1 这条总线上的,频率为 42MHz</span></span><br><span class="line">    <span class="comment">// 为了方便计算，我们将其倍频为 168HMz 进行在进行分频（注意查看框图看起最大支持的频率是多少）</span></span><br><span class="line">    <span class="comment">// 通过时钟树框图可以看到 Timer 支持对 APB1 进行 1、2、4、8、16倍分频</span></span><br><span class="line">    <span class="comment">// 根据要求我们选择 4 倍分频即可</span></span><br><span class="line">    <span class="comment">// 不倍频也可以，那就要按照 42MHz 去进行计算</span></span><br><span class="line">	rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL4);</span><br><span class="line">	<span class="comment">// 根据定时器的工作原理，我们要先将 APB1 总线传递过来的频率进行分频后才可使用</span></span><br><span class="line">    <span class="comment">// 在配置其参数、</span></span><br><span class="line">	timer_parameter_struct initpara;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    initpara-&gt;prescaler = 0U; 预分频器的值，分频系数</span></span><br><span class="line"><span class="comment">    initpara-&gt;alignedmode = TIMER_COUNTER_EDGE; // 中断触发方式</span></span><br><span class="line"><span class="comment">    initpara-&gt;counterdirection = TIMER_COUNTER_UP; // 定时器计数方式</span></span><br><span class="line"><span class="comment">    initpara-&gt;period = 65535U; // 周期值，上升计数时候从0数到这个值触发</span></span><br><span class="line"><span class="comment">    // 设置定时器时钟的分频系数，在 prescaler 后的基础上在进行分频</span></span><br><span class="line"><span class="comment">    initpara-&gt;clockdivision = TIMER_CKDIV_DIV1; </span></span><br><span class="line"><span class="comment">    // 重复计数，每次溢出时会执行多少次重复计数操作。</span></span><br><span class="line"><span class="comment">    // 当溢出中断触发时，重复执行的次数</span></span><br><span class="line"><span class="comment">    initpara-&gt;repetitioncounter = 0U; 是    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		</span><br><span class="line">	timer_struct_para_init(&amp;initpara);</span><br><span class="line">	initpara.prescaler         = <span class="number">16800</span>; <span class="comment">// 168000000 / 16800 = 10000 -&gt; 1S</span></span><br><span class="line">    initpara.period            = <span class="number">30000</span>; <span class="comment">// 3S</span></span><br><span class="line">		</span><br><span class="line">	timer_init(TIMER3, &amp;initpara);	</span><br><span class="line">	<span class="comment">// 触发中断 配置NVIC</span></span><br><span class="line">	nvic_irq_enable(TIMER3_IRQn, <span class="number">2</span>, <span class="number">2</span>);	</span><br><span class="line">	timer_interrupt_enable(TIMER3, TIMER_INT_UP);	</span><br><span class="line">	</span><br><span class="line">	timer_enable(TIMER3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器3中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(SET == timer_interrupt_flag_get(TIMER3, TIMER_INT_FLAG_UP)) &#123;</span><br><span class="line">        timer_interrupt_flag_clear(TIMER3, TIMER_INT_FLAG_UP);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;123&quot;</span>);		</span><br><span class="line">    &#125;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">	GPIO_USART_Config();</span><br><span class="line">    USART_Config();</span><br><span class="line">	GPIO_LED_Config();</span><br><span class="line">	TImer_LED_Config();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>prescaler：计数器时钟等于 TIMER_CK 时钟除以(PSC+1)，每次当更新事件产生时，PSC 的值 被装入到对应的影子寄存器。</p>
</blockquote>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><strong>Timer 配置（中断）</strong></p>
<ul>
<li><p>使能外部 Timer 时钟</p>
</li>
<li><p>倍频（可以先试试看频率是否正确，不对就要去查看时钟树结构图将其倍频为 168MHz）</p>
</li>
<li><p>Timer 配置（分频值、自动重载器的初值、计数的方式、触发的方式）</p>
</li>
<li><p>使能 NVIC</p>
</li>
<li><p>使能 Timer 中断</p>
</li>
<li><p>编写中断处理函数</p>
</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>定时器无法直接操控引脚，那为什么还可以将引脚复用为 Timer？</strong></p>
<p>定时器的核心功能是<strong>计数和生成时间基准</strong>，它本身不会直接输出高低电平信号到 GPIO 上。定时器可以产生中断、溢出标志等，但这些事件并不直接影响 GPIO 的输出电平。</p>
<p>要让定时器影响 GPIO 引脚的状态，需要借助定时器的<strong>输出模式</strong>，如 PWM 模式或输出比较模式。这些模式通过定时器的比较寄存器、占空比和计数周期来调节 GPIO 输出信号。</p>
<p>二、<strong>在配置时候，预分频值和周期值为什么要减一</strong></p>
<p><strong>预分频值</strong></p>
<p>预分频器可以将定时器的时钟（TIMER_CK）频率按 1 到 65536 之间的任意值分频，分频后 的时钟 PSC_CLK 驱动计数器计数。所以我们在使用的时候需要将其减一，因为他再写入寄存器时候会自动加一；</p>
<p><strong>周期值</strong></p>
<p>因为定时器的中断方式为溢出中断，</p>
<p>从 0 开始向上计数时。在（TIMERx_CREP+1）次上溢后产生更新事件。</p>
<p>向下计数时候，在（TIMERx_CREP+1）次下溢后产生更新事件。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>USAET</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/USART/</url>
    <content><![CDATA[<p>USART（Universal Synchronous&#x2F;Asynchronous Receiver Transmitter）<strong>通用同步&#x2F;异步收发器</strong>是一种在嵌入式系统中广泛应用的<strong>串行通信协议</strong>。它支持<strong>同步</strong>和<strong>异步</strong>两种传输模式，其中同步模式在<strong>时钟信号</strong>的帮助下能够精确同步数据传输，而异步模式则不需要额外的时钟信号支持。同时它还支持多种通信模式，包括<strong>全双工</strong>、<strong>半双工</strong>和<strong>单线模式</strong>，并能够通过简单配置在同步和异步传输之间切换。</p>
<p>GD32F407 中 USART 协议的详细介绍：</p>
<p><strong>传输模式</strong></p>
<ul>
<li><p><strong>异步模式</strong>：与 UART 类似，不需要时钟信号，仅使用预设的波特率进行数据传输。</p>
</li>
<li><p><strong>同步模式</strong>：依赖时钟信号进行数据同步传输，通常用于需要更高传输速率和更精确同步的场景。</p>
</li>
</ul>
<p><strong>USART 通信的数据帧结构</strong></p>
<p>在异步模式下，USART 通信的数据帧结构通常包括以下几个部分：</p>
<ul>
<li><strong>起始位</strong>：1 位，通常为低电平（逻辑 0），用于通知接收端即将开始传输数据。</li>
<li><strong>数据位</strong>：8-9 位，可配置，表示实际传输的数据内容（一般配置为 8 位）。</li>
<li><strong>校验位</strong>（可选）：1 位，用于错误检测（奇校验或偶校验）。</li>
<li><strong>停止位</strong>：产生0.5，1，1.5或者2个停止位，表示数据帧结束，通常为高电平（逻辑 1）。</li>
</ul>
<p>例如，一个 8N1 格式的数据帧包括 1 位起始位、8 位数据、1 位停止位，没有校验位。</p>
<p>在同步模式下，由于时钟信号的同步作用，数据帧可以更加简化，不再需要起始位和停止位的区分。</p>
<p><strong>工作模式</strong></p>
<p>USART 支持多种模式：</p>
<ul>
<li><strong>全双工模式</strong>：发送端和接收端独立工作，同时收发数据。</li>
<li><strong>半双工模式</strong>：发送和接收共享同一条数据线，无法同时进行收发。</li>
<li><strong>半双工单线模式</strong>：只有一条单独的数据线，用于资源受限的场景。</li>
<li><strong>多处理器模式</strong>：适合主机与多个从机的场景。主机广播地址，选中的从机响应以避免混乱。</li>
</ul>
<p><strong>波特率控制</strong></p>
<ul>
<li>波特率（Baud Rate）定义了数据传输速率（每秒传输的比特数），例如 9600、115200。<strong>发送端和接收端的波特率必须一致才能正确传输和解析数据</strong>。USART 硬件中通常有专门的波特率寄存器来设置传输速率。</li>
</ul>
<p><strong>错误检测机制</strong></p>
<p>USART 协议包含多种错误检测机制，用于确保数据的可靠性：</p>
<ul>
<li><strong>帧错误（FERR）</strong>：当接收的数据帧的停止位不是高电平时，标记为帧错误。这通常表示起始位检测错误，或者信号受到干扰。</li>
<li><strong>过载错误（ORERR）</strong>：当接收方的接收缓冲区满，新的数据到达时会产生过载错误。</li>
<li><strong>奇偶校验错误（PERR）</strong>：如果启用奇偶校验功能，当接收的数据位和校验位不匹配时，标记为奇偶校验错误。</li>
<li><strong>噪声检测（NERR）</strong>：USART 会检测数据线上的噪声干扰，确保接收到的数据是稳定的。</li>
</ul>
<p><strong>USART 同步模式（时钟）</strong></p>
<p>在同步模式下，USART 会在 TX（发送）和 RX（接收）线上加上一条时钟线 SCLK（串行时钟）。数据会根据时钟上升沿或下降沿进行采样和发送，使发送方和接收方时刻保持同步。</p>
<ul>
<li><strong>主从配置</strong>：通常，发送方为主设备，提供时钟信号；接收方为从设备，接收并使用主设备的时钟信号。</li>
<li><strong>时钟极性（CPOL）</strong> 和 <strong>相位（CPHA）</strong>：USART 在同步模式下，可以设置时钟极性和相位，以控制数据位相对于时钟边沿的位置。</li>
</ul>
<p><strong>中断机制</strong></p>
<p>USART 支持多种中断，以便微控制器处理不同的事件。例如：</p>
<ul>
<li><strong>接收中断</strong>：接收到一帧数据时触发中断，应用程序可以在中断处理程序中读取数据。</li>
<li><strong>发送完成中断</strong>：数据帧发送完成时触发中断，应用程序可以在中断处理程序中进行相应操作（比如发送下一个数据帧）。</li>
<li><strong>错误中断</strong>：当发生错误（例如帧错误、奇偶校验错误）时，USART 会触发错误中断。</li>
</ul>
<p>USART 是一种灵活的串行通信协议，既可以在异步模式下工作，简化电路复杂度，又可以在同步模式下工作，提高数据传输速度和稳定性。它的多种错误检测机制、中断机制和可配置的帧格式使其非常适合嵌入式系统的可靠通信需求。在使用 USART 时，需要合理配置波特率、数据帧格式、校验机制等，确保通信的可靠性和准确性。</p>
<h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><strong>USART 引脚描述</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407uartyinjiaoshuom.png" alt="F407uartyinjiaoshuom"></p>
<blockquote>
<p>硬件流控制功能通过 nCTS 和 nRTS 引脚来实现。通过将 USART_CTL2 寄存器中 RTSEN 位置 1 来使能 RTS 流控，将 USART_CTL2 寄存器中 CTSEN 位置 1 来使能 CTS 流控。</p>
<p><strong>nCTS：</strong>USART 发送器监视 nCTS 输入引脚来决定数据帧是否可以发送。如果 USART_STAT0 寄存器中 TBE 位是 0 且 nCTS 为低电平，发送器发送数据帧。在发送期间，若 nCTS 信号变为高电平，发 送器将会在当前数据帧发送完成后停止发送。</p>
<p><strong>nRTS：</strong>USART接收器输出 nRTS，它用于反映接收缓冲区状态。当一帧数据接收完成，nRTS变成高电 平，这样是为了阻止发送器继续发送下一帧数据。当接收缓冲区满时，nRTS保持高电平，可 以通过读USART_DATA寄存器来清零。</p>
</blockquote>
<p><strong>引脚连线</strong></p>
<p>对于芯片和 PC 机之间的通信，则不能直接相连，因为电平不兼容。所以要中间要接一个RS232的转换器，将TTL电平转换为RS232电平</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/USARTyinjiaolianxian.png" alt="USARTyinjiaolianxian"></p>
<h2 id="USART-内部框图"><a href="#USART-内部框图" class="headerlink" title="USART 内部框图"></a>USART 内部框图</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/USARTneibukuangtu.png" alt="USARTneibukuangtu"></p>
<blockquote>
<p><strong>SW_RX：</strong>数据接收引脚，内部引脚，只用于单线和智能卡模式。</p>
</blockquote>
<h2 id="USART-数据帧"><a href="#USART-数据帧" class="headerlink" title="USART 数据帧"></a>USART 数据帧</h2><p>USART 数据帧开始于起始位，结束于停止位。USART_CTL0 寄存器中 WL 位可以设置数据长度。 将 USART_CTL0 寄存器中 PCEN 置位，最后一个数据位可以用作校验位。若 WL 位为 0，第七位 为校验位。若WL位置 1，第八位为校验位。USART_CTL0 寄存器中 PM 位用于选择校验位的计 算方法。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/USARTshujuzhen.png" alt="USARTshujuzhen"></p>
<p>根据图片中的数据传输示例，可以看到数据从 bit0 开始发送，依次到 bit7。这意味着数据是从低位（Least Significant Bit, LSB）开始传输的。</p>
<blockquote>
<p><strong>空闲帧</strong>：在数据帧之间的空闲状态，没有数据传输。（局域网协议使用，串口不需要）</p>
<p><strong>断开帧</strong>：在特定情况下用于表示连接断开的状态。（局域网协议使用，串口不需要）</p>
</blockquote>
<p><strong>GD32 中 USART 的发送流程实现</strong></p>
<ol>
<li>在 USART_CTL0 寄存器中置位 UEN位，使能 USART； </li>
<li>通过 USART_CTL0 寄存器的WL设置字长； </li>
<li>在 USART_CTL1 寄存器中写 STB[1:0] 位来设置停止位的长度； </li>
<li>如果选择了多级缓存通信方式，应该在 USART_CTL2 寄存器中使能 DMA（DENT位）；</li>
<li>在 USART_BAUD 寄存器中设置波特率；</li>
<li>在 USART_CTL0 寄存器中设置 TEN 位；</li>
<li>等待 TBE 置位；</li>
<li>向 USART_DATA 寄存器写数据；</li>
<li>若 DMA 未使能，每发送一个字节都需重复步骤 7-8； </li>
<li>等待 TC &#x3D; 1，发送完成</li>
</ol>
<p><strong>GD32 中 USART 的接收流程实现</strong></p>
<p>上电后，USART接收器使能按以下步骤进行： </p>
<ol>
<li>在USART_CTL0寄存器中置位UEN位，使能USART； </li>
<li>写USART_CTL0寄存器的WL去设置字长；</li>
<li>在USART_CTL1寄存器中写STB[1:0]位来设置停止位的长度；</li>
<li>如果选择了多级缓存通信方式，应该在USART_CTL2寄存器中使能DMA（DENR位）；</li>
<li>在USART_BAUD寄存器中设置波特率；</li>
<li>在USART_CTL0中设置REN位。</li>
</ol>
<p>接收器在使能后若检测到一个有效的起始脉冲便开始接收码流。在接收一个数据帧的过程中会检测噪声错误，奇偶校验错误，帧错误和过载错误。 </p>
<p>当接收到一个数据帧，USART_STAT0 寄存器中的 RBNE 置位，如果设置了 USART_CTL0 寄存器中相应的中断使能位 RBNEIE，将会产生中断。在 USART_STAT0 寄存器中可以观察接收状态标志。</p>
<p>在接收过程中，需使能 REN 位，不然当前的数据帧将会丢失；</p>
<p><strong>发送数据的两种情况</strong></p>
<p>正在发送过程中的情况：</p>
<ul>
<li>当你尝试向 USART_DATA 寄存器写入数据时，如果此时已有数据正在发送，那么新写入的数据会被存储在发送缓冲区中。</li>
<li>当当前的发送过程完成后，缓冲区中的数据会依次传输到发送移位寄存器中，继续进行发送。</li>
</ul>
<p>没有发送过程的情况：</p>
<ul>
<li>如果在写入 USART_DATA 时，没有数据正在发送（即 TBE 位，表示发送缓冲区空，Transmission Buffer Empty，已经被清空），那么新的数据将立即被传输到发送移位寄存器中，准备进行发送。</li>
<li>在这种情况下，TBE 位会首先被清零（表示缓冲区当前不为空），然后迅速设置为 1，表明新的数据可以进行发送。</li>
</ul>
<p>在 GD32 系列的微控制器中，<strong>接收缓冲区</strong>和<strong>发送缓冲区</strong>通常是指 USART 外设中用于接收和发送数据的硬件寄存器数（USART_DATA）;</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>串口通信过程</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407chuankoutongxinguoc.png" alt="F407chuankoutongxinguoc"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int8_t</span> dataBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int8_t</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_USART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 启用GPIOA的外设时钟。</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">    <span class="comment">// 配置引脚的工作模式为复用模式</span></span><br><span class="line">    gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_9);</span><br><span class="line">    <span class="comment">// 配置为特定的功能复用模式，指定复用哪一个模式</span></span><br><span class="line">    gpio_af_set(GPIOA, GPIO_AF_7, GPIO_PIN_9);</span><br><span class="line">    <span class="comment">// 配置GPIOA引脚的输出选项，Rx是输出引脚所以配了个推挽</span></span><br><span class="line">    gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// PA10配置 A10 是输入所以不需要配置输出</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_10);</span><br><span class="line">	gpio_af_set(GPIOA, GPIO_AF_7, GPIO_PIN_10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UART 配置  </span></span><br><span class="line"><span class="comment">// 我们在串口通信时候双方需要指定 数据位个数、校验位、停止位</span></span><br><span class="line"><span class="comment">// 以保证双方通信的正确，所以可以不像官方示例中那样写    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 启用USART0的外设时钟。</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_USART0);</span><br><span class="line">	usart_deinit(USART0);</span><br><span class="line">	<span class="comment">/*=================USART属性配置=================*/</span></span><br><span class="line">    <span class="comment">// 设置波特率</span></span><br><span class="line">    usart_baudrate_set(USART0, <span class="number">115200</span>);</span><br><span class="line">    <span class="comment">// 设置数据位个数、校验位、停止位</span></span><br><span class="line">    usart_word_length_set(USART0, USART_WL_8BIT);</span><br><span class="line">    usart_parity_config(USART0, USART_PM_NONE);</span><br><span class="line">    usart_stop_bit_set(USART0, USART_STB_1BIT);</span><br><span class="line">	<span class="comment">/*=================USART发送接收使能配置=================*/</span></span><br><span class="line">    <span class="comment">// 开启发送使能</span></span><br><span class="line">    usart_transmit_config(USART0, USART_TRANSMIT_ENABLE);</span><br><span class="line">	<span class="comment">// 开启接收使能</span></span><br><span class="line">	usart_receive_config(USART0, USART_RECEIVE_ENABLE);</span><br><span class="line">	<span class="comment">/*=================USART接收中断配置=================*/</span></span><br><span class="line">	<span class="comment">// 开启中断使能</span></span><br><span class="line">	nvic_irq_enable(USART0_IRQn, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 配置两个中断源，也就是RBNE和IDLE发生改变了就触发中断</span></span><br><span class="line">	usart_interrupt_enable(USART0, USART_INT_RBNE);</span><br><span class="line">	usart_interrupt_enable(USART0, USART_INT_IDLE);</span><br><span class="line">    <span class="comment">// 开启UART0使能</span></span><br><span class="line">   usart_enable(USART0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重定向C标准库的printf函数，使其通过USART（通用同步异步收发器）进行输出。*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span> &#123;</span><br><span class="line">    usart_data_transmit(USART0, (<span class="type">uint8_t</span>)ch);</span><br><span class="line">    <span class="keyword">while</span>(RESET == usart_flag_get(USART0, USART_FLAG_TBE));</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_data</span><span class="params">(<span class="type">uint8_t</span> dat)</span> &#123;</span><br><span class="line">    usart_data_transmit(USART0, dat);</span><br><span class="line">    <span class="keyword">while</span>(RESET == usart_flag_get(USART0, USART_FLAG_TBE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UART0 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 有数据了</span></span><br><span class="line">	<span class="keyword">if</span>(SET == usart_interrupt_flag_get(USART0, USART_INT_FLAG_RBNE)) &#123;</span><br><span class="line">		usart_interrupt_flag_clear(USART0, USART_INT_FLAG_RBNE);		</span><br><span class="line">		<span class="type">int8_t</span> data =  usart_data_receive(USART0);		</span><br><span class="line">		dataBuf[index] = data;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(SET == usart_interrupt_flag_get(USART0, USART_INT_FLAG_IDLE)) &#123;</span><br><span class="line">        <span class="comment">// 清除 LDLE 中断标志位</span></span><br><span class="line">        <span class="comment">// 软件先读USART_STAT0，再读USART_DATA可清除该位。</span></span><br><span class="line">        <span class="comment">// usart_interrupt_flag_get 读取的就是 USART_STAT0 寄存器中的标志位</span></span><br><span class="line">        <span class="comment">// USART_STAT0 是状态寄存器，USART_DATA 为数据寄存器</span></span><br><span class="line">		usart_data_receive(USART0); <span class="comment">// 读数据寄存器，以清除 LDLE 中断标志位</span></span><br><span class="line">		<span class="comment">// 使其成为一个字符串</span></span><br><span class="line">		dataBuf[index] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;rece_data = %s\n&quot;</span>, dataBuf);</span><br><span class="line">        </span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">    GPIO_USART_Config();</span><br><span class="line">    USART_Config();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi,Key&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>要使用 printf 串口打印功能需要使用嵌入式的 C 库而且不是 stdio.h；</p>
<p>“魔术棒” –&gt; “Target” 下勾选 Use MicroLIB；</p>
<p><strong>MicroLIB</strong> 是指使用一个轻量级的 C 标准库，专门为资源受限的嵌入式系统设计。它会将 printf 输出重新定向到串口而不是控制台；</p>
</blockquote>
<p><strong>实现步骤</strong></p>
<ol>
<li><strong>GPIO 配置</strong></li>
</ol>
<ul>
<li><p>启用指定GPIO端口的外设时钟</p>
</li>
<li><p>查看板子的原理图，了解有无外部上拉&#x2F;下拉电阻，并配置为复用模式</p>
</li>
<li><p>在复用为 USART 时可以查看下数据手册以防 Rx 和 Tx 引脚搞错了</p>
</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/UARTPA9P10.png" alt="UARTPA9P10"></p>
<blockquote>
<p><strong>Default：</strong>引脚的默认功能或连接，表示这是一个通用输入输出（GPIO）引脚。 </p>
<p><strong>Alternate：</strong>表示该引脚可以被配置为不同的外设功能。(复用)</p>
<p><strong>Additional：</strong>表示引脚的额外或可选功能。</p>
</blockquote>
<ul>
<li>要指定是那一个复用模式，需要在数据手册中查看<strong>端口复用功能摘要表</strong></li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407PA910duankoufuyongbiao.png" alt="F407PA910duankoufuyongbiao"></p>
<ol start="2">
<li><strong>USART 配置</strong></li>
</ol>
<ul>
<li><p>启用指定 USART 端口的外设时钟（在数据手册中可以看到引脚所属 USART 端口）</p>
</li>
<li><p>初始化设置端口（可选）</p>
</li>
<li><p>配置 USART 的波特率</p>
</li>
<li><p>数据位、校验位、停止位（可选）</p>
</li>
<li><p>设置发送使能</p>
</li>
<li><p>设置接收使能</p>
</li>
<li><p>设置中断使能</p>
</li>
<li><p>配置中断触发源</p>
</li>
<li><p>编写中断处理函数</p>
<ul>
<li>非必要尽量不要再中断处理函数中进行延时操作，除非确认没有问题</li>
<li>在读取标志位进行判断之后如果需要要将标志位置 0 或者置 1（查看用户手册了解是硬件置位还是软件置位）</li>
</ul>
</li>
<li><p>设置 USART 端口使能</p>
</li>
</ul>
<blockquote>
<p>USART 的数据接收一般都放在中断中，所以需要启用 USART 端口的中断使能</p>
<p>中断使能后需要指定如何触发中断也就是配置中断源，这个要去查看对应 USART 端口的用户手册，根据我们需要的功能找到需要的标志位，然后查看该标志位的中断触发位将其值 1 &#x2F; 0；（了解后去找对应的库函数实现）</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>GPIO 输出默认低电平，USART输出引脚则要高电平拉低在作为发送标志，这个引脚是什么时候被拉低的</strong></p>
<p>当引脚被复用为 <strong>USART 的 TX（发送）引脚</strong>时，默认情况下它的电平状态会由 USART 模块控制，而不是由内部上拉电阻控制。</p>
<p><strong>具体情况：</strong></p>
<ol>
<li><strong>默认高电平</strong>：USART 的 TX 引脚在空闲状态下通常为高电平（逻辑“1”）。这是 USART 通信协议的要求，当没有数据发送时，TX 线会保持在高电平。</li>
<li><strong>发送数据时</strong>：当 USART 开始发送数据时，TX 引脚会根据数据位的状态（0 或 1）改变电平，以形成串行通信的信号。</li>
</ol>
<p>因此，将引脚复用为 USART 的 TX 时，即使之前配置了内部上拉电阻，它在空闲状态下也会保持为高电平。上拉电阻对 TX 引脚的电平没有影响，因为此时<strong>引脚的控制权由 GPIO 移交给了 USART</strong>。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<p>在嵌入式开发中，中断（Interrupt）是一种机制，可以使处理器<strong>暂停当前执行的任务，去处理一个紧急或高优先级的事件</strong>。中断机制能帮助嵌入式系统快速响应外部或内部的事件，提升实时性能和效率。</p>
<p><strong>基本概念</strong></p>
<p>中断是由<strong>硬件</strong>或<strong>软件</strong>事件触发的一种信号，用于打断处理器的当前流程，使其快速跳转到指定的 <strong>中断服务程序（ISR）</strong>，以便处理特定事件。当 ISR 执行完毕，处理器会返回并继续执行被打断的任务。</p>
<p><strong>中断的分类</strong></p>
<p>中断大体可以分为以下几类：</p>
<ul>
<li><strong>外部中断</strong>：由外部硬件触发，例如按钮、传感器、计数器等。这类中断通常用于捕获外部事件。</li>
<li><strong>内部中断</strong>：由处理器或外设内部事件触发，如定时器溢出、ADC 转换完成、串口数据接收等。</li>
<li><strong>软件中断</strong>：通过软件指令触发的中断，用于实现特定的软件功能或系统调用。</li>
</ul>
<p><strong>中断的工作原理</strong></p>
<p>中断的基本工作流程如下：</p>
<ol>
<li><strong>中断请求</strong>：中断源（如外设或软件）产生中断请求信号。</li>
<li><strong>中断响应</strong>：处理器停止当前任务，并保存当前状态（如程序计数器和寄存器等）。</li>
<li><strong>执行 ISR</strong>：处理器跳转到对应的中断服务程序，执行中断处理代码。</li>
<li><strong>恢复执行</strong>：ISR 执行完成后，处理器恢复之前保存的状态，继续执行被打断的任务。</li>
</ol>
<p><strong>中断优先级和嵌套</strong></p>
<p>在多中断系统中，中断的优先级决定了响应的先后顺序。中断的优先级可以进一步细分为不同的类型，以便更好地满足系统实时性和复杂性的需求。常见的中断优先级类型包括<strong>响应式优先级</strong>、<strong>抢占式优先级</strong>和<strong>自然优先级</strong>。</p>
<ul>
<li><strong>响应式优先级：</strong>响应式中断优先级指的是，中断的处理<strong>根据固定优先级顺序</strong>进行，不支持中断的嵌套或抢占；在多个中断发生时，优先响应高优先级的中断，直到 ISR 完成才响应下一个中断。</li>
<li><strong>抢占式优先级：</strong>抢占式中断优先级允许<strong>高优先级中断打断低优先级中断的执行</strong>;</li>
<li><strong>自然优先级：</strong>自然优先级是一种<strong>基于中断向量表</strong>的优先级机制，自然优先级实际上是中断向量表的序号，序号越小优先级越高。</li>
</ul>
<blockquote>
<p>无论是抢占优先级还是响应优先级，都是用数值表示的，数值越小，优先级越高。</p>
</blockquote>
<p><strong>中断向量表</strong></p>
<p>中断向量表存储了各个中断服务程序的入口地址。每个中断源都有一个固定的入口地址。当发生中断时，处理器通过中断向量表找到相应 ISR 的地址并跳转执行。</p>
<p><strong>中断服务程序（ISR）</strong></p>
<p>中断服务程序用于处理中断事件的具体逻辑。设计 ISR 时需要注意以下几点：</p>
<ul>
<li><strong>简短高效</strong>：ISR 应该尽量简洁，避免长时间运行，减少对主程序的影响。</li>
<li><strong>避免阻塞操作</strong>：ISR 中不适合使用延时、复杂计算或等待操作，以避免影响系统的实时性。</li>
<li><strong>使用中断标志位</strong>：很多中断事件触发后会设置特定的标志位，ISR 中通常需要检查和清除标志位，以防止重复触发。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是一种简化的触发机制，通常用于在不需要中断服务程序（ISR）的情况下唤醒处理器或触发某些外设的操作。<strong>事件不会打断当前的程序执行</strong>，也不会跳转到一个特定的中断服务程序。因此，事件的处理方式更加轻量，也没有优先级之分。</p>
<h2 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h2><p><strong>NVIC</strong>（Nested Vectored Interrupt Controller，嵌套向量中断控制器）是 ARM Cortex-M 系列微控制器内核中的一个重要模块，负责管理和控制<strong>中断请求</strong>的响应和优先级处理。</p>
<h2 id="优先级分组"><a href="#优先级分组" class="headerlink" title="优先级分组"></a>优先级分组</h2><p><strong>优先级分组机制</strong>是一种在嵌入式系统中<strong>管理中断优先级</strong>的方式，它允许系统在中断的<strong>抢占优先级</strong>和<strong>子优先级（响应式优先级）</strong>之间进行分配，以更灵活地控制中断响应顺序。ARM Cortex-M 系列处理器通过<strong>嵌套向量中断控制器（NVIC）</strong>提供了优先级分组机制，使得在处理多种中断时可以实现更高的系统实时性和响应能力。</p>
<p>在 Cortex-M 架构中，中断优先级通过<strong>嵌套式向量型中断控制器（NVIC）</strong>进行配置；在 Cortex-M4 中使用 4 位来设置优先级；常见分组如下：</p>
<table>
<thead>
<tr>
<th align="center">优先级分组</th>
<th align="center">抢占优先级位数</th>
<th align="center">子优先级位数</th>
<th align="center">优先级分组类型描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">全抢占优先级，没有子优先级</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">3 位抢占优先级，1 位子优先级</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2 位抢占优先级，2 位子优先级</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1 位抢占优先级，3 位子优先级</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">没有抢占优先级，全部为子优先级</td>
</tr>
</tbody></table>
<blockquote>
<p>举例：在 <strong>4 位抢占优先级、0 位子优先级</strong>的情况下，抢占优先级可以使用 <strong>0 到 15</strong> 之间的值进行设置；因为他占了四个字节。</p>
</blockquote>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数是一种将函数作为参数传递给另一个函数的编程技术。回调函数的作用是：允许一个函数在完成某些特定任务后，通过调用另一个“回调”函数来通知调用方任务完成，或执行特定的后续操作。</p>
<p>在中断处理中，我们不可以帮用户做决定，所以我们在中断中无法预知客户要做的事情是什么，这时候就可以使用回调函数；</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>ARM Cortex-M 系列中断分为三类：</p>
<ul>
<li><strong>系统异常（System Exceptions）</strong>：<ul>
<li>内核自带的异常，例如复位（Reset）、不可屏蔽中断（NMI）、硬故障（Hard Fault）等。优先级较高，通常用于处理系统级的错误和状态。</li>
</ul>
</li>
<li><strong>外部中断（External Interrupts）</strong>：<ul>
<li>由外设（如 GPIO、UART、定时器等）产生的中断，通过 NVIC 进行管理。这些外部中断优先级由用户定义，响应外部事件，例如按钮按下、数据接收完成等。</li>
</ul>
</li>
<li><strong>软件中断（Software Interrupts）</strong>：<ul>
<li>由软件触发的中断，用于在代码中人为产生中断以实现特定功能，如任务调度或操作系统中的上下文切换。</li>
</ul>
</li>
</ul>
<h3 id="EXTI（外部中断）"><a href="#EXTI（外部中断）" class="headerlink" title="EXTI（外部中断）"></a>EXTI（外部中断）</h3><p><strong>EXTI</strong>（External Interrupt&#x2F;Event Controller，外部中断&#x2F;事件控制器）主要作用是捕获<strong>外部</strong>中断&#x2F;事件。</p>
<p>EXTI 负责<strong>检测和生成中断事件</strong>，而 NVIC 负责<strong>管理和调度中断的响应</strong>。</p>
<p><strong>EXTI 的结构与工作流程：</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407waibuzhonduanlc.png" alt="F407waibuzhonduanlc"></p>
<ol>
<li><strong>EXTI Line0~22</strong>：</li>
</ol>
<ul>
<li>EXTI 控制器提供了多个外部中断线（Line0~Line22），这些线可以连接到外部设备或者 GPIO 引脚。</li>
<li>每一条 EXTI 线可以设置为边沿检测，即检测上升沿或下降沿的信号变化。</li>
</ul>
<ol start="2">
<li><strong>极性控制</strong>：</li>
</ol>
<ul>
<li>用于设置信号的触发极性。可以选择触发上升沿、下降沿，或者两者都触发。</li>
<li>极性控制模块通过设置不同的极性，控制边沿检测器检测信号变化的类型。</li>
</ul>
<ol start="3">
<li><strong>边沿检测</strong>：</li>
</ol>
<ul>
<li>边沿检测模块用于检测外部信号的变化。根据极性控制的设定，这里可以检测上升沿、下降沿，或者两者都检测。</li>
<li>当检测到符合设定的边沿信号时，将触发后续的中断或事件。</li>
</ul>
<ol start="4">
<li><strong>软件触发</strong>：</li>
</ol>
<ul>
<li>软件触发模块允许通过编程来触发 EXTI 中断，而不依赖外部信号。</li>
<li>通过软件触发，程序可以手动生成中断或事件，适用于某些特殊的控制场景。</li>
</ul>
<ol start="5">
<li><strong>中断屏蔽控制</strong>：</li>
</ol>
<ul>
<li>中断屏蔽控制模块用于控制 EXTI 信号是否生成中断。</li>
<li>当中断屏蔽控制允许时，检测到的边沿信号将触发中断信号并传输给 NVIC。</li>
</ul>
<ol start="6">
<li><strong>事件屏蔽控制</strong>：</li>
</ol>
<ul>
<li>事件屏蔽控制模块用于控制 EXTI 信号是否生成事件。</li>
<li>当事件屏蔽控制允许时，检测到的边沿信号将触发一个事件，用于系统内部的其他功能模块，如低功耗模式下的唤醒。</li>
</ul>
<ol start="7">
<li><strong>事件产生</strong>：</li>
</ol>
<ul>
<li>事件产生模块在满足边沿检测条件时产生事件。事件不同于中断，它不会直接引发 NVIC 的中断请求，而是用于系统的其他用途，比如唤醒单元等。</li>
</ul>
<ol start="8">
<li><strong>至 NVIC</strong>：</li>
</ol>
<ul>
<li>如果边沿检测模块检测到外部信号符合设定的条件，并且中断屏蔽控制允许，则通过 NVIC 触发中断服务程序。</li>
</ul>
<ol start="9">
<li><strong>至唤醒单元</strong>：</li>
</ol>
<ul>
<li>如果边沿检测满足条件且事件屏蔽控制允许，则可以触发事件产生，用于唤醒单元。</li>
<li>该功能主要在低功耗模式下使用，用于处理待机或睡眠模式下的唤醒需求。</li>
</ul>
<blockquote>
<p>中断和事件是独立控制的，可以通过配置相应的寄存器来独立启用或屏蔽中断和事件。</p>
<ul>
<li>若只开启中断屏蔽而屏蔽事件，则只会产生中断，不会产生事件。</li>
<li>若只开启事件屏蔽而屏蔽中断，则只会产生事件，不会产生中断。</li>
<li>若同时开启中断和事件屏蔽，那么信号变化时会同时产生中断和事件。</li>
</ul>
</blockquote>
<p><strong>EXTI 编号与触发源</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407EXTIchufayuan.png" alt="F407EXTIchufayuan"></p>
<h3 id="NVIC-1"><a href="#NVIC-1" class="headerlink" title="NVIC"></a>NVIC</h3><p>NVIC 是处理器核心中的一个模块，负责<strong>接收和管理中断请求</strong>。它可以将多个中断请求进行排序，按优先级分配中断，决定何时和以何种优先级响应中断。</p>
<p><strong>中断向量表</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407NVICbiao.png" alt="F407NVICbiao"></p>
<p><strong>示例流程</strong></p>
<p>假设一个按键连接到 GPIO 引脚，用来触发 EXTI 中断，流程如下：</p>
<ol>
<li><strong>EXTI 监测按键状态</strong>，检测到按键按下，生成一个中断请求并将其发送到 NVIC。</li>
<li><strong>NVIC 检查优先级</strong>：如果该中断优先级足够高，NVIC 将立即响应此请求，暂停其他任务。</li>
<li><strong>执行中断服务程序</strong>：系统进入按键中断服务程序（ISR）进行处理，如记录按键状态或执行相应的功能。</li>
<li><strong>清除中断标志</strong>：在 ISR 中处理完毕后，清除 EXTI 的中断标志，以便下一次按键按下时可以重新触发中断。</li>
<li><strong>恢复正常运行</strong>：NVIC 将控制权交还给主程序或其他正在运行的任务。s</li>
</ol>
<h3 id="SYSCFG"><a href="#SYSCFG" class="headerlink" title="SYSCFG"></a>SYSCFG</h3><p>SYSCFG（系统配置控制器）是 ARM Cortex-M 微控制器（如 STM32 系列）中的一个重要外设，负责配置系统的各种功能和引导外设的资源管理。</p>
<p><strong>外部中断配置</strong></p>
<ul>
<li><strong>引脚映射</strong>：SYSCFG 允许将外部 GPIO 引脚映射到 EXTI（外部中断）线。用户可以指定哪些引脚用于外部中断触发。</li>
<li><strong>中断触发条件</strong>：支持设置中断触发条件（上升沿、下降沿、双边沿），以满足不同应用的需求。</li>
</ul>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p>MISC 是对嵌套向量中断控制器（NVIC）和系统定时器（SysTick）操作的软件包。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>功能：通过外部中断监听按钮按下和抬起的动作</p>
<h4 id="硬件触发"><a href="#硬件触发" class="headerlink" title="硬件触发"></a>硬件触发</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GPIO 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTI_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//启用GPIOA外部时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	<span class="comment">// 配置GPIO工作模式为复用模式</span></span><br><span class="line">	gpio_mode_set(GPIOA, GPIO_MODE_INPUT, GPIO_PUPD_NONE, GPIO_PIN_0);</span><br><span class="line">	<span class="comment">// 选择复用哪一个模式，这时候就需要去查看 中断不需要进行复用选择</span></span><br><span class="line">	<span class="comment">//gpio_af_set(GPIOA, uint32_t alt_func_num, uint32_t pin);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 我们要使用外部中断功能，但是在端口复用配置中，却没有外部中断这个复用选项</span></span><br><span class="line">	<span class="comment">// 所以我们需要用其他的方法将这个引脚映射到 EXTI 上</span></span><br><span class="line">	<span class="comment">// 这里就要使用系统提供的配置工作：SYSCFG（系统配置控制器）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 任何配置前我们先要配置时钟，我们用到的功能是 EXTI，但是 EXTI 的功能依赖于 SYSCFG 的配置</span></span><br><span class="line">	<span class="comment">// 所以我们要先配置 SYSCFG 的时钟，我们通过 SYSCFG 将 GPIO 映射到 EXTI</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 启用RCU_SYSCFG外部时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_SYSCFG);	</span><br><span class="line">	<span class="comment">// 将引脚映射到 EXTI</span></span><br><span class="line">	syscfg_exti_line_config(EXTI_SOURCE_GPIOA, EXTI_SOURCE_PIN0);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 中断处理需要用到 NVIC 所以还需要配置 NVIC</span></span><br><span class="line">	<span class="comment">// 使能 NIVC 请求，是来自什么的中断处理，优先级是什么样的</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 配置 EXIT，那个外部中断寄存器、是中断还是事件、触发方式是什么</span></span><br><span class="line">    <span class="comment">// 中断触发源</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_BOTH);</span><br><span class="line">	<span class="comment">// 使能外部中断</span></span><br><span class="line">	exti_interrupt_enable(EXTI_0);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写外部中断处理函数</span></span><br><span class="line"><span class="comment">// 查找初始化文件，找到 EXTI0 的中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="keyword">if</span>(SET == exti_interrupt_flag_get(EXTI_0)) &#123;</span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hi,chulihanshu\n&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">	GPIO_EXTI_Config();	</span><br><span class="line">	EXTI_Config();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">============================================================================</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="comment">// 这是用户要做的事情    </span></span><br><span class="line"><span class="type">void</span> EXTI0_Callback(USART0_KEY_STATE state) &#123;</span><br><span class="line">	<span class="keyword">if</span>(state) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;DOWN\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;UP\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 将用户的操作作为参数传递过去</span></span><br><span class="line">bsp_EXTI0_Callback(EXTI0_Callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bsp_exti0.c</span></span><br><span class="line"><span class="comment">// 我们定义一个函数指针类型的变量，并初始化为 NULL;</span></span><br><span class="line"><span class="type">void</span> (*p_Callback)(USART0_KEY_STATE state) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 我们通过上面的这个变量接收用户传递过来的参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bsp_EXTI0_Callback</span><span class="params">(<span class="type">void</span> (*p)(USART0_KEY_STATE state))</span>	&#123;</span><br><span class="line">	</span><br><span class="line">	p_Callback = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中断处理函数里面调用客户传过来的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="keyword">if</span>(SET == exti_interrupt_flag_get(EXTI_0)) &#123;</span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		<span class="comment">// 我们不去帮用户做决定，让用户自己决定要干什么</span></span><br><span class="line">		<span class="keyword">if</span>(SET == gpio_input_bit_get(GPIOA, GPIO_PIN_0)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(p_Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				p_Callback(DOWN);</span><br><span class="line">			&#125; 				</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(p_Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				</span><br><span class="line">				p_Callback(UP);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">=========================================================================</span><br><span class="line"> <span class="comment">// 软件消抖</span></span><br><span class="line"><span class="comment">//1. 延时，手动减少中断函数响应的次数</span></span><br><span class="line"><span class="type">void</span> EXTI0_IRQHandler(<span class="type">void</span>) &#123;	</span><br><span class="line">	<span class="keyword">if</span>(SET == exti_interrupt_flag_get(EXTI_0)) &#123;</span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		<span class="comment">// 我们不去帮用户做决定，让用户自己决定要干什么</span></span><br><span class="line">		<span class="keyword">if</span>(SET == gpio_input_bit_get(GPIOA, GPIO_PIN_0)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(p_Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				p_Callback(DOWN);</span><br><span class="line">			&#125; 				</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(p_Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				</span><br><span class="line">				p_Callback(UP);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">    delay_1ms(<span class="number">50</span>);</span><br><span class="line">&#125;  </span><br><span class="line">===============================================================</span><br><span class="line"><span class="comment">// 2.通过计数的方式来进行消抖</span></span><br><span class="line"><span class="comment">// 我们知道系统是通过滴答时钟来进行计数的</span></span><br><span class="line"><span class="type">void</span> delay_1ms(<span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delay = count * <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">        delay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过上面这个不难看出，他的 50ms 记时是通过在 delay_decrement 中 delay-- 实现的；</span></span><br><span class="line"><span class="comment">// 也就是说 delay_decrement 这个函数调用一次就是 1ms，那我们可以通过这个函数的调用来计时</span></span><br><span class="line"><span class="comment">// 但是 ms 的时间太长了，我们需要 us 的时间，这里我们就需要将时间进行细化</span></span><br><span class="line"><span class="comment">// 我们在 main() 中通过 systick_config() 函数可以看到：</span></span><br><span class="line"><span class="comment">// SystemCoreClock 就是我们之前的外部高速晶振 8000000Hz</span></span><br><span class="line"><span class="comment">// 通过 SysTick_Config(SystemCoreClock / 1000U) 这个函数可以定时触发异常</span></span><br><span class="line"><span class="comment">// 这里我们看到它默认是 1000Hmz 也就是 1ms,</span></span><br><span class="line"><span class="comment">// 我们需要将其改为 1us 也就是除以 1000000u</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* setup systick timer for 1000Hz interrupts  */</span></span><br><span class="line">    <span class="keyword">if</span>(SysTick_Config(SystemCoreClock / <span class="number">1000U</span>)) &#123;</span><br><span class="line">        <span class="comment">/* capture error */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure the systick handler priority */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, <span class="number">0x00</span>U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改为=============================================</span></span><br><span class="line"><span class="comment">// 这样它就会在 1us 触发一次他的中断库函数 SysTick_Handler</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">systick_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* setup systick timer for 1000Hz interrupts  */</span></span><br><span class="line">    <span class="keyword">if</span>(SysTick_Config(SystemCoreClock / <span class="number">1000000U</span>)) &#123;</span><br><span class="line">        <span class="comment">/* capture error */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* configure the systick handler priority */</span></span><br><span class="line">    NVIC_SetPriority(SysTick_IRQn, <span class="number">0x00</span>U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到他的函数就是调用了 delay_decrement 也就是 1us 调用一次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    led_spark();</span></span><br><span class="line">    delay_decrement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时候我们就可以进行如下修改：</span></span><br><span class="line"><span class="type">uint64_t</span> delay = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这样 cnt 就是 us</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_decrement</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cnt ++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">        delay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过函数返回 us 的时间</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">get_us</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cnt;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1us</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1us</span><span class="params">(<span class="type">uint32_t</span> count)</span> &#123;</span><br><span class="line">    delay = count * <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1ms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_1ms</span><span class="params">(<span class="type">uint32_t</span> count)</span>&#123;</span><br><span class="line">    delay = count * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0U</span> != delay) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================================================</span><br><span class="line"><span class="comment">// 这样就可以将中断函数改为如下</span></span><br><span class="line"><span class="comment">// 该函数只会在 100us 触发一次</span></span><br><span class="line"><span class="type">uint64_t</span> pre_cnt <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;	</span><br><span class="line">	<span class="keyword">if</span>(SET == exti_interrupt_flag_get(EXTI_0)) &#123;</span><br><span class="line">        <span class="comment">// 只能放在上面，否则不管是放在 if里面还是后面都会产生 bug</span></span><br><span class="line">        exti_interrupt_flag_clear(EXTI_0);      </span><br><span class="line">        <span class="comment">// 100us 让他执行一次</span></span><br><span class="line">        <span class="comment">// 函数不会阻塞，让他 100us 执行一次</span></span><br><span class="line">        <span class="comment">// 按键物理抖动通常在 5ms 到 50ms 之间，</span></span><br><span class="line">        <span class="type">uint64_t</span> cur_cnt = get_us();</span><br><span class="line">        <span class="keyword">if</span>(cur_cnt - pre_cnt &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_cnt = cur_cnt;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 我们不去帮用户做决定，让用户自己决定要干什么</span></span><br><span class="line">		<span class="keyword">if</span>(SET == gpio_input_bit_get(GPIOA, GPIO_PIN_0)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(p_Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				p_Callback(DOWN);</span><br><span class="line">			&#125; 				</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(p_Callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				</span><br><span class="line">				p_Callback(UP);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li><strong>GPIO 的配置</strong></li>
</ol>
<ul>
<li>主要外部中断不在 GPIO的复用选项中，我们需要通过其他方式将 GPIO 映射到 EXIT。</li>
</ul>
<ol start="2">
<li><strong>EXTI 配置</strong></li>
</ol>
<ul>
<li>GPIO 配置完成后，查看用户手册了解所使用的引脚属于那个中断源</li>
<li>使能 SYSCFG 外部时钟，将 GPIO 引脚映射到 EXTI</li>
<li>配置 NVIC</li>
<li>配置 EXIT，并使能</li>
</ul>
<ol start="3">
<li><strong>编写中断处理函数</strong></li>
</ol>
<ul>
<li>NVIC 所对应的中断处理函数要到启动文件（.s）文件中去找</li>
<li>在编写时候注意查看用户手册，了解我们所使用的的中断源是否需要手动清除；</li>
</ul>
<h4 id="软件触发"><a href="#软件触发" class="headerlink" title="软件触发"></a>软件触发</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数在 USART 的中断处理函数中进行调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart0_recv</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\r\n&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    exti_software_interrupt_enable(EXTI_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTI_config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> extix = EXTI_0; <span class="comment">// 哪个中断</span></span><br><span class="line">    <span class="type">uint32_t</span> extix_irq = EXTI0_IRQn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********************* EXTI config *********************/</span></span><br><span class="line">    <span class="comment">// 时钟配置</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_SYSCFG);</span><br><span class="line">    <span class="comment">// 中断初始化 因为是软件触发所以触发源就不需要选择上升或者下降沿了</span></span><br><span class="line">    exti_init(extix, EXTI_INTERRUPT, EXTI_TRIG_NONE);</span><br><span class="line">    <span class="comment">// 配置中断优先级</span></span><br><span class="line">    nvic_irq_enable(extix_irq, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使能中断</span></span><br><span class="line">    exti_interrupt_enable(extix);</span><br><span class="line">    <span class="comment">// 清除中断标志位</span></span><br><span class="line">    exti_interrupt_flag_clear(extix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IRQ \r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(SET == exti_interrupt_flag_get(EXTI_0)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exti 0 \r\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 清除中断标志位</span></span><br><span class="line">        exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UART0 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 有数据了</span></span><br><span class="line">	<span class="keyword">if</span>(SET == usart_interrupt_flag_get(USART0, USART_INT_FLAG_RBNE)) &#123;</span><br><span class="line">		usart_interrupt_flag_clear(USART0, USART_INT_FLAG_RBNE);		</span><br><span class="line">		<span class="type">int8_t</span> data =  usart_data_receive(USART0);		</span><br><span class="line">		dataBuf[index] = data;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(SET == usart_interrupt_flag_get(USART0, USART_INT_FLAG_IDLE)) &#123;</span><br><span class="line">        <span class="comment">// 清除 LDLE 中断标志位</span></span><br><span class="line">        <span class="comment">// 软件先读USART_STAT0，再读USART_DATA可清除该位。</span></span><br><span class="line">        <span class="comment">// usart_interrupt_flag_get 读取的就是 USART_STAT0 寄存器中的标志位</span></span><br><span class="line">        <span class="comment">// USART_STAT0 是状态寄存器，USART_DATA 为数据寄存器</span></span><br><span class="line">		usart_data_receive(USART0); <span class="comment">// 读数据寄存器，以清除 LDLE 中断标志位</span></span><br><span class="line">        <span class="comment">// 通过这个函数去调用 EXTI 的软件触发函数</span></span><br><span class="line">        Usart0_recv(dataBuf, index);        </span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">    Usart0_init();</span><br><span class="line">    EXTI_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一·、<strong>在使用 EXTI 与 NVIC 时为什么不需要显示的开启外部时钟</strong></p>
<p>因为这两个模块的工作原理和时钟管理与外部时钟的启用无关。</p>
<p>EXTI 是用于处理外部硬件事件（如按键、传感器、外部信号等）触发的中断。它本质上是一个由外部事件触发的信号，依赖于微控制器的输入引脚（如 GPIO）上的状态变化。</p>
<p>NVIC 本身并不依赖于外部时钟。NVIC 只是处理从不同外设或外部事件（如 EXTI）发出的中断请求。它的作用是管理中断的优先级、响应时间以及是否允许中断等，所有这些操作都基于内部时钟（通常是系统时钟或 APB 时钟）。所以，NVIC 与外部时钟并无直接关系。</p>
<p>二、<strong>通过计数消抖这时间如何确定</strong></p>
<p>以波特率为 <strong>115200 bps</strong> 为例，假设数据帧格式为<strong>1 位起始位 + 8 位数据位 + 1 位停止位</strong>，总共 <strong>10 位</strong>：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407RTCfpjissf.png" alt="F407RTCfpjissf"></p>
<p>也就是说我们延时的时间比这个大就可以了；</p>
<p>三、<strong>exti_interrupt_flag_clear(EXTI_0);，可能会产生的bug</strong></p>
<p>当凑巧我们按下的时候 EXTI0_IRQHandler 中的条件 cur_cnt - pre_cnt &lt;&#x3D; 100 为真时，函数会直接 return，而 <strong>在返回前没有清除 EXTI 的中断标志位</strong>。在这种情况下，<strong>该中断标志位依然保持为 1</strong>，因此后续也不会再触发相同的中断。</p>
<p>因此我们应该在进入中断后第一时间清除标志位；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>充电指示灯</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E5%85%85%E7%94%B5%E6%8C%87%E7%A4%BA%E7%81%AF/</url>
    <content><![CDATA[<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>在嵌入式开发中，<strong>状态机</strong>（State Machine）是一种编程模式，用来管理系统的不同状态及其转换逻辑。状态机通过分解复杂的控制逻辑，将系统的不同行为划分为独立的状态，每个状态定义在特定条件下如何转移到其他状态。这种模式广泛应用于嵌入式系统，因为它能够简化复杂的流程控制和事件处理，便于理解和维护。</p>
<p>因为无法使用中断和多任务模式，为了保证程序在顺序执行的时候，不会一直阻塞在 LED 延时闪烁的代码中，我们这里使用状态机的方式来进行功能模拟；</p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    功能：模拟设备充电时候充电指示灯闪烁的情况，以四格电为例：  </span></span><br><span class="line"><span class="comment">        0%-25% 四个灯依次亮起</span></span><br><span class="line"><span class="comment">        25%~50% 第一个亮起，其他三个依次闪烁</span></span><br><span class="line"><span class="comment">        50%~75% 第一二个亮起，其他两个依次闪烁</span></span><br><span class="line"><span class="comment">        75%~100% 第一二三亮起，最后一个闪烁</span></span><br><span class="line"><span class="comment">        100%   四个灯亮起不闪烁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当前使用独立按键进行模拟，key1按下表示充电，key2按下表示电量递增，key3表示断开充电  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用状态机的思维进行开发：</span></span><br><span class="line"><span class="comment">    因为按照正常的显示逻辑，在灯进行显示和闪烁的时候按钮的功能将会被阻塞</span></span><br><span class="line"><span class="comment">    因此，我们通过将延时拆分为更细小的时间片从而保证可以轮询检查按键而不是阻塞在LED灯的显示里  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">===================================================================================</span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx_gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx_rcu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO_LED_Driver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;battery_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机的状态 0（默认）开始充电</span></span><br><span class="line"><span class="comment">// 1 表示电量增加</span></span><br><span class="line"><span class="comment">// 2 表示移除充电器</span></span><br><span class="line"><span class="type">int8_t</span> battery_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KEY 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_KEY_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line"></span><br><span class="line">    gpio_mode_set(GPIOC, GPIO_MODE_INPUT, GPIO_PUPD_PULLUP, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">    \brief      按键状态处理</span></span><br><span class="line"><span class="comment">    \param[in]  key_flag: 用于按键消抖</span></span><br><span class="line"><span class="comment">                key_input：哪个按键</span></span><br><span class="line"><span class="comment">                battery_state：状态机控制变量</span></span><br><span class="line"><span class="comment">                state_value: 状态机状态:0电量显示，1电量增加，2关闭显示</span></span><br><span class="line"><span class="comment">    \param[out] none</span></span><br><span class="line"><span class="comment">    \retval     none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_key_state</span><span class="params">(<span class="type">int8_t</span> *key_flag, FlagStatus key_input, <span class="type">int8_t</span> *battery_state, <span class="type">int8_t</span> state_value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key_input == RESET &amp;&amp; *key_flag) &#123;</span><br><span class="line">        *key_flag = <span class="number">0</span>;</span><br><span class="line">        *battery_state = state_value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key_input == SET &amp;&amp; *key_flag == <span class="number">0</span>) &#123;</span><br><span class="line">        *key_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    systick_config();	</span><br><span class="line">	battery_led_Init();	</span><br><span class="line">    GPIO_KEY_Config();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防抖</span></span><br><span class="line">    <span class="type">int8_t</span> key1_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int8_t</span> key2_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int8_t</span> key3_flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延时控制</span></span><br><span class="line">    <span class="type">int32_t</span> time_Control = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Key1Flag 模拟插上开始充电</span></span><br><span class="line">        <span class="comment">// Key2Flag 模拟电量增加</span></span><br><span class="line">        <span class="comment">// Key3Flag 模拟移除充电器</span></span><br><span class="line">        FlagStatus Key1 =  gpio_input_bit_get(GPIOC, GPIO_PIN_0);</span><br><span class="line">        FlagStatus Key2 =  gpio_input_bit_get(GPIOC, GPIO_PIN_1);</span><br><span class="line">        FlagStatus Key3 =  gpio_input_bit_get(GPIOC, GPIO_PIN_2);</span><br><span class="line"></span><br><span class="line">        update_key_state(&amp;key1_flag, Key1, &amp;battery_state, <span class="number">0</span>);</span><br><span class="line">        update_key_state(&amp;key2_flag, Key2, &amp;battery_state, <span class="number">1</span>);</span><br><span class="line">        update_key_state(&amp;key3_flag, Key3, &amp;battery_state, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 灯闪烁时间为 0.5S</span></span><br><span class="line">        <span class="keyword">if</span>(time_Control &lt; <span class="number">20</span>) &#123;</span><br><span class="line">             delay_1ms(<span class="number">25</span>); </span><br><span class="line">             time_Control++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            time_Control = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 状态机处理函数</span></span><br><span class="line">            battery_machine_handle(&amp;battery_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">============================================================================</span><br><span class="line"><span class="comment">// battery_led.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;battery_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式传过来的电量百分比默认 26%</span></span><br><span class="line"><span class="type">int8_t</span> battery = <span class="number">26</span>; </span><br><span class="line"><span class="type">int8_t</span> batteryNum = <span class="number">0</span>; </span><br><span class="line"><span class="type">int8_t</span> flowNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">battery_led_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	leds_switch_Init();</span><br><span class="line">	leds_switch_open();	</span><br><span class="line">    leds_driver_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量与闪烁,0点亮1灭</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_led_state</span><span class="params">(<span class="type">int</span> flowNum)</span> &#123;</span><br><span class="line">    bsp_led_write(GPIOD, GPIO_PIN_8, flowNum &gt; <span class="number">0</span> ? RESET : SET);</span><br><span class="line">    bsp_led_write(GPIOD, GPIO_PIN_9, flowNum &gt; <span class="number">1</span> ? RESET : SET);</span><br><span class="line">    bsp_led_write(GPIOD, GPIO_PIN_10, flowNum &gt; <span class="number">2</span> ? RESET : SET);</span><br><span class="line">    bsp_led_write(GPIOD, GPIO_PIN_11, flowNum &gt; <span class="number">3</span> ? RESET : SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">battery_machine_handle</span><span class="params">(<span class="type">int8_t</span>* battery_state)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// batteryNum 表示长量几格 总共四格电</span></span><br><span class="line">    batteryNum = battery / <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">switch</span> (*battery_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            battery += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(battery &gt;= <span class="number">100</span>) &#123;battery = <span class="number">100</span>;&#125;</span><br><span class="line">			*battery_state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span>(flowNum &gt; <span class="number">4</span>) &#123;flowNum = batteryNum;&#125;</span><br><span class="line">            set_led_state(flowNum);</span><br><span class="line">            flowNum++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            bsp_leds_close_all();	</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">================================================================</span><br><span class="line"><span class="comment">// GPIO_LED_Driver.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GPIO_LED_Driver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个LED初始化 核心配置:时钟 端口 引脚编号</span></span><br><span class="line">LED_PARAM leds[] = &#123;</span><br><span class="line">	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_8&#125;,</span><br><span class="line">	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_9&#125;,</span><br><span class="line">	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_10&#125;,</span><br><span class="line">	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_11&#125;,</span><br><span class="line"><span class="comment">//	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_12&#125;,</span></span><br><span class="line"><span class="comment">//	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_13&#125;,</span></span><br><span class="line"><span class="comment">//	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_14&#125;,</span></span><br><span class="line"><span class="comment">//	&#123;RCU_GPIOD,GPIOD,GPIO_PIN_15&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="type">uint8_t</span> len = <span class="keyword">sizeof</span>(leds)/<span class="keyword">sizeof</span>(leds[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化总开关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_switch_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_mode_set(GPIOC, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO_PIN_6);</span><br><span class="line">	gpio_output_options_set(GPIOC, GPIO_OTYPE_OD, GPIO_OSPEED_MAX, GPIO_PIN_6);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个引脚初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_pin_config</span><span class="params">(rcu_periph_enum rcu,<span class="type">uint32_t</span> port,<span class="type">uint32_t</span> pin)</span>&#123;</span><br><span class="line">	rcu_periph_clock_enable(rcu);</span><br><span class="line">	gpio_mode_set(port, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, pin);</span><br><span class="line">	gpio_output_options_set(port, GPIO_OTYPE_PP, GPIO_OSPEED_MAX, pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_driver_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		LED_PARAM led = leds[i];</span><br><span class="line">		led_pin_config(led.rcu,led.port,led.pin);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 初始化默认关闭LED</span></span><br><span class="line">		gpio_bit_set(led.port,led.pin);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开总开关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_switch_open</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	gpio_bit_reset(GPIOC,GPIO_PIN_6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭总开关</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_switch_close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	gpio_bit_set(GPIOC,GPIO_PIN_6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点亮某一个灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_open</span><span class="params">(LED led)</span>&#123;</span><br><span class="line">	gpio_bit_reset(leds[led].port,leds[led].pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭某一个灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_close</span><span class="params">(LED led)</span>&#123;</span><br><span class="line">	gpio_bit_set(leds[led].port,leds[led].pin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点亮所有灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">leds_open_all</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">		LED_PARAM led = leds[i];</span><br><span class="line">		gpio_bit_reset(led.port,led.pin);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭所有灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bsp_leds_close_all</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		LED_PARAM led = leds[i];</span><br><span class="line">		gpio_bit_set(led.port,led.pin);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入一个 0 或者 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bsp_led_write</span><span class="params">(<span class="type">uint32_t</span> gpio_periph, <span class="type">uint32_t</span> pin, bit_status bit_value)</span>&#123;</span><br><span class="line">	gpio_bit_write(gpio_periph, pin, bit_value);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>总线与时钟</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E6%80%BB%E7%BA%BF%E4%B8%8E%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<h2 id="AHB-总线"><a href="#AHB-总线" class="headerlink" title="AHB 总线"></a>AHB 总线</h2><p>AHB（Advanced High-performance Bus）是一种在 ARM 体系结构中广泛使用的<strong>高性能总线标准</strong>，主要用于连接各种处理器和外设。它是 AMBA（Advanced Microcontroller Bus Architecture）的一部分，AMBA 是 ARM 设计的总线标准，用于<strong>增强不同模块之间的通信</strong>。</p>
<p>AMBA 架构通过不同的总线协议（AXI、AHB、APB、ACE 和 ATB），提供了从高带宽、高性能的数据传输到低功耗、简单控制的各种通信方式。设计师可以根据具体应用的需求，选择适合的总线类型，以优化性能、功耗和系统复杂度。</p>
<h3 id="GD32F407xx-微控制器框图"><a href="#GD32F407xx-微控制器框图" class="headerlink" title="GD32F407xx 微控制器框图"></a>GD32F407xx 微控制器框图</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407weikongzhiqikuangtu.png" alt="F407weikongzhiqikuangtu"></p>
<p>模块分析：</p>
<p>1.<strong>ARM Cortex-M4 Processor</strong></p>
<ul>
<li><strong>处理器核心</strong>，最高频率为 <strong>168MHz</strong>，负责执行代码和处理数据。</li>
<li><strong>TPIU</strong>：核心支持 <strong>JTAG&#x2F;SWD</strong> 调试接口，便于调试和编程。<ul>
<li>TPIU（Trace Port Interface Unit）是一种用于调试和追踪的接口单元。它可以将处理器的调试和追踪信息输出到外部调试器或分析仪中，以帮助开发人员进行软件调试和性能分析。</li>
</ul>
</li>
<li>通过 <strong>AHB（Advanced High-performance Bus）</strong> 总线与其他模块相连，AHB 最大频率也为 <strong>168MHz</strong>。</li>
</ul>
<p>2.<strong>存储器模块</strong></p>
<ul>
<li>包括 <strong>Flash Memory</strong>（闪存）、<strong>SRAM0</strong>、<strong>SRAM1</strong> 和 <strong>TCMSRAM</strong>，用于存储程序代码、数据和高速缓存。</li>
<li><strong>FMC（Flash Memory Controller）</strong> 用于控制闪存的访问。</li>
</ul>
<p>3.<strong>DMA（Direct Memory Access）控制器</strong></p>
<ul>
<li>包括 <strong>DMA0</strong> 和 <strong>DMA1</strong>，用于在外设和存储器之间进行数据传输，而不占用处理器资源。</li>
<li>通过 <strong>AHB总线</strong> 直接访问存储器和外设。</li>
</ul>
<p>4.<strong>外设接口</strong></p>
<ul>
<li>包括 <strong>USBHS</strong>、<strong>ENET（以太网接口）</strong> 和 <strong>EXMC（外部存储控制器）</strong>，可以连接外部设备和网络。</li>
<li><strong>AHB1外设</strong>和<strong>AHB2外设</strong>通过 <strong>AHB接口矩阵</strong>连接主总线，这些外设包括 <strong>GPIO</strong>（通用输入输出）、<strong>CRC</strong>（循环冗余校验）、<strong>BKP SRAM</strong>（备用SRAM）、<strong>TRNG</strong>（真随机数生成器）、<strong>DCI</strong>（数字摄像接口）等。</li>
</ul>
<p>5.<strong>APB总线（Advanced Peripheral Bus）</strong></p>
<ul>
<li><strong>APB1 和 APB2</strong> 两条总线用于连接相对低速的外设。</li>
<li><strong>APB1</strong> 包括 <strong>UART、I2C、SPI</strong> 等串行通信接口、<strong>I2S</strong> 音频接口以及定时器（TIMER）等。</li>
<li><strong>APB2</strong> 连接 <strong>ADC</strong>（模数转换器）、<strong>SPI0</strong>、<strong>USART</strong>、<strong>SDIO</strong>（SD卡接口）等外设模块。</li>
</ul>
<p>6.<strong>电源管理模块</strong></p>
<ul>
<li>包括 <strong>LDO</strong>（低压差稳压器）、<strong>PMU</strong>（电源管理单元）、<strong>POR&#x2F;PDR</strong>（上电复位&#x2F;掉电复位）等，用于管理芯片的电源供应和复位。</li>
<li>支持多个电源域，以降低功耗并提供稳定的电源管理。</li>
</ul>
<p>7.<strong>时钟和振荡器</strong></p>
<ul>
<li>包括 <strong>HXTAL</strong>（高频晶振）、<strong>LXTAL</strong>（低频晶振）、<strong>IRC16M</strong>（16MHz内部时钟）和 <strong>IRC32K</strong>（32kHz内部时钟）。</li>
<li>时钟树由 <strong>RCU</strong>（复位和时钟控制器）负责，生成整个系统所需的时钟信号，支持多种时钟源和分频选项。</li>
</ul>
<p>8.<strong>其他模块</strong></p>
<ul>
<li><strong>SAR ADC</strong>（逐次逼近模数转换器）：用于模拟信号的采集和转换。</li>
<li><strong>DAC</strong>（数模转换器）：将数字信号转换为模拟信号。</li>
<li><strong>LVD</strong>（低电压检测）：用于监控系统电压是否在安全范围内。</li>
<li><strong>RTC</strong>（实时时钟）：用于时间和日期的管理。</li>
</ul>
<p>9.<strong>AHB和APB总线接口矩阵</strong></p>
<ul>
<li>主要通过 <strong>AHB总线矩阵</strong> 和 <strong>APB总线接口</strong> 将不同的外设模块连接到主总线上，从而实现灵活的数据传输。</li>
<li>AHB总线用于高速外设和存储器，APB总线用于较低速的外设。</li>
</ul>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>在 ARM Cortex-M 微控制器（例如 ARM32 架构）中，时钟系统是核心模块之一，负责为整个系统和各个外设提供时钟信号。时钟信号是微控制器正常运行的基础，时钟系统通常包括多个时钟源、分频器和控制模块。</p>
<p>在 ARM 微控制器中，几乎每个操作都需要一个时钟信号来驱动。这是因为时钟信号在微控制器中用于同步操作，确保每一步执行都有明确的时间基准。</p>
<h3 id="GD32F407xx-时钟树结构图"><a href="#GD32F407xx-时钟树结构图" class="headerlink" title="GD32F407xx 时钟树结构图"></a>GD32F407xx 时钟树结构图</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407shizhongsujiegoutu.png" alt="F407shizhongsujiegoutu"></p>
<p>详细介绍：</p>
<p>1.<strong>时钟源</strong></p>
<ul>
<li><strong>外部时钟（HXTAL）</strong>：这是一个高频晶振输入，通常可以在 4 到 32 MHz 之间。它被用作系统主时钟的外部来源。</li>
<li><strong>内部振荡器（IRC16M 和 IRC48M）</strong>：这是微控制器内部集成的振荡器，IRC16M 提供 16 MHz 时钟源，而 IRC48M 提供 48 MHz 的固定时钟源。</li>
<li><strong>低速时钟源（LXTAL 和 IRC32K）</strong>：32.768 kHz 的外部低速晶振（LXTAL）和内部 32 kHz 的低速振荡器（IRC32K）用于实时时钟（RTC）和看门狗定时器（FWDGT）等低功耗应用。</li>
</ul>
<p>2.<strong>锁相环（PLL）</strong></p>
<ul>
<li><strong>PLL 电路</strong>：有多个 PLL（如 PLL、PLL1、PLL2 等）可以将外部时钟（HXTAL）或内部时钟（如 IRC16M）倍频到更高频率。它们用于生成系统所需的高频时钟，比如 168 MHz 的主系统时钟。</li>
<li><strong>PLL 配置</strong>：图中显示了 PLL 的输入、输出及其倍频系数选择。不同的倍频系数可以让用户灵活设置主时钟的频率。</li>
</ul>
<p>3.<strong>时钟选择和分配</strong></p>
<ul>
<li><strong>系统时钟选择（CK_SYS）</strong>：系统时钟可以由不同的源（如 PLL 输出、HXTAL、IRC16M 等）选择得到。通过 <code>SCS[1:0]</code> 选择信号，可以在这些时钟源之间切换，以适应不同的应用需求。</li>
<li><strong>AHB、APB1、APB2 分频器</strong>：时钟树包含了 AHB 和两个 APB 总线的分频器，允许将系统时钟分别分配到不同的外设总线。这些总线频率可以通过预分频器调节，以满足外设的时钟要求。APB1 最多支持 42 MHz，而 APB2 最多支持 84 MHz。</li>
</ul>
<p>4.<strong>特殊外设时钟</strong></p>
<ul>
<li><strong>USB、SDIO、ADC 等外设时钟</strong>：有些外设（如 USB 和 ADC）对时钟有特定的要求。USB 需要 48 MHz 时钟，因此会使用 IRC48M 或通过 PLL 分频得到。ADC 也有其特定的时钟路径和分频器，以确保符合采样速率要求。</li>
<li><strong>以太网和 I2S 时钟</strong>：以太网 PHY（物理层）和 I2S（音频接口）外设也各有独立的时钟选择，确保它们能够满足高速数据通信的需求。</li>
</ul>
<p>5.<strong>时钟输出和监控</strong></p>
<ul>
<li><strong>时钟输出</strong>：可以通过 CK_OUT0 和 CK_OUT1 引脚将特定的时钟信号输出，以供外部设备使用。这些输出时钟信号可以是 HXTAL、PLL 输出等，具体由 CKOUTDIV 和 CKOUTSEL[1:0] 设置。</li>
<li><strong>时钟监控器（Clock Monitor）</strong>：在 HXTAL 和 PLL 的路径上有一个时钟监控器，用于检测是否有时钟失效的情况（比如晶振失效）。当检测到问题时，系统可以切换到备用的时钟源。</li>
</ul>
<p>6.<strong>RTC 和低功耗时钟</strong></p>
<ul>
<li><strong>RTC（实时时钟）</strong>：图中显示 RTC 可以选择低速外部晶振（LXTAL）或内部 32 kHz 振荡器（IRC32K）作为其时钟源。</li>
<li><strong>看门狗定时器（FWDGT）</strong>：低功耗时钟（IRC32K）还可以提供给看门狗定时器。</li>
</ul>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>电源管理单元</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<p>电源管理单元（Power Management Unit, PMU）是用于管理芯片电源状态、低功耗模式、供电监控以及唤醒功能的重要模块。它通过多个功能和配置选项，使芯片能够平衡性能与功耗需求，非常适合应用于低功耗设计中。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407MPUdygldy.png" alt="F407MPUdygldy"></p>
<h2 id="省电模式"><a href="#省电模式" class="headerlink" title="省电模式"></a>省电模式</h2><p>省电模式是指处理器为了降低功耗而设计的一系列低功耗状态。这些模式通过暂停或关闭处理器的部分功能、时钟信号或供电，来减少功耗，延长设备的电池寿命。</p>
<h3 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h3><p>Sleep mode (Cortex®-M4 with FPU core stopped, peripherals kept running)</p>
<p><strong>描述</strong>：<br>在 <strong>Sleep 模式</strong>中，Cortex®-M4 内核（包括浮点单元 FPU）停止运行，但外设和时钟继续运行。此模式适合需要外设保持活跃、但允许处理器暂停任务的场景。</p>
<p>任何唤醒事件都可以唤醒系统（如果SEVONPEND 为1，任何中断都可以唤醒系统，请参考Cortex®-M4技术手册）。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>CPU 停止工作</strong>：通过执行 WFI（Wait For Interrupt） 或 WFE（Wait For Event）指令进入。</li>
<li><strong>外设继续运行</strong>：所有启用的外设（如 UART、I2C、ADC 等）保持正常工作。</li>
<li><strong>快速唤醒</strong>：唤醒时间极短，仅需几个时钟周期即可恢复到运行模式。</li>
<li><strong>功耗</strong>：相较运行模式功耗大幅降低，但高于 Stop 和 Standby 模式。</li>
</ul>
<h3 id="深度睡眠模式"><a href="#深度睡眠模式" class="headerlink" title="深度睡眠模式"></a>深度睡眠模式</h3><p>深度睡眠模式又叫停止模式（Stop mode (all clocks are stopped)）</p>
<p><strong>描述</strong>：<br>在 <strong>Stop 模式</strong>中，基于 Cortex®-M4   架构的的所有时钟（包括 1.2 供电域、系统时钟、外设时钟、PLL）都被停止，进入更深层次的低功耗状态。RAM 和寄存器内容会保持不变。</p>
<p>刚退出深度睡眠模式时，IRC16M 被选中作为系统时钟。请注意，如 果 LDO 工作在低功耗模式，那么唤醒时需额外的延时时间。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>所有时钟停止</strong>：主时钟 HCLK、AHB&#x2F;APB 总线时钟以及外设时钟完全停止。</li>
<li><strong>RAM 和寄存器内容保持</strong>：支持从停止模式快速恢复。</li>
<li><strong>低功耗</strong>：相比 Sleep 模式功耗更低。</li>
<li><strong>唤醒方式：</strong><ul>
<li>外部中断（例如：GPIO 引脚或 EXTI）。</li>
<li>RTC 闹钟中断或唤醒计时器。</li>
</ul>
</li>
<li><strong>恢复时间较短</strong>：由于无需重新配置寄存器和时钟，恢复速度比 Standby 模式快。</li>
</ul>
<h3 id="待机模式"><a href="#待机模式" class="headerlink" title="待机模式"></a>待机模式</h3><p>Standby mode (1.2 V domain powered off)</p>
<p><strong>描述</strong>：<br><strong>Standby 模式</strong>是 Cortex®-M4   架构最深度低功耗模式，整个 1.2V 供电区域被断电来达到最低功耗（同时 LDO 和包括 IRC16M、HXTAL 和 PLL 也会被关闭）。此模式下，系统状态信息几乎全部丢失，仅保留备用域供电。</p>
<p>退出待机模式时，会发生上电复位，复位 之后 Cortex®-M4 将从 0x00000000 地址开始执行指令代码。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>核心电源关闭</strong>：1.2 V 电源域（VCORE）完全断电，仅保持备用域供电（如 RTC 和备份寄存器）。</li>
<li><strong>所有时钟停止</strong>：系统所有时钟（包括外设时钟）停止。</li>
<li><strong>数据丢失：</strong><ul>
<li>RAM 和大部分寄存器内容丢失。</li>
<li>仅 RTC 和备用寄存器（Backup Domain）保存数据。</li>
</ul>
</li>
<li><strong>唤醒方式：</strong><ul>
<li>通过外部信号（例如 WKUP 引脚）。</li>
<li>RTC 闹钟。</li>
</ul>
</li>
<li><strong>恢复时间较长</strong>：需要重新初始化所有寄存器和时钟。</li>
</ul>
<blockquote>
<p>在 ARM 架构中，部分处理器内核（如 Cortex-M4 和 Cortex-M7）集成了 FPU，用于高效处理浮点运算，从而提升运算速度并减少处理器负载。</p>
</blockquote>
<h3 id="三种模式对比"><a href="#三种模式对比" class="headerlink" title="三种模式对比"></a>三种模式对比</h3><table>
<thead>
<tr>
<th align="center"><strong>模式</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>功耗</strong></th>
<th align="center"><strong>时钟状态</strong></th>
<th align="center"><strong>内存和寄存器状态</strong></th>
<th align="center"><strong>唤醒时间</strong></th>
<th align="center"><strong>唤醒方式</strong></th>
<th align="center"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Sleep 模式</strong></td>
<td align="center">Cortex®-M4 内核停止，外设和时钟继续运行</td>
<td align="center">较低</td>
<td align="center">系统时钟和外设时钟保持运行</td>
<td align="center">RAM 和寄存器保持</td>
<td align="center">极短（几个时钟周期）</td>
<td align="center">任何中断或事件（如外设中断、GPIO 中断）</td>
<td align="center">系统需快速响应中断，但内核无需持续运行的场景。</td>
</tr>
<tr>
<td align="center"><strong>Stop 模式</strong></td>
<td align="center">所有时钟停止，进入深度低功耗状态</td>
<td align="center">更低</td>
<td align="center">所有系统时钟和外设时钟完全停止</td>
<td align="center">RAM 和寄存器保持</td>
<td align="center">较短</td>
<td align="center">外部中断（如 GPIO、EXTI）、RTC 闹钟</td>
<td align="center">中长时间低功耗待机，需保持内存状态且快速恢复的场景。</td>
</tr>
<tr>
<td align="center"><strong>Standby 模式</strong></td>
<td align="center">核心电源关闭，仅保留备用域供电，达到最低功耗</td>
<td align="center">最低</td>
<td align="center">所有系统时钟和外设时钟停止</td>
<td align="center">RAM 和寄存器丢失，仅备份域保存数据</td>
<td align="center">较长</td>
<td align="center">外部中断（如 WKUP 引脚）、RTC 闹钟</td>
<td align="center">超长时间待机，追求最低功耗且无需保存内存状态的场景。</td>
</tr>
</tbody></table>
<blockquote>
<p>刚退出深度睡眠模式时，IRC16M 被选中作为系统时钟。请注意，如 果 LDO 工作在低功耗模式，那么唤醒时需额外的延时时间。</p>
</blockquote>
<h3 id="WFI-和-WFE-指令"><a href="#WFI-和-WFE-指令" class="headerlink" title="WFI 和 WFE 指令"></a>WFI 和 WFE 指令</h3><p>在 ARM Cortex-M 架构中，<strong>WFI</strong> 和 <strong>WFE</strong> 是两条用于低功耗管理的指令，它们主要用于让处理器进入等待状态，以降低功耗。</p>
<p>不同的进入指令通常对应着不同的换新方式；</p>
<h4 id="WFI"><a href="#WFI" class="headerlink" title="WFI"></a>WFI</h4><ul>
<li><p><strong>WFI</strong> 指令会让处理器进入低功耗状态，直到出现中断请求将其唤醒。</p>
</li>
<li><p>通常用于等待下一次中断的触发。</p>
</li>
</ul>
<p><strong>唤醒条件</strong>：</p>
<ul>
<li>有中断请求时唤醒。</li>
<li>如果中断已被屏蔽，但 SEVONPEND 位设置为 1，也可以唤醒。</li>
</ul>
<p><strong>操作逻辑</strong>：</p>
<ul>
<li>如果没有中断发生，处理器保持休眠；</li>
<li>如果中断发生，处理器退出低功耗模式并执行中断服务程序。</li>
</ul>
<h4 id="WFE"><a href="#WFE" class="headerlink" title="WFE"></a>WFE</h4><ul>
<li><p><strong>WFE</strong> 指令会让处理器进入低功耗状态，直到检测到事件信号。</p>
</li>
<li><p>与 WFI 不同，WFE 不仅可以通过中断唤醒，还可以通过事件唤醒。</p>
</li>
</ul>
<p><strong>唤醒条件</strong>：</p>
<ul>
<li>有中断请求（中断标志置位）。</li>
<li>外部事件或 SEVONPEND 被设置为 1。</li>
</ul>
<p><strong>操作逻辑</strong>：</p>
<ul>
<li>如果事件寄存器为 1，WFE 指令立即返回，事件寄存器清零。</li>
<li>如果事件寄存器为 0，处理器进入低功耗模式，直到事件信号到来。</li>
</ul>
<blockquote>
<p>事件和中断</p>
<p>中断是一种异步信号，通常由外设或内部系统异常触发，用于通知处理器需要立即执行特定任务。</p>
<p>事件是一种同步信号，用于在系统中传递较低优先级的触发信息。事件不会打断处理器的正常工作，而是依靠事件寄存器记录状态。</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;USART0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EXTI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_on_trig</span><span class="params">(exti_line_enum linex)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(linex == EXTI_1)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Key Trig\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_mode</span><span class="params">()</span>&#123;	<span class="comment">// 睡眠模式</span></span><br><span class="line">	<span class="comment">// PMU -&gt; RCU</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_PMU);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sleepmode1\n&quot;</span>);</span><br><span class="line">	<span class="comment">// sleep mode</span></span><br><span class="line">	pmu_to_sleepmode(WFI_CMD);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sleepmode2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deepsleep_mode</span><span class="params">()</span> &#123; <span class="comment">// 深度睡眠模式</span></span><br><span class="line">	<span class="comment">// PMU -&gt; RCU</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_PMU);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;deepsleep 1\n&quot;</span>);</span><br><span class="line">	<span class="comment">// deepsleep</span></span><br><span class="line">	pmu_to_deepsleepmode(PMU_LDO_LOWPOWER, PMU_LOWDRIVER_ENABLE, WFI_CMD);	</span><br><span class="line">	<span class="comment">// 把主频设置回来，当被唤醒后会从此处开始执行</span></span><br><span class="line">	SystemInit();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;deepsleep 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">standby_mode</span><span class="params">()</span>&#123; <span class="comment">// 待机模式	</span></span><br><span class="line">	<span class="comment">// PMU -&gt; RCU</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_PMU);	</span><br><span class="line">	<span class="comment">/* 清理待机模式标记 */</span></span><br><span class="line">	pmu_flag_clear(PMU_FLAG_RESET_STANDBY);	</span><br><span class="line">	<span class="comment">/* 启用唤醒按钮 enable PMU wakeup pin */</span></span><br><span class="line">	pmu_wakeup_pin_enable();	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;standby 1\n&quot;</span>);</span><br><span class="line">	<span class="comment">// standby待机模式</span></span><br><span class="line">	pmu_to_standbymode();	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;standby 2\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART0_on_recv</span><span class="params">(<span class="type">uint8_t</span>* data, <span class="type">uint32_t</span> len)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, data);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span>(data[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x00</span>:	<span class="comment">// 睡眠模式</span></span><br><span class="line">			sleep_mode();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x01</span>:	<span class="comment">// 深度睡眠模式</span></span><br><span class="line">			deepsleep_mode();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x02</span>:	<span class="comment">// 待机模式</span></span><br><span class="line">			standby_mode();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIO_config</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 初始化GPIO PB2</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOB);</span><br><span class="line">	gpio_mode_set(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO_PIN_2);</span><br><span class="line">	gpio_output_options_set(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_MAX, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> i = <span class="number">50000000</span>;	</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;</span><br><span class="line">		__NOP();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  nvic_priority_group_set(NVIC_PRIGROUP_PRE2_SUB2);</span><br><span class="line">  USART0_init();    	</span><br><span class="line">  EXTI_init();    </span><br><span class="line">  GPIO_config();    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Main Init\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;	</span><br><span class="line">		<span class="comment">// 让PB2切换亮灭</span></span><br><span class="line">		gpio_bit_toggle(GPIOB, GPIO_PIN_2);</span><br><span class="line">		<span class="comment">// 使用自己的睡眠函数</span></span><br><span class="line">		delay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>看门狗</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    <content><![CDATA[<p><strong>看门狗（Watchdog）</strong> 是一种硬件<strong>计时器</strong>，旨在确保系统<strong>在出现异常时能够自动复位或采取其他措施</strong>。</p>
<p>在 ARM32 微控制器中，通常有两种类型的看门狗：</p>
<ol>
<li><strong>独立看门狗（IWDG, Independent Watchdog）</strong></li>
<li><strong>窗口看门狗（WWDG, Window Watchdog）</strong></li>
</ol>
<p>看门狗定时器在内部计数值达到预设门限的时候，会触发一个复位（对于窗口看门狗定时器来说，会产生一个中断）。</p>
<h2 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h2><p>独立看门狗定时器（FWDGT）有独立时钟源（IRC40K）。即使主时钟失效，FWDGT 依然能保持正常工作状态，适用于需要独立环境且对计时精度要求不高的场合。 </p>
<p>当内部<strong>向下计数器</strong>的计数值达到 0，独立看门狗会产生一个系统复位。</p>
<p>使能独立看门狗的寄存器写保护功能可以避免寄存器的值被意外的配置篡改。</p>
<p>独立运行的 12 位向下计数器。</p>
<h3 id="原理框图"><a href="#原理框图" class="headerlink" title="原理框图"></a>原理框图</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407dlkmgcxkt.png" alt="F407dlkmgcxkt"></p>
<p><strong>IRC32K 时钟源</strong>：这是一个 32kHz 的内部低速 RC 振荡器，为看门狗模块提供时钟信号。</p>
<p><strong>预分频器</strong>：预分频器用于对时钟源进行分频。预分频的选择范围为 4 到 256，实际分频因子可以通过控制寄存器配置。分频后的时钟会作为输入，驱动后面的计数器工作。</p>
<p><strong>12位向下递减计数器</strong>：这是一个 12 位的向下递减计数器。计数器的初始值由重装载寄存器的值决定。当计数器从初始值开始递减到零时，如果没有被重载（即未“喂狗”），则会触发系统复位信号。</p>
<p><strong>重装载寄存器</strong>：重装载寄存器用于设置计数器的初始值，开发者可以通过编程将需要的初值加载到重装载寄存器中。该值会在“喂狗”操作时重新加载到计数器中。</p>
<p><strong>控制寄存器</strong>：控制寄存器负责配置看门狗的一些参数，比如预分频器的分频系数，以及使能或禁用看门狗的功能。通过控制寄存器，用户可以控制看门狗的主要参数。</p>
<p><strong>状态：PUD 和 RUD</strong>：</p>
<ul>
<li><strong>PUD（预分频器更新）</strong>：指示预分频器的状态，当 PUD 位被置位时，表示预分频器配置已更新。</li>
<li><strong>RUD（重装载寄存器更新）</strong>：指示重装载寄存器的状态，当 RUD 位被置位时，表示重装载寄存器配置已更新。</li>
</ul>
<h3 id="超时周期表"><a href="#超时周期表" class="headerlink" title="超时周期表"></a>超时周期表</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407dlkmgcszqb.png" alt="F407dlkmgcszqb"></p>
<blockquote>
<p>以 32 分频为例：011 表示寄存器的值、0.03125 表示在对应预分频设置下的最小超时值，4095.03125在对应预分频设置下的最大超时值。</p>
<p>就是说在 32 分频的周期下，我们设置的计数值最大不可以超过 4095.03125，最小不能小于 0.03125；</p>
</blockquote>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>由 40kHz 的 IRC 时钟通过预分频器进行分频处理，生成一个较低频率的时钟信号。</p>
<p>预分频后的时钟信号驱动 12 位的向下递减计数器。</p>
<p>当计数器递减到零时，若没有在此之前重载（即没有“喂狗”），会触发一个复位信号，从而实现系统复位。</p>
<p>通过重装载寄存器和控制寄存器，用户可以调整看门狗的超时时间（通过设置计数器初值和分频值）。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立看门狗</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>  <span class="title function_">watchdog_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 开启晶振</span></span><br><span class="line">	<span class="comment">// 查看时钟树了解他硬件使用的是哪一个时钟源	</span></span><br><span class="line">	rcu_osci_on(RCU_IRC32K);	</span><br><span class="line">	<span class="comment">// 等待晶振频率稳定</span></span><br><span class="line">	ErrStatus status = rcu_osci_stab_wait(RCU_IRC32K);</span><br><span class="line">	<span class="keyword">if</span> (status == ERROR) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;osci wait error...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">// 开启写使能</span></span><br><span class="line">	fwdgt_write_enable();	</span><br><span class="line">	<span class="comment">// 配置看门狗</span></span><br><span class="line">	<span class="comment">// 时钟频率配置 比如我要配置 1ms</span></span><br><span class="line">	<span class="comment">// 我们启用的是 32khz ==&gt; 32000hz / 32 = 1000Hz </span></span><br><span class="line">	fwdgt_prescaler_value_config(FWDGT_PSC_DIV32);</span><br><span class="line">	<span class="comment">// 设置计数值</span></span><br><span class="line">	fwdgt_reload_value_config(<span class="number">4000</span>);</span><br><span class="line">	<span class="comment">// 重加载计数值</span></span><br><span class="line">	fwdgt_counter_reload();</span><br><span class="line">	<span class="comment">// 上面三条语句可以合并为这一条</span></span><br><span class="line"><span class="comment">//	fwdgt_config(1000, FWDGT_PSC_DIV32);</span></span><br><span class="line">	<span class="comment">// 看门狗使能</span></span><br><span class="line">	fwdgt_enable();</span><br><span class="line">	<span class="comment">// 关闭写保护</span></span><br><span class="line">	fwdgt_write_disable();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">	bsp_USART0_Init();</span><br><span class="line">	watchdog_config();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Run...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 我们在配置中设置的时间为 4000 也就是 4m</span></span><br><span class="line">		<span class="comment">// 我们只需要在这个时间内喂狗即可</span></span><br><span class="line">		fwdgt_counter_reload();<span class="comment">// 重载计数值也就是&#x27;喂狗&#x27;		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在配置时候一定要执行 fwdgt_counter_reload 操作也就是上面框图中的 ’重加载‘，只有操作之后计数器才可以正常拿到我们设定的计数值；</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>独立看门狗为什么不需要开启外部中断使能</strong></p>
<p>如果独立看门狗已经由硬件选项或软件启动，LSI 振荡器将被强制在打开状态，并且不能被关闭，在 LSI 振荡器稳定后，时钟供应给 IWDG。</p>
<p>也就是说我们可以不用手动开启晶振和使能时钟；</p>
<p>二、<strong>独立看门狗为什么要开启写使能</strong></p>
<p>独立看门狗（Independent Watchdog, IWDG）需要 <strong>写保护</strong>（Write Protection）的主要原因是确保其可靠性和防止系统或软件错误对看门狗寄存器的意外或恶意修改。写保护机制是为了防止看门狗的配置或状态被不恰当地改变，特别是在关键时刻，以免破坏看门狗的监控功能，导致系统失去对死锁或故障的检测。</p>
<h2 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h2><p>用于监测程序的异常行为并在发生问题时对系统复位。它与普通的独立看门狗（IWDG）有所不同，增加了“窗口期”限制，要求喂狗操作必须在一个特定的时间窗口内进行，否则系统会被复位。</p>
<p>可编程的7位自由运行向下递减计数器。</p>
<p>窗口看门狗引入了一个“窗口期”的概念，以防止系统因为太早或太晚喂狗导致潜在的错误：</p>
<ul>
<li>当计数器达到0x3F时产生复位（CNT[6] 位被清0）。</li>
<li>当计数器的值大于窗口寄存器的值时，更新计数器会产生复位。</li>
</ul>
<h3 id="原理框图-1"><a href="#原理框图-1" class="headerlink" title="原理框图"></a>原理框图</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ckkmgylt.png" alt="F407ckkmgylt"></p>
<p><strong>PCLK1&#x2F;4096</strong>：窗口看门狗的时钟源来自于系统的 APB1 总线时钟（即 PCLK1），经过固定的 1&#x2F;4096 分频后作为看门狗的输入时钟源。这样可以使看门狗计数器的计时频率较低，从而方便实现较长的超时时间。</p>
<p><strong>预分频系数</strong>：在经过 1&#x2F;4096 分频后，还可以进一步选择 1、2、4 或 8 的预分频系数，进一步降低时钟频率。这使得计数器可以更慢地递减，从而实现更大的计时范围。</p>
<p><strong>7位递减计数器 CNT</strong>：这是 WWDG 的核心计数器，由 7 位组成（最大值 0x7F，最小值 0x3F）。在启动 WWDG 后，计数器开始从设定的初始值递减，当计数器值达到 0x40 时，如果没有被重装载（喂狗），系统将触发复位。该计数器会根据预分频后的时钟频率递减。</p>
<p><strong>窗口值 WIN</strong>：这是一个可配置的窗口值，用于设定喂狗的时间窗口。当计数器的值递减到窗口值以下时，可以进行喂狗操作。如果计数器值高于窗口值时喂狗，WWDG 会立即触发复位。因此，喂狗操作必须在计数器值介于窗口值和 0x40 之间的特定窗口内进行。</p>
<p><strong>WDGTEN</strong>：这是窗口看门狗的使能信号。只有在 WDGTEN 使能的情况下，窗口看门狗才会开始计数和触发复位功能。</p>
<p><strong>复位条件</strong>：</p>
<ul>
<li><strong>CNT[6] &#x3D; 0 时触发复位</strong>：计数器递减到 0x40（计数器的最小值）时，如果没有及时喂狗，系统将被复位。</li>
<li><strong>计数器大于窗口值时喂狗触发复位</strong>：如果在计数器值大于窗口值的情况下进行了喂狗操作（即写入 WWDGT_CTL），也会触发复位。这是窗口看门狗的独特之处，要求喂狗必须在窗口期内进行，否则会被认为是异常情况。</li>
</ul>
<p><strong>复位输出</strong>：当满足任一复位条件（计数器值达到 0x40 或喂狗在窗口之外）时，WWDG 将触发复位信号，使系统重新启动。</p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ckkmgsxt.png" alt="F407ckkmgsxt"></p>
<h3 id="超时周期表-1"><a href="#超时周期表-1" class="headerlink" title="超时周期表"></a>超时周期表</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407ckkmgcszqb.png" alt="F407ckkmgcszqb"></p>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>启用窗口看门狗</strong></p>
<ul>
<li>在使用 WWDG 之前，需要启用 WWDG 的时钟。</li>
<li>配置看门狗的参数，包括：<ul>
<li><strong>计数器初始值</strong>：通常为 7 位（0x7F），从这个值开始递减。</li>
<li><strong>窗口值</strong>：用于设定喂狗的时间窗口上限。</li>
<li><strong>分频系数</strong>：控制计数器递减的频率。</li>
</ul>
</li>
</ul>
<p>配置完成后使能窗口看门狗，计数器开始从设定的初始值递减。</p>
<p><strong>喂狗</strong></p>
<p>在 WWDG 中，喂狗操作（也称“刷新”操作）需要在特定的时间窗口内进行，才能避免系统复位。</p>
<p>窗口时间由两个值决定：</p>
<ul>
<li><strong>上限窗口值（WIN）</strong>：喂狗时计数器值不能大于这个值。</li>
<li><strong>下限值</strong>：计数器值递减到 0x3F 时会触发系统复位。</li>
</ul>
<p>喂狗操作就是将计数器重新加载到初始值（通常是 0x7F）以避免复位。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口看门狗</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wingod_config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 使能窗口看门狗外部时钟</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_WWDGT);</span><br><span class="line">	<span class="comment">// 看门狗配置</span></span><br><span class="line">	<span class="comment">// 1.从这个数开始递减 7位数最大为 0x7F</span></span><br><span class="line">	<span class="comment">// 2.窗口上限  下限为 0x3F，</span></span><br><span class="line">	<span class="comment">// 3.分频系数 42000000 / 4096 = 10253 / 8 = 1281Hz &lt;==&gt; 1000ms 	</span></span><br><span class="line">	<span class="comment">// 也就是说数一个数大概 0.78ms</span></span><br><span class="line">	wwdgt_config(<span class="number">0x7F</span>, <span class="number">100</span>, WWDGT_CFG_PSC_DIV8);</span><br><span class="line">	<span class="comment">// 窗口看门狗使能</span></span><br><span class="line">	wwdgt_enable();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    systick_config();</span><br><span class="line">	bsp_USART0_Init();</span><br><span class="line">	wingod_config();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Run1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		delay_1ms(<span class="number">30</span>);</span><br><span class="line">		<span class="comment">// 设置中窗口期为 100(0x64)~0x3F</span></span><br><span class="line">		<span class="comment">// 0x7F-0x67 = 27 0.78 * 27 = 21(ms) 期间不可以喂狗</span></span><br><span class="line">		<span class="comment">// 0x7F-0x3F = 64 0.78 * 64 = 49(ms) 超过这就自动复位了</span></span><br><span class="line">		<span class="comment">// 也就是说我们要在数数递减到 100~64之间喂狗才有效 21~49之间</span></span><br><span class="line">		wwdgt_counter_update(<span class="number">0x7F</span>);		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Run2...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>APB1 总线时钟频率可以在 时钟树上查看；</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>一、<strong>为什么最小值为 0x3F</strong></p>
<p>因为它是通过计数器的最高位来进行判断的；</p>
<p>WWDG 的计数器是一个 <strong>7位递减计数器</strong>，当计数器值递减到 <strong>0x3F</strong> 时， <strong>CNT[6] 位清零</strong>也就是计数器的最高位（第7位）被清零时触发复位。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>裸机多任务</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E8%A3%B8%E6%9C%BA%E5%A4%9A%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>裸机多任务开发（Bare-Metal Multitasking Development）是指在没有操作系统的情况下，通过软件设计实现多任务运行的机制。</p>
<p>这种多任务实现依赖于时间分片或任务切换，任务轮流运行，但由于切换速度快，从外部看起来就像是同时进行的。</p>
<h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><h3 id="时间分片与任务切换"><a href="#时间分片与任务切换" class="headerlink" title="时间分片与任务切换"></a><strong>时间分片与任务切换</strong></h3><p>逻辑多任务通过分配给每个任务一小段时间（称为<strong>时间片</strong>）来实现多个任务的轮流执行。</p>
<ul>
<li><strong>时间片分配</strong>： 每个任务在被调度到时运行一段时间，然后暂停并切换到下一个任务。</li>
<li><strong>任务切换</strong>： 在任务切换时，保存当前任务的运行状态（上下文，例如寄存器和程序计数器），以便下次恢复。</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a><strong>任务调度</strong></h3><p>逻辑多任务依赖一个调度器来决定哪个任务应该运行。常见的调度策略有：</p>
<ul>
<li><strong>时间片轮转调度</strong>： 任务按固定顺序依次执行，每个任务占用固定的时间片。</li>
<li><strong>优先级调度</strong>： 任务根据优先级执行，高优先级任务可以抢占低优先级任务。</li>
<li><strong>事件驱动调度</strong>： 任务在满足某些条件或触发事件时被执行。</li>
</ul>
<h3 id="状态机设计"><a href="#状态机设计" class="headerlink" title="状态机设计"></a><strong>状态机设计</strong></h3><p>逻辑多任务常通过状态机设计来实现任务间的非阻塞切换：</p>
<ul>
<li>每个任务在运行过程中处于某个状态，例如<strong>初始化</strong>、<strong>运行</strong>、<strong>等待</strong>、<strong>完成</strong>等。</li>
<li>主程序（Super Loop）中依次检查各任务的状态，并根据状态决定是否调用任务的功能。</li>
</ul>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a><strong>中断机制</strong></h3><p>中断是逻辑多任务的重要部分，用于处理高优先级或异步事件：</p>
<ul>
<li><strong>硬件中断</strong>：当硬件事件（如按键触发、UART 接收）发生时，中断服务程序（ISR）可以立即执行。</li>
<li><strong>定时器中断</strong>：通过定时器产生周期性中断，用于触发任务切换。</li>
</ul>
<h3 id="任务的上下文保存与恢复"><a href="#任务的上下文保存与恢复" class="headerlink" title="任务的上下文保存与恢复"></a><strong>任务的上下文保存与恢复</strong></h3><p>为了实现任务切换，逻辑多任务需要在切换时保存任务的上下文（包括寄存器、堆栈指针等），并在下次运行时恢复这些信息。裸机系统通常通过以下方式实现上下文切换：</p>
<ul>
<li><strong>手动保存和恢复</strong>：由程序员在任务切换时明确保存和恢复上下文。</li>
<li><strong>自动保存和恢复</strong>：某些嵌入式架构（如 ARM Cortex-M）在中断时自动保存部分寄存器。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时任务 1ms 触发一次</span></span><br></pre></td></tr></table></figure>



<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义通信协议</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>在嵌入式开发中，自定义通信协议是指开发者根据具体应用的需求，设计并实现一个专门的协议，用于在嵌入式系统与外部设备（如上位机、传感器、其他微控制器等）之间进行数据交换。这种协议通常定义了数据的格式、传输规则、错误检测机制等，确保通信的正确性与可靠性。</p>
<h2 id="自定义通信的目的"><a href="#自定义通信的目的" class="headerlink" title="自定义通信的目的"></a>自定义通信的目的</h2><p><strong>简化通信</strong>：通过明确的数据格式和规则，确保嵌入式系统与其他设备之间能够顺利、准确地交换数据。</p>
<p><strong>提高效率</strong>：根据实际需求设计协议，使通信更加高效、低功耗、节省带宽。</p>
<p><strong>解决兼容性问题</strong>：避免使用标准协议时可能出现的兼容性问题，特别是当设备数量、数据类型等不确定时。</p>
<p><strong>增加可控性</strong>：在嵌入式开发中，通过自定义协议可以精确控制数据的传输方式和格式。</p>
<h2 id="自定义hex协议"><a href="#自定义hex协议" class="headerlink" title="自定义hex协议"></a>自定义hex协议</h2><p>我们在使用 USART 与上位机通信时，有时标准的 USART 协议不能满足我们的功能需求，故我们需要在 USART 的基础上定义我们自己的通信协议；</p>
<p>我们首先规定，PC 与 MCU 通信过程中，先发送高位的字节（0x1213456 先发送 12），以小端方式存储（具体需要验证当前环境的存储方式）；</p>
<p>以平衡小球为例，我们需要定义如下规则：</p>
<h3 id="设置小球位置"><a href="#设置小球位置" class="headerlink" title="设置小球位置"></a>设置小球位置</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">帧头</th>
<th align="center">命令位</th>
<th align="center">数据长度</th>
<th align="center">数据位</th>
<th align="center">校验位</th>
<th align="center">帧尾</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节数</strong></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>默认值</strong></td>
<td align="center">0xAA 0xAA</td>
<td align="center">0xB0</td>
<td align="center">0x02</td>
<td align="center">上位机传入</td>
<td align="center">Add(8)</td>
<td align="center">0xBB</td>
</tr>
</tbody></table>
<p>小球的位置可以从 0ms ~ 2000+ms，所以我们这里用两个字节存放小球返回的位置；</p>
<p>Add(8)：对命令位、数据长度和数据位进行累加后取低 8 位。</p>
<h3 id="设置-PID-相关参数"><a href="#设置-PID-相关参数" class="headerlink" title="设置 PID 相关参数"></a>设置 PID 相关参数</h3><table>
<thead>
<tr>
<th></th>
<th align="center">帧头</th>
<th align="center">命令位</th>
<th align="center">数据长度</th>
<th align="center">数据位</th>
<th align="center">校验位</th>
<th align="center">帧尾</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节数</strong></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">12</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td><strong>默认值</strong></td>
<td align="center">0xAA 0xAA</td>
<td align="center">0xB1</td>
<td align="center">0x0C</td>
<td align="center">上位机传入</td>
<td align="center">Add(8)</td>
<td align="center">0xBB</td>
</tr>
</tbody></table>
<p>数据位：数据位包含P、I、D三个参数，每个参数 4 个字节所以一共 12 个字节</p>
<ul>
<li>P:   4 个字节，float 类型。P 值</li>
<li>I:  4 个字节，float 类型。I 值</li>
<li>D:  4 个字节，float 类型。D 值</li>
</ul>
<h3 id="获取当前小球位置"><a href="#获取当前小球位置" class="headerlink" title="获取当前小球位置"></a>获取当前小球位置</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">帧头</th>
<th align="center">命令位</th>
<th align="center">数据长度</th>
<th align="center">数据</th>
<th align="center">校验位</th>
<th align="center">帧尾</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节数</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">默认值</td>
<td align="center">0xAA 0xAA</td>
<td align="center">0xF0</td>
<td align="center">0x02</td>
<td align="center">MPU 返回</td>
<td align="center">Add(8)</td>
<td align="center">0xBB</td>
</tr>
</tbody></table>
<h3 id="获取当前-PID-相关参数"><a href="#获取当前-PID-相关参数" class="headerlink" title="获取当前 PID 相关参数"></a>获取当前 PID 相关参数</h3><table>
<thead>
<tr>
<th></th>
<th align="center">帧头</th>
<th align="center">命令位</th>
<th align="center">数据长度</th>
<th align="center">数据位</th>
<th align="center">校验位</th>
<th align="center">帧尾</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字节数</strong></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">type(1)  | P&#x2F;I&#x2F;D(4)</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td><strong>默认值</strong></td>
<td align="center">0xAA 0xAA</td>
<td align="center">0xE0</td>
<td align="center">0x05</td>
<td align="center">MPU 返回</td>
<td align="center">Add(8)</td>
<td align="center">0xBB</td>
</tr>
</tbody></table>
<p>数据位包含一个 type 用于区分参数（P、I、D三个参数），后 4 个字节是前面 type 所返回的具体数值</p>
<ul>
<li><p>0x00 : Kp</p>
</li>
<li><p>0x01：Ki</p>
</li>
<li><p>0x02：Kd</p>
</li>
</ul>
<h3 id="float-的内存表示"><a href="#float-的内存表示" class="headerlink" title="float 的内存表示"></a>float 的内存表示</h3><p>因为 PC 在与 MCU 通信时会涉及到小数的传输，所以这里需要先了解下 float 在内存中是如何表示的：在 C 语言中，float 通常以 <strong>IEEE 754 单精度浮点数</strong>格式存储，占 <strong>4字节（32位）</strong>。</p>
<p>PC 在与 MCU 通信时我们如果直接传输一个小数比如 12.1231，MCU 就需要通过字符串来接收这个指令，虽然简单但是会造成数据位的大小不固定，协议是需要规定数据位大小的。（12.1 是 4 个字节，12.1213 是 7 个字节）</p>
<p>所以我们这里采取将 float 转为 十六进制码进行发送，这样 MCU 只需要通过 char[4] 大小的数组接收并组装为 float 即可。（12.1 是 4 个字节，12.1213 还是 4 个字节）</p>
<p><a href="https://www.asciim.cn/hex/float.html">浮点数十六进制转换器</a></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// USART 接收处理</span></span><br><span class="line"><span class="comment">// 上位机发送后我们要按照定义的协议进行解析</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// USART 发送处理</span></span><br><span class="line"><span class="comment">// 我们要发送给上位机进行实时显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 何时将数据搬运到环形队列中</span></span><br><span class="line"><span class="comment">// 这里我们就简单来一个字节搬运一次</span></span><br><span class="line"><span class="comment">// 搬运应该是实时的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>PC 通过 USART 与 MCU 通信过程中通常会产生如下一些问题：</p>
<p>MCU 的接收处理速度跟不上 PC 的发送速度，未完整处理接收到的数据，从而导致丢包或者粘包的问题；因此我们引入了环形队列这一数据结构进行处理；</p>
<p>环形队列是一种特殊的队列数据结构，它使用固定长度的数组实现队列的功能，并通过逻辑上的“首尾相接”形成一个环形的结构。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>队列的最后一个元素的下一个位置可以与第一个元素相连，形成一个循环结构。</p>
</li>
<li><p>当队尾指针到达数组末尾时，如果还有空余空间，可以绕回到数组的开头继续存储数据。</p>
</li>
<li><p>为了区分队列是“空”还是“满”，通常会保留一个空闲位置或者使用额外的标志位。</p>
</li>
</ul>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>假设用一个固定长度为 N 的数组来实现环形队列：</p>
<ul>
<li><strong>队头指针（head）</strong>：指向队列中第一个元素的位置。</li>
<li><strong>队尾指针（tail）</strong>：指向下一个可以插入的位置（注意，不是最后一个元素）。</li>
</ul>
<h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a><strong>队列的基本操作</strong></h3><ol>
<li><p><strong>入队（enqueue）</strong>：</p>
<ul>
<li>检查队列是否已满： (tail + 1) % N &#x3D;&#x3D; head 若成立，则队列已满。</li>
<li>插入数据后，将 tail 指针向前移动： tail &#x3D; (tail + 1) % N</li>
</ul>
</li>
<li><p><strong>出队（dequeue）</strong>：</p>
<ul>
<li>检查队列是否为空： tail &#x3D;&#x3D; head 若成立，则队列为空。</li>
<li>删除数据后，将 head 指针向前移动： head &#x3D; (head + 1) % N</li>
</ul>
</li>
<li><p><strong>判断队列是否为空</strong>：</p>
<p>tail &#x3D;&#x3D; head</p>
</li>
<li><p><strong>判断队列是否已满</strong>：</p>
<p>(tail + 1) % N &#x3D;&#x3D; head</p>
</li>
<li><p><strong>计算队列中元素个数</strong>：</p>
<p>size &#x3D; (tail − head + N) % N</p>
</li>
</ol>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CIRCULAR_QUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CIRCULAR_QUEUE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="comment">// 循环队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> head;      <span class="comment">// 队头指针</span></span><br><span class="line">    <span class="type">uint32_t</span> tail;      <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="type">uint32_t</span> size;      <span class="comment">// 队列大小</span></span><br><span class="line">    <span class="type">uint8_t</span> *buffer;    <span class="comment">// 队列缓冲区</span></span><br><span class="line">&#125; CircularQueue_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QUEUE_OK = <span class="number">0</span>,  <span class="comment">// 成功</span></span><br><span class="line">    QUEUE_FULL,   <span class="comment">// 队列满</span></span><br><span class="line">    QUEUE_EMPTY,  <span class="comment">// 队列空</span></span><br><span class="line">    QUEUE_ERROR   <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">&#125; CircularQueueStatus_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化环形队列    </span></span><br><span class="line"><span class="comment"> * \param queue  队列结构体变量指针</span></span><br><span class="line"><span class="comment"> * \param buffer 队列缓存区地址</span></span><br><span class="line"><span class="comment"> * \param buffer_size   队列最大大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CircularQueue_Init</span><span class="params">(CircularQueue_t *<span class="built_in">queue</span>, <span class="type">uint8_t</span> *buffer, <span class="type">uint32_t</span> buffer_size)</span> &#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = buffer_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;buffer = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 数据入队（向队列尾部插入数据）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * \param queue 队列结构体变量指针</span></span><br><span class="line"><span class="comment"> * \param dat  一个字节数据</span></span><br><span class="line"><span class="comment"> * \return QueueStatus_t  入队结果 QUEUE_OK 成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CircularQueueStatus_t <span class="title function_">CircularQueue_push</span><span class="params">(CircularQueue_t *<span class="built_in">queue</span>, <span class="type">uint8_t</span> dat)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算下一个元素的索引</span></span><br><span class="line">    <span class="type">uint32_t</span> next_index = (<span class="built_in">queue</span>-&gt;tail + <span class="number">1</span>)  % <span class="built_in">queue</span>-&gt;size;</span><br><span class="line">    <span class="comment">// 队列满(保留一个空位)</span></span><br><span class="line">    <span class="keyword">if</span> (next_index == <span class="built_in">queue</span>-&gt;head) &#123;</span><br><span class="line">        <span class="keyword">return</span> QUEUE_FULL;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;buffer[<span class="built_in">queue</span>-&gt;tail] = dat;</span><br><span class="line">    <span class="comment">// 更新队尾指针</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;tail = next_index;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 数据出队（从队首弹出数据）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * \param queue 队列结构体变量指针</span></span><br><span class="line"><span class="comment"> * \param pdat  出队数据指针</span></span><br><span class="line"><span class="comment"> * \return QueueStatus_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CircularQueueStatus_t <span class="title function_">circularQueue_pop</span><span class="params">(CircularQueue_t *<span class="built_in">queue</span>, <span class="type">uint8_t</span> *p_dat)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果head与tail相等，说明队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;head == <span class="built_in">queue</span>-&gt;tail) &#123;</span><br><span class="line">        <span class="keyword">return</span> QUEUE_EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取head的数据</span></span><br><span class="line">    *p_dat = <span class="built_in">queue</span>-&gt;buffer[<span class="built_in">queue</span>-&gt;head];</span><br><span class="line">    <span class="comment">// 更新队头指针</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;head = (<span class="built_in">queue</span>-&gt;head + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;size;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取队列数据个数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * \param queue  队列指针</span></span><br><span class="line"><span class="comment"> * \return uint32_t  队列有效数据个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">CircularQueue_DataCount</span><span class="params">(CircularQueue_t *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;tail &gt;= <span class="built_in">queue</span>-&gt;head) &#123;</span><br><span class="line">        <span class="comment">// 队尾指针在队头指针后边</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;tail - <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队尾指针在队头指针前边（转了一圈到了队头指针之前）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size + <span class="built_in">queue</span>-&gt;tail - <span class="built_in">queue</span>-&gt;head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 压入一组数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * \param queue  队列结构体变量指针</span></span><br><span class="line"><span class="comment"> * \param p_arr  待入队数组指针</span></span><br><span class="line"><span class="comment"> * \param len    待入队数组长度 </span></span><br><span class="line"><span class="comment"> * \return uint32_t 实际写入的数据个数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">circularQueue_pushArray</span><span class="params">(CircularQueue_t *<span class="built_in">queue</span>, <span class="type">uint8_t</span> *p_arr, <span class="type">uint32_t</span> len)</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (circularQueue_push(<span class="built_in">queue</span>, p_arr[i]) == QUEUE_FULL)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 出队一组数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * \param queue 队列指针</span></span><br><span class="line"><span class="comment"> * \param p_arr 待出队数组指针</span></span><br><span class="line"><span class="comment"> * \param len   待出队数组长度</span></span><br><span class="line"><span class="comment"> * \return QueueStatus_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">circularQueue_popArray</span><span class="params">(CircularQueue_t *<span class="built_in">queue</span>, <span class="type">uint8_t</span> *p_arr, <span class="type">uint32_t</span> len)</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (circularQueue_pop(<span class="built_in">queue</span>, &amp;p_arr[i]) == QUEUE_EMPTY)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>环形队列中为什么要预留一个空位</strong></p>
<p>环形队列中的数据是通过头指针（head）和尾指针（tail）来管理的：</p>
<ul>
<li><strong>空队列</strong>：当 head &#x3D;&#x3D; tail 时，队列为空。</li>
<li><strong>满队列</strong>：如果不预留空位，当所有缓冲区都填满时，head 和 tail 也会变成相等，这会导致无法区分“队列满”和“队列空”这两种状态。</li>
</ul>
<p>因此，为了简化逻辑并明确状态，环形队列中通常会<strong>留出一个空位作为缓冲</strong>，这样就可以通过以下规则来判断队列是否满或空：</p>
<ul>
<li>队列<strong>空</strong>：head &#x3D;&#x3D; tail</li>
<li>队列<strong>满</strong>：(tail + 1) % size &#x3D;&#x3D; head</li>
</ul>
<p>二、<strong>同时使用 DMA 和 RBEN 中断时的数据竞争问题</strong></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>门电路</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/GD32/GD32F407/%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<p>门电路是基本的逻辑电路，用于实现逻辑运算。它们通常由晶体管、电阻和其他元件构成，用于控制电信号的流动。。</p>
<h2 id="门电路介绍"><a href="#门电路介绍" class="headerlink" title="门电路介绍"></a>门电路介绍</h2><p>门电路是数字电路的基本组成部分，而 GPIO 作为控制和输入输出的接口，常常<strong>依赖于门电路的逻辑来实现复杂的功能</strong>。因此，在学习 GPIO 时，先介绍门电路能够帮助我们理解其工作原理和应用场景。</p>
<p><strong>NOT 门电路</strong></p>
<p>NOT（非门）是数字逻辑电路中的一种基本逻辑门，也称为<strong>反相器</strong>。它执行的是逻辑非操作，即将输入信号取反。NOT门具有一个输入和一个输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407feimen.png" alt="F407feimen"></p>
<p>A输入，B输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>1</td>
</tr>
<tr>
<td align="center">1</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>AND 门电路</strong></p>
<p>AND（与门）是数字逻辑电路中的一种基本逻辑门，用于执行逻辑与操作。AND门具有多个输入和一个输出，它的输出信号取决于所有输入信号的状态。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yumen.png" alt="F407yumen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>OR 门电路</strong></p>
<p>OR（或门）是数字逻辑电路中的一种基本逻辑门，用于执行逻辑或操作。OR门具有多个输入和一个输出，它的输出信号取决于所有输入信号的状态。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407huomen.png" alt="F407huomen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>NAND 门电路</strong></p>
<p>NAND（NOT AND）门，<strong>与非门</strong>，是一种常见的逻辑门类型，它执行逻辑与（AND）操作的反操作，并具有特殊的性质，被广泛应用于电子和计算机领域。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yufeimen.png" alt="F407yufeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>NOR 门电路</strong></p>
<p>NOR（NOT OR）门，<strong>或非门</strong>，是数字电路中的另一种基本逻辑门，它执行逻辑或（OR）操作的反操作。NOR门也被广泛应用于电子和计算机领域，用于构建各种逻辑功能。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407huofeimen.png" alt="F407huofeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>XOR 门电路</strong></p>
<p>XOR（<strong>异或门</strong>）是数字逻辑电路中的一种基本逻辑门，用于执行逻辑异或操作。异或操作是指当输入的两个信号不相同时，输出为高电平（逻辑1）；当输入的两个信号相同时，输出为低电平（逻辑0）。XOR门具有两个输入和一个输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuomen.png" alt="F407yihuomen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><strong>XNOR 门电路</strong></p>
<p>XNOR（<strong>异或非门</strong>）是数字逻辑电路中的一种基本逻辑门，是异或门（XOR门）的补充。XNOR门执行逻辑异或操作的反操作，也称为等价门。XNOR门具有两个输入和一个输出，用于比较两个输入信号是否相等。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407yihuofeimen.png" alt="F407yihuofeimen"></p>
<p>A和B输入，Y输出，以下是真值表：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>GD32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>Init</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/STM32/STM32F407/Init/</url>
    <content><![CDATA[<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>下载相关文件，STM32F407 的用户手册、数组手册、选型手册、固件使用指南（一般下载固件库时会附带）等。</p>
<h2 id="创建项目与配置"><a href="#创建项目与配置" class="headerlink" title="创建项目与配置"></a>创建项目与配置</h2><p><strong>创建项目</strong></p>
<p>在工程目录中创捷下列文件夹</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录结构</span></span><br><span class="line"></span><br><span class="line">Demo01</span><br><span class="line">└── Docs/		 <span class="comment">// 说明文档 README.md</span></span><br><span class="line">└── Project/	 <span class="comment">// 存放 Keil 文件和生成的一些配置文件、hex 文件     </span></span><br><span class="line">├── CMSIS/       <span class="comment">// CMSIS 中 ARM 相关文件</span></span><br><span class="line">├── Hardware/    <span class="comment">// 协议层代码</span></span><br><span class="line">├── Firmware/    <span class="comment">// 官方标准固件库中的驱动程序</span></span><br><span class="line">├── Drivers/     <span class="comment">// 外设硬件驱动程序</span></span><br><span class="line">├── Middleware/  <span class="comment">// 上层中间件组件</span></span><br><span class="line">├── App/         <span class="comment">// 应用层代码</span></span><br><span class="line">└── User/      	 <span class="comment">// 入口层     </span></span><br></pre></td></tr></table></figure>

<p><strong>文件移植</strong></p>
<p>将官方标准固件库中我们需要的的文件拷贝到对应的工程目录中去：</p>
<p><strong>CMSIS</strong> –&gt; 官方标准固件库中的 CMSIS 中的代码；</p>
<p><strong>Firmware</strong> –&gt; 官方标准固件库中的外设驱动；</p>
<p><strong>Drivers</strong> –&gt; 我们自己封装的驱动，如按键、显示屏等；</p>
<p><strong>Middleware</strong> –&gt; 项目中的中间件，如上位机的可视化界面等；</p>
<p><strong>App</strong> –&gt; 具体的业务处理逻辑</p>
<p><strong>User</strong> –&gt; 程序的入口和一些工具文件</p>
<p><strong>Project</strong> –&gt; Keil 文件的目录</p>
<p>那么具体都是要拷贝哪些软件呢，</p>
<ul>
<li><p>将对应目录下文件都拷贝过去，然后将所有 .c 文件添加进项目中然后在解决错误问题（不建议）</p>
</li>
<li><p>查看官方的示例代码，看看人家官方示例是需要拷贝那些，</p>
<ul>
<li>打开 Keil 查看他的工程目录，然后从官方库中复制对应的文件到我们自己的项目中；(注意，一般工程中只会显示 .c 文件但我们要记得将对应的 .h 文件一起拷贝)</li>
<li>注意在每一款芯片的固件库中都包含一个用于导入所有固件库的头文件，这个头文件在示例工程中可能并没有导入，但我们不要忘记导入，他一般存在于示例代码的模板目录下，STM32 中叫做 stm32f4xx_conf.h；</li>
</ul>
</li>
</ul>
<p><strong>在 Keil 工程中创建工程目录并添加对应的文件</strong></p>
<ul>
<li>创建 Keil 工程并新建对应的工程目录</li>
<li>将工程文件夹下的 .C 文件添加到 Keil 工程中去</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407Keilyinruwenjian.png" alt="F407Keilyinruwenjian"></p>
<p><strong>添加 Include PATH 路径</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407Keilinclude.png" alt="F407Keilinclude"></p>
<p><strong>其他 Keil 配置</strong></p>
<ol>
<li><strong>芯片的型号要与所用硬件一致</strong></li>
</ol>
<p>“”魔术棒” –&gt; “Device” 下的芯片型号与我们用的硬件是否一样，不一样就要改；</p>
<ol start="2">
<li><strong>编译器版本是否正确</strong></li>
</ol>
<p>“”魔术棒” –&gt; “Target” 下 ARM Compiler 的版本是否为 “Use default compiler version 6”，如果 “missing compiler version 5” 表示 5 这个版本的不存在那么我们也要去安装；</p>
<p>勾选 “Use Micro LIB” 以优化代码；</p>
<ol start="3">
<li><strong>是否生成 .HEX 文件</strong></li>
</ol>
<p>“魔术棒” –&gt; “Output” 下勾选 “Create HEX File”;</p>
<ol start="4">
<li><strong>设置 C 和 C++ 的编译器版本，不然有些宏关键字它可能不识别，设置代码优化级别</strong></li>
</ol>
<p>“魔术棒” –&gt; “C&#x2F;C++” 下的 Language C 设置为 “C990”，Language C++ 设置为 “C++ 11”</p>
<p>设置编译警告的级别，选择 “Wamings” 中的内容为 “AC5-like Wamings”，表示与 Keil5 一致；</p>
<p>设置代码优化的级别，选择 “Optimizaion” 中的内容为 “-O1”，级别越高优化程序越高，但是太高了有时候会出错，此处设置为 “-O1” 即可；</p>
<ol start="5">
<li><strong>添加 Keil 工程中的使用文件的路径</strong></li>
</ol>
<p>“魔术棒” –&gt; “C&#x2F;C++” 下的 “Include Path” 中进行添加；</p>
<ol start="6">
<li><strong>选择所使用的烧录器</strong></li>
</ol>
<p>“魔术棒” –&gt; “Debug” 下右侧 “Use” 中的烧录器，此处我们设置为 “CMSIS-DAP Debugger”;</p>
<p>勾选自动复位并运行，左侧 “Setting” –&gt; “Flash Download” 中勾选 “Reset and Run”;</p>
<p>通常如果烧录器连上后可以在  “Setting” –&gt; “Debug” 右侧中的 “SW Device” 中看到；</p>
<h2 id="开发与调试"><a href="#开发与调试" class="headerlink" title="开发与调试"></a>开发与调试</h2><ol>
<li><strong>示例的 main.c 中使用的芯片与我们不一致，所以需要删掉他的头文件和其代码</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f450i_eval.h&quot;</span> <span class="comment">// 删掉</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个函数删掉</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_spark</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> __IO <span class="type">uint32_t</span> timingdelaylocal = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timingdelaylocal) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timingdelaylocal &lt; <span class="number">500U</span>) &#123;</span><br><span class="line">            gd_eval_led_on(LED1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gd_eval_led_off(LED1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timingdelaylocal--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timingdelaylocal = <span class="number">1000U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    gd_eval_led_init(LED1); <span class="comment">// 这个调用语句也删掉</span></span><br><span class="line">    systick_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gd32f4xx_it.c 中调用了 led_spark() 我们也要讲他删掉</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>编译运行这时他会报错，提示缺少一些文件，我们去看这些文件在我们的目录中是否存在，如果不存在就加进来</strong></p>
<p>这里一般情况下是缺少 “core_cmFunc.h”，”core_cm4.h”，”core_cm4_simd.h”，”core_cmlnstr.h”，这四个</p>
</li>
<li><p><strong>此时还是报错，我们点击报错的语句，发现他会跳到某些个 include 处报错：D:&#x2F;Tools&#x2F;IDE&#x2F;keil&#x2F;keil&#x2F;ARM&#x2F;Packs&#x2F;GigaDevice&#x2F;GD32F4xx_DFP&#x2F;3.0.3&#x2F;Device&#x2F;F4XX&#x2F;Include\gd32f4xx_libopt.h(11): error: ‘RTE_Components.h’ file not found；</strong></p>
</li>
</ol>
<ul>
<li><p>注意看他这个报错信息中的路径好像用的不是我们本地的那个呀，那么 ok，我们首先要将 gd32f4xx_libopt.h 包含在我们的项目本地，确保他在本地是存在的，</p>
</li>
<li><p>gd32f4xx_libopt.h 这个文件是在哪被声明使用的呢？，我们发现，他是在 gd32f4xx.h 中被声明使用的，那么 gd32f4xx.h 这个文件在本地是否存在呢，如果不存在就需要从标准固件库中添加进我们的项目中；</p>
</li>
</ul>
<p>此时，运行它使用的就是我们本地的 gd32f4xx_libopt.h 文件了，这时它有时候还会报错某些引用错误，但这是官方的标准文件是不会出错了，那么大概率就是某些头没有导入，他某些头文件的导入是通过宏来定义的；我们需要在 Keil 中定义某些宏；</p>
<ol start="4">
<li><strong>简化外设库的使用</strong></li>
</ol>
<p>我们看 gd32f4xx_libopt.h 文件发现其中定义了很多的头文件，但是它需要通过宏去判断是否导入这些头文件，所以此时我们需要添加这些宏关键字；</p>
<p>“魔术棒” –&gt; “C&#x2F;C++” 下的 “Define” 中进行添加；”USE_STDPERIPH_DRIVER,GD32F407”，这两个宏定义，</p>
<p>USE_STDPERIPH_DRIVER 用于在 gd32f4xx.h 中展开 gd32f4xx_libopt.h 头文件（这一句可以不加，它本身会做判断，不存在就自动定义）；</p>
<p>GD32F407 用于在 gd32f4xx_libopt.h 展开标准固件库中的头文件；</p>
<h2 id="烧写与验证"><a href="#烧写与验证" class="headerlink" title="烧写与验证"></a>烧写与验证</h2><p>在嵌入式开发中，<strong>拿到一块开发板后，烧录方式不能随意选择</strong>，而是需要<strong>根据开发板的硬件支持情况</strong>来选择适合的烧录方法。</p>
<p><strong>如何查看开发板的烧录方式支持情况</strong></p>
<ul>
<li><p><strong>查看数据手册</strong>：芯片的数据手册通常会列出支持的烧录接口和方法，例如 ST-Link、J-Link、UART、USB DFU 等。</p>
</li>
<li><p><strong>检查开发板的接口</strong>：查看开发板是否有特定的调试&#x2F;编程接口，例如 <strong>SWD</strong> 接口、<strong>JTAG</strong> 接口、<strong>USB</strong> 接口、或 <strong>UART</strong> 引脚等。</p>
</li>
<li><p><strong>开发板文档</strong>：一些开发板还会提供专门的用户手册，其中会详细说明支持的烧录方法和推荐的工具。</p>
</li>
</ul>
<h3 id="DAP-Link-下载"><a href="#DAP-Link-下载" class="headerlink" title="DAP-Link 下载"></a>DAP-Link 下载</h3><ol>
<li>DAP-Link 连线</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPlianxian.png" alt="F407DAPlianxian"></p>
<ol start="2">
<li>Keil 设置</li>
</ol>
<p>Debug 中的设置此处不再赘述，如果发现一直无法识别烧录器则需要换一个烧录器或者换一种烧录方式；</p>
<ol start="3">
<li>烧录</li>
</ol>
<p>“主界面” –&gt; “保存” –&gt; “Rebuild” –&gt; “Download” 即可</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407shaolumulu.png" alt="F407shaolumulu"></p>
<h3 id="使用-DFU-烧录"><a href="#使用-DFU-烧录" class="headerlink" title="使用 DFU 烧录"></a>使用 DFU 烧录</h3><p><strong>下载安装 CH340 驱动</strong></p>
<p><a href="https://www.wch.cn/download/CH341SER_EXE.html">CH341SER.EXE - 南京沁恒微电子股份有限公司</a></p>
<p><strong>下载安装 DFU 驱动</strong></p>
<p><a href="https://www.gd32mcu.com/cn/download?kw=DFU&lan=cn">兆易创新GigaDevice-资料下载兆易创新GD32 MCU</a></p>
<p><strong>下载烧录软件</strong></p>
<p><a href="https://www.gd32mcu.com/en/download?kw=GD32+All-In-One+Programmer">兆易创新GigaDevice-资料下载GigaDevice GD32 MCU</a></p>
<p><strong>Keil配置</strong></p>
<p>“魔术棒” –&gt; “Output” 下勾选 “Create HEX File”;</p>
<p><strong>烧录器使用</strong></p>
<ol>
<li>解压后以管理员身份运行</li>
<li>软件配置</li>
</ol>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpezhi01.png" alt="F407DAPpezhi01"></p>
<ol start="3">
<li>开始进入升级模式。首先按住BOOT0不要松手，然后再按一次RESET进入到升级模式。</li>
</ol>
<p>进入升级模式成功之后，会在软件中显示设备 <strong>GD DFU DEVICE 1</strong> 。如果没有进入请多次尝试。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpeizhi02.png" alt="F407DAPpeizhi02"></p>
<ol start="4">
<li>点击 “Connect” 连接开发板。</li>
</ol>
<p>连接成功之后，会显示出芯片内存大小。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpeizhi03.png" alt="F407DAPpeizhi03"></p>
<ol start="5">
<li>查看有无读写保护</li>
</ol>
<p>主界面中选择 “Erase selected pages” ，点击 “Erase”，如果有读写保护则需要解除保护如果没有就不管他</p>
<ol start="6">
<li>下载测试代码</li>
</ol>
<p>在主界面，点击 “Browse” ,选择 .hex 文件，之后点击 “Download”；</p>
<p>然后我们按一下复位按键，就可以让程序开始运行。</p>
<ol start="6">
<li>解除写保护</li>
</ol>
<p>在主界面，点击 “Edit Option Bytes”;</p>
<p>主要内容为修改 SPC 的值为非 0XAA 和非 0XCC 值，比如 0x55</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407DAPpeizhi04.png" alt="F407DAPpeizhi04"></p>
<blockquote>
<p>但我测试时候发现，将 WP0 下面的两个沟去掉也可以接触写保护;</p>
</blockquote>
<h2 id="调整时钟频率"><a href="#调整时钟频率" class="headerlink" title="调整时钟频率"></a>调整时钟频率</h2><p>我们在测试中发现设置为 1S 的时间间隔与实际运行时的时间相差太大，这是我们就要去修改系统的始终频率，让其与我们这个芯片所支持的时钟频率保持一致；</p>
<p>芯片选型手册</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407xinpianxuanxingbiao.png" alt="F407xinpianxuanxingbiao"></p>
<p>这张图表展示了 GD32F407VET6 芯片的主要参数和特性，以下是对各项的详细说明：</p>
<p><strong>基本参数</strong></p>
<ul>
<li><p><strong>Max Speed (MHz)</strong> - <strong>最大速度</strong>:</p>
<ul>
<li>GD32F407VET6 的主频最高可达 168 MHz，适合处理需要较高运算速度的嵌入式应用场景。</li>
</ul>
</li>
<li><p><strong>Memory (Bytes)</strong> - <strong>内存</strong>:</p>
<ul>
<li><p><strong>Flash</strong>: 512 KB 的内部 Flash 存储，用于存储程序代码。</p>
</li>
<li><p><strong>SRAM</strong>: 192 KB 的 SRAM，供程序运行时使用，存储临时数据和变量。</p>
</li>
</ul>
</li>
</ul>
<p><strong>输入&#x2F;输出 (I&#x2F;O)</strong></p>
<ul>
<li><strong>I&#x2F;O Pins</strong>: 提供了最多 82 个 GPIO 引脚（通用输入输出引脚），这些引脚可以用于连接外部设备或控制器件。</li>
</ul>
<p><strong>定时器 (Timer)</strong></p>
<ul>
<li><p><strong>Adv TM (16bit)</strong> - <strong>高级定时器</strong>:</p>
<ul>
<li>包含 2 个 16 位高级定时器，通常用于需要复杂 PWM 生成的应用，比如电机控制。</li>
</ul>
</li>
<li><p><strong>GPTM (16bit)</strong> - <strong>通用定时器</strong>:</p>
<ul>
<li>配置了 4 个 16 位通用定时器，适合用于普通计时任务或输入捕获。</li>
</ul>
</li>
<li><p><strong>GPTM (32bit)</strong> - <strong>32 位通用定时器</strong>:</p>
<ul>
<li>配置了 2 个 32 位通用定时器，适合计时精度要求较高的场景。</li>
</ul>
</li>
<li><p><strong>Basic TM (16bit)</strong> - <strong>基本定时器</strong>:</p>
<ul>
<li>配置了 2 个基本定时器，适合简单的计数或时间延迟任务。</li>
</ul>
</li>
<li><p><strong>WDG</strong> - <strong>看门狗定时器</strong>:</p>
<ul>
<li>配置了 2 个看门狗定时器，用于在程序异常时重启系统，以确保系统安全。</li>
</ul>
</li>
<li><p><strong>RTC</strong> - <strong>实时时钟</strong>:</p>
<ul>
<li>具备 1 个 RTC 实时时钟，通常用于计时任务，如数据记录或时间戳生成。</li>
</ul>
</li>
</ul>
<p><strong>通信接口 (Connectivity)</strong></p>
<ul>
<li><p><strong>USART + UART</strong>:</p>
<ul>
<li>提供 4 个 USART 和 2 个 UART 接口，可以用于串口通信，如与其他设备通信或调试信息输出。</li>
</ul>
</li>
<li><p><strong>I²C</strong>:</p>
<ul>
<li>配置了 3 个 I²C 接口，用于与 I²C 总线设备通信，比如传感器和存储设备。</li>
</ul>
</li>
<li><p><strong>SPI</strong>:</p>
<ul>
<li>包含 3 个 SPI 接口，支持与 SPI 设备的高速数据交换，比如与 ADC、DAC 通信。</li>
</ul>
</li>
<li><p><strong>CAN 2.0B</strong>:</p>
<ul>
<li>包含 2 个 CAN 2.0B 接口，用于工业控制网络中的数据传输。</li>
</ul>
</li>
<li><p><strong>USB OTG</strong>:</p>
<ul>
<li>配置了 USB 全速 (FS) 和高速 (HS) 双模式 OTG（On-The-Go）接口，可以用于 USB 设备或主机功能。</li>
</ul>
</li>
<li><p><strong>I²S</strong>:</p>
<ul>
<li>具有 2 个 I²S 接口，用于音频数据传输。</li>
</ul>
</li>
<li><p><strong>SDIO</strong>:</p>
</li>
<li><p>支持 SDIO 接口，可以与 SD 卡通信，用于数据存储应用。</p>
</li>
</ul>
<ol>
<li><strong>LCD-SDIO TFT</strong>:<ul>
<li>提供 1 个 LCD 接口，用于连接显示屏（如 TFT 屏幕）。</li>
</ul>
</li>
<li><strong>Camera</strong>:<ul>
<li>配置 1 个摄像头接口，支持外接摄像头模块，实现图像采集功能。</li>
</ul>
</li>
<li><strong>ETH MAC</strong>:<ul>
<li>配置了 1 个 Ethernet MAC 接口，可以用于网络通信应用。</li>
</ul>
</li>
</ol>
<p><strong>模拟接口 (Analog Interface)</strong></p>
<ul>
<li><p><strong>12-bit ADC Units (CHs)</strong> - <strong>ADC 单元和通道</strong>:</p>
<ul>
<li>配置了 3 个 12 位 ADC，拥有总共 16 个通道，用于模拟信号采集。</li>
</ul>
</li>
<li><p><strong>12-bit DAC Units</strong> - <strong>DAC 单元</strong>:</p>
<ul>
<li>配置了 2 个 12 位 DAC，用于将数字信号转换为模拟信号输出。</li>
</ul>
</li>
</ul>
<p><strong>存储器接口 (EMMC&#x2F;SDRAM)</strong></p>
<ul>
<li>EXMC<ul>
<li>配置了 1 个 EXMC 外部存储控制器接口，可以连接外部 SDRAM 或 NOR Flash 扩展存储器。</li>
</ul>
</li>
</ul>
<p><strong>封装 (Package)</strong></p>
<ul>
<li>LQFP100<ul>
<li>该型号的芯片封装类型为 LQFP100（100 引脚的低轮廓方形封装），方便焊接和电路板设计。</li>
</ul>
</li>
</ul>
<p>根据手册我们要设置系统主频为 168 MHz，那么要如何实现这个 168MHz 的频率，这时候就要去看板子商家的原理图和用户手册了，看他们是如何实现的，然后选择为对应的方式，如果他们设置了外部就选择外部否则可以选择内部的；</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407jinzhenbufen.png" alt="F407jinzhenbufen"></p>
<p>通过板子的原理图可以看出它使用的是外部 8MHz 所以我们在 system_gd32f4xx.c 中要放开对下面代码的注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSTEM_CLOCK_168M_PLL_8M_HXTAL        (uint32_t)(168000000)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>如果板子有 25MHz 的外部晶振</strong>，则选择 <code>__SYSTEM_CLOCK_168M_PLL_25M_HXTAL</code>。</p>
</li>
<li><p><strong>如果板子有 8MHz 的外部晶振</strong>，则选择 <code>__SYSTEM_CLOCK_168M_PLL_8M_HXTAL</code>。</p>
</li>
<li><p><strong>如果没有外部晶振（即使用内部16MHz振荡器）</strong>，则选择 <code>__SYSTEM_CLOCK_168M_PLL_IRC16M</code>。</p>
</li>
</ul>
<h2 id="调整晶振的频率"><a href="#调整晶振的频率" class="headerlink" title="调整晶振的频率"></a>调整晶振的频率</h2><p>我们这个板子使用的是外部高速的 8MHz 我们要将代码中使用的改为 8MHz</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407xitshizhong.png" alt="F407xitshizhong"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/GD32/GD32F407/F407xitongshizhong02.png" alt="F407xitongshizhong02"></p>
<p>板子上使用的是外部的晶振，她本身不知道会用到多大的，所以创建项目时候要记得去修改系统时钟相关的配置；</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、**..&#x2F;CMSIS\stm32f4xx.h(115): error: “Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)”**</p>
<p>这个报错是因为在  stm32f4xx.h 文件中，你还没有选择具体的 STM32F4 系列微控制器型号。</p>
<p>我们需要添加宏已</p>
<p>二、**..&#x2F;CMSIS\core_cmFunc.h(629): error: unknown register name ‘vfpcc’ in asm**</p>
<p>这个错误通常表示编译器无法识别 <code>vfpcc</code> 寄存器，可能是因为当前的编译设置或目标架构不正确。</p>
<p>我们需要修改 ARM 编译器的版本将他改为 5 或者 6；</p>
<p>三、**..\Firmware\misc.c(114): warning:  #223-D: function “assert_param” declared implicitly**</p>
<p>这个警告表示 <code>assert_param</code> 函数在使用时没有找到相应的声明。</p>
<p>这是我们要点击报错信息，找到这条语句，右键跳转到他的定义文件中去，这时候大概会提示文件不存在，例如提示 stm32f4xx_fmc.c 文件不存在，他有一个头文件用于导入大部分的估</p>
<p>四、**.\Objects\project.sct(7): error: L6236E: No section matches selector - no section to be FIRST&#x2F;LAST.**</p>
<p>表示没有添加启动文件</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F407</tag>
      </tags>
  </entry>
  <entry>
    <title>I2S</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/I2S/</url>
    <content><![CDATA[<p>12S(Inter-lc Sound)总线,又称<strong>集成电路内置音频总线</strong>，是飞飞利浦公司为数字音频设备之间的音频数据传输而制定的一种总线标准，该总线专门用于音频设备之间的数据传输(数字信号)。<br>12S 是一种<strong>串行数字音频接口</strong>，数据是一位一位传输的，它传输的是 PCM 或 PDM 音频数据(都是未经压缩的音频采样数据裸流)。<br>12S 和I2C 没有任务的关系。<br>I2S 特点：支持全双工 &#x2F; 半双工，支持主 &#x2F; 从模式。</p>
<p><strong>PCM 参数</strong></p>
<p>声道数、采样位数和采样频率<br>采样频率：每秒钟对声音样本采样的次数。采样频率越高，声音质量越好，但产生的数据量也越大。(常用 44kHz)<br>采样位数：每个采样的样本用多少位二进制表示数据。量化位数越多，音质越好，越细腻，数据量也越大。(常用 16 bit)<br>声道数：使用声音通道的个数，有单声道和立体声之分立体声比单声道数据量翻倍。<br>音频数据量 &#x3D; 采样频率 x 量化位数 x 声道数 (bps)</p>
<h2 id="I2S基本信号线"><a href="#I2S基本信号线" class="headerlink" title="I2S基本信号线"></a>I2S基本信号线</h2><p>12S总线至少有三条线，分别是</p>
<p><strong>SCK</strong>：(continuous serial clock)串行时钟，也叫做 BCK、BCLK (位时钟)，一个时钟传输 1bit 的数据。SCK 的频率&#x3D; 2 x 采样频率 x 采样位数。<br><strong>WS</strong>：(word select)字段(声道)选择，也叫 LRCK、LRCLK (帧时钟)，用于切换左右声道的数据。<strong>WS 的频率等于采样频率</strong>。声道选择线表明了正在被传输的声道。 <strong>WS 为”0”表示正在传输的是左声道的数据，”1”表示正在传输的是右声道的数据</strong>。<br>WS 可以在串行时钟的上升沿或者下降沿发生改变，并且 <strong>WS 信号不需要一定是对称的</strong>。在从属设备端，WS 在时钟信号的上升沿发生改变。<br>WS 总是在最高位传输前的一个时钟周期发生改变，这样可以使从属设备得到与被传输的串行数据同步的时间，并且使接收端存储当前的命令以及为下次的命令清除空间。<br><strong>SD</strong>：(serial data)串行数据，用二进制补码表示的音频数据。12S 串行数据在传输的时候，<strong>由高位(MSB)到低位(LSB)依次进行传输</strong>。<br><strong>SCK 和 WS 信号都是由主机发送的</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/jbxhx.png" alt="jbxhx"></p>
<h2 id="传输标准"><a href="#传输标准" class="headerlink" title="传输标准"></a>传输标准</h2><p>I2S 规定了 三种数据格式</p>
<h3 id="飞利浦标准"><a href="#飞利浦标准" class="headerlink" title="飞利浦标准"></a>飞利浦标准</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/flpbz.png" alt="flpbz"></p>
<p><strong>I2S Philips 标准</strong> 使用 <strong>LRCLK</strong> 切换左右声道，<strong>BCLK</strong> 控制数据传输，数据为 <strong>MSB 优先</strong>，并支持不同的位宽格式。</p>
<p>高位数据是我们有效的数据，相对来说地位数据只是精度的差别。</p>
<h3 id="左对齐标准"><a href="#左对齐标准" class="headerlink" title="左对齐标准"></a>左对齐标准</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/zdqbz.png" alt="zdqbz"></p>
<p><strong>左对齐标准</strong> 与 Philips 标准的主要区别在于 <strong>数据对齐方式</strong>：</p>
<ul>
<li><strong>左对齐：MSB 在 LRCLK 变化后紧接着 BCLK 第一个上升沿传输</strong>。</li>
<li><strong>Philips：MSB 在 LRCLK 变化后延迟 1 个 BCLK 传输</strong>。</li>
<li><strong>LRCLK 信号的高低电平代表的声道也与 Philips 相反</strong>。</li>
</ul>
<h3 id="右对齐标准"><a href="#右对齐标准" class="headerlink" title="右对齐标准"></a>右对齐标准</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/ydqbz.png" alt="ydqbz"></p>
<p><strong>右对齐标准（Sony 格式）</strong> 的核心特性是 <strong>LSB 对齐 LRCLK</strong>，这与左对齐标准（MSB 紧跟 LRCLK 变化）不同。</p>
<ul>
<li><strong>优点</strong>：适用于某些需要 LSB 对齐的数据处理场景。</li>
<li><strong>缺点</strong>：接收端必须提前知道数据字长，否则会导致数据错位。</li>
</ul>
<p>适用于 <strong>特定 DSP 或音频处理设备</strong>，不同设备需要匹配对应的传输格式。</p>
<h2 id="I2S-传输模型"><a href="#I2S-传输模型" class="headerlink" title="I2S 传输模型"></a>I2S 传输模型</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/csmx.png" alt="csmx"></p>
<h2 id="LN882H-I2S-支持"><a href="#LN882H-I2S-支持" class="headerlink" title="LN882H I2S 支持"></a>LN882H I2S 支持</h2><p>只支持从机模式<br>全双工模式双声道立体声<br>可配置的数据位宽，支持 12、16、20、24 和 32 位宽的数据<br>支持飞利浦 I2S 标准<br>I2S 不支持 DMA<br>I2S 只有一路<br>因为 I2S 只支持从机模式，所以 I2S 时钟由主机提供<br>测试 I2S 的时候一定要注意先开主机再开从机，否则初始化从机的时候，主机可能会误收数据<br>I2S 作为从机接收的时候，可能会丢掉帧头帧尾的数据，发送数据的时候不会有这个问题</p>
<blockquote>
<p><strong>I2S 的从机模式（Slave Mode）</strong> 指的是 I2S 设备不生成时钟信号，而是依赖外部设备（通常是主机）提供时钟信号（SCK 和 WS），并根据这些时钟信号进行数据的接收或发送。</p>
</blockquote>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>LN882H</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/LN882H/</url>
    <content><![CDATA[<p>LN882H是一款专为室内短距物联网连接设计的高集成度 IoT Wi-Fi&#x2F;BLE Combo MCU芯片。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/gnkt.png" alt="gnkt"></p>
<blockquote>
<p>该芯片的主要特性如下：     </p>
<p>通讯制式上支持802.11b&#x2F;g&#x2F;n和蓝牙5.1双模共存；    </p>
<p>硬件配置为Coretex M4F，160M主频，内置296KByte RAM，8&#x2F;16Mbit Flash；    </p>
<p>支持高达2000V的静电放电保护，-40度~105度环境温度，以及通过双85测试；    </p>
<p>多达20个GPIO口，具备常规ADC、PWM、SDIO、I2C等多种客户接口；    </p>
<p>Wi-Fi&#x2F;BLE满负荷运行后，客户进行Open Mcu开发时，可使用内存空间多达130KB；    </p>
<p>封装为5*5 32Pin QFN；</p>
</blockquote>
<p>根据文档说明，在没有特殊情况的时候，我们将固定 XTAL_CLOCK &#x3D; 40Mhz，PLL_CLOCK &#x3D; 160Mhz；也就是说时钟主频为 160M。</p>
<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul>
<li><p>LN882H 软件 SDK 仓库地址：<a href="https://gitee.com/lightningsemi/ln882h">https://gitee.com/lightningsemi/ln882h</a></p>
</li>
<li><p>LN882H 文档仓库地址：<a href="https://gitee.com/lightningsemi/ln882h-document-collection">https://gitee.com/lightningsemi/ln882h-document-collection</a></p>
</li>
<li><p>软件环境搭建指导：<a href="https://gitee.com/lightningsemi/ln882h/tree/master/doc">https://gitee.com/lightningsemi/ln882h/tree/master/doc</a></p>
</li>
</ul>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="软件工具安装"><a href="#软件工具安装" class="headerlink" title="软件工具安装"></a>软件工具安装</h3><p><strong>正常安装 Keil 即可，推荐使用 keil-MDK5.18 版本，与原厂SDK的开发环境保持一 致，以避免IDE环境带来的额外问题。</strong></p>
<blockquote>
<p>注意：keil 版本如果太高的话，在选择 Device 时候可能没有 ARMCM4_FP ，只有 CMSDK_CM4_FP；所以这里建议与原厂保持一致。</p>
</blockquote>
<p><strong>将Keil安装目录下的编译执行文件路径 E:\Keil_v5\ARM\ARMCC\bin 加入系统环境变量 path 和用户环境变量 path中</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/keilpz.png" alt="keilpz"></p>
<p><strong>从官网下载最新版本 python3，安装完成后将安装路径添加在系统环境变量 path 以及用户环境变量 path 中</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/pypz2.png" alt="pypz2"></p>
<blockquote>
<p>由于工程内部执行 python 脚本运行的可执行文件名是 python3，所以需要将安装好的 python3 安装目录下的可执行文件python.exe 新拷贝一份并重命名为 python3.exe 即可。</p>
<p>博主这里使用的是 Python 3.9.13，官方推荐最新版没有测试过不知道是由存在问题，如果担心这里可以选择与博主相同的版本。</p>
</blockquote>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/pyhj.png" alt="pyhj"></p>
<h3 id="Keil配置"><a href="#Keil配置" class="headerlink" title="Keil配置"></a>Keil配置</h3><p><strong>Device选择ARMCM4_FP(Cortex-M4F)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/devicexz.png" alt="devicexz"></p>
<p><strong>Debug配置J-Link调试器(如果不使用 J-Link 可忽略此步骤)</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/debugsz.png" alt="debugsz"></p>
<p><strong>使用 JFlash.exe 作为外部 Flash 工具</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/szflash.png" alt="szflash"></p>
<p>Command：..\..\..\tools\JFlash\JFlash.exe</p>
<p>Arguments：-openprj ..\..\..\tools\JFlash\ln882h.jflash -open.\flashimage.bin,0x0 -programverify</p>
<blockquote>
<p>注意：如果使用的是官方的 Demo 那么这里默认即可，因为官方实例中已经帮我们配置好了，如果是自己建的示例工程这里 JFlash 的路径一定不要选错了；</p>
</blockquote>
<h3 id="ECK板说明"><a href="#ECK板说明" class="headerlink" title="ECK板说明"></a>ECK板说明</h3><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/eckbsm.png" alt="eckbsm"></p>
<blockquote>
<p>B9(Tx)、B8(Rx)：UART0 口，官方实例中 LOG 使用的就是 UART0</p>
<p>A2(Tx)、A3(Rx)：UART1，串口烧录口</p>
<p>左边白色为复位按钮、右边白色为 Boot 模式</p>
</blockquote>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>打开官方 SDK 中的任意示例代码，编译输出如下图，表示编译成功。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/by.png" alt="by"></p>
<blockquote>
<p>在 Keil 编译流程中：</p>
<ol>
<li>编译前：Keil 调用一个 Python 脚本 (before_build_keil.py)，根据指定的配置文件 (flash_partition_cfg.json) 生成分区表头文件 (flash_partition_table.h)。<ul>
<li>命令：python3 ......\tools\python_scripts\before_build_keil.py p ..\cfg\flash_partition_cfg.json -o ..\cfg\flash_partition_table.h</li>
</ul>
</li>
<li>编译后：Keil 调用一个 after-build 脚本，处理编译生成的 .axf 文件：<ul>
<li>首先生成 .bin 和 .asm 文件；</li>
<li>然后将 boot.bin 与生成的 .bin 文件拼接合并，填充 image header 格式，最终生成 flashimage.bin。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="串口烧录"><a href="#串口烧录" class="headerlink" title="串口烧录"></a>串口烧录</h2><p>LN882H 文档仓库中提供了亮牛串口烧录工具，这是一款通过计算机串口对芯片 Flash 进行烧录的专用工具。其优点在于支持一拖多烧录，并集成了烧录后自动复位、连续烧录以及烧录失败报警等功能。<strong>为确保顺利使用，第一次使用时强烈建议查看快速使用说明，并采用工厂模式进行烧录。</strong></p>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p><strong>首先打开软件，进入到选择工作模式界面，选择默认的工厂模式进行烧录。</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/bz1.png" alt="bz1"></p>
<p><strong>进入到工厂模式后先选择串口，选择你要烧录的文件，并输入烧录地址，然后选中地址输入框左面 的选中框。最后设置烧录波特率，然后就可以点击开始下载了，具体流程如下图：</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/bz2.png" alt="bz2"></p>
<blockquote>
<p>按住 RST 的同时按住 BOOT，然后依次松开 RST 、BOOT 即可进入串口烧录模式</p>
<p>注意： </p>
<ol>
<li>烧录文件路径最好不要有中文，如果必须出现中文则不能有特殊字符以及空格。 </li>
<li>由于不同的串口工具对波特率的支持都不一样，请尝试使用多个波特率进行烧录。 </li>
<li>如果提示无法识别芯片信息，请检查芯片是否进入了BOOT状态，通过串口发送 version\r\n 指令给芯片，返回 Mar 14 2021&#x2F;00:23:32 才正确。</li>
</ol>
</blockquote>
<h2 id="JLink烧录"><a href="#JLink烧录" class="headerlink" title="JLink烧录"></a>JLink烧录</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>J-Link 通过 SWD（Serial Wire Debug）接口连接到 LN882H 开发板，通常需要连接以下信号线：</p>
<ol>
<li><strong>SWDIO（Serial Wire Debug I&#x2F;O）</strong> - 数据传输信号</li>
<li><strong>SWCLK（Serial Wire Clock）</strong> - 时钟信号</li>
<li><strong>GND（Ground）</strong> - 公共地</li>
<li><strong>VCC（Target Power）</strong> - 目标板供电检测（用于 J-Link 识别目标电压）</li>
<li><strong>nRESET（Optional）</strong> - 复位信号（可选，用于调试过程中复位芯片）</li>
</ol>
<p>在 LN882H 中 GPIOA1 为芯片的 SWD，GPIOA4 为芯片的 SCLK。</p>
<p>按照上述配置完成并在 Keil 中设置好后，点击load按钮，keil会自动调用JFlash进行烧录。</p>
<p>如下图，即表示烧录成功。注意：每次jlink烧录前确保芯片进行过复位，可按 EVK 的复位键进行彻底复位。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/jlinksl.png" alt="jlinksl"></p>
<p>烧录默认只擦除烧录bin文件大小区域，如希望在烧录前进行整片flash的擦除可 在keil配置的Utilities-&gt;Arguments中加入-erasechip参数，如下：</p>
<p>-openprj ..\..\..\tools\JFlash\ln882h.jflash -open.\flashimage.bin,0x0-programverif</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>PCM</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/PCM/</url>
    <content><![CDATA[<p>PCM（Pulse Code Modulation，脉冲编码调制）是一种用于数字音频信号处理的技术（可以理解为是一种音频数据格式），广泛应用于语音通信、音频存储和信号传输等领域。它的基本原理是将连续的模拟信号（如声音）转换为离散的数字信号，以便进行存储、传输和处理。</p>
<h2 id="PCM的基本工作原理"><a href="#PCM的基本工作原理" class="headerlink" title="PCM的基本工作原理"></a><strong>PCM的基本工作原理</strong></h2><p>PCM 的工作原理与 PWM 非常相似，主要包括三个关键步骤：</p>
<p><strong>采样（Sampling）</strong></p>
<ul>
<li>采样是指按照一定的时间间隔对连续的模拟信号进行测量，以获取其瞬时值。</li>
<li>采样率决定了信号的时间分辨率，通常以 Hz（每秒采样次数）表示。</li>
<li>例如，CD 音频的标准采样率是 <strong>44.1 kHz</strong>，即每秒钟采样 44100 次。</li>
</ul>
<p><strong>量化（Quantization）</strong></p>
<ul>
<li>量化是将采样得到的模拟值映射到离散的数值范围。</li>
<li>量化精度由位深度（Bit Depth）决定，例如 16-bit 量化表示信号可以分成 $2^{16} &#x3D; 65536$ 个离散级别。</li>
<li>量化误差是指实际信号值与量化后信号值之间的误差，较高的位深度可以减少误差，提高音频质量。</li>
</ul>
<p><strong>编码（Encoding）</strong></p>
<ul>
<li>编码是将量化后的数值转换为二进制数据，以便存储或传输。</li>
<li>例如，16-bit PCM 每个采样点用 16 位二进制数表示。</li>
</ul>
<h2 id="PCM类型"><a href="#PCM类型" class="headerlink" title="PCM类型"></a>PCM类型</h2><p>PCM 有不同的变种，主要包括：</p>
<p><strong>线性 PCM（Linear PCM, LPCM）</strong></p>
<ul>
<li>最常见的 PCM 形式，量化间隔是等间隔的，因此信号的失真较小。</li>
<li>CD 音频、WAV 文件等使用的是线性 PCM。</li>
</ul>
<p><strong>对数 PCM（Logarithmic PCM）</strong></p>
<ul>
<li>使用非线性量化，以减少数据量，常用于语音编码。</li>
<li>典型编码方式包括 <strong>μ-law（美式标准）</strong> 和 <strong>A-law（欧洲标准）</strong>，用于电话通信。</li>
</ul>
<p><strong>差分 PCM（DPCM, Differential PCM）</strong></p>
<ul>
<li>记录相邻采样值之间的差值，而不是绝对值，从而降低数据存储需求。</li>
<li>适用于低比特率的应用，如语音编码。</li>
</ul>
<p><strong>自适应差分 PCM（ADPCM, Adaptive Differential PCM）</strong></p>
<ul>
<li>在 DPCM 的基础上，动态调整量化步长，以适应信号的变化，提高效率。</li>
<li>广泛用于音视频压缩，如 G.726 语音编码标准。</li>
</ul>
<h2 id="PCM优缺点"><a href="#PCM优缺点" class="headerlink" title="PCM优缺点"></a>PCM优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>✅ <strong>高保真</strong>：PCM 是无损编码方式，不会丢失音频质量。<br> ✅ <strong>简单易实现</strong>：相比其他复杂的音频压缩算法（如 MP3、AAC），PCM 编解码计算量较低，适用于实时音频处理。<br> ✅ <strong>兼容性强</strong>：几乎所有音频设备（CD 播放器、计算机、手机等）都支持 PCM。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>❌ <strong>数据量大</strong>：PCM 不进行压缩，存储和传输成本高。例如，一分钟的 16-bit 44.1 kHz 立体声音频数据大约需要 10 MB。<br> ❌ <strong>对带宽要求高</strong>：在网络传输中，未经压缩的 PCM 需要较高带宽，不适合低带宽环境。</p>
<h2 id="PCM与PWM区别"><a href="#PCM与PWM区别" class="headerlink" title="PCM与PWM区别"></a>PCM与PWM区别</h2><p>PCM（脉冲编码调制）和 PWM（脉冲宽度调制）在名字上确实有些相似，但它们的原理和应用是完全不同的。可以简单理解为：</p>
<p>✅ <strong>PCM 是一种数字信号编码方式</strong>，主要用于音频、语音等信号的数字化存储与传输。<br>✅ <strong>PWM 是一种模拟信号调制方式</strong>，用于控制电机、LED 亮度、音频信号合成等。</p>
<blockquote>
<p>PCM 格式的数据是二进制的(0 和 1)，PWM 输出的是高低电平(0 和 1)，二者看似是一样的，但其实对于信息表达方式是完全不同的</p>
<p>✅ <strong>PCM 直接表示信号的数值</strong>（用二进制编码一个具体的幅值）。<br>✅ <strong>PWM 通过时间来编码信号的幅值</strong>（用脉冲的占空比表示模拟信号的强度）。</p>
</blockquote>
<h3 id="二者的核心区别"><a href="#二者的核心区别" class="headerlink" title="二者的核心区别"></a>二者的核心区别</h3><p><strong>PCM - 直接量化幅度</strong></p>
<p>PCM 通过<strong>二进制编码</strong>直接表示信号的瞬时幅度。<br>例如，16-bit PCM 编码可能会用 0110110100101110 这样的二进制数来表示某一时刻的信号幅值。<br>这意味着<strong>每个 PCM 采样点的数值与输入信号的幅度一一对应</strong>。</p>
<p><strong>PWM - 用时间表示幅度</strong></p>
<p>PWM <strong>不直接存储幅度值</strong>，而是通过调整“高电平持续的时间”来表达信号的强弱。<br>例如，占空比 50% 代表 50% 的幅度，占空比 75% 代表 75% 的幅度，占空比 25% 代表 25% 的幅度。<br>PWM 输出的是一连串<strong>固定频率</strong>的脉冲，而不是直接的二进制数值。</p>
<h2 id="PCM如何转为PWM信号"><a href="#PCM如何转为PWM信号" class="headerlink" title="PCM如何转为PWM信号"></a>PCM如何转为PWM信号</h2><p>PCM（脉冲编码调制）转换为 PWM（脉冲宽度调制）通常用于数字音频信号驱动功率放大器（如 D 类放大器），在这个转换过程中，PCM 主要提供<strong>信号的幅度信息</strong>，而 PWM 需要根据 PCM 信号计算出<strong>占空比</strong>，而<strong>频率通常是固定的</strong>。</p>
<h3 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h3><p><strong>设定 PWM 频率</strong></p>
<p>PWM 频率通常远高于 PCM 采样率，以确保信号能够被低通滤波器平滑还原，并避免高频噪声进入可听范围（20 Hz - 20 kHz）。<br>例如，对于 44.1 kHz 的 PCM 采样率（CD 音频），PWM 频率通常设定在 100 kHz 至 500 kHz 之间，其中 D 类音频放大器常使用 200 kHz 以上，以保证噪声超出人耳感知范围。</p>
<blockquote>
<p>PWM 频率至少应为采样率的 4-10 倍（Nyquist 定理的扩展考虑），以保证波形保真度。对于 44.1 kHz 采样率，100 kHz 是一个合理的最小值，而 200-500 kHz 是 D 类放大器的常见范围。</p>
</blockquote>
<p>PCM 本身是<strong>裸数据</strong>格式，通常没有文件头，所以你<strong>不能直接</strong>从 PCM 文件内部获取采样率，而需要从外部信息（比如文件命名、存储格式说明）或者使用正确的播放参数来解析（与同事那边商量好都使用一直的频率，比如都使用 44.1kHz）。</p>
<p>当然我们也可以使用公式大概计算出 PCM 文件的采样率</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/cyljs.png" alt="cyljs"></p>
<p><strong>计算占空比</strong></p>
<p>PCM 信号的数值范围通常是有符号整数，例如：</p>
<ul>
<li><strong>8-bit PCM</strong>: -128 ～ +127</li>
<li><strong>16-bit PCM</strong>: -32768 ～ +32767</li>
</ul>
<p>PWM 占空比计算方式：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/wfhzkbjs.png" alt="wfhzkbjs"></p>
<p>对于有符号 PCM 数据：</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/yfhzkbjs.png" alt="yfhzkbjs"></p>
<p>其中 V<sub>PCM</sub> 是当前 PCM 采样值。<br>V<sub>max</sub> 是 PCM 信号的最大值（比如 32767 对于 16-bit PCM）。<br>V<sub>min</sub> 是 PCM 信号的最小值（比如 -32768）。</p>
<p>示例：假设 PCM 采样值是 <strong>16-bit</strong>，范围是 <strong>-32768 到 32767</strong>：</p>
<ul>
<li>当 PCM &#x3D; <strong>0</strong> 时，PWM 占空比 &#x3D; <strong>50%</strong>(表示中间电平)</li>
<li>当 PCM &#x3D; <strong>32767</strong> 时，PWM 占空比 &#x3D; <strong>100%</strong></li>
<li>当 PCM &#x3D; <strong>-32768</strong> 时，PWM 占空比 &#x3D; <strong>0%</strong></li>
<li>当 PCM &#x3D; <strong>16384</strong>（一半）时，PWM 占空比 &#x3D; <strong>75%</strong></li>
<li>当 PCM &#x3D; <strong>-16384</strong>（负一半）时，PWM 占空比 &#x3D; <strong>25%</strong></li>
</ul>
<p>✅ 这样，PCM 的幅度信息就映射到了 PWM 的占空比。</p>
<p><strong>具体的数值范围可以询问数据的来源，或则通过 PCM_Bit.py 工具码进行检测</strong></p>
<p><a href="https://github.com/TooUpper/SensorDrive/tree/main/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">PCM_Bit.py 工具下载链接</a></p>
<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><p>服务端要么直接发送过来 PCM 编码，要么发送 MP3 编码，然后我本地解析为 PCM。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/Socket/</url>
    <content><![CDATA[<p><strong>Socket（套接字）</strong> 是一种编程接口（API），用于在计算机网络中实现不同主机之间通信，允许不同设备或同一设备上的不同程序通过网络发送和接收数据。</p>
<p><strong>本质</strong>：Socket 是网络通信的端点，类似于电话系统中的“插座”，连接应用程序和底层网络协议。</p>
<p><strong>用途</strong>：</p>
<ul>
<li>客户端与服务器通信（如你的 MCU 和 Python 服务器）。</li>
<li>数据传输（例如 HTTP、FTP、邮件等协议都基于 Socket）。</li>
</ul>
<p><strong>类型</strong>：</p>
<ul>
<li><strong>流套接字（SOCK_STREAM）</strong>：基于 TCP，提供可靠、面向连接的通信（你的代码中使用）。</li>
<li><strong>数据报套接字（SOCK_DGRAM）</strong>：基于 UDP，无连接、不可靠但快速。</li>
<li>其他类型（如原始套接字 SOCK_RAW，用于特殊用途）。</li>
</ul>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/socketlc.png" alt="socketlc"></p>
<p>Socket 实现通信的方式很简单，客户端和服务器只需要知道彼此的 <strong>IP 地址</strong> 和<strong>端口号</strong>，即可建立连接并进行数据传输。</p>
<h2 id="通信中-IP-和端口的需求"><a href="#通信中-IP-和端口的需求" class="headerlink" title="通信中 IP 和端口的需求"></a>通信中 IP 和端口的需求</h2><ol>
<li><strong>服务器端</strong></li>
</ol>
<ul>
<li>需要知道自己的 IP 和端口：<ul>
<li>服务器必须绑定到一个特定的 IP 和端口，以便客户端可以找到它。</li>
<li>示例：你的 Python 代码中 server.bind((“192.168.2.54”, 8080)) 指定了服务器的 IP（192.168.2.54）和端口（8080）。</li>
<li><strong>原因</strong>：服务器需要监听这个地址，等待客户端连接。</li>
</ul>
</li>
<li>不需要知道客户端的 IP 和端口：<ul>
<li>服务器通过 accept() 接受连接后，自动获取客户端的 IP 和端口（例如 conn, addr &#x3D; server.accept() 返回的 addr）。</li>
<li>示例：你的 Python 输出 Connected by (‘192.168.2.52’, xxxx)，其中 192.168.2.52 是 MCU 的 IP，xxxx 是动态分配的端口。</li>
<li><strong>原因</strong>：客户端主动发起连接，服务器被动接受，无需预先知道客户端地址。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>客户端</strong></li>
</ol>
<ul>
<li>需要知道服务器的 IP 和端口：<ul>
<li>客户端必须明确指定目标服务器的 IP 和端口，才能发起连接。</li>
<li>示例：你的 MCU 代码中 server_addr.sin_addr.s_addr &#x3D; inet_addr(“192.168.2.54”) 和 server_addr.sin_port &#x3D; lwip_htons(8080) 指定了服务器地址。</li>
<li><strong>原因</strong>：客户端通过 connect() 建立连接，需要知道服务器的“地址簿”才能拨通“电话”。</li>
</ul>
</li>
<li>不需要知道自己的 IP 和端口：<ul>
<li>客户端的 IP 由网络接口自动分配（例如你的 MCU 获取到 192.168.2.52）。</li>
<li>客户端的端口由操作系统动态分配（临时端口，例如 49152-65535 范围内的某个值），无需手动指定。</li>
<li>示例：你的 MCU 不需要显式设置本地端口，lwip_connect() 自动处理。</li>
<li><strong>原因</strong>：客户端的本地地址在连接时由协议栈管理，服务器通过连接自动获知。</li>
</ul>
</li>
</ul>
<p>所以一般情况下我们只需要知道服务端的 IP 和端口号即可，服务端会被动接受客户端的地址。</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞是对一个文件描述符指定的文件或设备的两种工作方式。 阻塞的意思是指，<strong>当试图对该文件描述符进行读写时，如果当时没有东西可读或者暂时不可写，程序就进入等待状态，直到有东西可读或者可写为止。</strong> 非阻塞的意思是，<strong>当没有东西可读或者不可写时，读写函数就马上返回，而不会等待。</strong></p>
<p>现在来理解什么是阻塞socket，什么是非阻塞socket。每个通过socket()函数创建的socket，本质就是一个文件描述符，所以对该文件描述符的 <strong>IO 操作</strong>方式不同，就有了阻塞socket和非阻塞socket。 </p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>创建</strong>：客户端和服务器分别创建 Socket（socket()）。</p>
<p><strong>绑定与监听</strong>：服务器绑定 IP 和端口（bind()），监听连接（listen()）。</p>
<p><strong>连接</strong>：客户端连接服务器（connect()），通过 TCP 三次握手建立连接。</p>
<p><strong>数据传输</strong>：双方通过 send() 和 recv() 交换数据，TCP 保证可靠传输。</p>
<p><strong>关闭</strong>：通信结束时关闭 Socket（close()），通过四次挥手释放连接。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>该实现是基于亮牛 LN882H 芯片，示例模板为 wifi_mcu_basic_example </p>
<p>可以随时监听来自指定 IP 和端口的信息，并且每 5s 向对方发送一句 Hello from MCU!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usr_app.c</span></span><br><span class="line"><span class="comment">// RTOS 任务的入口函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">socket_task_entry</span><span class="params">(<span class="type">void</span> *params)</span> &#123;</span><br><span class="line">    <span class="comment">// 声明 socket 文件描述符 sockfd，初始化为 -1，表示未创建。</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 存储服务器地址（IP 和端口）。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="comment">// 定义连接和接收的超时时间为 5 秒（5000 毫秒）。</span></span><br><span class="line">    <span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 定义发送消息的间隔为 5 秒。</span></span><br><span class="line">    <span class="type">int</span> send_interval_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="comment">// 循环检查 WiFi 是否获取到 IP 地址。</span></span><br><span class="line">    <span class="keyword">while</span> (!netdev_got_ip()) &#123;</span><br><span class="line">        LOG(LOG_LVL_INFO, <span class="string">&quot;Socket task: No IP Address...\n&quot;</span>);</span><br><span class="line">        OS_MsDelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">tcpip_ip_info_t</span> ip_info;</span><br><span class="line">    <span class="comment">// 获取 STA（客户端）模式的 IP。</span></span><br><span class="line">    netdev_get_ip_info(NETIF_IDX_STA, &amp;ip_info);</span><br><span class="line">    <span class="comment">// 将 IP 转换为字符串（如 &quot;192.168.2.52&quot;）并打印。</span></span><br><span class="line">    LOG(LOG_LVL_INFO, <span class="string">&quot;Socket task: IP assigned: %s\n&quot;</span>, ip4addr_ntoa(&amp;ip_info.ip));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查 socket 是否未创建或已关闭。</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 TCP socket。</span></span><br><span class="line">            <span class="comment">// AF_INET：IPv4 协议。</span></span><br><span class="line">			<span class="comment">// SOCK_STREAM：TCP 类型。</span></span><br><span class="line">			<span class="comment">// 0：默认协议（TCP）。SOCK_STREAM 表示是流，默认就是 TCP</span></span><br><span class="line">            sockfd = lwip_socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 检查 socket 创建是否成功。</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;Socket Creation Failed: %d\n&quot;</span>, errno);</span><br><span class="line">                OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳回循环开头。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建成功时，打印 socket 文件描述符。</span></span><br><span class="line">            LOG(LOG_LVL_INFO, <span class="string">&quot;Socket created, fd=%d\n&quot;</span>, sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 socket 设置为非阻塞模式。</span></span><br><span class="line">            <span class="type">int</span> flags = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// FIONBIO：设置非阻塞标志。flags = 1：启用非阻塞。</span></span><br><span class="line">            <span class="keyword">if</span> (lwip_ioctl(sockfd, FIONBIO, &amp;flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 失败时，关闭 socket，重试。</span></span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_ioctl failed: %d\n&quot;</span>, errno);</span><br><span class="line">                lwip_close(sockfd);</span><br><span class="line">                sockfd = <span class="number">-1</span>;</span><br><span class="line">                OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳回循环开头重试</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置服务端地址。</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));<span class="comment">// 清空结构体。</span></span><br><span class="line">            server_addr.sin_family = AF_INET; <span class="comment">// IPv4。</span></span><br><span class="line">            server_addr.sin_port = lwip_htons(<span class="number">8080</span>); <span class="comment">// 端口 8080</span></span><br><span class="line">            server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.2.217&quot;</span>); <span class="comment">// 服务端 IP</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试连接服务端。</span></span><br><span class="line">            LOG(LOG_LVL_INFO, <span class="string">&quot;Attempting to connect to 192.168.2.217:8080...\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 发起 TCP 连接。</span></span><br><span class="line">            <span class="type">int</span> connect_result = lwip_connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">            <span class="comment">// 非阻塞模式下，可能返回 -1 且 errno = EINPROGRESS（连接正在进行）。</span></span><br><span class="line">            <span class="comment">// 如果失败且不是 EINPROGRESS，关闭 socket 并重试。</span></span><br><span class="line">            <span class="keyword">if</span> (connect_result &lt; <span class="number">0</span> &amp;&amp; errno != EINPROGRESS) &#123;</span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_connect immediate failure: %d\n&quot;</span>, errno);</span><br><span class="line">                lwip_close(sockfd);</span><br><span class="line">                sockfd = <span class="number">-1</span>;</span><br><span class="line">                OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 select 检查连接状态。</span></span><br><span class="line">            fd_set writefds, exceptfds;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">            tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">            tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            FD_ZERO(&amp;writefds);</span><br><span class="line">            FD_ZERO(&amp;exceptfds);</span><br><span class="line">            <span class="comment">// 将 sockfd 添加到 fd_set 中，用于 select 函数监控。</span></span><br><span class="line">            FD_SET(sockfd, &amp;writefds);</span><br><span class="line">            FD_SET(sockfd, &amp;exceptfds);</span><br><span class="line">            <span class="type">int</span> select_result = lwip_select(sockfd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;writefds, &amp;exceptfds, &amp;tv);</span><br><span class="line">            <span class="comment">// 检查 select 结果。</span></span><br><span class="line">            <span class="keyword">if</span> (select_result &lt;= <span class="number">0</span> || FD_ISSET(sockfd, &amp;exceptfds)) &#123;</span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;Socket Connect timed out or failed after 5s\n&quot;</span>);</span><br><span class="line">                lwip_close(sockfd);</span><br><span class="line">                sockfd = <span class="number">-1</span>;</span><br><span class="line">                OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查 socket 的错误状态。</span></span><br><span class="line">            <span class="type">int</span> so_error = <span class="number">0</span>; <span class="comment">// 获取连接的最终状态。</span></span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(so_error);</span><br><span class="line">            <span class="keyword">if</span> (lwip_getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;so_error, &amp;len) &lt; <span class="number">0</span> || so_error != <span class="number">0</span>) &#123;</span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_connect failed with error: %d\n&quot;</span>, so_error);</span><br><span class="line">                lwip_close(sockfd);</span><br><span class="line">               sockfd = <span class="number">-1</span>;</span><br><span class="line">                OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 连接成功时打印日志。</span></span><br><span class="line">            LOG(LOG_LVL_INFO, <span class="string">&quot;Connected to 192.168.2.217:8080\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置接收超时为 5 秒。</span></span><br><span class="line">            tv.tv_sec = timeout_ms / <span class="number">1000</span>;</span><br><span class="line">            tv.tv_usec = (timeout_ms % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">// SO_RCVTIMEO：避免 lwip_recv 无限阻塞。</span></span><br><span class="line">            <span class="keyword">if</span> (lwip_setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_setsockopt SO_RCVTIMEO failed: %d\n&quot;</span>, errno);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义发送消息和上一次发送时间。</span></span><br><span class="line">        <span class="type">char</span> *msg = <span class="string">&quot;Hello from MCU!&quot;</span>;</span><br><span class="line">        <span class="type">uint32_t</span> last_send_time = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 进入数据收发循环。</span></span><br><span class="line">        <span class="keyword">while</span> (sockfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前时间戳（毫秒）。</span></span><br><span class="line">            <span class="type">uint32_t</span> current_time = OS_GetTicks();</span><br><span class="line">            <span class="comment">// 检查是否到发送时间（每 5 秒）。</span></span><br><span class="line">            <span class="keyword">if</span> (current_time - last_send_time &gt;= send_interval_ms) &#123;</span><br><span class="line">                <span class="comment">// 发送消息给服务端。</span></span><br><span class="line">                <span class="type">int</span> sent = lwip_send(sockfd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 失败时关闭 socket，退出收发循环。</span></span><br><span class="line">                <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_send failed: %d\n&quot;</span>, errno);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送成功时打印日志，更新发送时间。</span></span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;Sent: %s (%d bytes)\n&quot;</span>, msg, sent);</span><br><span class="line">                last_send_time = current_time;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收服务端数据。</span></span><br><span class="line">            <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">            <span class="type">int</span> len = lwip_recv(sockfd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 处理接收到的数据。</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">            <span class="comment">// 服务端关闭连接。    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;Server closed connection\n&quot;</span>);</span><br><span class="line">                lwip_close(sockfd);</span><br><span class="line">                sockfd = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 接收超时或无数据。    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == ETIMEDOUT) &#123;</span><br><span class="line">                <span class="comment">// EAGAIN/ETIMEDOUT：非阻塞模式下正常，延时 100ms。</span></span><br><span class="line">                OS_MsDelay(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他接收错误。关闭 socket，退出循环。</span></span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_recv failed: %d\n&quot;</span>, errno);</span><br><span class="line">                lwip_close(sockfd);</span><br><span class="line">                sockfd = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接断开后延时 2 秒。避免频繁重试占用资源。</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 usr_app_task_entry 中添加这个任务</span></span><br><span class="line"><span class="keyword">if</span> (OS_OK != OS_ThreadCreate(&amp;g_socket_thread, <span class="string">&quot;SocketTask&quot;</span>, socket_task_entry, <span class="literal">NULL</span>, OS_PRIORITY_BELOW_NORMAL, USR_APP_TASK_STACK_SIZE)) &#123;</span><br><span class="line">        LN_ASSERT(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">socket_task_entry</span><span class="params">(<span class="type">void</span> *params)</span> &#123;</span><br><span class="line">    <span class="comment">// 没什么意义，params不用会提示警告，用于去除警告</span></span><br><span class="line">    LN_UNUSED(params);</span><br><span class="line">    <span class="comment">// Socket ID，初始化为 -1，表示未创建。</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 存储服务端地址（IP 和端口）。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="comment">// 定义连接和接收的超时时间为 5 秒（5000 毫秒）。</span></span><br><span class="line">    <span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 控制 MCU 向服务端发送数据的频率。</span></span><br><span class="line">    <span class="type">int</span> send_interval_ms = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 检查 WiFi 是否获取到 IP 地址，返回 true 表示已连接并有 IP。 </span></span><br><span class="line">        <span class="keyword">if</span> (!netdev_got_ip()) &#123;</span><br><span class="line">            LOG(LOG_LVL_INFO, <span class="string">&quot;Socket task: No IP Address, waiting for WiFi...\n&quot;</span>);</span><br><span class="line">            OS_MsDelay(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳回主循环开头，继续检查 IP 状态。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储网络信息。</span></span><br><span class="line">        <span class="type">tcpip_ip_info_t</span> ip_info;</span><br><span class="line">        <span class="comment">// 获取 STA（客户端）模式的网络信息。</span></span><br><span class="line">        netdev_get_ip_info(NETIF_IDX_STA, &amp;ip_info);</span><br><span class="line">        <span class="comment">// 打印分配的 IP 地址、子网掩码和网关。说明已经配网成功</span></span><br><span class="line">        LOG(LOG_LVL_INFO, <span class="string">&quot;Socket task: IP assigned: %s, Mask: %s, Gateway: %s\n&quot;</span>,</span><br><span class="line">            ip4addr_ntoa(&amp;ip_info.ip),</span><br><span class="line">            ip4addr_ntoa(&amp;ip_info.netmask),</span><br><span class="line">            ip4addr_ntoa(&amp;ip_info.gw));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并打印当前 WiFi 信号强度。</span></span><br><span class="line">        <span class="comment">// dBm数值越接近0，表明信号越强。</span></span><br><span class="line">        <span class="type">int8_t</span> rssi;</span><br><span class="line">        wifi_sta_get_rssi(&amp;rssi);</span><br><span class="line">        LOG(LOG_LVL_INFO, <span class="string">&quot;WiFi RSSI: %d dBm\n&quot;</span>, rssi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保 WiFi 连接有效时才执行 Socket 操作。</span></span><br><span class="line">        <span class="keyword">while</span> (netdev_got_ip()) &#123;</span><br><span class="line">            <span class="comment">// 小于 0 表示需要创建新 Socket。</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建 TCP Socket。返回值：成功为非负整数，失败为 -1。</span></span><br><span class="line">                sockfd = lwip_socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;Socket Creation Failed: %d\n&quot;</span>, errno);</span><br><span class="line">                    OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建成功时打印 Socket 文件描述符。</span></span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;Socket created ID=%d\n&quot;</span>, sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 Socket 设置为非阻塞模式。</span></span><br><span class="line">                <span class="type">int</span> flags = <span class="number">1</span>; </span><br><span class="line">                <span class="comment">// FIONBIO：非阻塞标志。flags = 1：启用非阻塞。</span></span><br><span class="line">                <span class="keyword">if</span> (lwip_ioctl(sockfd, FIONBIO, &amp;flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_ioctl failed: %d\n&quot;</span>, errno);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 配置服务端地址。</span></span><br><span class="line">                <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">                server_addr.sin_family = AF_INET; <span class="comment">// 设置 IPv4</span></span><br><span class="line">                server_addr.sin_port = lwip_htons(<span class="number">8080</span>);</span><br><span class="line">                server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.2.51&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 尝试连接服务端。 </span></span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;Attempting to connect to 192.168.2.51:8080...\n&quot;</span>);</span><br><span class="line">                <span class="type">int</span> connect_result = lwip_connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">                <span class="comment">// 非 EINPROGRESS 的错误表示连接失败（例如服务端不可达）。</span></span><br><span class="line">                <span class="keyword">if</span> (connect_result &lt; <span class="number">0</span> &amp;&amp; errno != EINPROGRESS) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_connect immediate failure: %d\n&quot;</span>, errno);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用 select 检查连接状态。</span></span><br><span class="line">                fd_set writefds, exceptfds;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">                tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">                tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                FD_ZERO(&amp;writefds);</span><br><span class="line">                FD_ZERO(&amp;exceptfds);</span><br><span class="line">                FD_SET(sockfd, &amp;writefds);</span><br><span class="line">                FD_SET(sockfd, &amp;exceptfds);</span><br><span class="line">                <span class="type">int</span> select_result = lwip_select(sockfd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;writefds, &amp;exceptfds, &amp;tv);</span><br><span class="line">                <span class="comment">// 检查 select 结果。</span></span><br><span class="line">                <span class="comment">// select_result &lt;= 0：超时或错误。</span></span><br><span class="line">                <span class="comment">// FD_ISSET(sockfd, &amp;exceptfds)：异常。</span></span><br><span class="line">                <span class="keyword">if</span> (select_result &lt;= <span class="number">0</span> || FD_ISSET(sockfd, &amp;exceptfds)) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;Socket Connect timed out or failed after 5s, errno=%d\n&quot;</span>, errno);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查 Socket 连接的最终状态。</span></span><br><span class="line">                <span class="type">int</span> so_error = <span class="number">0</span>;</span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(so_error);</span><br><span class="line">                <span class="comment">// SO_ERROR：获取连接错误码。</span></span><br><span class="line">                <span class="keyword">if</span> (lwip_getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;so_error, &amp;len) &lt; <span class="number">0</span> || so_error != <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_connect failed with error: %d\n&quot;</span>, so_error);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 连接成功后设置接收超时。</span></span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;Connected to 192.168.2.51:8080\n&quot;</span>);</span><br><span class="line">                tv.tv_sec = timeout_ms / <span class="number">1000</span>;</span><br><span class="line">                tv.tv_usec = (timeout_ms % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">                <span class="comment">// SO_RCVTIMEO：接收超时 5 秒。</span></span><br><span class="line">                <span class="keyword">if</span> (lwip_setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_setsockopt SO_RCVTIMEO failed: %d\n&quot;</span>, errno);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义发送消息和时间戳。</span></span><br><span class="line">            <span class="type">char</span> *msg = <span class="string">&quot;Hello from MCU!&quot;</span>;</span><br><span class="line">            <span class="type">uint32_t</span> last_send_time = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 检查 Socket 和 WiFi 状态，确保通信有效。</span></span><br><span class="line">            <span class="keyword">while</span> (sockfd &gt;= <span class="number">0</span> &amp;&amp; netdev_got_ip()) &#123;</span><br><span class="line">                <span class="comment">// 获取当前时间戳</span></span><br><span class="line">                <span class="type">uint32_t</span> current_time = OS_GetTicks();</span><br><span class="line">                <span class="comment">// 每隔 5s 发送一次</span></span><br><span class="line">                <span class="keyword">if</span> (current_time - last_send_time &gt;= send_interval_ms) &#123;</span><br><span class="line">                    <span class="type">int</span> sent = lwip_send(sockfd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_send failed: %d\n&quot;</span>, errno);</span><br><span class="line">                        lwip_close(sockfd);</span><br><span class="line">                        sockfd = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOG(LOG_LVL_INFO, <span class="string">&quot;Sent: %s (%d bytes)\n&quot;</span>, msg, sent);</span><br><span class="line">                    last_send_time = current_time;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收服务端数据。最多 127 个字节</span></span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">                <span class="type">int</span> len = lwip_recv(sockfd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123; <span class="comment">// len &gt; 0：接收成功。</span></span><br><span class="line">                    buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    LOG(LOG_LVL_INFO, <span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123; <span class="comment">// len == 0：服务端关闭。</span></span><br><span class="line">                    LOG(LOG_LVL_INFO, <span class="string">&quot;Server closed connection\n&quot;</span>);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// EAGAIN/ETIMEDOUT：超时，延时 100ms。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == ETIMEDOUT) &#123;</span><br><span class="line">                    OS_MsDelay(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// 其他错误：关闭 Socket。    </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOG(LOG_LVL_ERROR, <span class="string">&quot;lwip_recv failed: %d\n&quot;</span>, errno);</span><br><span class="line">                    lwip_close(sockfd);</span><br><span class="line">                    sockfd = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 收发循环中监控 RSSI，实时检查 WiFi 状态。</span></span><br><span class="line">                wifi_sta_get_rssi(&amp;rssi);</span><br><span class="line">                LOG(LOG_LVL_INFO, <span class="string">&quot;WiFi RSSI: %d dBm\n&quot;</span>, rssi);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Socket 断开时延时重试。</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOG(LOG_LVL_ERROR, <span class="string">&quot;Socket disconnected, retrying...\n&quot;</span>);</span><br><span class="line">                OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// WiFi 断开时打印延时后等待重试。</span></span><br><span class="line">        LOG(LOG_LVL_ERROR, <span class="string">&quot;WiFi disconnected, waiting for reconnect...\n&quot;</span>);</span><br><span class="line">        OS_MsDelay(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面需要改进的地方：</p>
<ol>
<li>账密需要存储在 flash 中不需要用户二次输入</li>
<li>如果账密不对， 他会不停的触发扫描然后读取密码连接，这是需要从 flash 中读取，并且返回账密错误的信息</li>
<li>需要读取 flash 中传递过来的数据，并将其发给客户端</li>
<li>接收服务端传递过来的数据并存入 flash 中</li>
</ol>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><p>一个 python 编写的测试工具，只需要修改文件中的 IP 和端口号即可；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>喇叭</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/%E5%96%87%E5%8F%AD/</url>
    <content><![CDATA[<p>PWM（Pulse Width Modulation，脉冲宽度调制）是一种<strong>通过调节脉冲信号的占空比（Duty Cycle）来控制功率输出</strong>的技术。它广泛应用于 <strong>电机控制、LED 调光、音频信号处理</strong>等领域。</p>
<p><strong>PWM 的核心参数：</strong></p>
<p><strong>频率（Frequency）</strong>：PWM 信号的重复速率，单位 Hz。<br><strong>占空比（Duty Cycle）</strong>：高电平时间与整个周期的比例，影响输出功率。<br><strong>周期（Period）</strong>：PWM 信号的一个完整波形所占用的时间。</p>
<p><strong>PWM 的输出比较功能</strong></p>
<p>PWM 的 <strong>输出比较功能（Output Compare，简称 OC）</strong> 是基于定时器的，可以用于<strong>控制 PWM 信号的高低电平转换</strong>。其核心机制如下：</p>
<p>基本原理<br><strong>定时器</strong>计数到设定值（比较值，Compare Value）时，改变 PWM 输出信号的状态（高电平或低电平）。<br>通过设置<strong>比较寄存器（Compare Register）</strong>，决定何时翻转输出信号，从而产生 PWM 波形。</p>
<p>PWM 输出比较有多种模式，常见的有：<br>1.<strong>PWM 方式 1（PWM Mode 1）</strong><br>计数器从 0 增加（Up Counting）时，PWM 输出在 <strong>计数值小于比较值时输出高电平</strong>，否则输出低电平。<br><strong>占空比 &#x3D; (Compare Value) &#x2F; (ARR)</strong>(ARR 是自动重装寄存器)。<br>2.<strong>PWM 方式 2（PWM Mode 2）</strong><br>计数器从 0 增加时，PWM 输出在<strong>计数值小于比较值时输出低电平</strong>，否则输出高电平。<br><strong>与 PWM 方式 1 相反</strong>，适用于反相驱动。<br><strong>PWM 中心对齐模式（Center-Aligned PWM）</strong><br>计数器既增又减，使得 PWM 输出在中心点对称翻转，减少高频噪声。</p>
<p>喇叭使用的主要就是 PMW 的输出比较功能。</p>
<h2 id="LN882H对PMW支持"><a href="#LN882H对PMW支持" class="headerlink" title="LN882H对PMW支持"></a>LN882H对PMW支持</h2><p>LN882H 提供 6 个高级定时器（Timer0 至 Timer5），每个定时器支持两个 PWM 通道（通道 a 和通道 b），因此共有 12 个 PWM 通道（PWM_CHA_0 至 PWM_CHA_11）。具体映射如下：</p>
<ul>
<li>PWM_CHA_0 和 PWM_CHA_1 对应 ADV_TIMER_0_BASE；</li>
<li>PWM_CHA_2 和 PWM_CHA_3 对应 ADV_TIMER_1_BASE；</li>
<li>PWM_CHA_4 和 PWM_CHA_5 对应 ADV_TIMER_2_BASE；</li>
<li>PWM_CHA_6 和 PWM_CHA_7 对应 ADV_TIMER_3_BASE；</li>
<li>PWM_CHA_8 和 PWM_CHA_9 对应 ADV_TIMER_4_BASE；</li>
<li>PWM_CHA_10 和 PWM_CHA_11 对应 ADV_TIMER_5_BASE。</li>
</ul>
<p>由于同一定时器下的两个通道共用相同的定时器计数器，同一定时器的两个 PWM 通道必须设置为相同的频率，但占空比可以独立配置。</p>
<p>在 LN882H 中 PWM 支持是三种对齐方式：<br>ADV_TIMER_CNT_MODE_INC      是计数器向上计数，对应的 PWM 就是左对齐。<br>ADV_TIMER_CNT_MODE_DEC      是计数器向下计数，对应的 PWM 就是右对齐。<br>ADV_TIMER_CNT_MODE_BOTH     是计数器先向上计数然后向下计数，对应的 PWM 就是中间对齐，中间对齐时要注意PWM的频率左右对齐的二分之一（相同LOAD值的情况下）。</p>
<p>配置 PWM 死区的时候，会自动让 PWMA 和 PWMB 形成互补，此时，如果想改变波形的占空比只能 通过改变 PWMA 的通道值，改变 PWMB 无效。</p>
<p>LOAD 值设置为 65535 的时候会无法产生 LOAD 中断。</p>
<p>由于 PWM 中断标志位是通过 W1C ISRR 寄存器，因此无法通过写位域来清除相应标志位（因为写位域会先读再逻辑或再写，写的时候会把别的标志位也置1）。</p>
<p>PWM 占空比设置到 100% 的时候，波形会出现毛刺。</p>
<p>PWM 周期 p &#x3D; (load) * 1 &#x2F; (APB &#x2F; DIV) s，占空比为 cmp_a &#x2F; load，其中 load 为加载值，cmp_a 为比较值，APB 为外设时钟，DIV 为高级定时器的分频。</p>
<h2 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h2><p>我们要通过喇叭播放服务端处理过后通过 Socket 传递过来的音频数据，通过一组互补的 PMW 模拟 PCM 音频格式的输出。</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/lbdlsj.png" alt="lbdlsj"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>目前效果是声音小，而且只有电磁音，听不出来内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_clock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_show_reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_test_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils/debug/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_drv_pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PCM参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAMPLE_RATE   8000       <span class="comment">// 采样率 8kHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_FREQ      50000      <span class="comment">// PWM频率 50kHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINE_LENGTH   32         <span class="comment">// 正弦波表长度（模拟语音）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版PCM数据：正弦波（250 Hz，32点，8 kHz采样率）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int16_t</span> sineWave[SINE_LENGTH] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">6392</span>, <span class="number">12539</span>, <span class="number">18204</span>, <span class="number">23170</span>, <span class="number">27245</span>, <span class="number">30273</span>, <span class="number">32137</span>,</span><br><span class="line">    <span class="number">32767</span>, <span class="number">32137</span>, <span class="number">30273</span>, <span class="number">27245</span>, <span class="number">23170</span>, <span class="number">18204</span>, <span class="number">12539</span>, <span class="number">6392</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">-6392</span>, <span class="number">-12539</span>, <span class="number">-18204</span>, <span class="number">-23170</span>, <span class="number">-27245</span>, <span class="number">-30273</span>, <span class="number">-32137</span>,</span><br><span class="line">    <span class="number">-32767</span>, <span class="number">-32137</span>, <span class="number">-30273</span>, <span class="number">-27245</span>, <span class="number">-23170</span>, <span class="number">-18204</span>, <span class="number">-12539</span>, <span class="number">-6392</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 播放“你好”约0.5秒，8kHz采样率，约4000样本</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAMPLES_TOTAL 4000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">/****************** 1. 系统初始化 ***********************/</span></span><br><span class="line">    SetSysClock();</span><br><span class="line">    log_init();</span><br><span class="line">    LOG(LOG_LVL_INFO, <span class="string">&quot;LN882H init for audio playback (no amp)!\n&quot;</span>);</span><br><span class="line">    ln_show_reg_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************** 2. 外设配置 ***********************/</span></span><br><span class="line">    <span class="comment">// 初始化PWM通道</span></span><br><span class="line">    pwm_init(PWM_FREQ, <span class="number">50</span>, PWM_CHA_0, GPIO_B, GPIO_PIN_5);  <span class="comment">// PWMP，初始占空比50%</span></span><br><span class="line">    pwm_init(PWM_FREQ, <span class="number">50</span>, PWM_CHA_1, GPIO_B, GPIO_PIN_6);  <span class="comment">// PWMN，初始占空比50%</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动PWM</span></span><br><span class="line">    pwm_start(PWM_CHA_0);</span><br><span class="line">    pwm_start(PWM_CHA_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************** 3. 轮询播放“你好” ***********************/</span></span><br><span class="line">    <span class="type">uint32_t</span> sampleInterval = <span class="number">1000000</span> / SAMPLE_RATE;</span><br><span class="line">    <span class="type">uint32_t</span> sampleIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">uint16_t</span> sineIndex = (sampleIndex * SINE_LENGTH / SAMPLES_TOTAL) % SINE_LENGTH;</span><br><span class="line">        <span class="type">int16_t</span> pcmValue = sineWave[sineIndex];</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> duty = (pcmValue + <span class="number">32768.0</span>) / <span class="number">65536.0</span> * <span class="number">100.0</span>;  <span class="comment">// PCM (-32768至32767) -&gt; 占空比 (0-100%)</span></span><br><span class="line"></span><br><span class="line">        pwm_set_duty(duty, PWM_CHA_0);         <span class="comment">// PWMP</span></span><br><span class="line">        pwm_set_duty(<span class="number">100.0</span> - duty, PWM_CHA_1); <span class="comment">// PWMN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ln_delay_us(sampleInterval);</span><br><span class="line">        sampleIndex++;</span><br><span class="line">        <span class="keyword">if</span> (sampleIndex &gt;= SAMPLES_TOTAL)&#123;</span><br><span class="line">            sampleIndex = <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>异常总结</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一、<strong>跑官方 WiFi 例程时候一直重启</strong></p>
<p>例程：combo_mcu_basic_example、wifi_mcu_basic_example</p>
<p>现象：<img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/error1.png" alt="error1"></p>
<blockquote>
<p>Reboot cause: 2 这个自己添加下面这个函数打印的重启错误日志</p>
<p>chip_reboot_cause_t cause &#x3D; ln_chip_get_reboot_cause();<br>LOG(LOG_LVL_INFO, “Reboot cause: %d\r\n”, cause);</p>
</blockquote>
<p>经过排查是在 wifi_rf_calibration(); 处由于看门狗复位所导致的。</p>
<p>解决方案：</p>
<p>串口板的供电不够，使用板载的那个 USB 供电，因为 RF 校准瞬间需要几百毫安的电流，芯片电源要求：3.3V，500ma（已解决）</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>片上Flash</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/%E7%89%87%E4%B8%8AFlash/</url>
    <content><![CDATA[<p>我们当前使用的芯片属于 LN882HKI 系列，根据官方手册说明，其内置 Flash 容量为 2MB。此外，按照官方 SDK 示例中相关注释来看，采用的是 W25Q16 SPI Flash 作为存储器。</p>
<p><img src="C:\Users\kay\AppData\Roaming\Typora\typora-user-images\image-20250307095128743.png" alt="image-20250307095128743"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/error1.png" alt="error1"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>麦克风</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M4/LN/LN882H/%E9%BA%A6%E5%85%8B%E9%A3%8E/</url>
    <content><![CDATA[<p>ADC 指模&#x2F;数转换器或者模数转换器。是指将连续变化的模拟信号转换为离散的数字信号的器件。</p>
<p>我们这里需要使用 ADC 功能采集麦克风数据，将其作为 PMC 数据流发送给服务端。</p>
<h2 id="LN882H对ADC的支持"><a href="#LN882H对ADC的支持" class="headerlink" title="LN882H对ADC的支持"></a>LN882H对ADC的支持</h2><p>支持 6 通道轮询采样<br>12bit 分辨率<br>单次和连续转换模式<br>支持DMA<br>支持转换完成中断</p>
<blockquote>
<p>注：如果要使用 ADC 的 DMA，除了要使能 ADC_DMA_EN，还要配置 ADC 的转换中断使能（不用配置 NVIC），这样才能触发 DMA采集数据</p>
</blockquote>
<p>引脚和ADC通道对应关系</p>
<p>GPIOA0  -&gt;  ADC2<br>GPIOA1  -&gt;  ADC3<br>GPIOA4  -&gt;  ADC4<br>GPIOB3  -&gt;  ADC5<br>GPIOB4  -&gt;  ADC6<br>GPIOB5  -&gt;  ADC7</p>
<h2 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h2><p><strong>实体样式</strong></p>
<p>咪头式麦克风</p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/mtmkf.png" alt="mtmkf"></p>
<p><strong>规格说明</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/mkfgzsm.png" alt="mkfgzsm"></p>
<p>参数说明：</p>
<p>指向性：全指向(说明麦克风能均匀接收<strong>各个方向</strong>的声音，适用于语音采集)<br>灵敏度：-31±3(麦克风将声压转换为电信号的能力)</p>
<ul>
<li><strong>0 dB &#x3D; 1V&#x2F;Pa</strong>，即 <strong>1 帕斯卡（Pa）的声压下，麦克风输出 1V 电压</strong>。</li>
<li>规格中参数是 <strong>-31 ±3 dB</strong>，意味着灵敏度范围在 <strong>-34 dB 到 -28 dB</strong> 之间。</li>
<li>那么根据公式：<img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/dbjsgs.png" alt="dbjsgs"></li>
<li>我们可以将参数 -31dB 带入：<img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/dairufsycs.png" alt="dairufsycs">可以得出有效值为 28.2mv，峰值约为 39.9mV</li>
</ul>
<p>标准工作电压：4.5V(范围是 2v-10V，4.5V 最佳)<br>输出阻抗：2.2KΩ(麦克风输出信号的内阻，影响与后续电路的匹配)<br>频率：100Hz-20000Hz(麦克风能有效响应的音频频率范围)<br>最大耗电流：0.5mA(麦克风在工作时的最大电流)<br>…</p>
<p><strong>最小测试电路</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M4/LN882H/zxcsdl.png" alt="zxcsdl"></p>
<p>为什么不可以直接将咪头麦克风接入 ADC 引脚而需要外置电路？</p>
<p>根据规格说明中的解释我们可以得出如下麦克风特性：<br>咪头麦克风（驻极体麦克风）输出的是<strong>交流音频信号</strong>，以直流偏置电压为中心。<br>直流偏置：根据公式，假设负载电阻 R<sub>L</sub> &#x3D; 2.2kΩ，电流 0.5 mA，咪头两端压降约为 0.5 x 10<sup>-3</sup> x 2200 &#x3D; 1.1 V。若供电4.5V，输出引脚（Term 1）的直流电平约为 4.5 - 1.1 &#x3D; 3.4。<br>交流部分：±39.9 mV（1Pa声压），总输出范围约为 3.4V ± 39.9 mV（3.3601V到3.4399V）。</p>
<p>LN882H ADC 引脚特性：<br><strong>输入范围</strong>：0V 至 3.3V（单极输入，常见值）。</p>
<p><strong>分辨率</strong>：LN882H ADC 12 位(2<sup>12</sup> &#x3D; 4096），电压分辨率约为$$ \frac{3.3}{4096} \approx 0.805\text{mV} $$</p>
<p>这两个特性说明了两点：</p>
<p>第一、引脚输入电压不能超过 3.3V，因为它最大只支持 3.3V<br>第二、咪头麦克风的电压变化大概在 0.805mV 左右太微弱了，ADC 可能无法精确识别<br>第三、麦克风需要的电压为 4.5V，ADC 引脚最大也就 3.3V</p>
<p>为了解决这些问题：我们就需要外置电路，对麦克风提供 4.5V 的电压，并将电压变大让 ADC 可以正常采集这些变化；</p>
<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><p>思路：通过 ADC 读取音频数据，将其转为 PCM 数据流，通过 socket 发送给大模型进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_clock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_adc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hal/hal_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_show_reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_test_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils/debug/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_drv_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ln_drv_adc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_CHANNEL   ADC_CH5    <span class="comment">// 使用GPIOB3作为ADC输入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAMPLE_RATE   40000      <span class="comment">// 目标采样率 40kHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE   1024       <span class="comment">// PCM缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PCM缓冲区</span></span><br><span class="line"><span class="type">int16_t</span> pcmBuffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint16_t</span> bufferIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器中断回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_callback</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 直接读取最新ADC值 (0-4095，非阻塞)</span></span><br><span class="line">    <span class="type">uint16_t</span> adcValue = adc_get_data(ADC_CHANNEL);</span><br><span class="line">	LOG(LOG_LVL_INFO, <span class="string">&quot;PCM ...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 转换为16位PCM (-32768至32767)</span></span><br><span class="line">    <span class="type">int16_t</span> pcmValue = (<span class="type">int16_t</span>)((adcValue - <span class="number">2048</span>) * (<span class="number">32767.0</span> / <span class="number">2047.0</span>)); <span class="comment">// 线性映射</span></span><br><span class="line">    <span class="keyword">if</span> (pcmValue &gt; <span class="number">32767</span>) pcmValue = <span class="number">32767</span>;  <span class="comment">// 防止溢出</span></span><br><span class="line">    <span class="keyword">if</span> (pcmValue &lt; <span class="number">-32768</span>) pcmValue = <span class="number">-32768</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储到缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (bufferIndex &lt; BUFFER_SIZE)&#123;</span><br><span class="line">        pcmBuffer[bufferIndex++] = pcmValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 缓冲区满，处理数据（例如发送或重置）</span></span><br><span class="line">        bufferIndex = <span class="number">0</span>;</span><br><span class="line">        LOG(LOG_LVL_INFO, <span class="string">&quot;PCM Buffer Full, Processing...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 可添加数据传输逻辑（如串口发送）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">/****************** 1. 系统初始化 ***********************/</span></span><br><span class="line">    SetSysClock();</span><br><span class="line">    log_init();</span><br><span class="line">    LOG(LOG_LVL_INFO, <span class="string">&quot;LN882H init for audio capture!\n&quot;</span>);</span><br><span class="line">    ln_show_reg_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************** 2. 外设配置 ***********************/</span></span><br><span class="line">    <span class="comment">// 初始化ADC</span></span><br><span class="line">    adc_init(ADC_CHANNEL);  <span class="comment">// 配置ADC_CH5 (GPIOB3)为连续模式</span></span><br><span class="line">    adc_start();            <span class="comment">// 开始ADC转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化定时器 (使用Timer0，40kHz中断)</span></span><br><span class="line">    <span class="type">uint32_t</span> timer_us = <span class="number">1000000</span> / SAMPLE_RATE; <span class="comment">// 40kHz -&gt; 25 us</span></span><br><span class="line">    timer_init(TIMER_CH_0, timer_us, timer_callback); <span class="comment">// 初始化Timer0，25us中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************** 3. 采集循环 ***********************/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        ln_delay_ms(<span class="number">100</span>);  <span class="comment">// 避免CPU过载</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>LN</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M3/STM32/STM32F103/ADC/</url>
    <content><![CDATA[<p>ADC（模数转换器）是一种12位逐次逼近型转换器，支持最多18个通道（16个外部信号源和2个内部信号源）。它支持单次、连续、扫描或间断模式转换，转换结果可左对齐或右对齐存储在16位数据寄存器中。内置模拟看门狗功能，可监测输入电压是否超出用户设定的阈值。ADC输入时钟由PCLK2分频产生，最高频率不超过14MHz。</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><p><strong>基础性能</strong></p>
<ul>
<li>12位分辨率。</li>
<li>供电范围：2.4V至3.6V。</li>
<li>输入电压范围：VREF- ≤ VIN ≤ VREF+。</li>
</ul>
<p><strong>工作模式</strong></p>
<ul>
<li>支持单次、连续、自动扫描、间断模式。</li>
<li>规则转换和注入转换均支持外部触发。</li>
<li>双重模式（适用于多ADC器件）。</li>
</ul>
<p><strong>功能特性</strong></p>
<ul>
<li>转换结束、注入转换结束、模拟看门狗事件触发中断。</li>
<li>自校准功能，数据对齐（内嵌一致性校验）。</li>
<li>支持通道独立的采样间隔编程。</li>
<li>规则通道转换期间可产生DMA请求。</li>
</ul>
<p><strong>转换时间</strong>（典型值）</p>
<ul>
<li>STM32F103xx增强型：1μs（56MHz时钟）或1.17μs（72MHz）。</li>
<li>STM32F101xx基本型：1μs（28MHz时钟）或1.55μs（36MHz）。</li>
<li>STM32F102xx USB型：1.2μs（48MHz时钟）。</li>
<li>STM32F105xx&#x2F;107xx：1μs（56MHz时钟）或1.17μs（72MHz）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>VREF-引脚连接</strong>：若封装包含VREF-引脚，必须将其与VSSA（模拟地）连接。</li>
<li><strong>时钟限制</strong>：输入时钟频率不可超过14MHz，需通过PCLK2分频配置。</li>
</ul>
<h2 id="ADC模块框图"><a href="#ADC模块框图" class="headerlink" title="ADC模块框图"></a>ADC模块框图</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/ADCmkkt.png" alt="ADCmkkt"></p>
<h2 id="ADC引脚"><a href="#ADC引脚" class="headerlink" title="ADC引脚"></a>ADC引脚</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/ADCyj.png" alt="ADCyj"></p>
<h2 id="ADC通道和引脚对应关系"><a href="#ADC通道和引脚对应关系" class="headerlink" title="ADC通道和引脚对应关系"></a>ADC通道和引脚对应关系</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/ADCtd.png" alt="ADCtd"></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
<p>说明一下这里采样到的数值是 0~4095 因为寄存器最大就是 12 位，所以是 4095；</p>
<p><strong>ADC值 0</strong>：表示输入电压为 <strong>0V</strong>。</p>
<p><strong>ADC值 4095</strong>：表示输入电压为 <strong>V_ref</strong>（通常为 3.3V 或 5V）。</p>
<p><strong>ADC值 2047</strong>：表示输入电压大约为 <strong>V_ref &#x2F; 2</strong>，例如 1.65V 如果 <strong>V_ref &#x3D; 3.3V</strong>。</p>
<p>这里得到的 0~4095 不停波动的值指的是该引脚采样所获取的电压值；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F103</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M3/STM32/STM32F103/DMA/</url>
    <content><![CDATA[<p><strong>DMA（直接内存访问）</strong> 是一种强大的功能，用于实现内存与外设之间以及内存与内存之间的高速数据传输。通过 DMA，数据可以快速地移动，而无需 CPU 的干预，这样可以让 CPU 专注于其他任务，从而提高系统效率。</p>
<p><strong>DMA 控制器概述</strong></p>
<p>STM32 具有两个 DMA 控制器：<strong>DMA1</strong> 和 <strong>DMA2</strong>。</p>
<ul>
<li><strong>DMA1</strong>：7 个通道</li>
<li><strong>DMA2</strong>：5 个通道</li>
<li><strong>总共</strong>：12 个可配置的 DMA 通道。</li>
</ul>
<p><strong>DMA 通道</strong></p>
<p>每个 DMA 通道管理一个或多个外设的内存访问请求。</p>
<p>DMA 通道通过专用硬件 DMA 请求与外设进行通信，也支持软件触发器。</p>
<p>每个 DMA 通道具有独立的配置功能，包括数据传输方向、内存和外设的数据大小等。</p>
<p>每个通道都能够独立配置，可以连接到外设（如 USART、SPI、ADC、DAC 等）进行数据传输。</p>
<p><strong>DMA 请求优先级</strong></p>
<p>DMA 通道之间的优先级是可编程的，有 4 个优先级级别：非常高、高、中、低。</p>
<p>当多个请求的优先级相等时，优先级由硬件决定（例如请求1优先于请求2）。</p>
<p><strong>支持的传输类型</strong></p>
<p>DMA 支持以下几种数据传输模式：</p>
<ul>
<li><strong>内存到内存</strong>：可以直接在内存之间传输数据。</li>
<li><strong>外设到内存</strong>：将外设（例如 USART、ADC）的数据传输到内存。</li>
<li><strong>内存到外设</strong>：将内存中的数据传输到外设（例如 DAC、USART）。</li>
<li><strong>外设到外设</strong>：外设之间的数据传输。</li>
</ul>
<p><strong>数据传输大小</strong></p>
<p>DMA 支持独立的源和目标数据传输大小，常见的大小单位包括字节、半字、字等。</p>
<p>数据源和目标地址必须按数据大小进行对齐。</p>
<p><strong>循环缓冲区</strong></p>
<p>支持<strong>循环缓冲区管理</strong>，适用于需要连续读取&#x2F;写入数据的场景。</p>
<p><strong>事件标志和中断</strong></p>
<p>DMA 控制器有三个主要的事件标志：</p>
<ol>
<li><strong>DMA 半传输完成</strong>（表示数据块的一部分已传输完毕）</li>
<li><strong>DMA 传输完成</strong>（表示数据传输完成）</li>
<li><strong>DMA 传输错误</strong>（表示传输过程中发生了错误）</li>
</ol>
<p>这些事件标志会通过单个中断请求统一处理，简化中断管理。</p>
<p><strong>数据传输的访问目标</strong></p>
<p>DMA 可以访问各种外设和内存区域：</p>
<ul>
<li><strong>闪存</strong>、<strong>SRAM</strong>、<strong>APB1</strong>、<strong>APB2</strong> 和 <strong>AHB</strong> 外设。</li>
</ul>
<p>数据传输的<strong>可编程数据传输数量</strong>最大为 <strong>65536</strong>。</p>
<p><strong>数据传输的触发</strong></p>
<p><strong>硬件触发</strong>：通过外设的事件触发 DMA 数据传输。</p>
<p><strong>软件触发</strong>：可以通过软件请求启动 DMA 传输。</p>
<h2 id="DMA模块框图"><a href="#DMA模块框图" class="headerlink" title="DMA模块框图"></a>DMA模块框图</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/dmamkkt.png" alt="dmamkkt"></p>
<h2 id="DMA处理"><a href="#DMA处理" class="headerlink" title="DMA处理"></a>DMA处理</h2><p>在发生一个事件后，外设向DMA控制器发送一个请求信号。DMA控制器根据通道的优先权处理请求。当DMA控制器开始访问发出请求的外设时，DMA控制器立即发送给它一个应答信号。当从DMA控制器得到应答信号时，外设立即释放它的请求。一旦外设释放了这个请求，DMA控制器同时撤销应答信号。如果有更多的请求时，外设可以启动下一个周期。</p>
<p>总之，每次DMA传送由3个操作组成:</p>
<ul>
<li>从外设数据寄存器或者从当前外设&#x2F;存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是DMACPARX或DMACARx存指定的外设基地址或存储单元。</li>
<li>存数据到外设数据寄存器或者当前外设&#x2F;存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是DMACPARX或DMACMARx存器指定的外设基地址或存储器单元。</li>
<li>执行一次DMACNDTRx寄存器的递减操作，该寄存器包含未完成的操作数目。</li>
</ul>
<h2 id="DMA-请求表"><a href="#DMA-请求表" class="headerlink" title="DMA 请求表"></a>DMA 请求表</h2><p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/DMA1qqb.png" alt="DMA1qqb"></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/DMA2qqb.png" alt="DMA2qqb.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F103</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32F103C8T6</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M3/STM32/STM32F103/STM32F103C8T6/</url>
    <content><![CDATA[<p><strong>命名规则</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/STM32F103mmguize.png" alt="STM32F103mmguize"></p>
<p><strong>引脚定义</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/STM32F103yinjiao.png" alt="STM32F103yinjiao"></p>
<p><strong>系统架构</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/STM32F103xitongjiagou.png" alt="STM32F103xitongjiagou"></p>
<p><strong>启动配置</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/STM32F103qidongpeizhi.png" alt="STM32F103qidongpeizhi"></p>
<p><strong>最小系统电路</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/STM32F103zuixiaoxitongdianlu.png" alt="STM32F103zuixiaoxitongdianlu"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F103</tag>
      </tags>
  </entry>
  <entry>
    <title>新建工程步骤</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M3/STM32/STM32F103/Init/</url>
    <content><![CDATA[<p><strong>命名规则</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/STM32F103mmguize.png" alt="STM32F103mmguize"></p>
<ol>
<li>创建工程文件夹、Keil 中新建工程，选择芯片型号</li>
<li>工程文件夹中创建 Start、Library、User 等文件夹，复制固件库中的文件到对应文件夹中</li>
<li>Keil 工程中添加对应的 Start、Libray、User等同名的分区,然后将文件夹内的文件添加到对应的组里</li>
<li>Keil 工程选项，C&#x2F;C++，Include Paths 中添引入工作文件夹</li>
<li>Keil 工程选项，C&#x2F;C++, Define 内定义 USE_STDPERIRH_DRIVER</li>
</ol>
<p>启动文件,ARM启动时候要初始化堆栈指针。等等</p>
<p>外设寄存器描述文件和时钟配置文件</p>
<p>内核的寄存器描述文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Project/</span><br><span class="line">│</span><br><span class="line">├── Docs/                          <span class="comment">// 说明文档</span></span><br><span class="line">│   ├── Guides/                   <span class="comment">// 使用指南</span></span><br><span class="line">│   ├── API/                      <span class="comment">// 接口文档</span></span><br><span class="line">│   └── Changelog/                <span class="comment">// 更新日志</span></span><br><span class="line">│</span><br><span class="line">├── Source/                       <span class="comment">// 源代码文件</span></span><br><span class="line">│   ├── Main/                     <span class="comment">// 主程序</span></span><br><span class="line">│   ├── Utils/                    <span class="comment">// 工具函数</span></span><br><span class="line">│   └── Tasks/                    <span class="comment">// 任务管理</span></span><br><span class="line">│</span><br><span class="line">├── Drivers/                      <span class="comment">// 硬件驱动程序</span></span><br><span class="line">│   ├── GPIO/                     <span class="comment">// GPIO 驱动</span></span><br><span class="line">│   ├── ADC/                      <span class="comment">// ADC 驱动</span></span><br><span class="line">│   └── UART/                     <span class="comment">// UART 驱动</span></span><br><span class="line">│</span><br><span class="line">├── Vendor_Libs/             <span class="comment">// 官方提供的固件库函数</span></span><br><span class="line">│   └── [固件库相关文件]</span><br><span class="line">│</span><br><span class="line">├── Custom_Libs/                  <span class="comment">// 自己封装的库</span></span><br><span class="line">│   ├── Math/                     <span class="comment">// 数学库</span></span><br><span class="line">│   └── Communication/            <span class="comment">// 通信库</span></span><br><span class="line">│</span><br><span class="line">└── Build/                        <span class="comment">// 程序生成的可执行文件</span></span><br><span class="line">    ├── Binaries/                 <span class="comment">// 二进制文件</span></span><br><span class="line">    └── Logs/                     <span class="comment">// 日志文件</span></span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、<strong>初始化编译报错</strong></p>
<p><strong>error: non-ASM statement in naked function is not supported</strong></p>
<p>修改编译器版本为 5 的版本</p>
<p>如果 Missing:Compiler Version 5 没有要去<a href="https://developer.arm.com/documentation/ka005198/latest">官网</a>下载（需要登陆注册吧比较麻烦，百度云中有了）</p>
<p><strong>error: A1023E: File “..\Firmware\CMSIS\startup_stm32f10x_md.s” could not be opened: No such file or directory</strong></p>
<p><strong>Error:  #5: cannot open source input file “..\Firmware\CMSIS\core_cm3.c”: No such file or directory</strong></p>
<p><strong>Error:  #5: cannot open source input file “..\Firmware\CMSIS\system_stm32f10x.c”: No such file or directory</strong></p>
<p>这是路径错了，正确的路径应该是 ..\CMSIS\system_stm32f10x.c，删掉多余的引用；</p>
<p><strong>warning:  #223-D: function “assert_param” declared implicitly</strong></p>
<p>在 stm32f10x.h 中没有引用 stm32f10x_conf.h 头文件，将其宏定义放开即可；添加 USE_STDPERIPH_DRIVER 宏。</p>
<p><strong>Error: L6218E: Undefined symbol RCC_APB1PeriphResetCmd (referred from stm32f10x_usart.o).</strong></p>
<p>引用的 RCC_APB1PeriphResetCmd 找不到，我们要将对应的 stm32f10x_rcc.h 添加到环境中；</p>
<p><strong>Error: L6218E: Undefined symbol assert_param (referred from misc.o).</strong></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F103</tag>
      </tags>
  </entry>
  <entry>
    <title>Timer</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M3/STM32/STM32F103/Timer/</url>
    <content><![CDATA[<p>TIM 定时器是用于产生精确时间控制的 <strong>16 位自动装载计数器</strong>。这些定时器被广泛应用于信号生成、PWM 控制、输入捕获、输出比较等多种嵌入式应用中。通过灵活的配置，定时器可以满足从简单的时间控制到复杂的多任务同步等多种需求。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>主要特点</strong></p>
<ul>
<li><p><strong>16 位计数器</strong>：定时器采用 <strong>16 位计数器</strong>，可以产生高精度的计时和信号控制。</p>
</li>
<li><p><strong>可编程的时钟分频器</strong>：定时器支持 <strong>16 位可编程预分频器</strong>，时钟频率可调，分频范围从 1 到 65536，适应不同的应用场景。</p>
</li>
<li><p><strong>多功能通道支持</strong>：支持 <strong>4 种输入输出通道</strong>，可以进行 <strong>输入捕获、输出比较、PWM 输出</strong> 等多种功能，广泛用于电机控制、亮度调节、频率测量等。</p>
</li>
<li><p><strong>死区时间控制</strong>：支持 <strong>PWM 信号的死区时间控制</strong>，适用于 H 桥电路驱动和电机控制等应用，确保信号的稳定性。</p>
</li>
<li><p><strong>DMA 支持</strong>：定时器支持 <strong>DMA</strong>，可以高效地将数据从外设传输到内存，减少 CPU 占用，提高系统性能。</p>
</li>
<li><p><strong>多定时器同步</strong>：多个定时器可以通过同步信号协同工作，适用于更复杂的应用场景，如多任务控制。</p>
</li>
<li><p><strong>高级功能（TIM1 和 TIM8）</strong>：<strong>TIM1</strong> 和 <strong>TIM8</strong> 定时器作为高级定时器，支持更高精度的频率控制、波形生成和同步功能。</p>
</li>
</ul>
<p><strong>各定时器功能区分如下</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/Timerqf.png" alt="Timerqf"></p>
<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>时钟配置</strong>：在配置定时器时，要确保时钟源的正确配置，特别是当使用 <strong>外部时钟源</strong> 或 <strong>预分频器</strong> 时，确保时钟频率符合系统要求。</p>
</li>
<li><p><strong>死区时间控制</strong>：当使用 <strong>PWM 输出</strong> 时，需要合理设置 <strong>死区时间</strong>，避免输出信号的交叠，这在电机驱动和高功率控制应用中尤为重要。</p>
</li>
<li><p><strong>DMA 配置</strong>：使用 <strong>DMA</strong> 时，要确保 DMA 配置正确，确保数据的传输效率，并避免冲突。</p>
</li>
<li><p><strong>同步信号</strong>：在使用多个定时器进行同步操作时，需要确保各定时器的同步信号正确配置，避免不同定时器之间的竞争条件。</p>
</li>
<li><p><strong>高级定时器的资源共享</strong>：<strong>TIM1</strong> 和 <strong>TIM8</strong> 是高级定时器，它们共享一些系统资源。在使用这些定时器时，要注意避免资源冲突，确保系统的稳定性。</p>
</li>
</ul>
<h2 id="功能框图"><a href="#功能框图" class="headerlink" title="功能框图"></a>功能框图</h2><p><strong>高级定时器框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/gjdsqgnkt.png" alt="gjdsqgnkt"></p>
<p><strong>通用定时器框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/tydsqgnkt.png" alt="tydsqgnkt"></p>
<p><strong>基本定时器框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/jbdsqgnkt.png" alt="jbdsqgnkt"></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
<p>说明一下这里采样到的数值是 0~4095 因为寄存器最大就是 12 位，所以是 4095；</p>
<p><strong>ADC值 0</strong>：表示输入电压为 <strong>0V</strong>。</p>
<p><strong>ADC值 4095</strong>：表示输入电压为 <strong>V_ref</strong>（通常为 3.3V 或 5V）。</p>
<p><strong>ADC值 2047</strong>：表示输入电压大约为 <strong>V_ref &#x2F; 2</strong>，例如 1.65V 如果 <strong>V_ref &#x3D; 3.3V</strong>。</p>
<p>这里得到的 0~4095 不停波动的值指的是该引脚采样所获取的电压值；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F103</tag>
      </tags>
  </entry>
  <entry>
    <title>输入捕获</title>
    <url>/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/ARM/Cortex-M3/STM32/STM32F103/%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<p>输入捕获是一种通过定时器捕捉外部信号<strong>特定边沿</strong>（如上升沿或下降沿）发生时的时间戳的功能。它可以精确测量外部信号的周期、频率或脉宽等时间特性，常用于频率计数、脉冲宽度测量和信号时序分析等应用。输入捕获模式通常通过定时器的输入引脚接收信号，并将捕获的时间值存储在定时器的捕获寄存器中。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>输入捕获模式</strong>：</p>
<ul>
<li>当定时器在输入捕获模式下工作时，它会检测输入信号（如ICx引脚上的信号），并根据设定条件记录捕获时刻的计数器值。</li>
<li>在这种模式下，定时器会通过输入信号触发捕获，并将捕获的时间戳存储在寄存器TIMx_CCR1中。</li>
<li>需要注意的是，捕获是基于输入信号的边沿进行的，通常是上升沿或下降沿，取决于配置。</li>
</ul>
<p><strong>配置步骤</strong>：</p>
<ul>
<li>选择输入引脚并配置TIMx_CCR1寄存器连接到对应的输入信号。</li>
<li>配置输入信号的边沿检测（上升沿或下降沿），通过设置TIMx_CCMR寄存器的CC1S位来选择。</li>
<li>配置定时器的周期频率，并通过设置TIMx_CCR1寄存器的C1E位来允许或禁止捕获。</li>
</ul>
<p><strong>定时器寄存器的配置</strong>：</p>
<ul>
<li>配置TIMx_CCR1寄存器中的C1S位来选择输入信号的类型（例如选择TIMx的输入引脚）。</li>
<li>配置TIMx_CCMR寄存器中的CC1S位，用于选择捕获的边沿（上升沿或下降沿）。</li>
<li>允许或禁止DMA请求和中断功能，通过设置TIMx_DIER寄存器中的CC1IE位和CC1DMA位来启用DMA和中断请求。</li>
</ul>
<p><strong>输入捕获时的工作原理</strong>：</p>
<ul>
<li>在输入信号的每次边沿变化时，TIMx_CCR1寄存器会捕获当前计数器的值。</li>
<li>如果启用了DMA，捕获值会自动传送到内存或其他寄存器，并生成中断或DMA请求。</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>主要特点</strong></p>
<ul>
<li><p><strong>16 位计数器</strong>：定时器采用 <strong>16 位计数器</strong>，可以产生高精度的计时和信号控制。</p>
</li>
<li><p><strong>可编程的时钟分频器</strong>：定时器支持 <strong>16 位可编程预分频器</strong>，时钟频率可调，分频范围从 1 到 65536，适应不同的应用场景。</p>
</li>
<li><p><strong>多功能通道支持</strong>：支持 <strong>4 种输入输出通道</strong>，可以进行 <strong>输入捕获、输出比较、PWM 输出</strong> 等多种功能，广泛用于电机控制、亮度调节、频率测量等。</p>
</li>
<li><p><strong>死区时间控制</strong>：支持 <strong>PWM 信号的死区时间控制</strong>，适用于 H 桥电路驱动和电机控制等应用，确保信号的稳定性。</p>
</li>
<li><p><strong>DMA 支持</strong>：定时器支持 <strong>DMA</strong>，可以高效地将数据从外设传输到内存，减少 CPU 占用，提高系统性能。</p>
</li>
<li><p><strong>多定时器同步</strong>：多个定时器可以通过同步信号协同工作，适用于更复杂的应用场景，如多任务控制。</p>
</li>
<li><p><strong>高级功能（TIM1 和 TIM8）</strong>：<strong>TIM1</strong> 和 <strong>TIM8</strong> 定时器作为高级定时器，支持更高精度的频率控制、波形生成和同步功能。</p>
</li>
</ul>
<p><strong>各定时器功能区分如下</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/Timerqf.png" alt="Timerqf"></p>
<p><strong>注意事项</strong></p>
<ul>
<li><p><strong>时钟配置</strong>：在配置定时器时，要确保时钟源的正确配置，特别是当使用 <strong>外部时钟源</strong> 或 <strong>预分频器</strong> 时，确保时钟频率符合系统要求。</p>
</li>
<li><p><strong>死区时间控制</strong>：当使用 <strong>PWM 输出</strong> 时，需要合理设置 <strong>死区时间</strong>，避免输出信号的交叠，这在电机驱动和高功率控制应用中尤为重要。</p>
</li>
<li><p><strong>DMA 配置</strong>：使用 <strong>DMA</strong> 时，要确保 DMA 配置正确，确保数据的传输效率，并避免冲突。</p>
</li>
<li><p><strong>同步信号</strong>：在使用多个定时器进行同步操作时，需要确保各定时器的同步信号正确配置，避免不同定时器之间的竞争条件。</p>
</li>
<li><p><strong>高级定时器的资源共享</strong>：<strong>TIM1</strong> 和 <strong>TIM8</strong> 是高级定时器，它们共享一些系统资源。在使用这些定时器时，要注意避免资源冲突，确保系统的稳定性。</p>
</li>
</ul>
<h2 id="功能框图"><a href="#功能框图" class="headerlink" title="功能框图"></a>功能框图</h2><p><strong>高级定时器框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/gjdsqgnkt.png" alt="gjdsqgnkt"></p>
<p><strong>通用定时器框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/tydsqgnkt.png" alt="tydsqgnkt"></p>
<p><strong>基本定时器框图</strong></p>
<p><img src="/public/image/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/ARM/Cortex-M3/STM32/STM32F103/jbdsqgnkt.png" alt="jbdsqgnkt"></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p><a href="https://github.com/TooUpper/SensorDrive">https://github.com/TooUpper/SensorDrive</a></p>
<p>说明一下这里采样到的数值是 0~4095 因为寄存器最大就是 12 位，所以是 4095；</p>
<p><strong>ADC值 0</strong>：表示输入电压为 <strong>0V</strong>。</p>
<p><strong>ADC值 4095</strong>：表示输入电压为 <strong>V_ref</strong>（通常为 3.3V 或 5V）。</p>
<p><strong>ADC值 2047</strong>：表示输入电压大约为 <strong>V_ref &#x2F; 2</strong>，例如 1.65V 如果 <strong>V_ref &#x3D; 3.3V</strong>。</p>
<p>这里得到的 0~4095 不停波动的值指的是该引脚采样所获取的电压值；</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>STM32F103</tag>
      </tags>
  </entry>
</search>
