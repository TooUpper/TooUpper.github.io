<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="应用程序与基本执行环境创建一个bin项目12345$ mkdir tuos$ cd tuos$ cargo new os --bin    Creating binary (application) &#96;os&#96; packagenote: see more &#96;Cargo.toml&#96; keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;carg">
<meta property="og:type" content="article">
<meta property="og:title" content="应用程序与基本执行环境">
<meta property="og:url" content="https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/index.html">
<meta property="og:site_name" content="流年不知心底事">
<meta property="og:description" content="应用程序与基本执行环境创建一个bin项目12345$ mkdir tuos$ cd tuos$ cargo new os --bin    Creating binary (application) &#96;os&#96; packagenote: see more &#96;Cargo.toml&#96; keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;carg">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.tooupper.org/public/image/OS/tuos/MemoryLayout.png">
<meta property="og:image" content="https://www.tooupper.org/public/image/tuos/MemoryLayout-Linker.png">
<meta property="article:published_time" content="2024-04-02T13:02:02.000Z">
<meta property="article:modified_time" content="2025-01-07T10:58:33.635Z">
<meta property="article:author" content="kay">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="rCore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.tooupper.org/public/image/OS/tuos/MemoryLayout.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>应用程序与基本执行环境</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">博主</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/OS/rCore/%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/Git/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&text=应用程序与基本执行环境"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&is_video=false&description=应用程序与基本执行环境"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=应用程序与基本执行环境&body=Check out this article: https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&name=应用程序与基本执行环境&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&t=应用程序与基本执行环境"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">应用程序与基本执行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAbin%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">创建一个bin项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%AF%B9%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.</span> <span class="toc-text">移除执行环境对操作系统的依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E7%9B%AE%E6%A0%87%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.添加目标平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E9%99%A4%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.移除标准库依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.添加错误处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A7%BB%E9%99%A4%E6%A0%87%E5%87%86main%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.移除标准main函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81Qemu%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%8F%AF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">验证Qemu模拟器与执行环境是否正确可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">编写内核第一条指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.3.2.</span> <span class="toc-text">调整内核的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">手动加载内核可执行文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EGDB%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">基于GDB验证启动流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%88%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%8F%8A%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">设置栈空间以及内核初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.1.</span> <span class="toc-text">分配栈空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">编写入口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-bss-%E6%AE%B5%E7%9A%84%E6%B8%85%E9%9B%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">对 .bss 段的清零</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8RustSBI-%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.</span> <span class="toc-text">使用RustSBI 实现字符打印功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-SBI-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">调用 SBI 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%9C%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.2.</span> <span class="toc-text">实现关机功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.3.</span> <span class="toc-text">格式化输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">程序内存布局与编译流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.1.</span> <span class="toc-text">程序内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">编译流程</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        应用程序与基本执行环境
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">kay</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-04-02T13:02:02.000Z" class="dt-published" itemprop="datePublished">2024-04-02</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/OS/">OS</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Rust/" rel="tag">Rust</a>, <a class="p-category" href="/tags/rCore/" rel="tag">rCore</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="应用程序与基本执行环境"><a href="#应用程序与基本执行环境" class="headerlink" title="应用程序与基本执行环境"></a>应用程序与基本执行环境</h1><h2 id="创建一个bin项目"><a href="#创建一个bin项目" class="headerlink" title="创建一个bin项目"></a>创建一个bin项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new os --bin</span></span><br><span class="line">    Creating binary (application) `os` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<h2 id="移除执行环境对操作系统的依赖"><a href="#移除执行环境对操作系统的依赖" class="headerlink" title="移除执行环境对操作系统的依赖"></a>移除执行环境对操作系统的依赖</h2><h3 id="1-添加目标平台"><a href="#1-添加目标平台" class="headerlink" title="1.添加目标平台"></a>1.添加目标平台</h3><ol>
<li>我们要构建一个可以在裸机上运行的 RISC-V架构的操作系统，那么就需要添加对目标平台的支持：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/os</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version --verbose</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: 385fa9d845dd326c6bbfd58c22244215e431948a</span><br><span class="line">commit-date: 2024-04-04</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.79.0-nightly</span><br><span class="line">LLVM version: 18.1.2</span><br></pre></td></tr></table></figure>

<p>这条命令有几个作用：</p>
<ol>
<li><p><strong>识别目标平台：</strong></p>
<ul>
<li><code>riscv64gc</code> 表示 RISC-V 64位通用计算（General-Purpose Computing）架构（ CPU 架构）。</li>
<li><code>unknown</code> 表示 Rust 不了解这个目标的操作系统或供应商信息（CPU 厂商）。</li>
<li><code>none</code> 表示没有操作系统，这通常用于裸机编程（操作系统）。</li>
<li><code>elf</code> 表示没有标准的运行时库（没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序（运行时库）。</li>
</ul>
</li>
<li><p><strong>安装必要组件：</strong>如果 <code>rustup</code> 有为 <code>riscv64gc-unknown-none-elf</code> 准备的预编译组件，它会尝试下载并安装这些组件。</p>
</li>
<li><p><strong>更新Rust工具链配置：</strong>在 Rust 配置中添加对新目标的支持，这样当你使用 <code>cargo build --target riscv64gc-unknown-none-elf</code> 命令时，Cargo 就会知道如何为 <code>riscv64gc-unknown-none-elf</code> 目标构建你的项目。</p>
</li>
</ol>
<p>可以使用如下命令查看当前Rust工具链支持的所有目标平台:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target list</span></span><br></pre></td></tr></table></figure>

<p>2.在 <code>tuos</code> 目录下新建 <code>.cargo</code> 目录，并在这个目录下创建 <code>config</code> 文件，并在里面输入如下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#  tuos/os/.cargo/config</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会对于 Cargo 工具在 os 目录下的行为进行调整：<strong>现在默认会使用 riscv64gc 作为目标平台而不是原先的默认 x86_64-unknown-linux-gnu。</strong></p>
<h3 id="2-移除标准库依赖"><a href="#2-移除标准库依赖" class="headerlink" title="2.移除标准库依赖"></a>2.移除标准库依赖</h3><p>我们希望它能够被编译到 RV64GC 裸机平台上，为此我们需要移除它对于 Rust std标准库的依赖，因为 Rust std标准库自己就需要操作系统内核的支持。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tuos/os/src/main.rs</span><br><span class="line"><span class="comment">// 告诉 Rust 编译器不使用 Rust 标准库 std 转而使用核心库 core（core库不需要操作系统的支持）;</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 注释掉println!宏,它是由标准库 std 提供的且会使用到一个名为 write 的系统调用;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加错误处理机制"><a href="#3-添加错误处理机制" class="headerlink" title="3.添加错误处理机制"></a>3.添加错误处理机制</h3><p>Rust编译器在编译程序时，从安全性考虑，需要有 <code>panic!</code> 宏的具体实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># os/src/lang_items.rs</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="comment">// 指定一个函数作为程序的 panic 处理程序。</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把 <code>panic_handler</code> 配置在单独的文件 <code>tuos/src/lang_items.rs</code> 后，需要在os&#x2F;src&#x2F;main.rs文件中添加以下内容才能正常编译整个软件：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br></pre></td></tr></table></figure>

<h3 id="4-移除标准main函数"><a href="#4-移除标准main函数" class="headerlink" title="4.移除标准main函数"></a>4.移除标准main函数</h3><p>应用程序在执行之前进行一些初始化工作，然后才跳转到应用程序的入口点（也就是跳转到我们编写的 <code>main</code> 函数）开始执行。 <code>start</code> 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。最简单的解决方案就是压根不让编译器使用这项功能。我们在 <code>main.rs</code> 的开头加入设置 <code>#![no_main]</code> 告诉编译器我们没有一般意义上的 <code>main</code> 函数，并将原来的 <code>main</code> 函数删除。在失去了 <code>main</code> 函数的情况下，编译器也就不需要完成所谓的初始化工作了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 禁用标准main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 删掉 自带的main函数</span></span><br></pre></td></tr></table></figure>

<p>至此，我们成功移除了标准库的依赖，并完成了构建裸机平台上操作系统的第一步工作–通过编译器检查并生成执行码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure>

<h2 id="验证Qemu模拟器与执行环境是否正确可用"><a href="#验证Qemu模拟器与执行环境是否正确可用" class="headerlink" title="验证Qemu模拟器与执行环境是否正确可用"></a>验证Qemu模拟器与执行环境是否正确可用</h2><p>下面我们将实践在 Qemu 上执行内核的第一条指令,用以检验环境是否正确可用。</p>
<h3 id="编写内核第一条指令"><a href="#编写内核第一条指令" class="headerlink" title="编写内核第一条指令"></a>编写内核第一条指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line">    .section .text.entry # .section: 定义或切换到一个特定的代码段 .text.enery代码段</span><br><span class="line">    .globl _start        # 告知编译器 _start 是一个全局符号,可以被其他目标文件使用</span><br><span class="line">_start:                  # 全局符号,指向下面的(li x1, 100)</span><br><span class="line">    li x1, 100           # 立即数 100 被加载到了寄存器 x1 中</span><br></pre></td></tr></table></figure>

<p>一般情况下，所有的代码都被放到一个名为 <code>.text</code> 的代码段中，这里我们将其命名为 <code>.text.entry</code> 从而区别于其他 <code>.text</code> 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。</p>
<blockquote>
<p> 常见的 x86、RISC-V 等架构采用的是小端序。</p>
</blockquote>
<p><strong>将汇编代码嵌入<code>main.rs</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="comment">// 移除标准库</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 移除main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 载入模块</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">use</span> core::arch::global_asm;</span><br><span class="line"><span class="comment">// global_asm!宏：嵌入全局汇编代码;include_str!宏：文件的内容作为一个字符串嵌入到程序中;</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于 <code>main</code> 函数和 <code>global_asm!</code> 的执行顺序，重要的是理解它们的作用和上下文：</strong></p>
<ul>
<li><p><strong>global_asm!</strong>: 这个宏用于在编译时嵌入汇编代码。这些汇编代码通常用于设置中断向量表、初始化硬件或其他低级设置。这些代码在二进制文件的开始或特定段中，并且在程序开始执行时就已经存在。<em>它们并不是在运行时执行的代码，而是作为二进制文件的一部分存在</em>。</p>
</li>
<li><p><strong>main 函数</strong>: 在 Rust 程序中，<code>main</code> 函数是程序的入口点。当程序开始执行时，它首先会跳转到 <code>main</code> 函数。<em>在 <code>main</code> 函数之前，任何全局的初始化代码（包括通过 <code>global_asm!</code> 嵌入的汇编代码）都应该已经完成</em>。</p>
</li>
</ul>
</blockquote>
<h3 id="调整内核的内存布局"><a href="#调整内核的内存布局" class="headerlink" title="调整内核的内存布局"></a>调整内核的内存布局</h3><p>由于链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000 。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code>os/src/linker.ld</code> 而非使用默认的内存布局：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/.cargo/config</span></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>“-Clink-arg&#x3D;-Tsrc&#x2F;linker.ld” ：告诉 Rust 编译器在链接阶段使用 <code>src/linker.ld</code> 作为链接器脚本</li>
<li>“-Cforce-frame-pointers&#x3D;yes” : 强制编译器在生成的代码中包含帧指针。</li>
</ul>
</blockquote>
<p>链接脚本 <code>os/src/linker.ld</code> 如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)	# 设置了目标平台为 riscv;</span><br><span class="line">ENTRY(_start)	# 设置了整个程序的入口点为之前定义的全局符号 _start;</span><br><span class="line">BASE_ADDRESS = 0x80200000;	# 定义了一个常量 BASE_ADDRESS 为 0x80200000 ,内核的初始化时的地址;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code>_start</code>；</p>
<p>第 3 行定义了一个常量 <code>BASE_ADDRESS</code> 为 <code>0x80200000</code> ，也就是我们之前提到内核的初始化代码被放置的地址；</p>
<p>从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 <code>.</code> 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 <code>.</code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code>.</code> 从而记录这一时刻的位置。我们还能够看到这样的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 <code>&lt;ObjectFile&gt;(SectionName)</code>，表示目标文件 <code>ObjectFile</code> 的名为 <code>SectionName</code> 的段需要被放进去。我们也可以使用通配符来书写 <code>&lt;ObjectFile&gt;</code> 和 <code>&lt;SectionName&gt;</code> 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 <code>.text, .rodata .data, .bss</code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code>.text</code> 段的开始和结束地址分别是 <code>stext</code> 和 <code>etext</code> ）。</p>
<p>第 12 行我们将包含内核第一条指令的 <code>.text.entry</code> 段放在最终的 <code>.text</code> 段的最开头，同时注意到在最终内存布局中代码段 <code>.text</code> 又是先于任何其他段的。因为所有的段都从 <code>BASE_ADDRESS</code> 也即 <code>0x80200000</code> 开始放置，这就能够保证内核的第一条指令正好放在 <code>0x80200000</code> 从而能够正确对接到 Qemu 上。</p>
<p>生成内核可执行文件，切换到 <code>os</code> 目录下进行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 release 模式生成了内核可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.06s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 file 工具查看它的属性</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file target/riscv64gc-unknown-none-elf/release/os</span></span><br><span class="line">target/riscv64gc-unknown-none-elf/release/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>

<h3 id="手动加载内核可执行文件"><a href="#手动加载内核可执行文件" class="headerlink" title="手动加载内核可执行文件"></a>手动加载内核可执行文件</h3><p>使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cargo build --release</code>后得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。所以我们需要将其元数据丢弃</p>
</blockquote>
<h3 id="基于GDB验证启动流程"><a href="#基于GDB验证启动流程" class="headerlink" title="基于GDB验证启动流程"></a>基于GDB验证启动流程</h3><p>在 <code>os</code> 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \</span></span><br><span class="line"><span class="language-bash">    -s -S</span></span><br></pre></td></tr></table></figure>

<p><code>-s</code> 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 <code>-S</code> 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 <code>-s -S</code> 。</p>
<p>打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-elf-gdb \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;set arch riscv:rv64&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;target remote localhost:1234&#x27;</span></span></span><br><span class="line">[GDB output]</span><br><span class="line">0x0000000000001000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 <code>0x1000</code> 。我们可以检查一下 Qemu 的启动固件的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) x/10i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x1000:      auipc   t0,0x0</span><br><span class="line">   0x1004:      add     a2,t0,40</span><br><span class="line">   0x1008:      csrr    a0,mhartid</span><br><span class="line">   0x100c:      ld      a1,32(t0)</span><br><span class="line">   0x1010:      ld      t0,24(t0)</span><br><span class="line">   0x1014:      jr      t0</span><br><span class="line">   0x1018:      unimp</span><br><span class="line">   0x101a:      .2byte  0x8000</span><br><span class="line">   0x101c:      unimp</span><br><span class="line">   0x101e:      unimp</span><br></pre></td></tr></table></figure>

<p>这里 <code>x/10i $pc</code> 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 <code>0x1018</code> 开始都是数据，当数据为 0 的时候则会被反汇编为 <code>unimp</code> 指令。 <code>0x101a</code> 处的数据 <code>0x8000</code> 是能够跳转到 <code>0x80000000</code> 进入启动下一阶段的关键。总之，在执行位于 <code>0x1014</code> 的指令之前，寄存器 <code>t0</code> 的值恰好为 <code>0x80000000</code> ，随后通过 <code>jr t0</code> 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000000000100c in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$t0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x80000000</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>其中， <code>si</code> 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 <code>p/x $t0</code> 以 16 进制打印寄存器 <code>t0</code> 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 <code>$</code> 。可以看到，当位于 <code>0x1010</code> 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 <code>0x80000000</code> ，这意味着我们即将把控制权转交给 RustSBI 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x80000000:  auipc   sp,0x29</span><br><span class="line">   0x80000004:  add     sp,sp,-200</span><br><span class="line">   0x80000008:  lui     t0,0x4</span><br><span class="line">   0x8000000a:  add     t1,a0,1</span><br><span class="line">   0x8000000e:  add     sp,sp,t0</span><br><span class="line">   0x80000010:  add     t1,t1,-1</span><br><span class="line">   0x80000012:  bnez    t1,0x8000000e</span><br><span class="line">   0x80000016:  j       0x80015e0c</span><br><span class="line">   0x8000001a:  unimp</span><br><span class="line">   0x8000001c:  add     sp,sp,-32</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000a in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000e in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) b *0x80200000</span></span><br><span class="line">Breakpoint 1 at 0x80200000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) c</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000080200000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们在内核的入口点，也即地址 <code>0x80200000</code> 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 <code>*</code> 。接下来通过 <code>c</code> 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 <code>0x80200000</code> 处。随后，可以检查内核第一条指令是否被正确执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5i $pc</span><br><span class="line">=&gt; 0x80200000:  li      ra,100</span><br><span class="line">   0x80200004:  unimp</span><br><span class="line">   0x80200006:  unimp</span><br><span class="line">   0x80200008:  unimp</span><br><span class="line">   0x8020000a:  unimp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080200004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/d <span class="variable">$x1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 100</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$sp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x0</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们在 <code>entry.asm</code> 中编写的第一条指令可以在 <code>0x80200000</code> 处找到。这里 <code>ra</code> 是寄存器 <code>x1</code> 的别名， <code>p/d $x1</code> 可以以十进制打印寄存器 <code>x1</code> 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 <code>sp</code> 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。</p>
<h2 id="设置栈空间以及内核初始化"><a href="#设置栈空间以及内核初始化" class="headerlink" title="设置栈空间以及内核初始化"></a>设置栈空间以及内核初始化</h2><h3 id="分配栈空间"><a href="#分配栈空间" class="headerlink" title="分配栈空间"></a>分配栈空间</h3><p>我们在 <code>entry.asm</code> 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 <code>sp</code> 设置为栈顶的位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line"></span><br><span class="line">    .section .text.entry	# 定义一个段</span><br><span class="line">    .globl _start	# 定义一个全局符号</span><br><span class="line">_start:	# 程序入口</span><br><span class="line">    la sp, boot_stack_top	# 立即将 boot_stack_top 的地址加载到栈指针 sp 中</span><br><span class="line">    call main # 调用一个名为main的子程序</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16	# 为数据段分配一定数量的空间。</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:		# 表示为栈顶 ,上文_start程序入口加载的位置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上所述，这段代码定义了程序的入口点 <code>_start</code>，并设置了一个栈空间，栈的顶部是 <code>boot_stack_top</code>，底部是 <code>boot_stack_lower_bound</code>，总共 64KB。程序从 <code>_start</code> 开始执行，首先设置栈指针，然后调用 Rust 编写的 <code>main</code> 函数。</p>
</blockquote>
<h3 id="编写入口函数"><a href="#编写入口函数" class="headerlink" title="编写入口函数"></a>编写入口函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要对该函数名进行修饰，以便其他语言就可以通过该原始名称来链接和调用 Rust 函数或访问 Rust 变量。</span></span><br><span class="line"><span class="comment">// 这里面的main名字要与汇编代码中指定的入口子函数名称一致</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123; </span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-bss-段的清零"><a href="#对-bss-段的清零" class="headerlink" title="对 .bss 段的清零"></a>对 <code>.bss</code> 段的清零</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对.bss段清零</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数 <code>clear_bss</code> 中，我们会尝试从其他地方找到全局符号 <code>sbss</code> 和 <code>ebss</code> ，它们由链接脚本 <code>linker.ld</code> 给出，并分别指出需要被清零的 <code>.bss</code> 段的起始和终止地址。接下来我们只需遍历该地址区间并逐字节进行清零即可。</p>
</blockquote>
<h2 id="使用RustSBI-实现字符打印功能"><a href="#使用RustSBI-实现字符打印功能" class="headerlink" title="使用RustSBI 实现字符打印功能"></a>使用RustSBI 实现字符打印功能</h2><p>RustSBI 通过实现 SBI 标准，使得操作系统能够利用RISC-V处理器的指令集系统来执行各种操作。</p>
<h3 id="调用-SBI-服务"><a href="#调用-SBI-服务" class="headerlink" title="调用 SBI 服务"></a>调用 SBI 服务</h3><p><strong>在 <code>Cargo.toml</code> 中引入 sbi_rt 依赖来调用 SBI 服务的接口：</strong></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 因为兼容问题Qemu9.0.0在进行后续学习时候或出错，故将版次改为 2018	</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sbi-rt</span> = &#123; version = <span class="string">&quot;0.0.2&quot;</span>, features = [<span class="string">&quot;legacy&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>我们将内核与 RustSBI 通信的相关功能实现在子模块 <code>sbi</code> 中，因此我们需要在 <code>main.rs</code> 中加入 <code>mod sbi</code> 将该子模块加入我们的项目。在 <code>os/src/sbi.rs</code> 中，我们直接调用 sbi_rt 提供的接口来将输出字符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="keyword">mod</span> sbi;</span><br><span class="line"></span><br><span class="line"># os/src/sbi.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// #[allow(deprecated)]属性来禁止编译器发出警告,对于某些已经弃用的方法。</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    sbi_rt::legacy::<span class="title function_ invoke__">console_putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现关机功能"><a href="#实现关机功能" class="headerlink" title="实现关机功能"></a>实现关机功能</h3><p><strong>实现关机功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/sbi.rs</span></span><br><span class="line">pub fn shutdown(failure: bool) -&gt; ! &#123;</span><br><span class="line">    use sbi_rt::&#123;system_reset, NoReason, Shutdown, SystemFailure&#125;;</span><br><span class="line">    if !failure &#123;</span><br><span class="line">        system_reset(Shutdown, NoReason);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        system_reset(Shutdown, SystemFailure);</span><br><span class="line">    &#125;</span><br><span class="line">    unreachable!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">mod</span> console;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/console.rs</span></span><br><span class="line"><span class="keyword">use</span> crate::sbi::console_putchar;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成内核镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Qemu模拟器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行结果如图：</span></span><br><span class="line">[rustsbi] RustSBI version 0.4.0-alpha.1, adapting to RISC-V SBI v2.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.3</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e01290</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">Hello, world!</span><br><span class="line">Panicked at src/main.rs:23 Shutdown machine!</span><br></pre></td></tr></table></figure>

<h2 id="程序内存布局与编译流程"><a href="#程序内存布局与编译流程" class="headerlink" title="程序内存布局与编译流程"></a>程序内存布局与编译流程</h2><h3 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h3><p>在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： <strong>段</strong> (Section) 。不同的段会被编译器放置在内存不同的位置上，这构成了程序的 <strong>内存布局</strong> (Memory Layout)。一种典型的程序相对内存布局如下所示：</p>
<p><img src="/public/image/OS/tuos/MemoryLayout.png" alt="MemoryLayout"></p>
<p>在上图中可以看到，代码部分只有代码段 <code>.text</code> 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：</p>
<ul>
<li>已初始化数据段保存程序中那些已初始化的全局数据，分为 <code>.rodata</code> 和 <code>.data</code> 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。</li>
<li>未初始化数据段 <code>.bss</code> 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；</li>
<li><strong>堆</strong> （heap）区域用来存放程序运行时动态分配的数据，如 C&#x2F;C++ 中的 malloc&#x2F;new 分配到的数据本体就放在堆区域，它向高地址增长；</li>
<li><strong>栈</strong> （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。</li>
</ul>
<blockquote>
<p><strong>局部变量与全局变量</strong></p>
<p>在一个函数的视角中，它能够访问的变量包括以下几种：</p>
<ul>
<li>函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；</li>
<li>全局变量：保存在数据段 <code>.data</code> 和 <code>.bss</code> 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。</li>
<li>堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 <em>直接</em> 访问栈上或者全局数据段中的 <strong>编译期确定大小</strong> 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。</li>
</ul>
</blockquote>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：</p>
<ul>
<li><p><strong>编译器</strong> (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；</p>
</li>
<li><p><strong>汇编器</strong> (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 <strong>目标文件</strong> (Object File)；</p>
</li>
<li><p><strong>链接器</strong> (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。</p>
</li>
</ul>
<p>汇编器输出的每个目标文件都有一个独立的程序内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整合成一个整体的内存布局。在此期间链接器主要完成两件事情：</p>
<ul>
<li>第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 <code>1.o</code> 和 <code>2.o</code> 段被按照段的功能进行分类，相同功能的段被排在一起放在拼装后的目标文件 <code>output.o</code> 中。注意到，目标文件 <code>1.o</code> 和 <code>2.o</code> 的内存布局是存在冲突的，同一个地址在不同的内存布局中存放不同的内容。而在合并后的内存布局中，这些冲突被消除。</li>
</ul>
<p>​	<img src="/public/image/tuos/MemoryLayout-Linker.png" alt="MemoryLayout-Linker"></p>
<ul>
<li><p>第二件事情是将符号替换为具体地址。这里的符号指什么呢？我们知道，在我们进行模块化编程的时候，每个模块都会提供一些向其他模块公开的全局变量、函数等供其他模块访问，也会访问其他模块向它公开的内容。要访问一个变量或者调用一个函数，在源代码级别我们只需知道它们的名字即可，这些名字被我们称为符号。取决于符号来自于模块内部还是其他模块，我们还可以进一步将符号分成内部符号和外部符号。然而，在机器码级别（也即在目标文件或可执行文件中）我们并不是通过符号来找到索引我们想要访问的变量或函数，而是直接通过变量或函数的地址。例如，如果想调用一个函数，那么在指令的机器码中我们可以找到函数入口的绝对地址或者相对于当前 PC 的相对地址。</p>
<p>那么，符号何时被替换为具体地址呢？因为符号对应的变量或函数都是放在某个段里面的固定位置（如全局变量往往放在 <code>.bss</code> 或者 <code>.data</code> 段中，而函数则放在 <code>.text</code> 段中），所以我们需要等待符号所在的段确定了它们在内存布局中的位置之后才能知道它们确切的地址。当一个模块被转化为目标文件之后，它的内部符号就已经在目标文件中被转化为具体的地址了，因为目标文件给出了模块的内存布局，也就意味着模块内的各个段的位置已经被确定了。然而，此时模块所用到的外部符号的地址无法确定。我们需要将这些外部符号记录下来，放在目标文件一个名为符号表（Symbol table）的区域内。由于后续可能还需要重定位，内部符号也同样需要被记录在符号表中。</p>
<p>外部符号需要等到链接的时候才能被转化为具体地址。假设模块 1 用到了模块 2 提供的内容，当两个模块的目标文件链接到一起的时候，它们的内存布局会被合并，也就意味着两个模块的各个段的位置均被确定下来。此时，模块 1 用到的来自模块 2 的外部符号可以被转化为具体地址。同时我们还需要注意：两个模块的段在合并后的内存布局中被重新排布，其最终的位置有可能和它们在模块自身的局部内存布局中的位置相比已经发生了变化。因此，每个模块的内部符号的地址也有可能会发生变化，我们也需要进行修正。上面的过程被称为重定位（Relocation），这个过程形象一些来说很像拼图：由于模块 1 用到了模块 2 的内容，因此二者分别相当于一块凹进和凸出一部分的拼图，正因如此我们可以将它们无缝地拼接到一起。</p>
</li>
</ul>
<p>上面我们简单介绍了程序内存布局和编译流程特别是链接过程的相关知识。那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 <code>0x80200000</code> 处，同时代码段所在的地址应低于其他段。这是因为 Qemu 物理内存中低于 <code>0x80200000</code> 的区域并未分配给内核，而是主要由 RustSBI 使用。其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中。下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">博主</a></li>
        
          <li><a href="/tags/">标签</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">应用程序与基本执行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAbin%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">创建一个bin项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%AF%B9%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.</span> <span class="toc-text">移除执行环境对操作系统的依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E7%9B%AE%E6%A0%87%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.添加目标平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E9%99%A4%E6%A0%87%E5%87%86%E5%BA%93%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.移除标准库依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.添加错误处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A7%BB%E9%99%A4%E6%A0%87%E5%87%86main%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.移除标准main函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81Qemu%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%8F%AF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">验证Qemu模拟器与执行环境是否正确可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">编写内核第一条指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.3.2.</span> <span class="toc-text">调整内核的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">手动加载内核可执行文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EGDB%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">基于GDB验证启动流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%88%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%8F%8A%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">设置栈空间以及内核初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.1.</span> <span class="toc-text">分配栈空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">编写入口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-bss-%E6%AE%B5%E7%9A%84%E6%B8%85%E9%9B%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">对 .bss 段的清零</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8RustSBI-%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.</span> <span class="toc-text">使用RustSBI 实现字符打印功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-SBI-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">调用 SBI 服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%9C%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.2.</span> <span class="toc-text">实现关机功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.3.</span> <span class="toc-text">格式化输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">程序内存布局与编译流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.1.</span> <span class="toc-text">程序内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">编译流程</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&text=应用程序与基本执行环境"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&is_video=false&description=应用程序与基本执行环境"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=应用程序与基本执行环境&body=Check out this article: https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&title=应用程序与基本执行环境"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&name=应用程序与基本执行环境&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://www.tooupper.org/OS/rCore/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/&t=应用程序与基本执行环境"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    kay
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">博主</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
